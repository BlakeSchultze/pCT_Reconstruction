/************************************************************************************************************************************************************************************************************************************************************************/
/********************************************************************************************************** User's Guide for Preprocessing in pCT ***********************************************************************************************************************/
/************************************************************************************************************************************************************************************************************************************************************************/

(1) Specifying location of input data and where output is to be written.

First, specify the directory where the input data is stored ("input_directory") and the directory where output data should be written ("output_directory").  Note that since the various data sets are typically stored in separate folders in the same directory, the program is designed as such, so do not include the folder where the data is located in the directory name, the folder name should be written to the variable "input_folder".  Similarly, output for various data sets are typically in separate folders in a single directory, so do not include the output folder name in the output directory name, write the folder name into the variable "output_folder".  The filenames for the data files should then be written to the variable "input_base_name" and the file extension to "file_extension" (e.g. .bin, .dat, .txt, etc).  The filename format is expected to be [input_base_name]_xxx.[file_extension], where "xxx" is a 3 digit number specifying the gantry angle from which the corresponding data was acquired.  This completes the input/output path specifications.  Since data has been written in various formats in the past/present, you must specify if the data is written in data format Version 0, Version 1, or the format prior to Version 0 by setting the corresponding boolean to true and the others to false (VERSION_0, VERSION_1, and VERSION_OLD, respectively).  Similarly, since there have been inconsistent units used in the past (i.e. mm/cm), two booleans have been added to provide compatibility by setting the "SSD_IN_MM" and "DATA_IN_MM" booleans appropriately.  In the past, many of the data sets also came with a config file (scan.cfg) which specified the u coordinates of the tracker planes, so if you are using any such data set, set the CONFIG_FILE boolean to true.  Otherwise, you must set it false.

If the program cannot find a file, whether it be data or a config file, an error message is printed to the console window and program execution is haulted.  To allow one to see the error message, an user input request is initiated.  Once you are finished reading the error message, hit any key to exit the program.

(2) Hull-Detection (i.e. determining objebt and its boundary for use in MLP)

There are currently 4 methods of hull-detection: FBP, Space/Silhouette Carving (SC), Modified Space/Silhouette Carving (MSC), and Space/Silhouette Modeling (SM).  These can be turned on/off using the variables FBP_ON, SC_ON, MSC_ON, and SM_ON, respectively.  These can typically all be turned on at the same time so their results can be compared, but this is not always possible; if the data sets are large, since each of these algorithms consume GPU memory (particularly SM), it is possible to exhaust the available GPU memory.  In most cases this does not raise an execution halting exception, but subsequent processing generates erroneous results.  This can be seen from the text output to the console window which notifies the user of how many protons passed through the reconstruction volume and, thus, were not cut from the data set: if memory is exhausted, the program will indicate that 0 histories pass reconstruction volume intersection detection for the remainder of gantry angles not yet processed.  

(3) Writing Data to File

There are several functions provided for writing data to disk and the appropriate choice depepnds on the data type (boolean, integer, float), its container type (C array, vector), and if the data is to be written to a single file or separated into several files.  Three parameters dictate the structure of these files, the first two specify the number of rows and columns and the last dictates either the number of files with this structure or the number of times this row/column structure is repeated below each other in a single file (depending on if writing to one or multiple files).  This structure was designed with images in mimd, but this does not preclude using them for any other type of data.  These functions can be added anywhere in the program, though if the data desired resides on the GPU, it must first be transferred to the host using cudaMemcpy( device array name, host array name, data_size, cudaMemcpyHostToDevice ).

General Notes on Program

The gpu cannot process all the histories at once, so they are broken up into chunks that can fit on the gpu.  as we iterate 
through the data one chunk at a time, we determine which histories enter the reconstruction volume and if they belong to a 
valid bin (i.e. t, v, and angular bin number is greater than zero and less than max).  if both are true, we append the bin
number, wepl, and relative entry/exit ut/uv angles to the following four arrays.  we do not know ahead of time how many 
valid histories there will be, so memory is allocated to accomodate every history and the actual number of valid histories
are counted. although we waste some host memory, we can avoid writing intermediate information to file or keeping the raw 
data and recalculating it every time its needed. once all the data is processed and we know how many valid histories we 
have, we simply ignore the illegitimate elements of the four arrays to avoid transferring invalid and unnecessary data to 
and from the gpu.