#line 1 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
#pragma section("__nv_managed_data__")
#line 1
static char __nv_inited_managed_rt = 0; static void **__nv_fatbinhandle_for_managed_rt; static void __nv_save_fatbinhandle_for_managed_rt(void **in){__nv_fatbinhandle_for_managed_rt = in;} static char __nv_init_managed_rt_with_module(void **); static inline void __nv_init_managed_rt(void) { __nv_inited_managed_rt = (__nv_inited_managed_rt ? __nv_inited_managed_rt                 : __nv_init_managed_rt_with_module(__nv_fatbinhandle_for_managed_rt));}
#line 1
#line 27 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
typedef unsigned __int64 size_t; 
#include "crt/host_runtime.h"
#line 52 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
namespace vc_attributes { 
#line 56 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
enum YesNoMaybe { 
#line 59
No = 268369921, 
#line 60
Maybe = 268369936, 
#line 61
Yes = 268370176
#line 62
}; 
#line 64
typedef YesNoMaybe YesNoMaybe; 
#line 66
enum AccessType { 
#line 68
NoAccess, 
#line 69
Read, 
#line 70
Write, 
#line 71
ReadWrite
#line 72
}; 
#line 74
typedef AccessType AccessType; 
#line 78
[repeatable, 
#line 79
source_annotation_attribute ( Parameter )] 
#line 80
struct PreAttribute { 
#line 83
PreAttribute(); 
#line 86 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
unsigned Deref; 
#line 87
YesNoMaybe Valid; 
#line 88
YesNoMaybe Null; 
#line 89
YesNoMaybe Tainted; 
#line 90
AccessType Access; 
#line 91
size_t ValidElementsConst; 
#line 92
size_t ValidBytesConst; 
#line 93
const __wchar_t *ValidElements; 
#line 94
const __wchar_t *ValidBytes; 
#line 95
const __wchar_t *ValidElementsLength; 
#line 96
const __wchar_t *ValidBytesLength; 
#line 97
size_t WritableElementsConst; 
#line 98
size_t WritableBytesConst; 
#line 99
const __wchar_t *WritableElements; 
#line 100
const __wchar_t *WritableBytes; 
#line 101
const __wchar_t *WritableElementsLength; 
#line 102
const __wchar_t *WritableBytesLength; 
#line 103
size_t ElementSizeConst; 
#line 104
const __wchar_t *ElementSize; 
#line 105
YesNoMaybe NullTerminated; 
#line 106
const __wchar_t *Condition; 
#line 107
}; 
#line 109
[repeatable, 
#line 110
source_annotation_attribute ( Parameter | ReturnValue )] 
#line 111
struct PostAttribute { 
#line 114
PostAttribute(); 
#line 117 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
unsigned Deref; 
#line 118
YesNoMaybe Valid; 
#line 119
YesNoMaybe Null; 
#line 120
YesNoMaybe Tainted; 
#line 121
AccessType Access; 
#line 122
size_t ValidElementsConst; 
#line 123
size_t ValidBytesConst; 
#line 124
const __wchar_t *ValidElements; 
#line 125
const __wchar_t *ValidBytes; 
#line 126
const __wchar_t *ValidElementsLength; 
#line 127
const __wchar_t *ValidBytesLength; 
#line 128
size_t WritableElementsConst; 
#line 129
size_t WritableBytesConst; 
#line 130
const __wchar_t *WritableElements; 
#line 131
const __wchar_t *WritableBytes; 
#line 132
const __wchar_t *WritableElementsLength; 
#line 133
const __wchar_t *WritableBytesLength; 
#line 134
size_t ElementSizeConst; 
#line 135
const __wchar_t *ElementSize; 
#line 136
YesNoMaybe NullTerminated; 
#line 137
YesNoMaybe MustCheck; 
#line 138
const __wchar_t *Condition; 
#line 139
}; 
#line 141
[source_annotation_attribute ( Parameter )] 
#line 142
struct FormatStringAttribute { 
#line 145
FormatStringAttribute(); 
#line 148 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
const __wchar_t *Style; 
#line 149
const __wchar_t *UnformattedAlternative; 
#line 150
}; 
#line 152
[repeatable, 
#line 153
source_annotation_attribute ( ReturnValue )] 
#line 154
struct InvalidCheckAttribute { 
#line 157
InvalidCheckAttribute(); 
#line 160 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
long Value; 
#line 161
}; 
#line 163
[source_annotation_attribute ( Method )] 
#line 164
struct SuccessAttribute { 
#line 167
SuccessAttribute(); 
#line 170 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
const __wchar_t *Condition; 
#line 171
}; 
#line 173
[repeatable, 
#line 174
source_annotation_attribute ( Parameter )] 
#line 175
struct PreBoundAttribute { 
#line 178
PreBoundAttribute(); 
#line 180 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
unsigned Deref; 
#line 181
}; 
#line 183
[repeatable, 
#line 184
source_annotation_attribute ( Parameter | ReturnValue )] 
#line 185
struct PostBoundAttribute { 
#line 188
PostBoundAttribute(); 
#line 190 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
unsigned Deref; 
#line 191
}; 
#line 193
[repeatable, 
#line 194
source_annotation_attribute ( Parameter )] 
#line 195
struct PreRangeAttribute { 
#line 198
PreRangeAttribute(); 
#line 200 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
unsigned Deref; 
#line 201
const char *MinVal; 
#line 202
const char *MaxVal; 
#line 203
}; 
#line 205
[repeatable, 
#line 206
source_annotation_attribute ( Parameter | ReturnValue )] 
#line 207
struct PostRangeAttribute { 
#line 210
PostRangeAttribute(); 
#line 212 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
unsigned Deref; 
#line 213
const char *MinVal; 
#line 214
const char *MaxVal; 
#line 215
}; 
#line 220 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
}
#line 244 "c:\\program files (x86)\\microsoft visual studio 10.0\\vc\\include\\codeanalysis\\sourceannotations.h"
typedef vc_attributes::YesNoMaybe SA_YesNoMaybe; 
#line 245
const vc_attributes::YesNoMaybe SA_Yes = vc_attributes::Yes; 
#line 246
const vc_attributes::YesNoMaybe SA_No = vc_attributes::No; 
#line 247
const vc_attributes::YesNoMaybe SA_Maybe = vc_attributes::Maybe; 
#line 249
typedef vc_attributes::AccessType SA_AccessType; 
#line 250
const vc_attributes::AccessType SA_NoAccess = vc_attributes::NoAccess; 
#line 251
const vc_attributes::AccessType SA_Read = vc_attributes::Read; 
#line 252
const vc_attributes::AccessType SA_Write = vc_attributes::Write; 
#line 253
const vc_attributes::AccessType SA_ReadWrite = vc_attributes::ReadWrite; 
#line 256
typedef vc_attributes::PreAttribute SA_Pre; 
#line 257
typedef vc_attributes::PostAttribute SA_Post; 
#line 258
typedef vc_attributes::FormatStringAttribute SA_FormatString; 
#line 259
typedef vc_attributes::InvalidCheckAttribute SA_InvalidCheck; 
#line 260
typedef vc_attributes::SuccessAttribute SA_Success; 
#line 261
typedef vc_attributes::PreBoundAttribute SA_PreBound; 
#line 262
typedef vc_attributes::PostBoundAttribute SA_PostBound; 
#line 263
typedef vc_attributes::PreRangeAttribute SA_PreRange; 
#line 264
typedef vc_attributes::PostRangeAttribute SA_PostRange; 
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#pragma pack ( push, 8 )
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"
#pragma pack ( push, 8 )
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"
extern "C" { typedef unsigned __int64 uintptr_t; }
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"
extern "C" { typedef char *va_list; }
#line 121 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"
extern "C" { extern void __cdecl __va_start(va_list *, ...); } 
#line 146 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vadefs.h"
#pragma pack ( pop )
#line 409 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
extern "C" { typedef size_t rsize_t; }
#line 416 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
extern "C" { typedef __int64 intptr_t; }
#line 434 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
extern "C" { typedef __int64 ptrdiff_t; }
#line 447 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
extern "C" { typedef unsigned short wint_t; }
#line 448
extern "C" { typedef unsigned short wctype_t; }
#line 469 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
extern "C" { typedef int errno_t; }
#line 473 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
extern "C" { typedef long __time32_t; }
#line 478 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
extern "C" { typedef __int64 __time64_t; }
#line 486 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
extern "C" { typedef __time64_t time_t; }
#line 545 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
extern "C" { __declspec(dllimport) void __cdecl _invalid_parameter_noinfo(); } 
#line 546
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(); } 
#line 550 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
extern "C" { 
#line 549
__declspec(dllimport) __declspec(noreturn) void __cdecl 
#line 550
_invoke_watson(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); } 
#line 1953 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
struct threadlocaleinfostruct; 
#line 1954
struct threadmbcinfostruct; 
#line 1955
extern "C" { typedef threadlocaleinfostruct *pthreadlocinfo; }
#line 1956
extern "C" { typedef threadmbcinfostruct *pthreadmbcinfo; }
#line 1957
struct __lc_time_data; 
#line 1963
extern "C" { typedef 
#line 1959
struct localeinfo_struct { 
#line 1961
pthreadlocinfo locinfo; 
#line 1962
pthreadmbcinfo mbcinfo; 
#line 1963
} _locale_tstruct, *_locale_t; }
#line 1970
extern "C" { typedef 
#line 1966
struct tagLC_ID { 
#line 1967
unsigned short wLanguage; 
#line 1968
unsigned short wCountry; 
#line 1969
unsigned short wCodePage; 
#line 1970
} LC_ID, *LPLC_ID; }
#line 1999 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
extern "C" { typedef 
#line 1975
struct threadlocaleinfostruct { 
#line 1976
int refcount; 
#line 1977
unsigned lc_codepage; 
#line 1978
unsigned lc_collate_cp; 
#line 1979
unsigned long lc_handle[6]; 
#line 1980
LC_ID lc_id[6]; 
#line 1981
struct { 
#line 1982
char *locale; 
#line 1983
__wchar_t *wlocale; 
#line 1984
int *refcount; 
#line 1985
int *wrefcount; 
#line 1986
} lc_category[6]; 
#line 1987
int lc_clike; 
#line 1988
int mb_cur_max; 
#line 1989
int *lconv_intl_refcount; 
#line 1990
int *lconv_num_refcount; 
#line 1991
int *lconv_mon_refcount; 
#line 1992
struct lconv *lconv; 
#line 1993
int *ctype1_refcount; 
#line 1994
unsigned short *ctype1; 
#line 1995
const unsigned short *pctype; 
#line 1996
const unsigned char *pclmap; 
#line 1997
const unsigned char *pcumap; 
#line 1998
__lc_time_data *lc_time_curr; 
#line 1999
} threadlocinfo; }
#line 2036 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdefs.h"
#pragma pack ( pop )
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_types.h"
#if 0
#line 61
enum cudaRoundMode { 
#line 63
cudaRoundNearest, 
#line 64
cudaRoundZero, 
#line 65
cudaRoundPosInf, 
#line 66
cudaRoundMinInf
#line 67
}; 
#endif
#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"
namespace std { typedef decltype((__nullptr)) nullptr_t; }
#line 39
using std::nullptr_t;
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"
extern "C" { __declspec(dllimport) extern int *__cdecl _errno(); } 
#line 50
extern "C" { errno_t __cdecl _set_errno(int ); } 
#line 51
extern "C" { errno_t __cdecl _get_errno(int * ); } 
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stddef.h"
extern "C" { __declspec(dllimport) extern unsigned long __cdecl __threadid(); } 
#line 75
extern "C" { __declspec(dllimport) extern uintptr_t __cdecl __threadhandle(); } 
#line 128 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 128
enum cudaError { 
#line 135
cudaSuccess, 
#line 141
cudaErrorMissingConfiguration, 
#line 147
cudaErrorMemoryAllocation, 
#line 153
cudaErrorInitializationError, 
#line 163
cudaErrorLaunchFailure, 
#line 172
cudaErrorPriorLaunchFailure, 
#line 182
cudaErrorLaunchTimeout, 
#line 191
cudaErrorLaunchOutOfResources, 
#line 197
cudaErrorInvalidDeviceFunction, 
#line 206
cudaErrorInvalidConfiguration, 
#line 212
cudaErrorInvalidDevice, 
#line 218
cudaErrorInvalidValue, 
#line 224
cudaErrorInvalidPitchValue, 
#line 230
cudaErrorInvalidSymbol, 
#line 235
cudaErrorMapBufferObjectFailed, 
#line 240
cudaErrorUnmapBufferObjectFailed, 
#line 246
cudaErrorInvalidHostPointer, 
#line 252
cudaErrorInvalidDevicePointer, 
#line 258
cudaErrorInvalidTexture, 
#line 264
cudaErrorInvalidTextureBinding, 
#line 271
cudaErrorInvalidChannelDescriptor, 
#line 277
cudaErrorInvalidMemcpyDirection, 
#line 287
cudaErrorAddressOfConstant, 
#line 296
cudaErrorTextureFetchFailed, 
#line 305
cudaErrorTextureNotBound, 
#line 314
cudaErrorSynchronizationError, 
#line 320
cudaErrorInvalidFilterSetting, 
#line 326
cudaErrorInvalidNormSetting, 
#line 334
cudaErrorMixedDeviceExecution, 
#line 341
cudaErrorCudartUnloading, 
#line 346
cudaErrorUnknown, 
#line 354
cudaErrorNotYetImplemented, 
#line 363
cudaErrorMemoryValueTooLarge, 
#line 370
cudaErrorInvalidResourceHandle, 
#line 378
cudaErrorNotReady, 
#line 385
cudaErrorInsufficientDriver, 
#line 398
cudaErrorSetOnActiveProcess, 
#line 404
cudaErrorInvalidSurface, 
#line 410
cudaErrorNoDevice, 
#line 416
cudaErrorECCUncorrectable, 
#line 421
cudaErrorSharedObjectSymbolNotFound, 
#line 426
cudaErrorSharedObjectInitFailed, 
#line 432
cudaErrorUnsupportedLimit, 
#line 438
cudaErrorDuplicateVariableName, 
#line 444
cudaErrorDuplicateTextureName, 
#line 450
cudaErrorDuplicateSurfaceName, 
#line 460
cudaErrorDevicesUnavailable, 
#line 465
cudaErrorInvalidKernelImage, 
#line 473
cudaErrorNoKernelImageForDevice, 
#line 486
cudaErrorIncompatibleDriverContext, 
#line 493
cudaErrorPeerAccessAlreadyEnabled, 
#line 500
cudaErrorPeerAccessNotEnabled, 
#line 506
cudaErrorDeviceAlreadyInUse = 54, 
#line 513
cudaErrorProfilerDisabled, 
#line 521
cudaErrorProfilerNotInitialized, 
#line 528
cudaErrorProfilerAlreadyStarted, 
#line 535
cudaErrorProfilerAlreadyStopped, 
#line 543
cudaErrorAssert, 
#line 550
cudaErrorTooManyPeers, 
#line 556
cudaErrorHostMemoryAlreadyRegistered, 
#line 562
cudaErrorHostMemoryNotRegistered, 
#line 567
cudaErrorOperatingSystem, 
#line 573
cudaErrorPeerAccessUnsupported, 
#line 580
cudaErrorLaunchMaxDepthExceeded, 
#line 588
cudaErrorLaunchFileScopedTex, 
#line 596
cudaErrorLaunchFileScopedSurf, 
#line 611
cudaErrorSyncDepthExceeded, 
#line 623
cudaErrorLaunchPendingCountExceeded, 
#line 628
cudaErrorNotPermitted, 
#line 634
cudaErrorNotSupported, 
#line 643
cudaErrorHardwareStackError, 
#line 651
cudaErrorIllegalInstruction, 
#line 660
cudaErrorMisalignedAddress, 
#line 671
cudaErrorInvalidAddressSpace, 
#line 679
cudaErrorInvalidPc, 
#line 687
cudaErrorIllegalAddress, 
#line 693
cudaErrorStartupFailure = 127, 
#line 701
cudaErrorApiFailureBase = 10000
#line 702
}; 
#endif
#line 707 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 707
enum cudaChannelFormatKind { 
#line 709
cudaChannelFormatKindSigned, 
#line 710
cudaChannelFormatKindUnsigned, 
#line 711
cudaChannelFormatKindFloat, 
#line 712
cudaChannelFormatKindNone
#line 713
}; 
#endif
#line 718 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 718
struct cudaChannelFormatDesc { 
#line 720
int x; 
#line 721
int y; 
#line 722
int z; 
#line 723
int w; 
#line 724
cudaChannelFormatKind f; 
#line 725
}; 
#endif
#line 730 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
typedef struct cudaArray *cudaArray_t; 
#line 735
typedef const cudaArray *cudaArray_const_t; 
#line 737
struct cudaArray; 
#line 742
typedef struct cudaMipmappedArray *cudaMipmappedArray_t; 
#line 747
typedef const cudaMipmappedArray *cudaMipmappedArray_const_t; 
#line 749
struct cudaMipmappedArray; 
#line 754
#if 0
#line 754
enum cudaMemoryType { 
#line 756
cudaMemoryTypeHost = 1, 
#line 757
cudaMemoryTypeDevice
#line 758
}; 
#endif
#line 763 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 763
enum cudaMemcpyKind { 
#line 765
cudaMemcpyHostToHost, 
#line 766
cudaMemcpyHostToDevice, 
#line 767
cudaMemcpyDeviceToHost, 
#line 768
cudaMemcpyDeviceToDevice, 
#line 769
cudaMemcpyDefault
#line 770
}; 
#endif
#line 776 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 776
struct cudaPitchedPtr { 
#line 778
void *ptr; 
#line 779
size_t pitch; 
#line 780
size_t xsize; 
#line 781
size_t ysize; 
#line 782
}; 
#endif
#line 788 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 788
struct cudaExtent { 
#line 790
size_t width; 
#line 791
size_t height; 
#line 792
size_t depth; 
#line 793
}; 
#endif
#line 799 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 799
struct cudaPos { 
#line 801
size_t x; 
#line 802
size_t y; 
#line 803
size_t z; 
#line 804
}; 
#endif
#line 809 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 809
struct cudaMemcpy3DParms { 
#line 811
cudaArray_t srcArray; 
#line 812
cudaPos srcPos; 
#line 813
cudaPitchedPtr srcPtr; 
#line 815
cudaArray_t dstArray; 
#line 816
cudaPos dstPos; 
#line 817
cudaPitchedPtr dstPtr; 
#line 819
cudaExtent extent; 
#line 820
cudaMemcpyKind kind; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 821
}; 
#endif
#line 826 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 826
struct cudaMemcpy3DPeerParms { 
#line 828
cudaArray_t srcArray; 
#line 829
cudaPos srcPos; 
#line 830
cudaPitchedPtr srcPtr; 
#line 831
int srcDevice; 
#line 833
cudaArray_t dstArray; 
#line 834
cudaPos dstPos; 
#line 835
cudaPitchedPtr dstPtr; 
#line 836
int dstDevice; 
#line 838
cudaExtent extent; 
#line 839
}; 
#endif
#line 844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
struct cudaGraphicsResource; 
#line 849
#if 0
#line 849
enum cudaGraphicsRegisterFlags { 
#line 851
cudaGraphicsRegisterFlagsNone, 
#line 852
cudaGraphicsRegisterFlagsReadOnly, 
#line 853
cudaGraphicsRegisterFlagsWriteDiscard, 
#line 854
cudaGraphicsRegisterFlagsSurfaceLoadStore = 4, 
#line 855
cudaGraphicsRegisterFlagsTextureGather = 8
#line 856
}; 
#endif
#line 861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 861
enum cudaGraphicsMapFlags { 
#line 863
cudaGraphicsMapFlagsNone, 
#line 864
cudaGraphicsMapFlagsReadOnly, 
#line 865
cudaGraphicsMapFlagsWriteDiscard
#line 866
}; 
#endif
#line 871 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 871
enum cudaGraphicsCubeFace { 
#line 873
cudaGraphicsCubeFacePositiveX, 
#line 874
cudaGraphicsCubeFaceNegativeX, 
#line 875
cudaGraphicsCubeFacePositiveY, 
#line 876
cudaGraphicsCubeFaceNegativeY, 
#line 877
cudaGraphicsCubeFacePositiveZ, 
#line 878
cudaGraphicsCubeFaceNegativeZ
#line 879
}; 
#endif
#line 884 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 884
enum cudaResourceType { 
#line 886
cudaResourceTypeArray, 
#line 887
cudaResourceTypeMipmappedArray, 
#line 888
cudaResourceTypeLinear, 
#line 889
cudaResourceTypePitch2D
#line 890
}; 
#endif
#line 895 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 895
enum cudaResourceViewFormat { 
#line 897
cudaResViewFormatNone, 
#line 898
cudaResViewFormatUnsignedChar1, 
#line 899
cudaResViewFormatUnsignedChar2, 
#line 900
cudaResViewFormatUnsignedChar4, 
#line 901
cudaResViewFormatSignedChar1, 
#line 902
cudaResViewFormatSignedChar2, 
#line 903
cudaResViewFormatSignedChar4, 
#line 904
cudaResViewFormatUnsignedShort1, 
#line 905
cudaResViewFormatUnsignedShort2, 
#line 906
cudaResViewFormatUnsignedShort4, 
#line 907
cudaResViewFormatSignedShort1, 
#line 908
cudaResViewFormatSignedShort2, 
#line 909
cudaResViewFormatSignedShort4, 
#line 910
cudaResViewFormatUnsignedInt1, 
#line 911
cudaResViewFormatUnsignedInt2, 
#line 912
cudaResViewFormatUnsignedInt4, 
#line 913
cudaResViewFormatSignedInt1, 
#line 914
cudaResViewFormatSignedInt2, 
#line 915
cudaResViewFormatSignedInt4, 
#line 916
cudaResViewFormatHalf1, 
#line 917
cudaResViewFormatHalf2, 
#line 918
cudaResViewFormatHalf4, 
#line 919
cudaResViewFormatFloat1, 
#line 920
cudaResViewFormatFloat2, 
#line 921
cudaResViewFormatFloat4, 
#line 922
cudaResViewFormatUnsignedBlockCompressed1, 
#line 923
cudaResViewFormatUnsignedBlockCompressed2, 
#line 924
cudaResViewFormatUnsignedBlockCompressed3, 
#line 925
cudaResViewFormatUnsignedBlockCompressed4, 
#line 926
cudaResViewFormatSignedBlockCompressed4, 
#line 927
cudaResViewFormatUnsignedBlockCompressed5, 
#line 928
cudaResViewFormatSignedBlockCompressed5, 
#line 929
cudaResViewFormatUnsignedBlockCompressed6H, 
#line 930
cudaResViewFormatSignedBlockCompressed6H, 
#line 931
cudaResViewFormatUnsignedBlockCompressed7
#line 932
}; 
#endif
#line 937 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 937
struct cudaResourceDesc { 
#line 938
cudaResourceType resType; 
#line 940
union { 
#line 941
struct { 
#line 942
cudaArray_t array; 
#line 943
} array; 
#line 944
struct { 
#line 945
cudaMipmappedArray_t mipmap; 
#line 946
} mipmap; 
#line 947
struct { 
#line 948
void *devPtr; 
#line 949
cudaChannelFormatDesc desc; 
#line 950
size_t sizeInBytes; 
#line 951
} linear; 
#line 952
struct { 
#line 953
void *devPtr; 
#line 954
cudaChannelFormatDesc desc; 
#line 955
size_t width; 
#line 956
size_t height; 
#line 957
size_t pitchInBytes; 
#line 958
} pitch2D; 
#line 959
} res; 
#line 960
}; 
#endif
#line 965 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 965
struct cudaResourceViewDesc { 
#line 967
cudaResourceViewFormat format; 
#line 968
size_t width; 
#line 969
size_t height; 
#line 970
size_t depth; 
#line 971
unsigned firstMipmapLevel; 
#line 972
unsigned lastMipmapLevel; 
#line 973
unsigned firstLayer; 
#line 974
unsigned lastLayer; 
#line 975
}; 
#endif
#line 980 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 980
struct cudaPointerAttributes { 
#line 986
cudaMemoryType memoryType; 
#line 997
int device; 
#line 1003
void *devicePointer; 
#line 1009
void *hostPointer; 
#line 1014
int isManaged; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 1015
}; 
#endif
#line 1020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 1020
struct cudaFuncAttributes { 
#line 1027
size_t sharedSizeBytes; 
#line 1033
size_t constSizeBytes; 
#line 1038
size_t localSizeBytes; 
#line 1045
int maxThreadsPerBlock; 
#line 1050
int numRegs; 
#line 1057
int ptxVersion; 
#line 1064
int binaryVersion; 
#line 1070
int cacheModeCA; 
#line 1071
}; 
#endif
#line 1076 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 1076
enum cudaFuncCache { 
#line 1078
cudaFuncCachePreferNone, 
#line 1079
cudaFuncCachePreferShared, 
#line 1080
cudaFuncCachePreferL1, 
#line 1081
cudaFuncCachePreferEqual
#line 1082
}; 
#endif
#line 1088 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 1088
enum cudaSharedMemConfig { 
#line 1090
cudaSharedMemBankSizeDefault, 
#line 1091
cudaSharedMemBankSizeFourByte, 
#line 1092
cudaSharedMemBankSizeEightByte
#line 1093
}; 
#endif
#line 1098 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 1098
enum cudaComputeMode { 
#line 1100
cudaComputeModeDefault, 
#line 1101
cudaComputeModeExclusive, 
#line 1102
cudaComputeModeProhibited, 
#line 1103
cudaComputeModeExclusiveProcess
#line 1104
}; 
#endif
#line 1109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 1109
enum cudaLimit { 
#line 1111
cudaLimitStackSize, 
#line 1112
cudaLimitPrintfFifoSize, 
#line 1113
cudaLimitMallocHeapSize, 
#line 1114
cudaLimitDevRuntimeSyncDepth, 
#line 1115
cudaLimitDevRuntimePendingLaunchCount
#line 1116
}; 
#endif
#line 1121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 1121
enum cudaOutputMode { 
#line 1123
cudaKeyValuePair, 
#line 1124
cudaCSV
#line 1125
}; 
#endif
#line 1130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 1130
enum cudaDeviceAttr { 
#line 1132
cudaDevAttrMaxThreadsPerBlock = 1, 
#line 1133
cudaDevAttrMaxBlockDimX, 
#line 1134
cudaDevAttrMaxBlockDimY, 
#line 1135
cudaDevAttrMaxBlockDimZ, 
#line 1136
cudaDevAttrMaxGridDimX, 
#line 1137
cudaDevAttrMaxGridDimY, 
#line 1138
cudaDevAttrMaxGridDimZ, 
#line 1139
cudaDevAttrMaxSharedMemoryPerBlock, 
#line 1140
cudaDevAttrTotalConstantMemory, 
#line 1141
cudaDevAttrWarpSize, 
#line 1142
cudaDevAttrMaxPitch, 
#line 1143
cudaDevAttrMaxRegistersPerBlock, 
#line 1144
cudaDevAttrClockRate, 
#line 1145
cudaDevAttrTextureAlignment, 
#line 1146
cudaDevAttrGpuOverlap, 
#line 1147
cudaDevAttrMultiProcessorCount, 
#line 1148
cudaDevAttrKernelExecTimeout, 
#line 1149
cudaDevAttrIntegrated, 
#line 1150
cudaDevAttrCanMapHostMemory, 
#line 1151
cudaDevAttrComputeMode, 
#line 1152
cudaDevAttrMaxTexture1DWidth, 
#line 1153
cudaDevAttrMaxTexture2DWidth, 
#line 1154
cudaDevAttrMaxTexture2DHeight, 
#line 1155
cudaDevAttrMaxTexture3DWidth, 
#line 1156
cudaDevAttrMaxTexture3DHeight, 
#line 1157
cudaDevAttrMaxTexture3DDepth, 
#line 1158
cudaDevAttrMaxTexture2DLayeredWidth, 
#line 1159
cudaDevAttrMaxTexture2DLayeredHeight, 
#line 1160
cudaDevAttrMaxTexture2DLayeredLayers, 
#line 1161
cudaDevAttrSurfaceAlignment, 
#line 1162
cudaDevAttrConcurrentKernels, 
#line 1163
cudaDevAttrEccEnabled, 
#line 1164
cudaDevAttrPciBusId, 
#line 1165
cudaDevAttrPciDeviceId, 
#line 1166
cudaDevAttrTccDriver, 
#line 1167
cudaDevAttrMemoryClockRate, 
#line 1168
cudaDevAttrGlobalMemoryBusWidth, 
#line 1169
cudaDevAttrL2CacheSize, 
#line 1170
cudaDevAttrMaxThreadsPerMultiProcessor, 
#line 1171
cudaDevAttrAsyncEngineCount, 
#line 1172
cudaDevAttrUnifiedAddressing, 
#line 1173
cudaDevAttrMaxTexture1DLayeredWidth, 
#line 1174
cudaDevAttrMaxTexture1DLayeredLayers, 
#line 1175
cudaDevAttrMaxTexture2DGatherWidth = 45, 
#line 1176
cudaDevAttrMaxTexture2DGatherHeight, 
#line 1177
cudaDevAttrMaxTexture3DWidthAlt, 
#line 1178
cudaDevAttrMaxTexture3DHeightAlt, 
#line 1179
cudaDevAttrMaxTexture3DDepthAlt, 
#line 1180
cudaDevAttrPciDomainId, 
#line 1181
cudaDevAttrTexturePitchAlignment, 
#line 1182
cudaDevAttrMaxTextureCubemapWidth, 
#line 1183
cudaDevAttrMaxTextureCubemapLayeredWidth, 
#line 1184
cudaDevAttrMaxTextureCubemapLayeredLayers, 
#line 1185
cudaDevAttrMaxSurface1DWidth, 
#line 1186
cudaDevAttrMaxSurface2DWidth, 
#line 1187
cudaDevAttrMaxSurface2DHeight, 
#line 1188
cudaDevAttrMaxSurface3DWidth, 
#line 1189
cudaDevAttrMaxSurface3DHeight, 
#line 1190
cudaDevAttrMaxSurface3DDepth, 
#line 1191
cudaDevAttrMaxSurface1DLayeredWidth, 
#line 1192
cudaDevAttrMaxSurface1DLayeredLayers, 
#line 1193
cudaDevAttrMaxSurface2DLayeredWidth, 
#line 1194
cudaDevAttrMaxSurface2DLayeredHeight, 
#line 1195
cudaDevAttrMaxSurface2DLayeredLayers, 
#line 1196
cudaDevAttrMaxSurfaceCubemapWidth, 
#line 1197
cudaDevAttrMaxSurfaceCubemapLayeredWidth, 
#line 1198
cudaDevAttrMaxSurfaceCubemapLayeredLayers, 
#line 1199
cudaDevAttrMaxTexture1DLinearWidth, 
#line 1200
cudaDevAttrMaxTexture2DLinearWidth, 
#line 1201
cudaDevAttrMaxTexture2DLinearHeight, 
#line 1202
cudaDevAttrMaxTexture2DLinearPitch, 
#line 1203
cudaDevAttrMaxTexture2DMipmappedWidth, 
#line 1204
cudaDevAttrMaxTexture2DMipmappedHeight, 
#line 1205
cudaDevAttrComputeCapabilityMajor, 
#line 1206
cudaDevAttrComputeCapabilityMinor, 
#line 1207
cudaDevAttrMaxTexture1DMipmappedWidth, 
#line 1208
cudaDevAttrStreamPrioritiesSupported, 
#line 1209
cudaDevAttrGlobalL1CacheSupported, 
#line 1210
cudaDevAttrLocalL1CacheSupported, 
#line 1211
cudaDevAttrMaxSharedMemoryPerMultiprocessor, 
#line 1212
cudaDevAttrMaxRegistersPerMultiprocessor, 
#line 1213
cudaDevAttrManagedMemory, 
#line 1214
cudaDevAttrIsMultiGpuBoard, 
#line 1215
cudaDevAttrMultiGpuBoardGroupID
#line 1216
}; 
#endif
#line 1221 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
#line 1221
struct cudaDeviceProp { 
#line 1223
char name[256]; 
#line 1224
size_t totalGlobalMem; 
#line 1225
size_t sharedMemPerBlock; 
#line 1226
int regsPerBlock; 
#line 1227
int warpSize; 
#line 1228
size_t memPitch; 
#line 1229
int maxThreadsPerBlock; 
#line 1230
int maxThreadsDim[3]; 
#line 1231
int maxGridSize[3]; 
#line 1232
int clockRate; 
#line 1233
size_t totalConstMem; 
#line 1234
int major; 
#line 1235
int minor; 
#line 1236
size_t textureAlignment; 
#line 1237
size_t texturePitchAlignment; 
#line 1238
int deviceOverlap; 
#line 1239
int multiProcessorCount; 
#line 1240
int kernelExecTimeoutEnabled; 
#line 1241
int integrated; 
#line 1242
int canMapHostMemory; 
#line 1243
int computeMode; 
#line 1244
int maxTexture1D; 
#line 1245
int maxTexture1DMipmap; 
#line 1246
int maxTexture1DLinear; 
#line 1247
int maxTexture2D[2]; 
#line 1248
int maxTexture2DMipmap[2]; 
#line 1249
int maxTexture2DLinear[3]; 
#line 1250
int maxTexture2DGather[2]; 
#line 1251
int maxTexture3D[3]; 
#line 1252
int maxTexture3DAlt[3]; 
#line 1253
int maxTextureCubemap; 
#line 1254
int maxTexture1DLayered[2]; 
#line 1255
int maxTexture2DLayered[3]; 
#line 1256
int maxTextureCubemapLayered[2]; 
#line 1257
int maxSurface1D; 
#line 1258
int maxSurface2D[2]; 
#line 1259
int maxSurface3D[3]; 
#line 1260
int maxSurface1DLayered[2]; 
#line 1261
int maxSurface2DLayered[3]; 
#line 1262
int maxSurfaceCubemap; 
#line 1263
int maxSurfaceCubemapLayered[2]; 
#line 1264
size_t surfaceAlignment; 
#line 1265
int concurrentKernels; 
#line 1266
int ECCEnabled; 
#line 1267
int pciBusID; 
#line 1268
int pciDeviceID; 
#line 1269
int pciDomainID; 
#line 1270
int tccDriver; 
#line 1271
int asyncEngineCount; 
#line 1272
int unifiedAddressing; 
#line 1273
int memoryClockRate; 
#line 1274
int memoryBusWidth; 
#line 1275
int l2CacheSize; 
#line 1276
int maxThreadsPerMultiProcessor; 
#line 1277
int streamPrioritiesSupported; 
#line 1278
int globalL1CacheSupported; 
#line 1279
int localL1CacheSupported; 
#line 1280
size_t sharedMemPerMultiprocessor; 
#line 1281
int regsPerMultiprocessor; 
#line 1282
int managedMemory; 
#line 1283
int isMultiGpuBoard; 
#line 1284
int multiGpuBoardGroupID; 
#line 1285
}; 
#endif
#line 1364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
typedef 
#line 1361
struct cudaIpcEventHandle_st { 
#line 1363
char reserved[64]; 
#line 1364
} cudaIpcEventHandle_t; 
#endif
#line 1372 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
typedef 
#line 1369
struct cudaIpcMemHandle_st { 
#line 1371
char reserved[64]; 
#line 1372
} cudaIpcMemHandle_t; 
#endif
#line 1383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
typedef cudaError 
#line 1383
cudaError_t; 
#endif
#line 1388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
typedef struct CUstream_st *
#line 1388
cudaStream_t; 
#endif
#line 1393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
typedef struct CUevent_st *
#line 1393
cudaEvent_t; 
#endif
#line 1398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
typedef cudaGraphicsResource *
#line 1398
cudaGraphicsResource_t; 
#endif
#line 1403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
typedef struct CUuuid_st 
#line 1403
cudaUUID_t; 
#endif
#line 1408 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_types.h"
#if 0
typedef cudaOutputMode 
#line 1408
cudaOutputMode_t; 
#endif
#line 84 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_types.h"
#if 0
#line 84
enum cudaSurfaceBoundaryMode { 
#line 86
cudaBoundaryModeZero, 
#line 87
cudaBoundaryModeClamp, 
#line 88
cudaBoundaryModeTrap
#line 89
}; 
#endif
#line 94 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_types.h"
#if 0
#line 94
enum cudaSurfaceFormatMode { 
#line 96
cudaFormatModeForced, 
#line 97
cudaFormatModeAuto
#line 98
}; 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_types.h"
#if 0
#line 103
struct surfaceReference { 
#line 108
cudaChannelFormatDesc channelDesc; 
#line 109
}; 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_types.h"
#if 0
typedef unsigned __int64 
#line 114
cudaSurfaceObject_t; 
#endif
#line 84 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_types.h"
#if 0
#line 84
enum cudaTextureAddressMode { 
#line 86
cudaAddressModeWrap, 
#line 87
cudaAddressModeClamp, 
#line 88
cudaAddressModeMirror, 
#line 89
cudaAddressModeBorder
#line 90
}; 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_types.h"
#if 0
#line 95
enum cudaTextureFilterMode { 
#line 97
cudaFilterModePoint, 
#line 98
cudaFilterModeLinear
#line 99
}; 
#endif
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_types.h"
#if 0
#line 104
enum cudaTextureReadMode { 
#line 106
cudaReadModeElementType, 
#line 107
cudaReadModeNormalizedFloat
#line 108
}; 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_types.h"
#if 0
#line 113
struct textureReference { 
#line 118
int normalized; 
#line 122
cudaTextureFilterMode filterMode; 
#line 126
cudaTextureAddressMode addressMode[3]; 
#line 130
cudaChannelFormatDesc channelDesc; 
#line 134
int sRGB; 
#line 138
unsigned maxAnisotropy; 
#line 142
cudaTextureFilterMode mipmapFilterMode; 
#line 146
float mipmapLevelBias; 
#line 150
float minMipmapLevelClamp; 
#line 154
float maxMipmapLevelClamp; 
#line 155
int __cudaReserved[15]; 
#line 156
}; 
#endif
#line 161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_types.h"
#if 0
#line 161
struct cudaTextureDesc { 
#line 166
cudaTextureAddressMode addressMode[3]; 
#line 170
cudaTextureFilterMode filterMode; 
#line 174
cudaTextureReadMode readMode; 
#line 178
int sRGB; 
#line 182
int normalizedCoords; 
#line 186
unsigned maxAnisotropy; 
#line 190
cudaTextureFilterMode mipmapFilterMode; 
#line 194
float mipmapLevelBias; 
#line 198
float minMipmapLevelClamp; 
#line 202
float maxMipmapLevelClamp; 
#line 203
}; 
#endif
#line 208 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_types.h"
#if 0
typedef unsigned __int64 
#line 208
cudaTextureObject_t; 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 96
struct char1 { 
#line 98
signed char x; 
#line 99
}; 
#endif
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 101
struct uchar1 { 
#line 103
unsigned char x; 
#line 104
}; 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 107
struct __declspec(align(2)) char2 { 
#line 109
signed char x, y; 
#line 110
}; 
#endif
#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 112
struct __declspec(align(2)) uchar2 { 
#line 114
unsigned char x, y; 
#line 115
}; 
#endif
#line 117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 117
struct char3 { 
#line 119
signed char x, y, z; 
#line 120
}; 
#endif
#line 122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 122
struct uchar3 { 
#line 124
unsigned char x, y, z; 
#line 125
}; 
#endif
#line 127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 127
struct __declspec(align(4)) char4 { 
#line 129
signed char x, y, z, w; 
#line 130
}; 
#endif
#line 132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 132
struct __declspec(align(4)) uchar4 { 
#line 134
unsigned char x, y, z, w; 
#line 135
}; 
#endif
#line 137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 137
struct short1 { 
#line 139
short x; 
#line 140
}; 
#endif
#line 142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 142
struct ushort1 { 
#line 144
unsigned short x; 
#line 145
}; 
#endif
#line 147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 147
struct __declspec(align(4)) short2 { 
#line 149
short x, y; 
#line 150
}; 
#endif
#line 152 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 152
struct __declspec(align(4)) ushort2 { 
#line 154
unsigned short x, y; 
#line 155
}; 
#endif
#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 157
struct short3 { 
#line 159
short x, y, z; 
#line 160
}; 
#endif
#line 162 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 162
struct ushort3 { 
#line 164
unsigned short x, y, z; 
#line 165
}; 
#endif
#line 167 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 167
struct __declspec(align(8)) short4 { short x; short y; short z; short w; }; 
#endif
#line 168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 168
struct __declspec(align(8)) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; 
#endif
#line 170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 170
struct int1 { 
#line 172
int x; 
#line 173
}; 
#endif
#line 175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 175
struct uint1 { 
#line 177
unsigned x; 
#line 178
}; 
#endif
#line 180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 180
struct __declspec(align(8)) int2 { int x; int y; }; 
#endif
#line 181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 181
struct __declspec(align(8)) uint2 { unsigned x; unsigned y; }; 
#endif
#line 183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 183
struct int3 { 
#line 185
int x, y, z; 
#line 186
}; 
#endif
#line 188 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 188
struct uint3 { 
#line 190
unsigned x, y, z; 
#line 191
}; 
#endif
#line 193 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 193
struct __declspec(align(16)) int4 { 
#line 195
int x, y, z, w; 
#line 196
}; 
#endif
#line 198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 198
struct __declspec(align(16)) uint4 { 
#line 200
unsigned x, y, z, w; 
#line 201
}; 
#endif
#line 203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 203
struct long1 { 
#line 205
long x; 
#line 206
}; 
#endif
#line 208 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 208
struct ulong1 { 
#line 210
unsigned long x; 
#line 211
}; 
#endif
#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 214
struct __declspec(align(8)) long2 { long x; long y; }; 
#endif
#line 215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 215
struct __declspec(align(8)) ulong2 { unsigned long x; unsigned long y; }; 
#endif
#line 230 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 230
struct long3 { 
#line 232
long x, y, z; 
#line 233
}; 
#endif
#line 235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 235
struct ulong3 { 
#line 237
unsigned long x, y, z; 
#line 238
}; 
#endif
#line 240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 240
struct __declspec(align(16)) long4 { 
#line 242
long x, y, z, w; 
#line 243
}; 
#endif
#line 245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 245
struct __declspec(align(16)) ulong4 { 
#line 247
unsigned long x, y, z, w; 
#line 248
}; 
#endif
#line 250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 250
struct float1 { 
#line 252
float x; 
#line 253
}; 
#endif
#line 272 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 272
struct __declspec(align(8)) float2 { float x; float y; }; 
#endif
#line 277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 277
struct float3 { 
#line 279
float x, y, z; 
#line 280
}; 
#endif
#line 282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 282
struct __declspec(align(16)) float4 { 
#line 284
float x, y, z, w; 
#line 285
}; 
#endif
#line 287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 287
struct longlong1 { 
#line 289
__int64 x; 
#line 290
}; 
#endif
#line 292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 292
struct ulonglong1 { 
#line 294
unsigned __int64 x; 
#line 295
}; 
#endif
#line 297 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 297
struct __declspec(align(16)) longlong2 { 
#line 299
__int64 x, y; 
#line 300
}; 
#endif
#line 302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 302
struct __declspec(align(16)) ulonglong2 { 
#line 304
unsigned __int64 x, y; 
#line 305
}; 
#endif
#line 307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 307
struct longlong3 { 
#line 309
__int64 x, y, z; 
#line 310
}; 
#endif
#line 312 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 312
struct ulonglong3 { 
#line 314
unsigned __int64 x, y, z; 
#line 315
}; 
#endif
#line 317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 317
struct __declspec(align(16)) longlong4 { 
#line 319
__int64 x, y, z, w; 
#line 320
}; 
#endif
#line 322 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 322
struct __declspec(align(16)) ulonglong4 { 
#line 324
unsigned __int64 x, y, z, w; 
#line 325
}; 
#endif
#line 327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 327
struct double1 { 
#line 329
double x; 
#line 330
}; 
#endif
#line 332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 332
struct __declspec(align(16)) double2 { 
#line 334
double x, y; 
#line 335
}; 
#endif
#line 337 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 337
struct double3 { 
#line 339
double x, y, z; 
#line 340
}; 
#endif
#line 342 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 342
struct __declspec(align(16)) double4 { 
#line 344
double x, y, z, w; 
#line 345
}; 
#endif
#line 360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef char1 
#line 360
char1; 
#endif
#line 361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef uchar1 
#line 361
uchar1; 
#endif
#line 362 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef char2 
#line 362
char2; 
#endif
#line 363 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef uchar2 
#line 363
uchar2; 
#endif
#line 364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef char3 
#line 364
char3; 
#endif
#line 365 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef uchar3 
#line 365
uchar3; 
#endif
#line 366 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef char4 
#line 366
char4; 
#endif
#line 367 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef uchar4 
#line 367
uchar4; 
#endif
#line 368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef short1 
#line 368
short1; 
#endif
#line 369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef ushort1 
#line 369
ushort1; 
#endif
#line 370 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef short2 
#line 370
short2; 
#endif
#line 371 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef ushort2 
#line 371
ushort2; 
#endif
#line 372 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef short3 
#line 372
short3; 
#endif
#line 373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef ushort3 
#line 373
ushort3; 
#endif
#line 374 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef short4 
#line 374
short4; 
#endif
#line 375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef ushort4 
#line 375
ushort4; 
#endif
#line 376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef int1 
#line 376
int1; 
#endif
#line 377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef uint1 
#line 377
uint1; 
#endif
#line 378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef int2 
#line 378
int2; 
#endif
#line 379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef uint2 
#line 379
uint2; 
#endif
#line 380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef int3 
#line 380
int3; 
#endif
#line 381 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef uint3 
#line 381
uint3; 
#endif
#line 382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef int4 
#line 382
int4; 
#endif
#line 383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef uint4 
#line 383
uint4; 
#endif
#line 384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef long1 
#line 384
long1; 
#endif
#line 385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef ulong1 
#line 385
ulong1; 
#endif
#line 386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef long2 
#line 386
long2; 
#endif
#line 387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef ulong2 
#line 387
ulong2; 
#endif
#line 388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef long3 
#line 388
long3; 
#endif
#line 389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef ulong3 
#line 389
ulong3; 
#endif
#line 390 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef long4 
#line 390
long4; 
#endif
#line 391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef ulong4 
#line 391
ulong4; 
#endif
#line 392 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef float1 
#line 392
float1; 
#endif
#line 393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef float2 
#line 393
float2; 
#endif
#line 394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef float3 
#line 394
float3; 
#endif
#line 395 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef float4 
#line 395
float4; 
#endif
#line 396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef longlong1 
#line 396
longlong1; 
#endif
#line 397 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef ulonglong1 
#line 397
ulonglong1; 
#endif
#line 398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef longlong2 
#line 398
longlong2; 
#endif
#line 399 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef ulonglong2 
#line 399
ulonglong2; 
#endif
#line 400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef longlong3 
#line 400
longlong3; 
#endif
#line 401 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef ulonglong3 
#line 401
ulonglong3; 
#endif
#line 402 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef longlong4 
#line 402
longlong4; 
#endif
#line 403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef ulonglong4 
#line 403
ulonglong4; 
#endif
#line 404 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef double1 
#line 404
double1; 
#endif
#line 405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef double2 
#line 405
double2; 
#endif
#line 406 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef double3 
#line 406
double3; 
#endif
#line 407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef double4 
#line 407
double4; 
#endif
#line 415 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
#line 415
struct dim3 { 
#line 417
unsigned x, y, z; 
#line 423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
}; 
#endif
#line 425 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_types.h"
#if 0
typedef dim3 
#line 425
dim3; 
#endif
#line 86 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\cuda_device_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaDeviceGetAttribute(int * , cudaDeviceAttr , int ); } 
#line 87
extern "C" { extern cudaError_t __stdcall cudaDeviceGetLimit(size_t * , cudaLimit ); } 
#line 88
extern "C" { extern cudaError_t __stdcall cudaDeviceGetCacheConfig(cudaFuncCache * ); } 
#line 89
extern "C" { extern cudaError_t __stdcall cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * ); } 
#line 90
extern "C" { extern cudaError_t __stdcall cudaDeviceSynchronize(); } 
#line 91
extern "C" { extern cudaError_t __stdcall cudaGetLastError(); } 
#line 92
extern "C" { extern cudaError_t __stdcall cudaPeekAtLastError(); } 
#line 93
extern "C" { extern const char *__stdcall cudaGetErrorString(cudaError_t ); } 
#line 94
extern "C" { extern cudaError_t __stdcall cudaGetDeviceCount(int * ); } 
#line 95
extern "C" { extern cudaError_t __stdcall cudaGetDevice(int * ); } 
#line 96
extern "C" { extern cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t * , unsigned ); } 
#line 97
extern "C" { extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t ); } 
#line 98
extern "C" { extern cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t , cudaEvent_t , unsigned ); } 
#line 99
extern "C" { extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t * , unsigned ); } 
#line 100
extern "C" { extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t , cudaStream_t ); } 
#line 101
extern "C" { extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t ); } 
#line 102
extern "C" { extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes * , const void * ); } 
#line 103
extern "C" { extern cudaError_t __stdcall cudaFree(void * ); } 
#line 104
extern "C" { extern cudaError_t __stdcall cudaMalloc(void ** , size_t ); } 
#line 105
extern "C" { extern cudaError_t __stdcall cudaMemcpyAsync(void * , const void * , size_t , cudaMemcpyKind , cudaStream_t ); } 
#line 106
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DAsync(void * , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t ); } 
#line 107
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms * , cudaStream_t ); } 
#line 108
extern "C" { extern cudaError_t __stdcall cudaMemsetAsync(void * , int , size_t , cudaStream_t ); } 
#line 109
extern "C" { extern cudaError_t __stdcall cudaMemset2DAsync(void * , size_t , int , size_t , size_t , cudaStream_t ); } 
#line 110
extern "C" { extern cudaError_t __stdcall cudaMemset3DAsync(cudaPitchedPtr , int , cudaExtent , cudaStream_t ); } 
#line 111
extern "C" { extern cudaError_t __stdcall cudaRuntimeGetVersion(int * ); } 
#line 113
extern "C" { extern void *__stdcall cudaGetParameterBuffer(size_t , size_t ); } 
#line 114
extern "C" { extern cudaError_t __stdcall cudaLaunchDevice(void * , void * , dim3 , dim3 , unsigned , cudaStream_t ); } 
#line 115
extern "C" { extern void *__stdcall cudaGetParameterBufferV2(void * , dim3 , dim3 , unsigned ); } 
#line 116
extern "C" { extern cudaError_t __stdcall cudaLaunchDeviceV2(void * , cudaStream_t ); } 
#line 118
namespace _GLOBAL__N__26_pCT_Reconstruction_cpp1_ii_ped { }; using namespace _GLOBAL__N__26_pCT_Reconstruction_cpp1_ii_ped; namespace _GLOBAL__N__26_pCT_Reconstruction_cpp1_ii_ped { 
#line 119
template< class T> __inline cudaError_t cudaMalloc(T ** , size_t ); 
#line 120
template< class T> __inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * , T * ); 
#line 121
}
#line 207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaDeviceReset(); } 
#line 224
extern "C" { extern cudaError_t __stdcall cudaDeviceSynchronize(); } 
#line 309
extern "C" { extern cudaError_t __stdcall cudaDeviceSetLimit(cudaLimit , size_t ); } 
#line 338
extern "C" { extern cudaError_t __stdcall cudaDeviceGetLimit(size_t * , cudaLimit ); } 
#line 369
extern "C" { extern cudaError_t __stdcall cudaDeviceGetCacheConfig(cudaFuncCache * ); } 
#line 404
extern "C" { extern cudaError_t __stdcall cudaDeviceGetStreamPriorityRange(int * , int * ); } 
#line 446
extern "C" { extern cudaError_t __stdcall cudaDeviceSetCacheConfig(cudaFuncCache ); } 
#line 475
extern "C" { extern cudaError_t __stdcall cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * ); } 
#line 517
extern "C" { extern cudaError_t __stdcall cudaDeviceSetSharedMemConfig(cudaSharedMemConfig ); } 
#line 540
extern "C" { extern cudaError_t __stdcall cudaDeviceGetByPCIBusId(int * , const char * ); } 
#line 567
extern "C" { extern cudaError_t __stdcall cudaDeviceGetPCIBusId(char * , int , int ); } 
#line 609
extern "C" { extern cudaError_t __stdcall cudaIpcGetEventHandle(cudaIpcEventHandle_t * , cudaEvent_t ); } 
#line 644
extern "C" { extern cudaError_t __stdcall cudaIpcOpenEventHandle(cudaEvent_t * , cudaIpcEventHandle_t ); } 
#line 682
extern "C" { extern cudaError_t __stdcall cudaIpcGetMemHandle(cudaIpcMemHandle_t * , void * ); } 
#line 732
extern "C" { extern cudaError_t __stdcall cudaIpcOpenMemHandle(void ** , cudaIpcMemHandle_t , unsigned ); } 
#line 762
extern "C" { extern cudaError_t __stdcall cudaIpcCloseMemHandle(void * ); } 
#line 802
extern "C" { extern cudaError_t __stdcall cudaThreadExit(); } 
#line 826
extern "C" { extern cudaError_t __stdcall cudaThreadSynchronize(); } 
#line 885
extern "C" { extern cudaError_t __stdcall cudaThreadSetLimit(cudaLimit , size_t ); } 
#line 916
extern "C" { extern cudaError_t __stdcall cudaThreadGetLimit(size_t * , cudaLimit ); } 
#line 951
extern "C" { extern cudaError_t __stdcall cudaThreadGetCacheConfig(cudaFuncCache * ); } 
#line 997
extern "C" { extern cudaError_t __stdcall cudaThreadSetCacheConfig(cudaFuncCache ); } 
#line 1051
extern "C" { extern cudaError_t __stdcall cudaGetLastError(); } 
#line 1092
extern "C" { extern cudaError_t __stdcall cudaPeekAtLastError(); } 
#line 1106
extern "C" { extern const char *__stdcall cudaGetErrorString(cudaError_t ); } 
#line 1136
extern "C" { extern cudaError_t __stdcall cudaGetDeviceCount(int * ); } 
#line 1372
extern "C" { extern cudaError_t __stdcall cudaGetDeviceProperties(cudaDeviceProp * , int ); } 
#line 1532
extern "C" { extern cudaError_t __stdcall cudaDeviceGetAttribute(int * , cudaDeviceAttr , int ); } 
#line 1551
extern "C" { extern cudaError_t __stdcall cudaChooseDevice(int * , const cudaDeviceProp * ); } 
#line 1585
extern "C" { extern cudaError_t __stdcall cudaSetDevice(int ); } 
#line 1602
extern "C" { extern cudaError_t __stdcall cudaGetDevice(int * ); } 
#line 1631
extern "C" { extern cudaError_t __stdcall cudaSetValidDevices(int * , int ); } 
#line 1691
extern "C" { extern cudaError_t __stdcall cudaSetDeviceFlags(unsigned ); } 
#line 1729
extern "C" { extern cudaError_t __stdcall cudaStreamCreate(cudaStream_t * ); } 
#line 1758
extern "C" { extern cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t * , unsigned ); } 
#line 1801
extern "C" { extern cudaError_t __stdcall cudaStreamCreateWithPriority(cudaStream_t * , unsigned , int ); } 
#line 1825
extern "C" { extern cudaError_t __stdcall cudaStreamGetPriority(cudaStream_t , int * ); } 
#line 1846
extern "C" { extern cudaError_t __stdcall cudaStreamGetFlags(cudaStream_t , unsigned * ); } 
#line 1867
extern "C" { extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t ); } 
#line 1899
extern "C" { extern cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t , cudaEvent_t , unsigned ); } 
#line 1913 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\cuda_runtime_api.h"
extern "C" { typedef void (__stdcall *cudaStreamCallback_t)(cudaStream_t , cudaError_t , void * ); }
#line 1975
extern "C" { extern cudaError_t __stdcall cudaStreamAddCallback(cudaStream_t , cudaStreamCallback_t , void * , unsigned ); } 
#line 1995
extern "C" { extern cudaError_t __stdcall cudaStreamSynchronize(cudaStream_t ); } 
#line 2016
extern "C" { extern cudaError_t __stdcall cudaStreamQuery(cudaStream_t ); } 
#line 2082
extern "C" { extern cudaError_t __stdcall cudaStreamAttachMemAsync(cudaStream_t , void * , size_t , unsigned ); } 
#line 2118
extern "C" { extern cudaError_t __stdcall cudaEventCreate(cudaEvent_t * ); } 
#line 2152
extern "C" { extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t * , unsigned ); } 
#line 2183
extern "C" { extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t , cudaStream_t  = 0); } 
#line 2215
extern "C" { extern cudaError_t __stdcall cudaEventQuery(cudaEvent_t ); } 
#line 2247
extern "C" { extern cudaError_t __stdcall cudaEventSynchronize(cudaEvent_t ); } 
#line 2272
extern "C" { extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t ); } 
#line 2313
extern "C" { extern cudaError_t __stdcall cudaEventElapsedTime(float * , cudaEvent_t , cudaEvent_t ); } 
#line 2360
extern "C" { extern cudaError_t __stdcall cudaConfigureCall(dim3 , dim3 , size_t  = 0, cudaStream_t  = 0); } 
#line 2387
extern "C" { extern cudaError_t __stdcall cudaSetupArgument(const void * , size_t , size_t ); } 
#line 2433
extern "C" { extern cudaError_t __stdcall cudaFuncSetCacheConfig(const void * , cudaFuncCache ); } 
#line 2484
extern "C" { extern cudaError_t __stdcall cudaFuncSetSharedMemConfig(const void * , cudaSharedMemConfig ); } 
#line 2519
extern "C" { extern cudaError_t __stdcall cudaLaunch(const void * ); } 
#line 2552
extern "C" { extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes * , const void * ); } 
#line 2574
extern "C" { extern cudaError_t __stdcall cudaSetDoubleForDevice(double * ); } 
#line 2596
extern "C" { extern cudaError_t __stdcall cudaSetDoubleForHost(double * ); } 
#line 2683
extern "C" { extern cudaError_t __stdcall cudaMallocManaged(void ** , size_t , unsigned ); } 
#line 2706
extern "C" { extern cudaError_t __stdcall cudaMalloc(void ** , size_t ); } 
#line 2735
extern "C" { extern cudaError_t __stdcall cudaMallocHost(void ** , size_t ); } 
#line 2774
extern "C" { extern cudaError_t __stdcall cudaMallocPitch(void ** , size_t * , size_t , size_t ); } 
#line 2816
extern "C" { extern cudaError_t __stdcall cudaMallocArray(cudaArray_t * , const cudaChannelFormatDesc * , size_t , size_t  = 0, unsigned  = 0); } 
#line 2840
extern "C" { extern cudaError_t __stdcall cudaFree(void * ); } 
#line 2860
extern "C" { extern cudaError_t __stdcall cudaFreeHost(void * ); } 
#line 2882
extern "C" { extern cudaError_t __stdcall cudaFreeArray(cudaArray_t ); } 
#line 2904
extern "C" { extern cudaError_t __stdcall cudaFreeMipmappedArray(cudaMipmappedArray_t ); } 
#line 2963
extern "C" { extern cudaError_t __stdcall cudaHostAlloc(void ** , size_t , unsigned ); } 
#line 3016
extern "C" { extern cudaError_t __stdcall cudaHostRegister(void * , size_t , unsigned ); } 
#line 3035
extern "C" { extern cudaError_t __stdcall cudaHostUnregister(void * ); } 
#line 3062
extern "C" { extern cudaError_t __stdcall cudaHostGetDevicePointer(void ** , void * , unsigned ); } 
#line 3081
extern "C" { extern cudaError_t __stdcall cudaHostGetFlags(unsigned * , void * ); } 
#line 3116
extern "C" { extern cudaError_t __stdcall cudaMalloc3D(cudaPitchedPtr * , cudaExtent ); } 
#line 3251
extern "C" { extern cudaError_t __stdcall cudaMalloc3DArray(cudaArray_t * , const cudaChannelFormatDesc * , cudaExtent , unsigned  = 0); } 
#line 3372
extern "C" { extern cudaError_t __stdcall cudaMallocMipmappedArray(cudaMipmappedArray_t * , const cudaChannelFormatDesc * , cudaExtent , unsigned , unsigned  = 0); } 
#line 3398
extern "C" { extern cudaError_t __stdcall cudaGetMipmappedArrayLevel(cudaArray_t * , cudaMipmappedArray_const_t , unsigned ); } 
#line 3495
extern "C" { extern cudaError_t __stdcall cudaMemcpy3D(const cudaMemcpy3DParms * ); } 
#line 3523
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DPeer(const cudaMemcpy3DPeerParms * ); } 
#line 3628
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms * , cudaStream_t  = 0); } 
#line 3651
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DPeerAsync(const cudaMemcpy3DPeerParms * , cudaStream_t  = 0); } 
#line 3670
extern "C" { extern cudaError_t __stdcall cudaMemGetInfo(size_t * , size_t * ); } 
#line 3691
extern "C" { extern cudaError_t __stdcall cudaArrayGetInfo(cudaChannelFormatDesc * , cudaExtent * , unsigned * , cudaArray_t ); } 
#line 3726
extern "C" { extern cudaError_t __stdcall cudaMemcpy(void * , const void * , size_t , cudaMemcpyKind ); } 
#line 3758
extern "C" { extern cudaError_t __stdcall cudaMemcpyPeer(void * , int , const void * , int , size_t ); } 
#line 3792
extern "C" { extern cudaError_t __stdcall cudaMemcpyToArray(cudaArray_t , size_t , size_t , const void * , size_t , cudaMemcpyKind ); } 
#line 3826
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromArray(void * , cudaArray_const_t , size_t , size_t , size_t , cudaMemcpyKind ); } 
#line 3861
extern "C" { extern cudaError_t __stdcall cudaMemcpyArrayToArray(cudaArray_t , size_t , size_t , cudaArray_const_t , size_t , size_t , size_t , cudaMemcpyKind  = cudaMemcpyDeviceToDevice); } 
#line 3903
extern "C" { extern cudaError_t __stdcall cudaMemcpy2D(void * , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind ); } 
#line 3945
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DToArray(cudaArray_t , size_t , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind ); } 
#line 3987
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DFromArray(void * , size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , cudaMemcpyKind ); } 
#line 4027
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DArrayToArray(cudaArray_t , size_t , size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , cudaMemcpyKind  = cudaMemcpyDeviceToDevice); } 
#line 4062
extern "C" { extern cudaError_t __stdcall cudaMemcpyToSymbol(const void * , const void * , size_t , size_t  = 0, cudaMemcpyKind  = cudaMemcpyHostToDevice); } 
#line 4097
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromSymbol(void * , const void * , size_t , size_t  = 0, cudaMemcpyKind  = cudaMemcpyDeviceToHost); } 
#line 4140
extern "C" { extern cudaError_t __stdcall cudaMemcpyAsync(void * , const void * , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4172
extern "C" { extern cudaError_t __stdcall cudaMemcpyPeerAsync(void * , int , const void * , int , size_t , cudaStream_t  = 0); } 
#line 4214
extern "C" { extern cudaError_t __stdcall cudaMemcpyToArrayAsync(cudaArray_t , size_t , size_t , const void * , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4256
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromArrayAsync(void * , cudaArray_const_t , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4308
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DAsync(void * , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4359
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DToArrayAsync(cudaArray_t , size_t , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4409
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DFromArrayAsync(void * , size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4452
extern "C" { extern cudaError_t __stdcall cudaMemcpyToSymbolAsync(const void * , const void * , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4495
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromSymbolAsync(void * , const void * , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); } 
#line 4521
extern "C" { extern cudaError_t __stdcall cudaMemset(void * , int , size_t ); } 
#line 4551
extern "C" { extern cudaError_t __stdcall cudaMemset2D(void * , size_t , int , size_t , size_t ); } 
#line 4594
extern "C" { extern cudaError_t __stdcall cudaMemset3D(cudaPitchedPtr , int , cudaExtent ); } 
#line 4623
extern "C" { extern cudaError_t __stdcall cudaMemsetAsync(void * , int , size_t , cudaStream_t  = 0); } 
#line 4657
extern "C" { extern cudaError_t __stdcall cudaMemset2DAsync(void * , size_t , int , size_t , size_t , cudaStream_t  = 0); } 
#line 4704
extern "C" { extern cudaError_t __stdcall cudaMemset3DAsync(cudaPitchedPtr , int , cudaExtent , cudaStream_t  = 0); } 
#line 4727
extern "C" { extern cudaError_t __stdcall cudaGetSymbolAddress(void ** , const void * ); } 
#line 4749
extern "C" { extern cudaError_t __stdcall cudaGetSymbolSize(size_t * , const void * ); } 
#line 4903
extern "C" { extern cudaError_t __stdcall cudaPointerGetAttributes(cudaPointerAttributes * , const void * ); } 
#line 4941
extern "C" { extern cudaError_t __stdcall cudaDeviceCanAccessPeer(int * , int , int ); } 
#line 4978
extern "C" { extern cudaError_t __stdcall cudaDeviceEnablePeerAccess(int , unsigned ); } 
#line 4997
extern "C" { extern cudaError_t __stdcall cudaDeviceDisablePeerAccess(int ); } 
#line 5055
extern "C" { extern cudaError_t __stdcall cudaGraphicsUnregisterResource(cudaGraphicsResource_t ); } 
#line 5087
extern "C" { extern cudaError_t __stdcall cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t , unsigned ); } 
#line 5123
extern "C" { extern cudaError_t __stdcall cudaGraphicsMapResources(int , cudaGraphicsResource_t * , cudaStream_t  = 0); } 
#line 5155
extern "C" { extern cudaError_t __stdcall cudaGraphicsUnmapResources(int , cudaGraphicsResource_t * , cudaStream_t  = 0); } 
#line 5184
extern "C" { extern cudaError_t __stdcall cudaGraphicsResourceGetMappedPointer(void ** , size_t * , cudaGraphicsResource_t ); } 
#line 5218
extern "C" { extern cudaError_t __stdcall cudaGraphicsSubResourceGetMappedArray(cudaArray_t * , cudaGraphicsResource_t , unsigned , unsigned ); } 
#line 5243
extern "C" { extern cudaError_t __stdcall cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t * , cudaGraphicsResource_t ); } 
#line 5283
extern "C" { extern cudaError_t __stdcall cudaGetChannelDesc(cudaChannelFormatDesc * , cudaArray_const_t ); } 
#line 5318
extern "C" { extern cudaChannelFormatDesc __stdcall cudaCreateChannelDesc(int , int , int , int , cudaChannelFormatKind ); } 
#line 5365
extern "C" { extern cudaError_t __stdcall cudaBindTexture(size_t * , const textureReference * , const void * , const cudaChannelFormatDesc * , size_t  = 4294967295U); } 
#line 5416
extern "C" { extern cudaError_t __stdcall cudaBindTexture2D(size_t * , const textureReference * , const void * , const cudaChannelFormatDesc * , size_t , size_t , size_t ); } 
#line 5444
extern "C" { extern cudaError_t __stdcall cudaBindTextureToArray(const textureReference * , cudaArray_const_t , const cudaChannelFormatDesc * ); } 
#line 5472
extern "C" { extern cudaError_t __stdcall cudaBindTextureToMipmappedArray(const textureReference * , cudaMipmappedArray_const_t , const cudaChannelFormatDesc * ); } 
#line 5493
extern "C" { extern cudaError_t __stdcall cudaUnbindTexture(const textureReference * ); } 
#line 5518
extern "C" { extern cudaError_t __stdcall cudaGetTextureAlignmentOffset(size_t * , const textureReference * ); } 
#line 5543
extern "C" { extern cudaError_t __stdcall cudaGetTextureReference(const textureReference ** , const void * ); } 
#line 5583
extern "C" { extern cudaError_t __stdcall cudaBindSurfaceToArray(const surfaceReference * , cudaArray_const_t , const cudaChannelFormatDesc * ); } 
#line 5602
extern "C" { extern cudaError_t __stdcall cudaGetSurfaceReference(const surfaceReference ** , const void * ); } 
#line 5817
extern "C" { extern cudaError_t __stdcall cudaCreateTextureObject(cudaTextureObject_t * , const cudaResourceDesc * , const cudaTextureDesc * , const cudaResourceViewDesc * ); } 
#line 5832
extern "C" { extern cudaError_t __stdcall cudaDestroyTextureObject(cudaTextureObject_t ); } 
#line 5848
extern "C" { extern cudaError_t __stdcall cudaGetTextureObjectResourceDesc(cudaResourceDesc * , cudaTextureObject_t ); } 
#line 5864
extern "C" { extern cudaError_t __stdcall cudaGetTextureObjectTextureDesc(cudaTextureDesc * , cudaTextureObject_t ); } 
#line 5881
extern "C" { extern cudaError_t __stdcall cudaGetTextureObjectResourceViewDesc(cudaResourceViewDesc * , cudaTextureObject_t ); } 
#line 5918
extern "C" { extern cudaError_t __stdcall cudaCreateSurfaceObject(cudaSurfaceObject_t * , const cudaResourceDesc * ); } 
#line 5933
extern "C" { extern cudaError_t __stdcall cudaDestroySurfaceObject(cudaSurfaceObject_t ); } 
#line 5948
extern "C" { extern cudaError_t __stdcall cudaGetSurfaceObjectResourceDesc(cudaResourceDesc * , cudaSurfaceObject_t ); } 
#line 5975
extern "C" { extern cudaError_t __stdcall cudaDriverGetVersion(int * ); } 
#line 5992
extern "C" { extern cudaError_t __stdcall cudaRuntimeGetVersion(int * ); } 
#line 5997
extern "C" { extern cudaError_t __stdcall cudaGetExportTable(const void ** , const cudaUUID_t * ); } 
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\channel_descriptor.h"
template< class T> __inline ::cudaChannelFormatDesc cudaCreateChannelDesc() 
#line 108
{ 
#line 109
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
#line 110
} 
#line 112
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf() 
#line 113
{ 
#line 114
int e = (((int)sizeof(unsigned short)) * 8); 
#line 116
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 117
} 
#line 119
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf1() 
#line 120
{ 
#line 121
int e = (((int)sizeof(unsigned short)) * 8); 
#line 123
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 124
} 
#line 126
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf2() 
#line 127
{ 
#line 128
int e = (((int)sizeof(unsigned short)) * 8); 
#line 130
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 131
} 
#line 133
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf4() 
#line 134
{ 
#line 135
int e = (((int)sizeof(unsigned short)) * 8); 
#line 137
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 138
} 
#line 140
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char> () 
#line 141
{ 
#line 142
int e = (((int)sizeof(char)) * 8); 
#line 147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\channel_descriptor.h"
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\channel_descriptor.h"
} 
#line 151
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< signed char> () 
#line 152
{ 
#line 153
int e = (((int)sizeof(signed char)) * 8); 
#line 155
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 156
} 
#line 158
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned char> () 
#line 159
{ 
#line 160
int e = (((int)sizeof(unsigned char)) * 8); 
#line 162
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 163
} 
#line 165
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char1> () 
#line 166
{ 
#line 167
int e = (((int)sizeof(signed char)) * 8); 
#line 169
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 170
} 
#line 172
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar1> () 
#line 173
{ 
#line 174
int e = (((int)sizeof(unsigned char)) * 8); 
#line 176
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 177
} 
#line 179
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char2> () 
#line 180
{ 
#line 181
int e = (((int)sizeof(signed char)) * 8); 
#line 183
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 184
} 
#line 186
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar2> () 
#line 187
{ 
#line 188
int e = (((int)sizeof(unsigned char)) * 8); 
#line 190
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 191
} 
#line 193
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char4> () 
#line 194
{ 
#line 195
int e = (((int)sizeof(signed char)) * 8); 
#line 197
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 198
} 
#line 200
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar4> () 
#line 201
{ 
#line 202
int e = (((int)sizeof(unsigned char)) * 8); 
#line 204
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 205
} 
#line 207
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short> () 
#line 208
{ 
#line 209
int e = (((int)sizeof(short)) * 8); 
#line 211
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 212
} 
#line 214
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned short> () 
#line 215
{ 
#line 216
int e = (((int)sizeof(unsigned short)) * 8); 
#line 218
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 219
} 
#line 221
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short1> () 
#line 222
{ 
#line 223
int e = (((int)sizeof(short)) * 8); 
#line 225
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 226
} 
#line 228
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort1> () 
#line 229
{ 
#line 230
int e = (((int)sizeof(unsigned short)) * 8); 
#line 232
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 233
} 
#line 235
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short2> () 
#line 236
{ 
#line 237
int e = (((int)sizeof(short)) * 8); 
#line 239
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 240
} 
#line 242
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort2> () 
#line 243
{ 
#line 244
int e = (((int)sizeof(unsigned short)) * 8); 
#line 246
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 247
} 
#line 249
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short4> () 
#line 250
{ 
#line 251
int e = (((int)sizeof(short)) * 8); 
#line 253
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 254
} 
#line 256
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort4> () 
#line 257
{ 
#line 258
int e = (((int)sizeof(unsigned short)) * 8); 
#line 260
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 261
} 
#line 263
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int> () 
#line 264
{ 
#line 265
int e = (((int)sizeof(int)) * 8); 
#line 267
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 268
} 
#line 270
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned> () 
#line 271
{ 
#line 272
int e = (((int)sizeof(unsigned)) * 8); 
#line 274
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 275
} 
#line 277
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int1> () 
#line 278
{ 
#line 279
int e = (((int)sizeof(int)) * 8); 
#line 281
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 282
} 
#line 284
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint1> () 
#line 285
{ 
#line 286
int e = (((int)sizeof(unsigned)) * 8); 
#line 288
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 289
} 
#line 291
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int2> () 
#line 292
{ 
#line 293
int e = (((int)sizeof(int)) * 8); 
#line 295
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 296
} 
#line 298
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint2> () 
#line 299
{ 
#line 300
int e = (((int)sizeof(unsigned)) * 8); 
#line 302
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 303
} 
#line 305
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int4> () 
#line 306
{ 
#line 307
int e = (((int)sizeof(int)) * 8); 
#line 309
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 310
} 
#line 312
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint4> () 
#line 313
{ 
#line 314
int e = (((int)sizeof(unsigned)) * 8); 
#line 316
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 317
} 
#line 321
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long> () 
#line 322
{ 
#line 323
int e = (((int)sizeof(long)) * 8); 
#line 325
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 326
} 
#line 328
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned long> () 
#line 329
{ 
#line 330
int e = (((int)sizeof(unsigned long)) * 8); 
#line 332
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 333
} 
#line 335
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long1> () 
#line 336
{ 
#line 337
int e = (((int)sizeof(long)) * 8); 
#line 339
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 340
} 
#line 342
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong1> () 
#line 343
{ 
#line 344
int e = (((int)sizeof(unsigned long)) * 8); 
#line 346
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 347
} 
#line 349
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long2> () 
#line 350
{ 
#line 351
int e = (((int)sizeof(long)) * 8); 
#line 353
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 354
} 
#line 356
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong2> () 
#line 357
{ 
#line 358
int e = (((int)sizeof(unsigned long)) * 8); 
#line 360
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 361
} 
#line 363
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long4> () 
#line 364
{ 
#line 365
int e = (((int)sizeof(long)) * 8); 
#line 367
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 368
} 
#line 370
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong4> () 
#line 371
{ 
#line 372
int e = (((int)sizeof(unsigned long)) * 8); 
#line 374
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 375
} 
#line 379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\channel_descriptor.h"
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float> () 
#line 380
{ 
#line 381
int e = (((int)sizeof(float)) * 8); 
#line 383
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 384
} 
#line 386
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float1> () 
#line 387
{ 
#line 388
int e = (((int)sizeof(float)) * 8); 
#line 390
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 391
} 
#line 393
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float2> () 
#line 394
{ 
#line 395
int e = (((int)sizeof(float)) * 8); 
#line 397
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 398
} 
#line 400
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float4> () 
#line 401
{ 
#line 402
int e = (((int)sizeof(float)) * 8); 
#line 404
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 405
} 
#line 79 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\driver_functions.h"
static __inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
#line 80
{ 
#line 81
cudaPitchedPtr s; 
#line 83
(s.ptr) = d; 
#line 84
(s.pitch) = p; 
#line 85
(s.xsize) = xsz; 
#line 86
(s.ysize) = ysz; 
#line 88
return s; 
#line 89
} 
#line 106
static __inline cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
#line 107
{ 
#line 108
cudaPos p; 
#line 110
(p.x) = x; 
#line 111
(p.y) = y; 
#line 112
(p.z) = z; 
#line 114
return p; 
#line 115
} 
#line 132
static __inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
#line 133
{ 
#line 134
cudaExtent e; 
#line 136
(e.width) = w; 
#line 137
(e.height) = h; 
#line 138
(e.depth) = d; 
#line 140
return e; 
#line 141
} 
#line 69 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\vector_functions.h"
static __inline char1 make_char1(signed char x) 
#line 70
{ 
#line 71
char1 t; (t.x) = x; return t; 
#line 72
} 
#line 74
static __inline uchar1 make_uchar1(unsigned char x) 
#line 75
{ 
#line 76
uchar1 t; (t.x) = x; return t; 
#line 77
} 
#line 79
static __inline char2 make_char2(signed char x, signed char y) 
#line 80
{ 
#line 81
char2 t; (t.x) = x; (t.y) = y; return t; 
#line 82
} 
#line 84
static __inline uchar2 make_uchar2(unsigned char x, unsigned char y) 
#line 85
{ 
#line 86
uchar2 t; (t.x) = x; (t.y) = y; return t; 
#line 87
} 
#line 89
static __inline char3 make_char3(signed char x, signed char y, signed char z) 
#line 90
{ 
#line 91
char3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 92
} 
#line 94
static __inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z) 
#line 95
{ 
#line 96
uchar3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 97
} 
#line 99
static __inline char4 make_char4(signed char x, signed char y, signed char z, signed char w) 
#line 100
{ 
#line 101
char4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 102
} 
#line 104
static __inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w) 
#line 105
{ 
#line 106
uchar4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 107
} 
#line 109
static __inline short1 make_short1(short x) 
#line 110
{ 
#line 111
short1 t; (t.x) = x; return t; 
#line 112
} 
#line 114
static __inline ushort1 make_ushort1(unsigned short x) 
#line 115
{ 
#line 116
ushort1 t; (t.x) = x; return t; 
#line 117
} 
#line 119
static __inline short2 make_short2(short x, short y) 
#line 120
{ 
#line 121
short2 t; (t.x) = x; (t.y) = y; return t; 
#line 122
} 
#line 124
static __inline ushort2 make_ushort2(unsigned short x, unsigned short y) 
#line 125
{ 
#line 126
ushort2 t; (t.x) = x; (t.y) = y; return t; 
#line 127
} 
#line 129
static __inline short3 make_short3(short x, short y, short z) 
#line 130
{ 
#line 131
short3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 132
} 
#line 134
static __inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z) 
#line 135
{ 
#line 136
ushort3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 137
} 
#line 139
static __inline short4 make_short4(short x, short y, short z, short w) 
#line 140
{ 
#line 141
short4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 142
} 
#line 144
static __inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w) 
#line 145
{ 
#line 146
ushort4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 147
} 
#line 149
static __inline int1 make_int1(int x) 
#line 150
{ 
#line 151
int1 t; (t.x) = x; return t; 
#line 152
} 
#line 154
static __inline uint1 make_uint1(unsigned x) 
#line 155
{ 
#line 156
uint1 t; (t.x) = x; return t; 
#line 157
} 
#line 159
static __inline int2 make_int2(int x, int y) 
#line 160
{ 
#line 161
int2 t; (t.x) = x; (t.y) = y; return t; 
#line 162
} 
#line 164
static __inline uint2 make_uint2(unsigned x, unsigned y) 
#line 165
{ 
#line 166
uint2 t; (t.x) = x; (t.y) = y; return t; 
#line 167
} 
#line 169
static __inline int3 make_int3(int x, int y, int z) 
#line 170
{ 
#line 171
int3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 172
} 
#line 174
static __inline uint3 make_uint3(unsigned x, unsigned y, unsigned z) 
#line 175
{ 
#line 176
uint3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 177
} 
#line 179
static __inline int4 make_int4(int x, int y, int z, int w) 
#line 180
{ 
#line 181
int4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 182
} 
#line 184
static __inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w) 
#line 185
{ 
#line 186
uint4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 187
} 
#line 189
static __inline long1 make_long1(long x) 
#line 190
{ 
#line 191
long1 t; (t.x) = x; return t; 
#line 192
} 
#line 194
static __inline ulong1 make_ulong1(unsigned long x) 
#line 195
{ 
#line 196
ulong1 t; (t.x) = x; return t; 
#line 197
} 
#line 199
static __inline long2 make_long2(long x, long y) 
#line 200
{ 
#line 201
long2 t; (t.x) = x; (t.y) = y; return t; 
#line 202
} 
#line 204
static __inline ulong2 make_ulong2(unsigned long x, unsigned long y) 
#line 205
{ 
#line 206
ulong2 t; (t.x) = x; (t.y) = y; return t; 
#line 207
} 
#line 209
static __inline long3 make_long3(long x, long y, long z) 
#line 210
{ 
#line 211
long3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 212
} 
#line 214
static __inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z) 
#line 215
{ 
#line 216
ulong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 217
} 
#line 219
static __inline long4 make_long4(long x, long y, long z, long w) 
#line 220
{ 
#line 221
long4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 222
} 
#line 224
static __inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w) 
#line 225
{ 
#line 226
ulong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 227
} 
#line 229
static __inline float1 make_float1(float x) 
#line 230
{ 
#line 231
float1 t; (t.x) = x; return t; 
#line 232
} 
#line 234
static __inline float2 make_float2(float x, float y) 
#line 235
{ 
#line 236
float2 t; (t.x) = x; (t.y) = y; return t; 
#line 237
} 
#line 239
static __inline float3 make_float3(float x, float y, float z) 
#line 240
{ 
#line 241
float3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 242
} 
#line 244
static __inline float4 make_float4(float x, float y, float z, float w) 
#line 245
{ 
#line 246
float4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 247
} 
#line 249
static __inline longlong1 make_longlong1(__int64 x) 
#line 250
{ 
#line 251
longlong1 t; (t.x) = x; return t; 
#line 252
} 
#line 254
static __inline ulonglong1 make_ulonglong1(unsigned __int64 x) 
#line 255
{ 
#line 256
ulonglong1 t; (t.x) = x; return t; 
#line 257
} 
#line 259
static __inline longlong2 make_longlong2(__int64 x, __int64 y) 
#line 260
{ 
#line 261
longlong2 t; (t.x) = x; (t.y) = y; return t; 
#line 262
} 
#line 264
static __inline ulonglong2 make_ulonglong2(unsigned __int64 x, unsigned __int64 y) 
#line 265
{ 
#line 266
ulonglong2 t; (t.x) = x; (t.y) = y; return t; 
#line 267
} 
#line 269
static __inline longlong3 make_longlong3(__int64 x, __int64 y, __int64 z) 
#line 270
{ 
#line 271
longlong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 272
} 
#line 274
static __inline ulonglong3 make_ulonglong3(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z) 
#line 275
{ 
#line 276
ulonglong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 277
} 
#line 279
static __inline longlong4 make_longlong4(__int64 x, __int64 y, __int64 z, __int64 w) 
#line 280
{ 
#line 281
longlong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 282
} 
#line 284
static __inline ulonglong4 make_ulonglong4(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z, unsigned __int64 w) 
#line 285
{ 
#line 286
ulonglong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 287
} 
#line 289
static __inline double1 make_double1(double x) 
#line 290
{ 
#line 291
double1 t; (t.x) = x; return t; 
#line 292
} 
#line 294
static __inline double2 make_double2(double x, double y) 
#line 295
{ 
#line 296
double2 t; (t.x) = x; (t.y) = y; return t; 
#line 297
} 
#line 299
static __inline double3 make_double3(double x, double y, double z) 
#line 300
{ 
#line 301
double3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 302
} 
#line 304
static __inline double4 make_double4(double x, double y, double z, double w) 
#line 305
{ 
#line 306
double4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 307
} 
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) void *__cdecl _memccpy(void * , const void * , int , size_t ); } 
#line 47
extern "C" { __declspec(dllimport) const void *__cdecl memchr(const void * , int , size_t ); } 
#line 48
extern "C" { __declspec(dllimport) int __cdecl _memicmp(const void * , const void * , size_t ); } 
#line 49
extern "C" { __declspec(dllimport) int __cdecl _memicmp_l(const void * , const void * , size_t , _locale_t ); } 
#line 50
extern "C" { int __cdecl memcmp(const void * , const void * , size_t ); } 
#line 51
extern "C" { void *__cdecl memcpy(void * , const void * , size_t ); } 
#line 53
extern "C" { __declspec(dllimport) errno_t __cdecl memcpy_s(void * , rsize_t , const void * , rsize_t ); } 
#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { void *__cdecl memset(void * , int , size_t ); } 
#line 92
extern "C" { __declspec(dllimport) void *__cdecl memccpy(void * , const void * , int , size_t ); } 
#line 93
extern "C" { __declspec(dllimport) int __cdecl memicmp(const void * , const void * , size_t ); } 
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _strset_s(char * , size_t , int ); } 
#line 99
template < size_t _Size > inline errno_t __cdecl _strset_s ( char ( & _Dest ) [ _Size ], int _Value ) throw ( ) { return _strset_s ( _Dest, _Size, _Value ); }
#line 100
extern "C" { char *__cdecl _strset(char * , int ); } 
#line 102
extern "C" { __declspec(dllimport) errno_t __cdecl strcpy_s(char * , rsize_t , const char * ); } 
#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl strcpy_s ( char ( & _Dest ) [ _Size ], const char * _Source ) throw ( ) { return strcpy_s ( _Dest, _Size, _Source ); }
#line 105
extern "C" { char *__cdecl strcpy(char * , const char * ); } 
#line 107
extern "C" { __declspec(dllimport) errno_t __cdecl strcat_s(char * , rsize_t , const char * ); } 
#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl strcat_s ( char ( & _Dest ) [ _Size ], const char * _Source ) throw ( ) { return strcat_s ( _Dest, _Size, _Source ); }
#line 110
extern "C" { char *__cdecl strcat(char * , const char * ); } 
#line 111
extern "C" { int __cdecl strcmp(const char * , const char * ); } 
#line 112
extern "C" { size_t __cdecl strlen(const char * ); } 
#line 113
extern "C" { __declspec(dllimport) size_t __cdecl strnlen(const char * , size_t ); } 
#line 115
extern "C" { static __inline size_t __cdecl strnlen_s(const char *_Str, size_t _MaxCount) 
#line 116
{ 
#line 117
return (_Str == (0)) ? (0) : strnlen(_Str, _MaxCount); 
#line 118
} } 
#line 121 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl memmove_s(void * , rsize_t , const void * , rsize_t ); } 
#line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) void *__cdecl memmove(void * , const void * , size_t ); } 
#line 135 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) char *__cdecl _strdup(const char * ); } 
#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) const char *__cdecl strchr(const char * , int ); } 
#line 142
extern "C" { __declspec(dllimport) int __cdecl _stricmp(const char * , const char * ); } 
#line 143
extern "C" { __declspec(dllimport) int __cdecl _strcmpi(const char * , const char * ); } 
#line 144
extern "C" { __declspec(dllimport) int __cdecl _stricmp_l(const char * , const char * , _locale_t ); } 
#line 145
extern "C" { __declspec(dllimport) int __cdecl strcoll(const char * , const char * ); } 
#line 146
extern "C" { __declspec(dllimport) int __cdecl _strcoll_l(const char * , const char * , _locale_t ); } 
#line 147
extern "C" { __declspec(dllimport) int __cdecl _stricoll(const char * , const char * ); } 
#line 148
extern "C" { __declspec(dllimport) int __cdecl _stricoll_l(const char * , const char * , _locale_t ); } 
#line 149
extern "C" { __declspec(dllimport) int __cdecl _strncoll(const char * , const char * , size_t ); } 
#line 150
extern "C" { __declspec(dllimport) int __cdecl _strncoll_l(const char * , const char * , size_t , _locale_t ); } 
#line 151
extern "C" { __declspec(dllimport) int __cdecl _strnicoll(const char * , const char * , size_t ); } 
#line 152
extern "C" { __declspec(dllimport) int __cdecl _strnicoll_l(const char * , const char * , size_t , _locale_t ); } 
#line 153
extern "C" { __declspec(dllimport) size_t __cdecl strcspn(const char * , const char * ); } 
#line 154
extern "C" { __declspec(dllimport) char *__cdecl _strerror(const char * ); } 
#line 155
extern "C" { __declspec(dllimport) errno_t __cdecl _strerror_s(char * , size_t , const char * ); } 
#line 156
template < size_t _Size > inline errno_t __cdecl _strerror_s ( char ( & _Buffer ) [ _Size ], const char * _ErrorMessage ) throw ( ) { return _strerror_s ( _Buffer, _Size, _ErrorMessage ); }
#line 157
extern "C" { __declspec(dllimport) char *__cdecl strerror(int); } 
#line 159
extern "C" { __declspec(dllimport) errno_t __cdecl strerror_s(char * , size_t , int ); } 
#line 161 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl strerror_s ( char ( & _Buffer ) [ _Size ], int _ErrorMessage ) throw ( ) { return strerror_s ( _Buffer, _Size, _ErrorMessage ); }
#line 162
extern "C" { __declspec(dllimport) errno_t __cdecl _strlwr_s(char * , size_t ); } 
#line 163
template < size_t _Size > inline errno_t __cdecl _strlwr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strlwr_s ( _String, _Size ); }
#line 164
extern "C" { __declspec(dllimport) char *__cdecl _strlwr(char * ); } 
#line 165
extern "C" { __declspec(dllimport) errno_t __cdecl _strlwr_s_l(char * , size_t , _locale_t ); } 
#line 166
template < size_t _Size > inline errno_t __cdecl _strlwr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strlwr_s_l ( _String, _Size, _Locale ); }
#line 167
extern "C" { __declspec(dllimport) char *__cdecl _strlwr_l(char * , _locale_t ); } 
#line 169
extern "C" { __declspec(dllimport) errno_t __cdecl strncat_s(char * , rsize_t , const char * , rsize_t ); } 
#line 171 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl strncat_s ( char ( & _Dest ) [ _Size ], const char * _Source, size_t _Count ) throw ( ) { return strncat_s ( _Dest, _Size, _Source, _Count ); }
#pragma warning(push)
#pragma warning(disable:6059)
#line 175
extern "C" { __declspec(dllimport) char *__cdecl strncat(char * , const char * , size_t ); } 
#pragma warning(pop)
#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) int __cdecl strncmp(const char * , const char * , size_t ); } 
#line 182 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) int __cdecl _strnicmp(const char * , const char * , size_t ); } 
#line 183
extern "C" { __declspec(dllimport) int __cdecl _strnicmp_l(const char * , const char * , size_t , _locale_t ); } 
#line 185
extern "C" { __declspec(dllimport) errno_t __cdecl strncpy_s(char * , rsize_t , const char * , rsize_t ); } 
#line 187 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl strncpy_s ( char ( & _Dest ) [ _Size ], const char * _Source, size_t _Count ) throw ( ) { return strncpy_s ( _Dest, _Size, _Source, _Count ); }
#line 188
extern "C" { __declspec(dllimport) char *__cdecl strncpy(char * , const char * , size_t ); } 
#line 189
extern "C" { __declspec(dllimport) errno_t __cdecl _strnset_s(char * , size_t , int , size_t ); } 
#line 190
template < size_t _Size > inline errno_t __cdecl _strnset_s ( char ( & _Dest ) [ _Size ], int _Val, size_t _Count ) throw ( ) { return _strnset_s ( _Dest, _Size, _Val, _Count ); }
#line 191
extern "C" { __declspec(dllimport) char *__cdecl _strnset(char * , int , size_t ); } 
#line 192
extern "C" { __declspec(dllimport) const char *__cdecl strpbrk(const char * , const char * ); } 
#line 193
extern "C" { __declspec(dllimport) const char *__cdecl strrchr(const char * , int ); } 
#line 194
extern "C" { __declspec(dllimport) char *__cdecl _strrev(char * ); } 
#line 195
extern "C" { __declspec(dllimport) size_t __cdecl strspn(const char * , const char * ); } 
#line 196
extern "C" { __declspec(dllimport) const char *__cdecl strstr(const char * , const char * ); } 
#line 197
extern "C" { __declspec(dllimport) char *__cdecl strtok(char * , const char * ); } 
#line 199
extern "C" { __declspec(dllimport) char *__cdecl strtok_s(char * , const char * , char ** ); } 
#line 201 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _strupr_s(char * , size_t ); } 
#line 202
template < size_t _Size > inline errno_t __cdecl _strupr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strupr_s ( _String, _Size ); }
#line 203
extern "C" { __declspec(dllimport) char *__cdecl _strupr(char * ); } 
#line 204
extern "C" { __declspec(dllimport) errno_t __cdecl _strupr_s_l(char * , size_t , _locale_t ); } 
#line 205
template < size_t _Size > inline errno_t __cdecl _strupr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strupr_s_l ( _String, _Size, _Locale ); }
#line 206
extern "C" { __declspec(dllimport) char *__cdecl _strupr_l(char * , _locale_t ); } 
#line 207
extern "C" { __declspec(dllimport) size_t __cdecl strxfrm(char * , const char * , size_t ); } 
#line 208
extern "C" { __declspec(dllimport) size_t __cdecl _strxfrm_l(char * , const char * , size_t , _locale_t ); } 
#line 214
inline char *__cdecl strchr(char *_Str, int _Ch) 
#line 215
{ return (char *)strchr((const char *)_Str, _Ch); } 
#line 216
inline char *__cdecl strpbrk(char *_Str, const char *_Control) 
#line 217
{ return (char *)strpbrk((const char *)_Str, _Control); } 
#line 218
inline char *__cdecl strrchr(char *_Str, int _Ch) 
#line 219
{ return (char *)strrchr((const char *)_Str, _Ch); } 
#line 220
inline char *__cdecl strstr(char *_Str, const char *_SubStr) 
#line 221
{ return (char *)strstr((const char *)_Str, _SubStr); } 
#line 225 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
inline void *__cdecl memchr(void *_Pv, int _C, size_t _N) 
#line 226
{ return (void *)memchr((const void *)_Pv, _C, _N); } 
#line 238 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) char *__cdecl strdup(const char * ); } 
#line 245 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) int __cdecl strcmpi(const char * , const char * ); } 
#line 246
extern "C" { __declspec(dllimport) int __cdecl stricmp(const char * , const char * ); } 
#line 247
extern "C" { __declspec(dllimport) char *__cdecl strlwr(char * ); } 
#line 248
extern "C" { __declspec(dllimport) int __cdecl strnicmp(const char * , const char * , size_t ); } 
#line 249
extern "C" { __declspec(dllimport) char *__cdecl strnset(char * , int , size_t ); } 
#line 250
extern "C" { __declspec(dllimport) char *__cdecl strrev(char * ); } 
#line 251
extern "C" { char *__cdecl strset(char * , int ); } 
#line 252
extern "C" { __declspec(dllimport) char *__cdecl strupr(char * ); } 
#line 266 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsdup(const __wchar_t * ); } 
#line 273 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl wcscat_s(__wchar_t * , rsize_t , const __wchar_t * ); } 
#line 275 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl wcscat_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source ) throw ( ) { return wcscat_s ( _Dest, _Size, _Source ); }
#line 276
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcscat(__wchar_t * , const __wchar_t * ); } 
#line 277
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcschr(const __wchar_t * , __wchar_t ); } 
#line 278
extern "C" { __declspec(dllimport) int __cdecl wcscmp(const __wchar_t * , const __wchar_t * ); } 
#line 280
extern "C" { __declspec(dllimport) errno_t __cdecl wcscpy_s(__wchar_t * , rsize_t , const __wchar_t * ); } 
#line 282 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl wcscpy_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source ) throw ( ) { return wcscpy_s ( _Dest, _Size, _Source ); }
#line 283
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcscpy(__wchar_t * , const __wchar_t * ); } 
#line 284
extern "C" { __declspec(dllimport) size_t __cdecl wcscspn(const __wchar_t * , const __wchar_t * ); } 
#line 285
extern "C" { __declspec(dllimport) size_t __cdecl wcslen(const __wchar_t * ); } 
#line 286
extern "C" { __declspec(dllimport) size_t __cdecl wcsnlen(const __wchar_t * , size_t ); } 
#line 288
extern "C" { static __inline size_t __cdecl wcsnlen_s(const __wchar_t *_Src, size_t _MaxCount) 
#line 289
{ 
#line 290
return (_Src == (0)) ? (0) : wcsnlen(_Src, _MaxCount); 
#line 291
} } 
#line 294 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl wcsncat_s(__wchar_t * , rsize_t , const __wchar_t * , rsize_t ); } 
#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl wcsncat_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _Count ) throw ( ) { return wcsncat_s ( _Dest, _Size, _Source, _Count ); }
#pragma warning(push)
#pragma warning(disable:6059)
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsncat(__wchar_t * , const __wchar_t * , size_t ); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) int __cdecl wcsncmp(const __wchar_t * , const __wchar_t * , size_t ); } 
#line 303
extern "C" { __declspec(dllimport) errno_t __cdecl wcsncpy_s(__wchar_t * , rsize_t , const __wchar_t * , rsize_t ); } 
#line 305 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
template < size_t _Size > inline errno_t __cdecl wcsncpy_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _Count ) throw ( ) { return wcsncpy_s ( _Dest, _Size, _Source, _Count ); }
#line 306
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsncpy(__wchar_t * , const __wchar_t * , size_t ); } 
#line 307
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcspbrk(const __wchar_t * , const __wchar_t * ); } 
#line 308
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcsrchr(const __wchar_t * , __wchar_t ); } 
#line 309
extern "C" { __declspec(dllimport) size_t __cdecl wcsspn(const __wchar_t * , const __wchar_t * ); } 
#line 310
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcsstr(const __wchar_t * , const __wchar_t * ); } 
#line 311
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcstok(__wchar_t * , const __wchar_t * ); } 
#line 313
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcstok_s(__wchar_t * , const __wchar_t * , __wchar_t ** ); } 
#line 315 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcserror(int ); } 
#line 316
extern "C" { __declspec(dllimport) errno_t __cdecl _wcserror_s(__wchar_t * , size_t , int ); } 
#line 317
template < size_t _Size > inline errno_t __cdecl _wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], int _Error ) throw ( ) { return _wcserror_s ( _Buffer, _Size, _Error ); }
#line 318
extern "C" { __declspec(dllimport) __wchar_t *__cdecl __wcserror(const __wchar_t * ); } 
#line 319
extern "C" { __declspec(dllimport) errno_t __cdecl __wcserror_s(__wchar_t * , size_t , const __wchar_t * ); } 
#line 320
template < size_t _Size > inline errno_t __cdecl __wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], const wchar_t * _ErrorMessage ) throw ( ) { return __wcserror_s ( _Buffer, _Size, _ErrorMessage ); }
#line 322
extern "C" { __declspec(dllimport) int __cdecl _wcsicmp(const __wchar_t * , const __wchar_t * ); } 
#line 323
extern "C" { __declspec(dllimport) int __cdecl _wcsicmp_l(const __wchar_t * , const __wchar_t * , _locale_t ); } 
#line 324
extern "C" { __declspec(dllimport) int __cdecl _wcsnicmp(const __wchar_t * , const __wchar_t * , size_t ); } 
#line 325
extern "C" { __declspec(dllimport) int __cdecl _wcsnicmp_l(const __wchar_t * , const __wchar_t * , size_t , _locale_t ); } 
#line 326
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsnset_s(__wchar_t * , size_t , __wchar_t , size_t ); } 
#line 327
template < size_t _Size > inline errno_t __cdecl _wcsnset_s ( wchar_t ( & _Dst ) [ _Size ], wchar_t _Val, size_t _MaxCount ) throw ( ) { return _wcsnset_s ( _Dst, _Size, _Val, _MaxCount ); }
#line 328
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsnset(__wchar_t * , __wchar_t , size_t ); } 
#line 329
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsrev(__wchar_t * ); } 
#line 330
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsset_s(__wchar_t * , size_t , __wchar_t ); } 
#line 331
template < size_t _Size > inline errno_t __cdecl _wcsset_s ( wchar_t ( & _Str ) [ _Size ], wchar_t _Val ) throw ( ) { return _wcsset_s ( _Str, _Size, _Val ); }
#line 332
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsset(__wchar_t * , __wchar_t ); } 
#line 334
extern "C" { __declspec(dllimport) errno_t __cdecl _wcslwr_s(__wchar_t * , size_t ); } 
#line 335
template < size_t _Size > inline errno_t __cdecl _wcslwr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcslwr_s ( _String, _Size ); }
#line 336
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcslwr(__wchar_t * ); } 
#line 337
extern "C" { __declspec(dllimport) errno_t __cdecl _wcslwr_s_l(__wchar_t * , size_t , _locale_t ); } 
#line 338
template < size_t _Size > inline errno_t __cdecl _wcslwr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcslwr_s_l ( _String, _Size, _Locale ); }
#line 339
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcslwr_l(__wchar_t * , _locale_t ); } 
#line 340
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsupr_s(__wchar_t * , size_t ); } 
#line 341
template < size_t _Size > inline errno_t __cdecl _wcsupr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcsupr_s ( _String, _Size ); }
#line 342
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsupr(__wchar_t * ); } 
#line 343
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsupr_s_l(__wchar_t * , size_t , _locale_t ); } 
#line 344
template < size_t _Size > inline errno_t __cdecl _wcsupr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcsupr_s_l ( _String, _Size, _Locale ); }
#line 345
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsupr_l(__wchar_t * , _locale_t ); } 
#line 346
extern "C" { __declspec(dllimport) size_t __cdecl wcsxfrm(__wchar_t * , const __wchar_t * , size_t ); } 
#line 347
extern "C" { __declspec(dllimport) size_t __cdecl _wcsxfrm_l(__wchar_t * , const __wchar_t * , size_t , _locale_t ); } 
#line 348
extern "C" { __declspec(dllimport) int __cdecl wcscoll(const __wchar_t * , const __wchar_t * ); } 
#line 349
extern "C" { __declspec(dllimport) int __cdecl _wcscoll_l(const __wchar_t * , const __wchar_t * , _locale_t ); } 
#line 350
extern "C" { __declspec(dllimport) int __cdecl _wcsicoll(const __wchar_t * , const __wchar_t * ); } 
#line 351
extern "C" { __declspec(dllimport) int __cdecl _wcsicoll_l(const __wchar_t * , const __wchar_t * , _locale_t ); } 
#line 352
extern "C" { __declspec(dllimport) int __cdecl _wcsncoll(const __wchar_t * , const __wchar_t * , size_t ); } 
#line 353
extern "C" { __declspec(dllimport) int __cdecl _wcsncoll_l(const __wchar_t * , const __wchar_t * , size_t , _locale_t ); } 
#line 354
extern "C" { __declspec(dllimport) int __cdecl _wcsnicoll(const __wchar_t * , const __wchar_t * , size_t ); } 
#line 355
extern "C" { __declspec(dllimport) int __cdecl _wcsnicoll_l(const __wchar_t * , const __wchar_t * , size_t , _locale_t ); } 
#line 361
inline __wchar_t *__cdecl wcschr(__wchar_t *_Str, __wchar_t _Ch) 
#line 362
{ return (__wchar_t *)wcschr((const __wchar_t *)_Str, _Ch); } 
#line 363
inline __wchar_t *__cdecl wcspbrk(__wchar_t *_Str, const __wchar_t *_Control) 
#line 364
{ return (__wchar_t *)wcspbrk((const __wchar_t *)_Str, _Control); } 
#line 365
inline __wchar_t *__cdecl wcsrchr(__wchar_t *_Str, __wchar_t _Ch) 
#line 366
{ return (__wchar_t *)wcsrchr((const __wchar_t *)_Str, _Ch); } 
#line 367
inline __wchar_t *__cdecl wcsstr(__wchar_t *_Str, const __wchar_t *_SubStr) 
#line 368
{ return (__wchar_t *)wcsstr((const __wchar_t *)_Str, _SubStr); } 
#line 380 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsdup(const __wchar_t * ); } 
#line 390 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string.h"
extern "C" { __declspec(dllimport) int __cdecl wcsicmp(const __wchar_t * , const __wchar_t * ); } 
#line 391
extern "C" { __declspec(dllimport) int __cdecl wcsnicmp(const __wchar_t * , const __wchar_t * , size_t ); } 
#line 392
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsnset(__wchar_t * , __wchar_t , size_t ); } 
#line 393
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsrev(__wchar_t * ); } 
#line 394
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsset(__wchar_t * , __wchar_t ); } 
#line 395
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcslwr(__wchar_t * ); } 
#line 396
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsupr(__wchar_t * ); } 
#line 397
extern "C" { __declspec(dllimport) int __cdecl wcsicoll(const __wchar_t * , const __wchar_t * ); } 
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"
#pragma pack ( push, 8 )
#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"
extern "C" { typedef long clock_t; }
#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"
extern "C" { struct tm { 
#line 107
int tm_sec; 
#line 108
int tm_min; 
#line 109
int tm_hour; 
#line 110
int tm_mday; 
#line 111
int tm_mon; 
#line 112
int tm_year; 
#line 113
int tm_wday; 
#line 114
int tm_yday; 
#line 115
int tm_isdst; 
#line 116
}; }
#line 131 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"
extern "C" { __declspec(dllimport) int *__cdecl __daylight(); } 
#line 135
extern "C" { __declspec(dllimport) long *__cdecl __dstbias(); } 
#line 139
extern "C" { __declspec(dllimport) long *__cdecl __timezone(); } 
#line 143
extern "C" { __declspec(dllimport) char **__cdecl __tzname(); } 
#line 146
extern "C" { __declspec(dllimport) errno_t __cdecl _get_daylight(int * ); } 
#line 147
extern "C" { __declspec(dllimport) errno_t __cdecl _get_dstbias(long * ); } 
#line 148
extern "C" { __declspec(dllimport) errno_t __cdecl _get_timezone(long * ); } 
#line 149
extern "C" { __declspec(dllimport) errno_t __cdecl _get_tzname(size_t * , char * , size_t , int ); } 
#line 153
extern "C" { __declspec(dllimport) char *__cdecl asctime(const tm * ); } 
#line 155
extern "C" { __declspec(dllimport) errno_t __cdecl asctime_s(char * , size_t , const tm * ); } 
#line 157 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"
template < size_t _Size > inline errno_t __cdecl asctime_s ( char ( & _Buffer ) [ _Size ], const struct tm * _Time ) throw ( ) { return asctime_s ( _Buffer, _Size, _Time ); }
#line 159
extern "C" { __declspec(dllimport) char *__cdecl _ctime32(const __time32_t * ); } 
#line 160
extern "C" { __declspec(dllimport) errno_t __cdecl _ctime32_s(char * , size_t , const __time32_t * ); } 
#line 161
template < size_t _Size > inline errno_t __cdecl _ctime32_s ( char ( & _Buffer ) [ _Size ], const __time32_t * _Time ) throw ( ) { return _ctime32_s ( _Buffer, _Size, _Time ); }
#line 163
extern "C" { __declspec(dllimport) clock_t __cdecl clock(); } 
#line 164
extern "C" { __declspec(dllimport) double __cdecl _difftime32(__time32_t , __time32_t ); } 
#line 166
extern "C" { __declspec(dllimport) tm *__cdecl _gmtime32(const __time32_t * ); } 
#line 167
extern "C" { __declspec(dllimport) errno_t __cdecl _gmtime32_s(tm * , const __time32_t * ); } 
#line 169
extern "C" { __declspec(dllimport) tm *__cdecl _localtime32(const __time32_t * ); } 
#line 170
extern "C" { __declspec(dllimport) errno_t __cdecl _localtime32_s(tm * , const __time32_t * ); } 
#line 172
extern "C" { __declspec(dllimport) size_t __cdecl strftime(char * , size_t , const char * , const tm * ); } 
#line 173
extern "C" { __declspec(dllimport) size_t __cdecl _strftime_l(char * , size_t , const char * , const tm * , _locale_t ); } 
#line 175
extern "C" { __declspec(dllimport) errno_t __cdecl _strdate_s(char * , size_t ); } 
#line 176
template < size_t _Size > inline errno_t __cdecl _strdate_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strdate_s ( _Buffer, _Size ); }
#line 177
extern "C" { __declspec(dllimport) char *__cdecl _strdate(char * ); } 
#line 179
extern "C" { __declspec(dllimport) errno_t __cdecl _strtime_s(char * , size_t ); } 
#line 180
template < size_t _Size > inline errno_t __cdecl _strtime_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strtime_s ( _Buffer, _Size ); }
#line 181
extern "C" { __declspec(dllimport) char *__cdecl _strtime(char * ); } 
#line 183
extern "C" { __declspec(dllimport) __time32_t __cdecl _time32(__time32_t * ); } 
#line 184
extern "C" { __declspec(dllimport) __time32_t __cdecl _mktime32(tm * ); } 
#line 185
extern "C" { __declspec(dllimport) __time32_t __cdecl _mkgmtime32(tm * ); } 
#line 190
extern "C" { __declspec(dllimport) void __cdecl _tzset(); } 
#line 193 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"
extern "C" { __declspec(dllimport) double __cdecl _difftime64(__time64_t , __time64_t ); } 
#line 194
extern "C" { __declspec(dllimport) char *__cdecl _ctime64(const __time64_t * ); } 
#line 195
extern "C" { __declspec(dllimport) errno_t __cdecl _ctime64_s(char * , size_t , const __time64_t * ); } 
#line 196
template < size_t _Size > inline errno_t __cdecl _ctime64_s ( char ( & _Buffer ) [ _Size ], const __time64_t * _Time ) throw ( ) { return _ctime64_s ( _Buffer, _Size, _Time ); }
#line 198
extern "C" { __declspec(dllimport) tm *__cdecl _gmtime64(const __time64_t * ); } 
#line 199
extern "C" { __declspec(dllimport) errno_t __cdecl _gmtime64_s(tm * , const __time64_t * ); } 
#line 201
extern "C" { __declspec(dllimport) tm *__cdecl _localtime64(const __time64_t * ); } 
#line 202
extern "C" { __declspec(dllimport) errno_t __cdecl _localtime64_s(tm * , const __time64_t * ); } 
#line 204
extern "C" { __declspec(dllimport) __time64_t __cdecl _mktime64(tm * ); } 
#line 205
extern "C" { __declspec(dllimport) __time64_t __cdecl _mkgmtime64(tm * ); } 
#line 206
extern "C" { __declspec(dllimport) __time64_t __cdecl _time64(__time64_t * ); } 
#line 209
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using GetLocalTime in" "stead. See online help for details.")) unsigned __cdecl _getsystime(tm * ); } 
#line 210
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetLocalTime in" "stead. See online help for details.")) unsigned __cdecl _setsystime(tm * , unsigned ); } 
#line 222
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wasctime(const tm * ); } 
#line 223
extern "C" { __declspec(dllimport) errno_t __cdecl _wasctime_s(__wchar_t * , size_t , const tm * ); } 
#line 224
template < size_t _Size > inline errno_t __cdecl _wasctime_s ( wchar_t ( & _Buffer ) [ _Size ], const struct tm * _Time ) throw ( ) { return _wasctime_s ( _Buffer, _Size, _Time ); }
#line 226
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wctime32(const __time32_t * ); } 
#line 227
extern "C" { __declspec(dllimport) errno_t __cdecl _wctime32_s(__wchar_t * , size_t , const __time32_t * ); } 
#line 228
template < size_t _Size > inline errno_t __cdecl _wctime32_s ( wchar_t ( & _Buffer ) [ _Size ], const __time32_t * _Time ) throw ( ) { return _wctime32_s ( _Buffer, _Size, _Time ); }
#line 230
extern "C" { __declspec(dllimport) size_t __cdecl wcsftime(__wchar_t * , size_t , const __wchar_t * , const tm * ); } 
#line 231
extern "C" { __declspec(dllimport) size_t __cdecl _wcsftime_l(__wchar_t * , size_t , const __wchar_t * , const tm * , _locale_t ); } 
#line 233
extern "C" { __declspec(dllimport) errno_t __cdecl _wstrdate_s(__wchar_t * , size_t ); } 
#line 234
template < size_t _Size > inline errno_t __cdecl _wstrdate_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrdate_s ( _Buffer, _Size ); }
#line 235
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wstrdate(__wchar_t * ); } 
#line 237
extern "C" { __declspec(dllimport) errno_t __cdecl _wstrtime_s(__wchar_t * , size_t ); } 
#line 238
template < size_t _Size > inline errno_t __cdecl _wstrtime_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrtime_s ( _Buffer, _Size ); }
#line 239
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wstrtime(__wchar_t * ); } 
#line 241
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wctime64(const __time64_t * ); } 
#line 242
extern "C" { __declspec(dllimport) errno_t __cdecl _wctime64_s(__wchar_t * , size_t , const __time64_t * ); } 
#line 243
template < size_t _Size > inline errno_t __cdecl _wctime64_s ( wchar_t ( & _Buffer ) [ _Size ], const __time64_t * _Time ) throw ( ) { return _wctime64_s ( _Buffer, _Size, _Time ); }
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wtime.inl"
#pragma warning(push)
#pragma warning(disable:4996)
#line 44
extern "C" { static __inline __wchar_t *__cdecl _wctime(const time_t *_Time) 
#line 45
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _wctime64(_Time); 
#pragma warning( pop )
} } 
#line 52
extern "C" { static __inline errno_t __cdecl _wctime_s(__wchar_t *_Buffer, size_t _SizeInWords, const time_t *_Time) 
#line 53
{ 
#line 54
return _wctime64_s(_Buffer, _SizeInWords, _Time); 
#line 55
} } 
#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wtime.inl"
#pragma warning(pop)
#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.inl"
extern "C" { static __inline double __cdecl difftime(time_t _Time1, time_t _Time2) 
#line 83
{ 
#line 84
return _difftime64(_Time1, _Time2); 
#line 85
} } 
#line 86
extern "C" { static __inline char *__cdecl ctime(const time_t *_Time) 
#line 87
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _ctime64(_Time); 
#pragma warning( pop )
} } 
#line 94
extern "C" { static __inline errno_t __cdecl ctime_s(char *_Buffer, size_t _SizeInBytes, const time_t *_Time) 
#line 95
{ 
#line 96
return _ctime64_s(_Buffer, _SizeInBytes, _Time); 
#line 97
} } 
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.inl"
extern "C" { static __inline tm *__cdecl gmtime(const time_t *_Time) 
#line 100
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _gmtime64(_Time); 
#pragma warning( pop )
} } 
#line 107
extern "C" { static __inline errno_t __cdecl gmtime_s(tm *_Tm, const time_t *_Time) 
#line 108
{ 
#line 109
return _gmtime64_s(_Tm, _Time); 
#line 110
} } 
#line 112 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.inl"
extern "C" { static __inline tm *__cdecl localtime(const time_t *_Time) 
#line 113
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _localtime64(_Time); 
#pragma warning( pop )
} } 
#line 119
extern "C" { static __inline errno_t __cdecl localtime_s(tm *_Tm, const time_t *_Time) 
#line 120
{ 
#line 121
return _localtime64_s(_Tm, _Time); 
#line 122
} } 
#line 123
extern "C" { static __inline time_t __cdecl mktime(tm *_Tm) 
#line 124
{ 
#line 125
return _mktime64(_Tm); 
#line 126
} } 
#line 127
extern "C" { static __inline time_t __cdecl _mkgmtime(tm *_Tm) 
#line 128
{ 
#line 129
return _mkgmtime64(_Tm); 
#line 130
} } 
#line 131
extern "C" { static __inline time_t __cdecl time(time_t *_Time) 
#line 132
{ 
#line 133
return _time64(_Time); 
#line 134
} } 
#line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"
extern "C" __declspec(dllimport) int daylight; 
#line 269
extern "C" __declspec(dllimport) long timezone; 
#line 270
extern "C" __declspec(dllimport) char *tzname[2]; 
#line 273 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"
extern "C" { __declspec(dllimport) void __cdecl tzset(); } 
#line 282 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\time.h"
#pragma pack ( pop )
#line 69 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\common_functions.h"
extern "C" { __declspec(dllimport) extern clock_t __cdecl clock(); } 
#line 70
extern "C" { extern void *__cdecl memset(void *, int, size_t); } 
#line 71
extern "C" { extern void *__cdecl memcpy(void *, const void *, size_t); } 
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
extern "C" { extern int __cdecl abs(int); } 
#line 150
extern "C" { extern long __cdecl labs(long); } 
#line 151
extern "C" { extern __int64 llabs(__int64); } 
#line 194 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
extern "C" { extern double __cdecl fabs(double ); } 
#line 235
extern "C" { extern inline float fabsf(float ); } 
#line 236
extern "C" { extern int min(int, int); } 
#line 237
extern "C" { extern unsigned umin(unsigned, unsigned); } 
#line 238
extern "C" { extern __int64 llmin(__int64, __int64); } 
#line 239
extern "C" { extern unsigned __int64 ullmin(unsigned __int64, unsigned __int64); } 
#line 255
extern "C" { extern float fminf(float , float ); } 
#line 271
extern "C" { extern double fmin(double , double ); } 
#line 272
extern "C" { extern int max(int, int); } 
#line 273
extern "C" { extern unsigned umax(unsigned, unsigned); } 
#line 274
extern "C" { extern __int64 llmax(__int64, __int64); } 
#line 275
extern "C" { extern unsigned __int64 ullmax(unsigned __int64, unsigned __int64); } 
#line 291
extern "C" { extern float fmaxf(float , float ); } 
#line 307
extern "C" { extern double fmax(double, double); } 
#line 348
extern "C" { extern double __cdecl sin(double ); } 
#line 381
extern "C" { extern double __cdecl cos(double ); } 
#line 396
extern "C" { extern void sincos(double , double * , double * ); } 
#line 412
extern "C" { extern void sincosf(float , float * , float * ); } 
#line 453
extern "C" { extern double __cdecl tan(double ); } 
#line 522
extern "C" { extern double __cdecl sqrt(double ); } 
#line 591
extern "C" { extern double rsqrt(double ); } 
#line 660
extern "C" { extern float rsqrtf(float ); } 
#line 711
extern "C" { extern double log2(double ); } 
#line 732
extern "C" { extern double exp2(double ); } 
#line 753
extern "C" { extern float exp2f(float ); } 
#line 774
extern "C" { extern double exp10(double ); } 
#line 796
extern "C" { extern float exp10f(float ); } 
#line 837
extern "C" { extern double expm1(double ); } 
#line 878
extern "C" { extern float expm1f(float ); } 
#line 929
extern "C" { extern float log2f(float ); } 
#line 980
extern "C" { extern double __cdecl log10(double ); } 
#line 1051
extern "C" { extern double __cdecl log(double ); } 
#line 1144
extern "C" { extern double log1p(double ); } 
#line 1237
extern "C" { extern float log1pf(float ); } 
#line 1309
extern "C" { __declspec(dllimport) extern double __cdecl floor(double ); } 
#line 1348
extern "C" { extern double __cdecl exp(double ); } 
#line 1379
extern "C" { extern double __cdecl cosh(double ); } 
#line 1409
extern "C" { extern double __cdecl sinh(double ); } 
#line 1439
extern "C" { extern double __cdecl tanh(double ); } 
#line 1473
extern "C" { extern double acosh(double ); } 
#line 1507
extern "C" { extern float acoshf(float ); } 
#line 1519
extern "C" { extern double asinh(double ); } 
#line 1531
extern "C" { extern float asinhf(float ); } 
#line 1581
extern "C" { extern double atanh(double ); } 
#line 1631
extern "C" { extern float atanhf(float ); } 
#line 1687
extern "C" { __declspec(dllimport) extern double __cdecl ldexp(double , int ); } 
#line 1743
extern "C" { extern inline float ldexpf(float , int ); } 
#line 1794
extern "C" { extern double logb(double ); } 
#line 1845
extern "C" { extern float logbf(float ); } 
#line 1871
extern "C" { extern int ilogb(double ); } 
#line 1897
extern "C" { extern int ilogbf(float ); } 
#line 1969
extern "C" { extern double scalbn(double , int ); } 
#line 2041
extern "C" { extern float scalbnf(float , int ); } 
#line 2113
extern "C" { extern double scalbln(double , long ); } 
#line 2185
extern "C" { extern float scalblnf(float , long ); } 
#line 2260
extern "C" { __declspec(dllimport) extern double __cdecl frexp(double , int * ); } 
#line 2335
extern "C" { extern inline float frexpf(float , int * ); } 
#line 2348
extern "C" { extern double round(double ); } 
#line 2361
extern "C" { extern float roundf(float ); } 
#line 2375
extern "C" { extern long lround(double ); } 
#line 2389
extern "C" { extern long lroundf(float ); } 
#line 2403
extern "C" { extern __int64 llround(double ); } 
#line 2417
extern "C" { extern __int64 llroundf(float ); } 
#line 2428
extern "C" { extern double rint(double ); } 
#line 2439
extern "C" { extern float rintf(float ); } 
#line 2451
extern "C" { extern long lrint(double ); } 
#line 2463
extern "C" { extern long lrintf(float ); } 
#line 2475
extern "C" { extern __int64 llrint(double ); } 
#line 2487
extern "C" { extern __int64 llrintf(float ); } 
#line 2536
extern "C" { extern double nearbyint(double ); } 
#line 2585
extern "C" { extern float nearbyintf(float ); } 
#line 2644
extern "C" { __declspec(dllimport) extern double __cdecl ceil(double ); } 
#line 2655
extern "C" { extern double trunc(double ); } 
#line 2666
extern "C" { extern float truncf(float ); } 
#line 2688
extern "C" { extern double fdim(double , double ); } 
#line 2710
extern "C" { extern float fdimf(float , float ); } 
#line 2743
extern "C" { extern double __cdecl atan2(double , double ); } 
#line 2774
extern "C" { extern double __cdecl atan(double ); } 
#line 2797
extern "C" { extern double __cdecl acos(double ); } 
#line 2829
extern "C" { extern double __cdecl asin(double ); } 
#line 2871 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
extern "C" { static __inline double __cdecl hypot(double , double ); } 
#line 2919 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
extern "C" { extern double rhypot(double , double ); } 
#line 2962 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
extern "C" { static __inline float __cdecl hypotf(float , float ); } 
#line 3010 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
extern "C" { extern float rhypotf(float , float ); } 
#line 3093
extern "C" { extern double cbrt(double ); } 
#line 3175
extern "C" { extern float cbrtf(float ); } 
#line 3224
extern "C" { extern double rcbrt(double ); } 
#line 3273
extern "C" { extern float rcbrtf(float ); } 
#line 3333
extern "C" { extern double sinpi(double ); } 
#line 3393
extern "C" { extern float sinpif(float ); } 
#line 3445
extern "C" { extern double cospi(double ); } 
#line 3497
extern "C" { extern float cospif(float ); } 
#line 3527
extern "C" { extern void sincospi(double , double * , double * ); } 
#line 3557
extern "C" { extern void sincospif(float , float * , float * ); } 
#line 3865
extern "C" { extern double __cdecl pow(double , double ); } 
#line 3921
extern "C" { __declspec(dllimport) extern double __cdecl modf(double , double * ); } 
#line 3980
extern "C" { extern double __cdecl fmod(double , double ); } 
#line 4065
extern "C" { extern double remainder(double , double ); } 
#line 4151
extern "C" { extern float remainderf(float , float ); } 
#line 4201
extern "C" { extern double remquo(double , double , int * ); } 
#line 4251
extern "C" { extern float remquof(float , float , int * ); } 
#line 4289
extern "C" { __declspec(dllimport) extern double __cdecl j0(double ); } 
#line 4327
extern "C" { extern float j0f(float ); } 
#line 4384
extern "C" { __declspec(dllimport) extern double __cdecl j1(double ); } 
#line 4441
extern "C" { extern float j1f(float ); } 
#line 4480
extern "C" { __declspec(dllimport) extern double __cdecl jn(int , double ); } 
#line 4519
extern "C" { extern float jnf(int , float ); } 
#line 4567
extern "C" { __declspec(dllimport) extern double __cdecl y0(double ); } 
#line 4615
extern "C" { extern float y0f(float ); } 
#line 4663
extern "C" { __declspec(dllimport) extern double __cdecl y1(double ); } 
#line 4711
extern "C" { extern float y1f(float ); } 
#line 4760
extern "C" { __declspec(dllimport) extern double __cdecl yn(int , double ); } 
#line 4809
extern "C" { extern float ynf(int , float ); } 
#line 4836
extern "C" { __declspec(dllimport) extern double __cdecl cyl_bessel_i0(double ); } 
#line 4862
extern "C" { extern float cyl_bessel_i0f(float ); } 
#line 4889
extern "C" { __declspec(dllimport) extern double __cdecl cyl_bessel_i1(double ); } 
#line 4915
extern "C" { extern float cyl_bessel_i1f(float ); } 
#line 4994
extern "C" { extern double erf(double ); } 
#line 5072
extern "C" { extern float erff(float ); } 
#line 5129
extern "C" { extern double erfinv(double ); } 
#line 5186
extern "C" { extern float erfinvf(float ); } 
#line 5220
extern "C" { extern double erfc(double ); } 
#line 5254
extern "C" { extern float erfcf(float ); } 
#line 5378
extern "C" { extern double lgamma(double ); } 
#line 5434
extern "C" { extern double erfcinv(double ); } 
#line 5490
extern "C" { extern float erfcinvf(float ); } 
#line 5548
extern "C" { extern double normcdfinv(double ); } 
#line 5606
extern "C" { extern float normcdfinvf(float ); } 
#line 5649
extern "C" { extern double normcdf(double ); } 
#line 5692
extern "C" { extern float normcdff(float ); } 
#line 5767
extern "C" { extern double erfcx(double ); } 
#line 5842
extern "C" { extern float erfcxf(float ); } 
#line 5971
extern "C" { extern float lgammaf(float ); } 
#line 6076
extern "C" { extern double tgamma(double ); } 
#line 6181
extern "C" { extern float tgammaf(float ); } 
#line 6190
extern "C" { extern double copysign(double , double ); } 
#line 6199
extern "C" { extern float copysignf(float , float ); } 
#line 6232
extern "C" { extern double nextafter(double , double ); } 
#line 6265
extern "C" { extern float nextafterf(float , float ); } 
#line 6277
extern "C" { extern double nan(const char * ); } 
#line 6289
extern "C" { extern float nanf(const char * ); } 
#line 6290
extern "C" { extern int __isinff(float); } 
#line 6291
extern "C" { extern int __isnanf(float); } 
#line 6300 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
extern "C" { extern int __finite(double); } 
#line 6301
extern "C" { extern int __finitef(float); } 
#line 6302
extern "C" { extern int __signbit(double); } 
#line 6303
extern "C" { extern int __isnan(double); } 
#line 6304
extern "C" { extern int __isinf(double); } 
#line 6307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
extern "C" { extern int __signbitf(float); } 
#line 6461
extern "C" { extern double fma(double , double , double ); } 
#line 6615
extern "C" { extern float fmaf(float , float , float ); } 
#line 6620
extern "C" { extern int __signbitl(long double); } 
#line 6626 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
extern "C" { extern int __finitel(long double); } 
#line 6627
extern "C" { extern int __isinfl(long double); } 
#line 6628
extern "C" { extern int __isnanl(long double); } 
#line 6632 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl acosf(float); } 
#line 6633
extern "C" { __declspec(dllimport) extern float __cdecl asinf(float); } 
#line 6634
extern "C" { __declspec(dllimport) extern float __cdecl atanf(float); } 
#line 6635
extern "C" { __declspec(dllimport) extern float __cdecl atan2f(float, float); } 
#line 6636
extern "C" { __declspec(dllimport) extern float __cdecl cosf(float); } 
#line 6637
extern "C" { __declspec(dllimport) extern float __cdecl sinf(float); } 
#line 6638
extern "C" { __declspec(dllimport) extern float __cdecl tanf(float); } 
#line 6639
extern "C" { __declspec(dllimport) extern float __cdecl coshf(float); } 
#line 6640
extern "C" { __declspec(dllimport) extern float __cdecl sinhf(float); } 
#line 6641
extern "C" { __declspec(dllimport) extern float __cdecl tanhf(float); } 
#line 6642
extern "C" { __declspec(dllimport) extern float __cdecl expf(float); } 
#line 6643
extern "C" { __declspec(dllimport) extern float __cdecl logf(float); } 
#line 6644
extern "C" { __declspec(dllimport) extern float __cdecl log10f(float); } 
#line 6645
extern "C" { __declspec(dllimport) extern float __cdecl modff(float, float *); } 
#line 6646
extern "C" { __declspec(dllimport) extern float __cdecl powf(float, float); } 
#line 6647
extern "C" { __declspec(dllimport) extern float __cdecl sqrtf(float); } 
#line 6648
extern "C" { __declspec(dllimport) extern float __cdecl ceilf(float); } 
#line 6649
extern "C" { __declspec(dllimport) extern float __cdecl floorf(float); } 
#line 6650
extern "C" { __declspec(dllimport) extern float __cdecl fmodf(float, float); } 
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
#pragma pack ( push, 8 )
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" { struct _exception { 
#line 38
int type; 
#line 39
char *name; 
#line 40
double arg1; 
#line 41
double arg2; 
#line 42
double retval; 
#line 43
}; }
#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" { struct _complex { 
#line 55
double x, y; 
#line 56
}; }
#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" __declspec(dllimport) double _HUGE; 
#line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" { int __cdecl abs(int ); } 
#line 102
extern "C" { long __cdecl labs(long ); } 
#line 103
extern "C" { __int64 __cdecl llabs(__int64 ); } 
#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" { double __cdecl acos(double ); } 
#line 107
extern "C" { double __cdecl asin(double ); } 
#line 108
extern "C" { double __cdecl atan(double ); } 
#line 109
extern "C" { double __cdecl atan2(double , double ); } 
#line 111
extern "C" { __declspec(dllimport) double __cdecl _copysign(double , double ); } 
#line 112
extern "C" { __declspec(dllimport) double __cdecl _chgsign(double ); } 
#line 115 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" { double __cdecl cos(double ); } 
#line 116
extern "C" { double __cdecl cosh(double ); } 
#line 117
extern "C" { double __cdecl exp(double ); } 
#line 118
extern "C" { double __cdecl fabs(double ); } 
#line 119
extern "C" { double __cdecl fmod(double , double ); } 
#line 120
extern "C" { double __cdecl log(double ); } 
#line 121
extern "C" { double __cdecl log10(double ); } 
#line 122
extern "C" { double __cdecl pow(double , double ); } 
#line 123
extern "C" { double __cdecl sin(double ); } 
#line 124
extern "C" { double __cdecl sinh(double ); } 
#line 125
extern "C" { double __cdecl tan(double ); } 
#line 126
extern "C" { double __cdecl tanh(double ); } 
#line 127
extern "C" { double __cdecl sqrt(double ); } 
#line 130
extern "C" { __declspec(dllimport) double __cdecl atof(const char * ); } 
#line 131
extern "C" { __declspec(dllimport) double __cdecl _atof_l(const char * , _locale_t ); } 
#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" { __declspec(dllimport) double __cdecl _cabs(_complex ); } 
#line 135
extern "C" { __declspec(dllimport) double __cdecl ceil(double ); } 
#line 136
extern "C" { __declspec(dllimport) double __cdecl floor(double ); } 
#line 137
extern "C" { __declspec(dllimport) double __cdecl frexp(double , int * ); } 
#line 138
extern "C" { __declspec(dllimport) double __cdecl _hypot(double , double ); } 
#line 139
extern "C" { __declspec(dllimport) float __cdecl _hypotf(float , float ); } 
#line 140
extern "C" { __declspec(dllimport) double __cdecl _j0(double ); } 
#line 141
extern "C" { __declspec(dllimport) double __cdecl _j1(double ); } 
#line 142
extern "C" { __declspec(dllimport) double __cdecl _jn(int , double ); } 
#line 143
extern "C" { __declspec(dllimport) double __cdecl ldexp(double , int ); } 
#line 149 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" { int __cdecl _matherr(_exception * ); } 
#line 152 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" { __declspec(dllimport) double __cdecl modf(double , double * ); } 
#line 154
extern "C" { __declspec(dllimport) double __cdecl _y0(double ); } 
#line 155
extern "C" { __declspec(dllimport) double __cdecl _y1(double ); } 
#line 156
extern "C" { __declspec(dllimport) double __cdecl _yn(int , double ); } 
#line 161
extern "C" { static __inline double __cdecl hypot(double _X, double _Y) 
#line 162
{ 
#line 163
return _hypot(_X, _Y); 
#line 164
} } 
#line 166
extern "C" { static __inline float __cdecl hypotf(float _X, float _Y) 
#line 167
{ 
#line 168
return _hypotf(_X, _Y); 
#line 169
} } 
#line 224 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" { __declspec(dllimport) float __cdecl acosf(float ); } 
#line 225
extern "C" { __declspec(dllimport) float __cdecl asinf(float ); } 
#line 226
extern "C" { __declspec(dllimport) float __cdecl atanf(float ); } 
#line 227
extern "C" { __declspec(dllimport) float __cdecl atan2f(float , float ); } 
#line 228
extern "C" { __declspec(dllimport) float __cdecl cosf(float ); } 
#line 229
extern "C" { __declspec(dllimport) float __cdecl sinf(float ); } 
#line 230
extern "C" { __declspec(dllimport) float __cdecl tanf(float ); } 
#line 233
extern "C" { __declspec(dllimport) float __cdecl coshf(float ); } 
#line 234
extern "C" { __declspec(dllimport) float __cdecl sinhf(float ); } 
#line 235
extern "C" { __declspec(dllimport) float __cdecl tanhf(float ); } 
#line 238
extern "C" { __declspec(dllimport) float __cdecl expf(float ); } 
#line 239
extern "C" { __declspec(dllimport) float __cdecl logf(float ); } 
#line 240
extern "C" { __declspec(dllimport) float __cdecl log10f(float ); } 
#line 241
extern "C" { __declspec(dllimport) float __cdecl modff(float , float * ); } 
#line 244
extern "C" { __declspec(dllimport) float __cdecl powf(float , float ); } 
#line 245
extern "C" { __declspec(dllimport) float __cdecl sqrtf(float ); } 
#line 248
extern "C" { __declspec(dllimport) float __cdecl ceilf(float ); } 
#line 249
extern "C" { __declspec(dllimport) float __cdecl floorf(float ); } 
#line 250
extern "C" { __declspec(dllimport) float __cdecl fmodf(float , float ); } 
#line 252
extern "C" { __declspec(dllimport) float __cdecl _copysignf(float , float ); } 
#line 253
extern "C" { __declspec(dllimport) float __cdecl _chgsignf(float ); } 
#line 254
extern "C" { __declspec(dllimport) float __cdecl _logbf(float ); } 
#line 255
extern "C" { __declspec(dllimport) float __cdecl _nextafterf(float , float ); } 
#line 256
extern "C" { __declspec(dllimport) int __cdecl _finitef(float ); } 
#line 257
extern "C" { __declspec(dllimport) int __cdecl _isnanf(float ); } 
#line 258
extern "C" { __declspec(dllimport) int __cdecl _fpclassf(float ); } 
#line 328 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" { inline long double acosl(long double _X) 
#line 329
{ return acos((double)_X); } } 
#line 330
extern "C" { inline long double asinl(long double _X) 
#line 331
{ return asin((double)_X); } } 
#line 332
extern "C" { inline long double atanl(long double _X) 
#line 333
{ return atan((double)_X); } } 
#line 334
extern "C" { inline long double atan2l(long double _Y, long double _X) 
#line 335
{ return atan2((double)_Y, (double)_X); } } 
#line 336
extern "C" { inline long double ceill(long double _X) 
#line 337
{ return ceil((double)_X); } } 
#line 338
extern "C" { inline long double cosl(long double _X) 
#line 339
{ return cos((double)_X); } } 
#line 340
extern "C" { inline long double coshl(long double _X) 
#line 341
{ return cosh((double)_X); } } 
#line 342
extern "C" { inline long double expl(long double _X) 
#line 343
{ return exp((double)_X); } } 
#line 344
extern "C" { inline long double fabsl(long double _X) 
#line 345
{ return fabs((double)_X); } } 
#line 346
extern "C" { inline long double floorl(long double _X) 
#line 347
{ return floor((double)_X); } } 
#line 348
extern "C" { inline long double fmodl(long double _X, long double _Y) 
#line 349
{ return fmod((double)_X, (double)_Y); } } 
#line 350
extern "C" { inline long double frexpl(long double _X, int *_Y) 
#line 351
{ return frexp((double)_X, _Y); } } 
#line 352
extern "C" { inline long double ldexpl(long double _X, int _Y) 
#line 353
{ return ldexp((double)_X, _Y); } } 
#line 354
extern "C" { inline long double logl(long double _X) 
#line 355
{ return log((double)_X); } } 
#line 356
extern "C" { inline long double log10l(long double _X) 
#line 357
{ return log10((double)_X); } } 
#line 358
extern "C" { inline long double modfl(long double _X, long double *_Y) 
#line 359
{ double _Di, _Df = modf((double)_X, &_Di); 
#line 360
(*_Y) = ((long double)_Di); 
#line 361
return _Df; } } 
#line 362
extern "C" { inline long double powl(long double _X, long double _Y) 
#line 363
{ return pow((double)_X, (double)_Y); } } 
#line 364
extern "C" { inline long double sinl(long double _X) 
#line 365
{ return sin((double)_X); } } 
#line 366
extern "C" { inline long double sinhl(long double _X) 
#line 367
{ return sinh((double)_X); } } 
#line 368
extern "C" { inline long double sqrtl(long double _X) 
#line 369
{ return sqrt((double)_X); } } 
#line 371
extern "C" { inline long double tanl(long double _X) 
#line 372
{ return tan((double)_X); } } 
#line 377 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" { inline long double tanhl(long double _X) 
#line 378
{ return tanh((double)_X); } } 
#line 380
extern "C" { inline long double _chgsignl(long double _Number) 
#line 381
{ 
#line 382
return _chgsign(static_cast< double>(_Number)); 
#line 383
} } 
#line 385
extern "C" { inline long double _copysignl(long double _Number, long double _Sign) 
#line 386
{ 
#line 387
return _copysign(static_cast< double>(_Number), static_cast< double>(_Sign)); 
#line 388
} } 
#line 390
extern "C" { inline float frexpf(float _X, int *_Y) 
#line 391
{ return (float)frexp((double)_X, _Y); } } 
#line 394
extern "C" { inline float fabsf(float _X) 
#line 395
{ return (float)fabs((double)_X); } } 
#line 396
extern "C" { inline float ldexpf(float _X, int _Y) 
#line 397
{ return (float)ldexp((double)_X, _Y); } } 
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" __declspec(dllimport) double HUGE; 
#line 465 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
extern "C" { __declspec(dllimport) double __cdecl cabs(_complex ); } 
#line 466
extern "C" { __declspec(dllimport) double __cdecl j0(double ); } 
#line 467
extern "C" { __declspec(dllimport) double __cdecl j1(double ); } 
#line 468
extern "C" { __declspec(dllimport) double __cdecl jn(int , double ); } 
#line 469
extern "C" { __declspec(dllimport) double __cdecl y0(double ); } 
#line 470
extern "C" { __declspec(dllimport) double __cdecl y1(double ); } 
#line 471
extern "C" { __declspec(dllimport) double __cdecl yn(int , double ); } 
#line 482 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
template < class _Ty > inline
        _Ty _Pow_int ( _Ty _X, int _Y )
        { unsigned int _N;
        if ( _Y >= 0 )
                _N = ( unsigned int ) _Y;
        else
                _N = ( unsigned int ) ( - _Y );
        for ( _Ty _Z = _Ty ( 1 );; _X *= _X )
                { if ( ( _N & 1 ) != 0 )
                        _Z *= _X;
                if ( ( _N >>= 1 ) == 0 )
                        return ( _Y < 0 ? _Ty ( 1 ) / _Z : _Z ); } }
#line 495
inline double __cdecl abs(double _X) 
#line 496
{ return fabs(_X); } 
#line 497
inline double __cdecl pow(double _X, int _Y) 
#line 498
{ return _Pow_int(_X, _Y); } 
#line 499
inline float __cdecl abs(float _X) 
#line 500
{ return fabsf(_X); } 
#line 501
inline float __cdecl acos(float _X) 
#line 502
{ return acosf(_X); } 
#line 503
inline float __cdecl asin(float _X) 
#line 504
{ return asinf(_X); } 
#line 505
inline float __cdecl atan(float _X) 
#line 506
{ return atanf(_X); } 
#line 507
inline float __cdecl atan2(float _Y, float _X) 
#line 508
{ return atan2f(_Y, _X); } 
#line 509
inline float __cdecl ceil(float _X) 
#line 510
{ return ceilf(_X); } 
#line 511
inline float __cdecl cos(float _X) 
#line 512
{ return cosf(_X); } 
#line 513
inline float __cdecl cosh(float _X) 
#line 514
{ return coshf(_X); } 
#line 515
inline float __cdecl exp(float _X) 
#line 516
{ return expf(_X); } 
#line 517
inline float __cdecl fabs(float _X) 
#line 518
{ return fabsf(_X); } 
#line 519
inline float __cdecl floor(float _X) 
#line 520
{ return floorf(_X); } 
#line 521
inline float __cdecl fmod(float _X, float _Y) 
#line 522
{ return fmodf(_X, _Y); } 
#line 523
inline float __cdecl frexp(float _X, int *_Y) 
#line 524
{ return frexpf(_X, _Y); } 
#line 525
inline float __cdecl ldexp(float _X, int _Y) 
#line 526
{ return ldexpf(_X, _Y); } 
#line 527
inline float __cdecl log(float _X) 
#line 528
{ return logf(_X); } 
#line 529
inline float __cdecl log10(float _X) 
#line 530
{ return log10f(_X); } 
#line 531
inline float __cdecl modf(float _X, float *_Y) 
#line 532
{ return modff(_X, _Y); } 
#line 533
inline float __cdecl pow(float _X, float _Y) 
#line 534
{ return powf(_X, _Y); } 
#line 535
inline float __cdecl pow(float _X, int _Y) 
#line 536
{ return _Pow_int(_X, _Y); } 
#line 537
inline float __cdecl sin(float _X) 
#line 538
{ return sinf(_X); } 
#line 539
inline float __cdecl sinh(float _X) 
#line 540
{ return sinhf(_X); } 
#line 541
inline float __cdecl sqrt(float _X) 
#line 542
{ return sqrtf(_X); } 
#line 543
inline float __cdecl tan(float _X) 
#line 544
{ return tanf(_X); } 
#line 545
inline float __cdecl tanh(float _X) 
#line 546
{ return tanhf(_X); } 
#line 547
inline long double __cdecl abs(long double _X) 
#line 548
{ return fabsl(_X); } 
#line 549
inline long double __cdecl acos(long double _X) 
#line 550
{ return acosl(_X); } 
#line 551
inline long double __cdecl asin(long double _X) 
#line 552
{ return asinl(_X); } 
#line 553
inline long double __cdecl atan(long double _X) 
#line 554
{ return atanl(_X); } 
#line 555
inline long double __cdecl atan2(long double _Y, long double _X) 
#line 556
{ return atan2l(_Y, _X); } 
#line 557
inline long double __cdecl ceil(long double _X) 
#line 558
{ return ceill(_X); } 
#line 559
inline long double __cdecl cos(long double _X) 
#line 560
{ return cosl(_X); } 
#line 561
inline long double __cdecl cosh(long double _X) 
#line 562
{ return coshl(_X); } 
#line 563
inline long double __cdecl exp(long double _X) 
#line 564
{ return expl(_X); } 
#line 565
inline long double __cdecl fabs(long double _X) 
#line 566
{ return fabsl(_X); } 
#line 567
inline long double __cdecl floor(long double _X) 
#line 568
{ return floorl(_X); } 
#line 569
inline long double __cdecl fmod(long double _X, long double _Y) 
#line 570
{ return fmodl(_X, _Y); } 
#line 571
inline long double __cdecl frexp(long double _X, int *_Y) 
#line 572
{ return frexpl(_X, _Y); } 
#line 573
inline long double __cdecl ldexp(long double _X, int _Y) 
#line 574
{ return ldexpl(_X, _Y); } 
#line 575
inline long double __cdecl log(long double _X) 
#line 576
{ return logl(_X); } 
#line 577
inline long double __cdecl log10(long double _X) 
#line 578
{ return log10l(_X); } 
#line 579
inline long double __cdecl modf(long double _X, long double *_Y) 
#line 580
{ return modfl(_X, _Y); } 
#line 581
inline long double __cdecl pow(long double _X, long double _Y) 
#line 582
{ return powl(_X, _Y); } 
#line 583
inline long double __cdecl pow(long double _X, int _Y) 
#line 584
{ return _Pow_int(_X, _Y); } 
#line 585
inline long double __cdecl sin(long double _X) 
#line 586
{ return sinl(_X); } 
#line 587
inline long double __cdecl sinh(long double _X) 
#line 588
{ return sinhl(_X); } 
#line 589
inline long double __cdecl sqrt(long double _X) 
#line 590
{ return sqrtl(_X); } 
#line 591
inline long double __cdecl tan(long double _X) 
#line 592
{ return tanl(_X); } 
#line 593
inline long double __cdecl tanh(long double _X) 
#line 594
{ return tanhl(_X); } 
#line 599 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\math.h"
#pragma pack ( pop )
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
#pragma pack ( push, 8 )
#line 52 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { typedef int (__cdecl *_onexit_t)(void); }
#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { typedef 
#line 75
struct _div_t { 
#line 76
int quot; 
#line 77
int rem; 
#line 78
} div_t; }
#line 83
extern "C" { typedef 
#line 80
struct _ldiv_t { 
#line 81
long quot; 
#line 82
long rem; 
#line 83
} ldiv_t; }
#line 88
extern "C" { typedef 
#line 85
struct _lldiv_t { 
#line 86
__int64 quot; 
#line 87
__int64 rem; 
#line 88
} lldiv_t; }
#line 102 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
#pragma pack ( 4 )
#line 105
extern "C" { typedef 
#line 103
struct { 
#line 104
unsigned char ld[10]; 
#line 105
} _LDOUBLE; }
#pragma pack ( )
#line 124 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { typedef 
#line 122
struct { 
#line 123
double x; 
#line 124
} _CRT_DOUBLE; }
#line 128
extern "C" { typedef 
#line 126
struct { 
#line 127
float f; 
#line 128
} _CRT_FLOAT; }
#line 139
extern "C" { typedef 
#line 134
struct { 
#line 138
long double x; 
#line 139
} _LONGDOUBLE; }
#line 143
#pragma pack ( 4 )
#line 146
extern "C" { typedef 
#line 144
struct { 
#line 145
unsigned char ld12[12]; 
#line 146
} _LDBL12; }
#pragma pack ( )
#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" __declspec(dllimport) int __mb_cur_max; 
#line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl ___mb_cur_max_func(); } 
#line 169
extern "C" { __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t); } 
#line 208 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { typedef void (__cdecl *_purecall_handler)(void); }
#line 211
extern "C" { __declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(_purecall_handler ); } 
#line 212
extern "C" { __declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(); } 
#line 228 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { typedef void (__cdecl *_invalid_parameter_handler)(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); }
#line 231
extern "C" { __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_invalid_parameter_handler ); } 
#line 232
extern "C" { __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(); } 
#line 256 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) unsigned long *__cdecl __doserrno(); } 
#line 259
extern "C" { errno_t __cdecl _set_doserrno(unsigned long ); } 
#line 260
extern "C" { errno_t __cdecl _get_doserrno(unsigned long * ); } 
#line 263
extern "C" { __declspec(dllimport) char **__cdecl __sys_errlist(); } 
#line 266
extern "C" { __declspec(dllimport) int *__cdecl __sys_nerr(); } 
#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" __declspec(dllimport) int __argc; 
#line 284
extern "C" __declspec(dllimport) char **__argv; 
#line 285
extern "C" __declspec(dllimport) __wchar_t **__wargv; 
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" __declspec(dllimport) char **_environ; 
#line 300
extern "C" __declspec(dllimport) __wchar_t **_wenviron; 
#line 303 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" __declspec(dllimport) char *_pgmptr; 
#line 304
extern "C" __declspec(dllimport) __wchar_t *_wpgmptr; 
#line 321 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { errno_t __cdecl _get_pgmptr(char ** ); } 
#line 322
extern "C" { errno_t __cdecl _get_wpgmptr(__wchar_t ** ); } 
#line 326
extern "C" __declspec(dllimport) int _fmode; 
#line 332 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _set_fmode(int ); } 
#line 333
extern "C" { __declspec(dllimport) errno_t __cdecl _get_fmode(int * ); } 
#line 342 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
template< class _CountofType, size_t _SizeOfArray> char (*__countof_helper(__unaligned _CountofType (& )[_SizeOfArray]))[_SizeOfArray]; 
#line 353 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl exit(int ); } 
#line 354
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(int ); } 
#line 355
extern "C" { __declspec(dllimport) void __cdecl abort(); } 
#line 358 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) unsigned __cdecl _set_abort_behavior(unsigned , unsigned ); } 
#line 367
extern "C" { __int64 __cdecl _abs64(__int64); } 
#line 398 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { int __cdecl atexit(void (__cdecl *)(void)); } 
#line 405 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl atoi(const char * ); } 
#line 406
extern "C" { __declspec(dllimport) int __cdecl _atoi_l(const char * , _locale_t ); } 
#line 407
extern "C" { __declspec(dllimport) long __cdecl atol(const char * ); } 
#line 408
extern "C" { __declspec(dllimport) long __cdecl _atol_l(const char * , _locale_t ); } 
#line 412
extern "C" { __declspec(dllimport) void *__cdecl bsearch_s(const void * , const void * , rsize_t , rsize_t , int (__cdecl * )(void *, const void *, const void *), void * ); } 
#line 416 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) void *__cdecl bsearch(const void * , const void * , size_t , size_t , int (__cdecl * )(const void *, const void *)); } 
#line 421
extern "C" { __declspec(dllimport) void __cdecl qsort_s(void * , rsize_t , rsize_t , int (__cdecl * )(void *, const void *, const void *), void * ); } 
#line 425 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) void __cdecl qsort(void * , size_t , size_t , int (__cdecl * )(const void *, const void *)); } 
#line 429 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { unsigned short __cdecl _byteswap_ushort(unsigned short ); } 
#line 430
extern "C" { unsigned long __cdecl _byteswap_ulong(unsigned long ); } 
#line 431
extern "C" { unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 ); } 
#line 432
extern "C" { __declspec(dllimport) div_t __cdecl div(int , int ); } 
#line 433
extern "C" { __declspec(dllimport) char *__cdecl getenv(const char * ); } 
#line 435
extern "C" { __declspec(dllimport) errno_t __cdecl getenv_s(size_t * , char * , rsize_t , const char * ); } 
#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
template < size_t _Size > inline errno_t __cdecl getenv_s ( size_t * _ReturnSize, char ( & _Dest ) [ _Size ], const char * _VarName ) throw ( ) { return getenv_s ( _ReturnSize, _Dest, _Size, _VarName ); }
#line 443 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _dupenv_s(char ** , size_t * , const char * ); } 
#line 449 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _itoa_s(int , char * , size_t , int ); } 
#line 450
template < size_t _Size > inline errno_t __cdecl _itoa_s ( int _Value, char ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _itoa_s ( _Value, _Dest, _Size, _Radix ); }
#line 451
extern "C" { __declspec(dllimport) char *__cdecl _itoa(int , char * , int ); } 
#line 452
extern "C" { __declspec(dllimport) errno_t __cdecl _i64toa_s(__int64 , char * , size_t , int ); } 
#line 453
extern "C" { __declspec(dllimport) char *__cdecl _i64toa(__int64 , char * , int ); } 
#line 454
extern "C" { __declspec(dllimport) errno_t __cdecl _ui64toa_s(unsigned __int64 , char * , size_t , int ); } 
#line 455
extern "C" { __declspec(dllimport) char *__cdecl _ui64toa(unsigned __int64 , char * , int ); } 
#line 456
extern "C" { __declspec(dllimport) __int64 __cdecl _atoi64(const char * ); } 
#line 457
extern "C" { __declspec(dllimport) __int64 __cdecl _atoi64_l(const char * , _locale_t ); } 
#line 458
extern "C" { __declspec(dllimport) __int64 __cdecl _strtoi64(const char * , char ** , int ); } 
#line 459
extern "C" { __declspec(dllimport) __int64 __cdecl _strtoi64_l(const char * , char ** , int , _locale_t ); } 
#line 460
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _strtoui64(const char * , char ** , int ); } 
#line 461
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(const char * , char ** , int , _locale_t ); } 
#line 462
extern "C" { __declspec(dllimport) ldiv_t __cdecl ldiv(long , long ); } 
#line 463
extern "C" { __declspec(dllimport) lldiv_t __cdecl lldiv(__int64 , __int64 ); } 
#line 467
inline long abs(long _X) 
#line 468
{ 
#line 469
return labs(_X); 
#line 470
} 
#line 471
inline __int64 abs(__int64 _X) 
#line 472
{ 
#line 473
return llabs(_X); 
#line 474
} 
#line 475
inline ldiv_t div(long _A1, long _A2) 
#line 476
{ 
#line 477
return ldiv(_A1, _A2); 
#line 478
} 
#line 479
inline lldiv_t div(__int64 _A1, __int64 _A2) 
#line 480
{ 
#line 481
return lldiv(_A1, _A2); 
#line 482
} 
#line 485 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _ltoa_s(long , char * , size_t , int ); } 
#line 486
template < size_t _Size > inline errno_t __cdecl _ltoa_s ( long _Value, char ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ltoa_s ( _Value, _Dest, _Size, _Radix ); }
#line 487
extern "C" { __declspec(dllimport) char *__cdecl _ltoa(long , char * , int ); } 
#line 488
extern "C" { __declspec(dllimport) int __cdecl mblen(const char * , size_t ); } 
#line 489
extern "C" { __declspec(dllimport) int __cdecl _mblen_l(const char * , size_t , _locale_t ); } 
#line 490
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrlen(const char * ); } 
#line 491
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrlen_l(const char * , _locale_t ); } 
#line 492
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrnlen(const char * , size_t ); } 
#line 493
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrnlen_l(const char * , size_t , _locale_t ); } 
#line 494
extern "C" { __declspec(dllimport) int __cdecl mbtowc(__wchar_t * , const char * , size_t ); } 
#line 495
extern "C" { __declspec(dllimport) int __cdecl _mbtowc_l(__wchar_t * , const char * , size_t , _locale_t ); } 
#line 496
extern "C" { __declspec(dllimport) errno_t __cdecl mbstowcs_s(size_t * , __wchar_t * , size_t , const char * , size_t ); } 
#line 497
template < size_t _Size > inline errno_t __cdecl mbstowcs_s ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], const char * _Source, size_t _MaxCount ) throw ( ) { return mbstowcs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }
#line 498
extern "C" { __declspec(dllimport) size_t __cdecl mbstowcs(__wchar_t * , const char * , size_t ); } 
#line 500
extern "C" { __declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(size_t * , __wchar_t * , size_t , const char * , size_t , _locale_t ); } 
#line 501
template < size_t _Size > inline errno_t __cdecl _mbstowcs_s_l ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], const char * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _mbstowcs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }
#line 502
extern "C" { __declspec(dllimport) size_t __cdecl _mbstowcs_l(__wchar_t * , const char * , size_t , _locale_t ); } 
#line 504
extern "C" { __declspec(dllimport) int __cdecl rand(); } 
#line 509 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl _set_error_mode(int ); } 
#line 511
extern "C" { __declspec(dllimport) void __cdecl srand(unsigned ); } 
#line 512
extern "C" { __declspec(dllimport) double __cdecl strtod(const char * , char ** ); } 
#line 513
extern "C" { __declspec(dllimport) double __cdecl _strtod_l(const char * , char ** , _locale_t ); } 
#line 514
extern "C" { __declspec(dllimport) long __cdecl strtol(const char * , char ** , int ); } 
#line 515
extern "C" { __declspec(dllimport) long __cdecl _strtol_l(const char * , char ** , int , _locale_t ); } 
#line 516
extern "C" { __declspec(dllimport) unsigned long __cdecl strtoul(const char * , char ** , int ); } 
#line 517
extern "C" { __declspec(dllimport) unsigned long __cdecl _strtoul_l(const char * , char ** , int , _locale_t ); } 
#line 520
extern "C" { __declspec(dllimport) int __cdecl system(const char * ); } 
#line 522 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _ultoa_s(unsigned long , char * , size_t , int ); } 
#line 523
template < size_t _Size > inline errno_t __cdecl _ultoa_s ( unsigned long _Value, char ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ultoa_s ( _Value, _Dest, _Size, _Radix ); }
#line 524
extern "C" { __declspec(dllimport) char *__cdecl _ultoa(unsigned long , char * , int ); } 
#line 525
extern "C" { __declspec(dllimport) int __cdecl wctomb(char * , __wchar_t ); } 
#line 526
extern "C" { __declspec(dllimport) int __cdecl _wctomb_l(char * , __wchar_t , _locale_t ); } 
#line 528
extern "C" { __declspec(dllimport) errno_t __cdecl wctomb_s(int * , char * , rsize_t , __wchar_t ); } 
#line 530 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _wctomb_s_l(int * , char * , size_t , __wchar_t , _locale_t ); } 
#line 531
extern "C" { __declspec(dllimport) errno_t __cdecl wcstombs_s(size_t * , char * , size_t , const __wchar_t * , size_t ); } 
#line 532
template < size_t _Size > inline errno_t __cdecl wcstombs_s ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _MaxCount ) throw ( ) { return wcstombs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }
#line 533
extern "C" { __declspec(dllimport) size_t __cdecl wcstombs(char * , const __wchar_t * , size_t ); } 
#line 534
extern "C" { __declspec(dllimport) errno_t __cdecl _wcstombs_s_l(size_t * , char * , size_t , const __wchar_t * , size_t , _locale_t ); } 
#line 535
template < size_t _Size > inline errno_t __cdecl _wcstombs_s_l ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _wcstombs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }
#line 536
extern "C" { __declspec(dllimport) size_t __cdecl _wcstombs_l(char * , const __wchar_t * , size_t , _locale_t ); } 
#line 598 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl calloc(size_t , size_t ); } 
#line 599
extern "C" { __declspec(dllimport) __declspec(noalias) void __cdecl free(void * ); } 
#line 600
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl malloc(size_t ); } 
#line 602
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl realloc(void * , size_t ); } 
#line 604
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _recalloc(void * , size_t , size_t ); } 
#line 605
extern "C" { __declspec(dllimport) __declspec(noalias) void __cdecl _aligned_free(void * ); } 
#line 606
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_malloc(size_t , size_t ); } 
#line 607
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_offset_malloc(size_t , size_t , size_t ); } 
#line 609
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_realloc(void * , size_t , size_t ); } 
#line 611
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_recalloc(void * , size_t , size_t , size_t ); } 
#line 613
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_offset_realloc(void * , size_t , size_t , size_t ); } 
#line 615
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_offset_recalloc(void * , size_t , size_t , size_t , size_t ); } 
#line 616
extern "C" { __declspec(dllimport) size_t __cdecl _aligned_msize(void * , size_t , size_t ); } 
#line 643 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _itow_s(int , __wchar_t * , size_t , int ); } 
#line 644
template < size_t _Size > inline errno_t __cdecl _itow_s ( int _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _itow_s ( _Value, _Dest, _Size, _Radix ); }
#line 645
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _itow(int , __wchar_t * , int ); } 
#line 646
extern "C" { __declspec(dllimport) errno_t __cdecl _ltow_s(long , __wchar_t * , size_t , int ); } 
#line 647
template < size_t _Size > inline errno_t __cdecl _ltow_s ( long _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ltow_s ( _Value, _Dest, _Size, _Radix ); }
#line 648
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _ltow(long , __wchar_t * , int ); } 
#line 649
extern "C" { __declspec(dllimport) errno_t __cdecl _ultow_s(unsigned long , __wchar_t * , size_t , int ); } 
#line 650
template < size_t _Size > inline errno_t __cdecl _ultow_s ( unsigned long _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ultow_s ( _Value, _Dest, _Size, _Radix ); }
#line 651
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _ultow(unsigned long , __wchar_t * , int ); } 
#line 652
extern "C" { __declspec(dllimport) double __cdecl wcstod(const __wchar_t * , __wchar_t ** ); } 
#line 653
extern "C" { __declspec(dllimport) double __cdecl _wcstod_l(const __wchar_t * , __wchar_t ** , _locale_t ); } 
#line 654
extern "C" { __declspec(dllimport) long __cdecl wcstol(const __wchar_t * , __wchar_t ** , int ); } 
#line 655
extern "C" { __declspec(dllimport) long __cdecl _wcstol_l(const __wchar_t * , __wchar_t ** , int , _locale_t ); } 
#line 656
extern "C" { __declspec(dllimport) unsigned long __cdecl wcstoul(const __wchar_t * , __wchar_t ** , int ); } 
#line 657
extern "C" { __declspec(dllimport) unsigned long __cdecl _wcstoul_l(const __wchar_t * , __wchar_t ** , int , _locale_t ); } 
#line 658
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wgetenv(const __wchar_t * ); } 
#line 659
extern "C" { __declspec(dllimport) errno_t __cdecl _wgetenv_s(size_t * , __wchar_t * , size_t , const __wchar_t * ); } 
#line 660
template < size_t _Size > inline errno_t __cdecl _wgetenv_s ( size_t * _ReturnSize, wchar_t ( & _Dest ) [ _Size ], const wchar_t * _VarName ) throw ( ) { return _wgetenv_s ( _ReturnSize, _Dest, _Size, _VarName ); }
#line 667 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _wdupenv_s(__wchar_t ** , size_t * , const __wchar_t * ); } 
#line 675 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl _wsystem(const __wchar_t * ); } 
#line 677 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) double __cdecl _wtof(const __wchar_t * ); } 
#line 678
extern "C" { __declspec(dllimport) double __cdecl _wtof_l(const __wchar_t * , _locale_t ); } 
#line 679
extern "C" { __declspec(dllimport) int __cdecl _wtoi(const __wchar_t * ); } 
#line 680
extern "C" { __declspec(dllimport) int __cdecl _wtoi_l(const __wchar_t * , _locale_t ); } 
#line 681
extern "C" { __declspec(dllimport) long __cdecl _wtol(const __wchar_t * ); } 
#line 682
extern "C" { __declspec(dllimport) long __cdecl _wtol_l(const __wchar_t * , _locale_t ); } 
#line 684
extern "C" { __declspec(dllimport) errno_t __cdecl _i64tow_s(__int64 , __wchar_t * , size_t , int ); } 
#line 685
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _i64tow(__int64 , __wchar_t * , int ); } 
#line 686
extern "C" { __declspec(dllimport) errno_t __cdecl _ui64tow_s(unsigned __int64 , __wchar_t * , size_t , int ); } 
#line 687
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _ui64tow(unsigned __int64 , __wchar_t * , int ); } 
#line 688
extern "C" { __declspec(dllimport) __int64 __cdecl _wtoi64(const __wchar_t * ); } 
#line 689
extern "C" { __declspec(dllimport) __int64 __cdecl _wtoi64_l(const __wchar_t * , _locale_t ); } 
#line 690
extern "C" { __declspec(dllimport) __int64 __cdecl _wcstoi64(const __wchar_t * , __wchar_t ** , int ); } 
#line 691
extern "C" { __declspec(dllimport) __int64 __cdecl _wcstoi64_l(const __wchar_t * , __wchar_t ** , int , _locale_t ); } 
#line 692
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(const __wchar_t * , __wchar_t ** , int ); } 
#line 693
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(const __wchar_t * , __wchar_t ** , int , _locale_t ); } 
#line 713 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) char *__cdecl _fullpath(char * , const char * , size_t ); } 
#line 721 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _ecvt_s(char * , size_t , double , int , int * , int * ); } 
#line 722
template < size_t _Size > inline errno_t __cdecl _ecvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits, int * _PtDec, int * _PtSign ) throw ( ) { return _ecvt_s ( _Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign ); }
#line 723
extern "C" { __declspec(dllimport) char *__cdecl _ecvt(double , int , int * , int * ); } 
#line 724
extern "C" { __declspec(dllimport) errno_t __cdecl _fcvt_s(char * , size_t , double , int , int * , int * ); } 
#line 725
template < size_t _Size > inline errno_t __cdecl _fcvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits, int * _PtDec, int * _PtSign ) throw ( ) { return _fcvt_s ( _Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign ); }
#line 726
extern "C" { __declspec(dllimport) char *__cdecl _fcvt(double , int , int * , int * ); } 
#line 727
extern "C" { __declspec(dllimport) errno_t __cdecl _gcvt_s(char * , size_t , double , int ); } 
#line 728
template < size_t _Size > inline errno_t __cdecl _gcvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits ) throw ( ) { return _gcvt_s ( _Dest, _Size, _Value, _NumOfDigits ); }
#line 729
extern "C" { __declspec(dllimport) char *__cdecl _gcvt(double , int , char * ); } 
#line 731
extern "C" { __declspec(dllimport) int __cdecl _atodbl(_CRT_DOUBLE * , char * ); } 
#line 732
extern "C" { __declspec(dllimport) int __cdecl _atoldbl(_LDOUBLE * , char * ); } 
#line 733
extern "C" { __declspec(dllimport) int __cdecl _atoflt(_CRT_FLOAT * , char * ); } 
#line 734
extern "C" { __declspec(dllimport) int __cdecl _atodbl_l(_CRT_DOUBLE * , char * , _locale_t ); } 
#line 735
extern "C" { __declspec(dllimport) int __cdecl _atoldbl_l(_LDOUBLE * , char * , _locale_t ); } 
#line 736
extern "C" { __declspec(dllimport) int __cdecl _atoflt_l(_CRT_FLOAT * , char * , _locale_t ); } 
#line 737
extern "C" { unsigned long __cdecl _lrotl(unsigned long , int ); } 
#line 738
extern "C" { unsigned long __cdecl _lrotr(unsigned long , int ); } 
#line 739
extern "C" { __declspec(dllimport) errno_t __cdecl _makepath_s(char * , size_t , const char * , const char * , const char * , const char * ); } 
#line 741
template < size_t _Size > inline errno_t __cdecl _makepath_s ( char ( & _Path ) [ _Size ], const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext ) throw ( ) { return _makepath_s ( _Path, _Size, _Drive, _Dir, _Filename, _Ext ); }
#line 742
extern "C" { __declspec(dllimport) void __cdecl _makepath(char * , const char * , const char * , const char * , const char * ); } 
#line 769 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { _onexit_t __cdecl _onexit(_onexit_t ); } 
#line 774 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) void __cdecl perror(const char * ); } 
#line 777 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
#pragma warning (push)
#pragma warning (disable:6540)
extern "C" { __declspec(dllimport) int __cdecl _putenv(const char * ); } 
#line 780
extern "C" { __declspec(dllimport) errno_t __cdecl _putenv_s(const char * , const char * ); } 
#line 781
extern "C" { unsigned __cdecl _rotl(unsigned , int ); } 
#line 782
extern "C" { unsigned __int64 __cdecl _rotl64(unsigned __int64 , int ); } 
#line 783
extern "C" { unsigned __cdecl _rotr(unsigned , int ); } 
#line 784
extern "C" { unsigned __int64 __cdecl _rotr64(unsigned __int64 , int ); } 
#pragma warning (pop)
#line 787
extern "C" { __declspec(dllimport) errno_t __cdecl _searchenv_s(const char * , const char * , char * , size_t ); } 
#line 788
template < size_t _Size > inline errno_t __cdecl _searchenv_s ( const char * _Filename, const char * _EnvVar, char ( & _ResultPath ) [ _Size ] ) throw ( ) { return _searchenv_s ( _Filename, _EnvVar, _ResultPath, _Size ); }
#line 789
extern "C" { __declspec(dllimport) void __cdecl _searchenv(const char * , const char * , char * ); } 
#line 791
extern "C" { __declspec(dllimport) void __cdecl _splitpath(const char * , char * , char * , char * , char * ); } 
#line 792
extern "C" { __declspec(dllimport) errno_t __cdecl _splitpath_s(const char * , char * , size_t , char * , size_t , char * , size_t , char * , size_t ); } 
#line 797
template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _splitpath_s ( const char * _Dest, char ( & _Drive ) [ _DriveSize ], char ( & _Dir ) [ _DirSize ], char ( & _Name ) [ _NameSize ], char ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _splitpath_s ( _Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }
#line 799
extern "C" { __declspec(dllimport) void __cdecl _swab(char * , char * , int ); } 
#line 810 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wfullpath(__wchar_t * , const __wchar_t * , size_t ); } 
#line 816 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _wmakepath_s(__wchar_t * , size_t , const __wchar_t * , const __wchar_t * , const __wchar_t * , const __wchar_t * ); } 
#line 818
template < size_t _Size > inline errno_t __cdecl _wmakepath_s ( wchar_t ( & _ResultPath ) [ _Size ], const wchar_t * _Drive, const wchar_t * _Dir, const wchar_t * _Filename, const wchar_t * _Ext ) throw ( ) { return _wmakepath_s ( _ResultPath, _Size, _Drive, _Dir, _Filename, _Ext ); }
#line 819
extern "C" { __declspec(dllimport) void __cdecl _wmakepath(__wchar_t * , const __wchar_t * , const __wchar_t * , const __wchar_t * , const __wchar_t * ); } 
#line 822
extern "C" { __declspec(dllimport) void __cdecl _wperror(const __wchar_t * ); } 
#line 824 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl _wputenv(const __wchar_t * ); } 
#line 825
extern "C" { __declspec(dllimport) errno_t __cdecl _wputenv_s(const __wchar_t * , const __wchar_t * ); } 
#line 826
extern "C" { __declspec(dllimport) errno_t __cdecl _wsearchenv_s(const __wchar_t * , const __wchar_t * , __wchar_t * , size_t ); } 
#line 827
template < size_t _Size > inline errno_t __cdecl _wsearchenv_s ( const wchar_t * _Filename, const wchar_t * _EnvVar, wchar_t ( & _ResultPath ) [ _Size ] ) throw ( ) { return _wsearchenv_s ( _Filename, _EnvVar, _ResultPath, _Size ); }
#line 828
extern "C" { __declspec(dllimport) void __cdecl _wsearchenv(const __wchar_t * , const __wchar_t * , __wchar_t * ); } 
#line 829
extern "C" { __declspec(dllimport) void __cdecl _wsplitpath(const __wchar_t * , __wchar_t * , __wchar_t * , __wchar_t * , __wchar_t * ); } 
#line 830
extern "C" { __declspec(dllimport) errno_t __cdecl _wsplitpath_s(const __wchar_t * , __wchar_t * , size_t , __wchar_t * , size_t , __wchar_t * , size_t , __wchar_t * , size_t ); } 
#line 835
template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _wsplitpath_s ( const wchar_t * _Path, wchar_t ( & _Drive ) [ _DriveSize ], wchar_t ( & _Dir ) [ _DirSize ], wchar_t ( & _Name ) [ _NameSize ], wchar_t ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _wsplitpath_s ( _Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }
#line 841 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetErrorMode in" "stead. See online help for details.")) __declspec(dllimport) void __cdecl _seterrormode(int ); } 
#line 842
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Beep instead. S" "ee online help for details.")) __declspec(dllimport) void __cdecl _beep(unsigned , unsigned ); } 
#line 843
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Sleep instead. " "See online help for details.")) __declspec(dllimport) void __cdecl _sleep(unsigned long ); } 
#line 862 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 4141)
extern "C" { __declspec(dllimport) char *__cdecl ecvt(double , int , int * , int * ); } 
#line 865
extern "C" { __declspec(dllimport) char *__cdecl fcvt(double , int , int * , int * ); } 
#line 866
extern "C" { __declspec(dllimport) char *__cdecl gcvt(double , int , char * ); } 
#line 867
extern "C" { __declspec(dllimport) char *__cdecl itoa(int , char * , int ); } 
#line 868
extern "C" { __declspec(dllimport) char *__cdecl ltoa(long , char * , int ); } 
#line 869
extern "C" { __declspec(dllimport) int __cdecl putenv(const char * ); } 
#line 870
extern "C" { __declspec(dllimport) void __cdecl swab(char * , char * , int ); } 
#line 871
extern "C" { __declspec(dllimport) char *__cdecl ultoa(unsigned long , char * , int ); } 
#pragma warning(pop)
extern "C" { _onexit_t __cdecl onexit(_onexit_t ); } 
#line 194 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
#pragma detect_mismatch("_MSC_VER", "1600")
#line 199 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\use_ansi.h"
#pragma comment(lib, "msvcprt")
#line 884 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdlib.h"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
#pragma pack ( push, 8 )
#line 535 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
namespace std { 
#line 536
typedef bool _Bool; 
#line 537
}
#line 553 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
typedef __int64 _Longlong; 
#line 554
typedef unsigned __int64 _ULonglong; 
#line 576 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
typedef unsigned short char16_t; 
#line 577
typedef unsigned char32_t; 
#line 591 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
namespace std { 
#line 592
enum _Uninitialized { 
#line 594
_Noinit
#line 595
}; 
#line 599
#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Lockit { 
#line 624 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
public: __thiscall _Lockit(); 
#line 625
explicit __thiscall _Lockit(int); 
#line 626
__thiscall ~_Lockit(); 
#line 629 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
static void __cdecl _Lockit_ctor(int); 
#line 630
static void __cdecl _Lockit_dtor(int); 
#line 633
private: static void __cdecl _Lockit_ctor(_Lockit *); 
#line 634
static void __cdecl _Lockit_ctor(_Lockit *, int); 
#line 635
static void __cdecl _Lockit_dtor(_Lockit *); 
#line 637
_Lockit(const _Lockit &); 
#line 638
_Lockit &operator=(const _Lockit &); 
#line 640
int _Locktype; 
#line 655 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
}; 
#line 742 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
class __declspec(dllimport) _Mutex { 
#line 773 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
public: __thiscall _Mutex(_Uninitialized) 
#line 774
{ 
#line 775
} 
#line 777
__thiscall _Mutex(); 
#line 778
__thiscall ~_Mutex(); 
#line 779
void __thiscall _Lock(); 
#line 780
void __thiscall _Unlock(); 
#line 784 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
private: static void __cdecl _Mutex_ctor(_Mutex *); 
#line 785
static void __cdecl _Mutex_dtor(_Mutex *); 
#line 786
static void __cdecl _Mutex_Lock(_Mutex *); 
#line 787
static void __cdecl _Mutex_Unlock(_Mutex *); 
#line 789
_Mutex(const _Mutex &); 
#line 790
_Mutex &operator=(const _Mutex &); 
#line 791
void *_Mtx; 
#line 802 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
}; 
#line 804
class __declspec(dllimport) _Init_locks { 
#line 820 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
public: __thiscall _Init_locks(); 
#line 821
__thiscall ~_Init_locks(); 
#line 825 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
private: static void __cdecl _Init_locks_ctor(_Init_locks *); 
#line 826
static void __cdecl _Init_locks_dtor(_Init_locks *); 
#line 837 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
}; 
#line 839
#pragma warning(pop)
}
#line 849 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\yvals.h"
__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void)); 
#line 851
typedef int _Mbstatet; 
#line 852
typedef unsigned long _Uint32t; 
#line 860
#pragma pack ( pop )
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cmath"
namespace std { 
#line 19
using ::acosf;using ::asinf;
#line 20
using ::atanf;using ::atan2f;using ::ceilf;
#line 21
using ::cosf;using ::coshf;using ::expf;
#line 22
using ::fabsf;using ::floorf;using ::fmodf;
#line 23
using ::frexpf;using ::ldexpf;using ::logf;
#line 24
using ::log10f;using ::modff;using ::powf;
#line 25
using ::sinf;using ::sinhf;using ::sqrtf;
#line 26
using ::tanf;using ::tanhf;
#line 28
using ::acosl;using ::asinl;
#line 29
using ::atanl;using ::atan2l;using ::ceill;
#line 30
using ::cosl;using ::coshl;using ::expl;
#line 31
using ::fabsl;using ::floorl;using ::fmodl;
#line 32
using ::frexpl;using ::ldexpl;using ::logl;
#line 33
using ::log10l;using ::modfl;using ::powl;
#line 34
using ::sinl;using ::sinhl;using ::sqrtl;
#line 35
using ::tanl;using ::tanhl;
#line 37
using ::abs;
#line 39
using ::acos;using ::asin;
#line 40
using ::atan;using ::atan2;using ::ceil;
#line 41
using ::cos;using ::cosh;using ::exp;
#line 42
using ::fabs;using ::floor;using ::fmod;
#line 43
using ::frexp;using ::ldexp;using ::log;
#line 44
using ::log10;using ::modf;using ::pow;
#line 45
using ::sin;using ::sinh;using ::sqrt;
#line 46
using ::tan;using ::tanh;
#line 47
}
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cstdlib"
namespace std { 
#line 19
using ::size_t;using ::div_t;using ::ldiv_t;
#line 21
using ::abort;using ::abs;using ::atexit;
#line 22
using ::atof;using ::atoi;using ::atol;
#line 23
using ::bsearch;using ::calloc;using ::div;
#line 24
using ::exit;using ::free;using ::getenv;
#line 25
using ::labs;using ::ldiv;using ::malloc;
#line 26
using ::mblen;using ::mbstowcs;using ::mbtowc;
#line 27
using ::qsort;using ::rand;using ::realloc;
#line 28
using ::srand;using ::strtod;using ::strtol;
#line 29
using ::strtoul;using ::system;
#line 30
using ::wcstombs;using ::wctomb;
#line 32
using ::lldiv_t;
#line 34
using ::llabs;using ::lldiv;
#line 35
}
#line 7880 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern double __cdecl _hypot(double , double ); } 
#line 7881
extern "C" { __declspec(dllimport) extern float __cdecl _hypotf(float , float ); } 
#line 7885 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
static __inline int signbit(long double a) 
#line 7886
{ 
#line 7887
return __signbitl(a); 
#line 7888
} 
#line 7901
static __inline int signbit(double a) 
#line 7902
{ 
#line 7903
return __signbit(a); 
#line 7904
} 
#line 7917
static __inline int signbit(float a) 
#line 7918
{ 
#line 7919
return __signbitf(a); 
#line 7920
} 
#line 7922
static __inline int isinf(long double a) 
#line 7923
{ 
#line 7924
return __isinfl(a); 
#line 7925
} 
#line 7938
static __inline int isinf(double a) 
#line 7939
{ 
#line 7940
return __isinf(a); 
#line 7941
} 
#line 7954
static __inline int isinf(float a) 
#line 7955
{ 
#line 7956
return __isinff(a); 
#line 7957
} 
#line 7959
static __inline int isnan(long double a) 
#line 7960
{ 
#line 7961
return __isnanl(a); 
#line 7962
} 
#line 7974
static __inline int isnan(double a) 
#line 7975
{ 
#line 7976
return __isnan(a); 
#line 7977
} 
#line 7989
static __inline int isnan(float a) 
#line 7990
{ 
#line 7991
return __isnanf(a); 
#line 7992
} 
#line 7994
static __inline int isfinite(long double a) 
#line 7995
{ 
#line 7996
return __finitel(a); 
#line 7997
} 
#line 8010
static __inline int isfinite(double a) 
#line 8011
{ 
#line 8012
return __finite(a); 
#line 8013
} 
#line 8026
static __inline int isfinite(float a) 
#line 8027
{ 
#line 8028
return __finitef(a); 
#line 8029
} 
#line 8031
template< class T> extern inline T _Pow_int(T, int); 
#line 8032
extern inline __int64 abs(__int64); 
#line 8048 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
extern inline long __cdecl abs(long); 
#line 8049
extern inline float __cdecl abs(float); 
#line 8050
extern inline double __cdecl abs(double); 
#line 8051
extern inline float __cdecl fabs(float); 
#line 8052
extern inline float __cdecl ceil(float); 
#line 8053
extern inline float __cdecl floor(float); 
#line 8054
extern inline float __cdecl sqrt(float); 
#line 8055
extern inline float __cdecl pow(float, float); 
#line 8056
extern inline float __cdecl pow(float, int); 
#line 8057
extern inline double __cdecl pow(double, int); 
#line 8058
extern inline float __cdecl log(float); 
#line 8059
extern inline float __cdecl log10(float); 
#line 8060
extern inline float __cdecl fmod(float, float); 
#line 8061
extern inline float __cdecl modf(float, float *); 
#line 8062
extern inline float __cdecl exp(float); 
#line 8063
extern inline float __cdecl frexp(float, int *); 
#line 8064
extern inline float __cdecl ldexp(float, int); 
#line 8065
extern inline float __cdecl asin(float); 
#line 8066
extern inline float __cdecl sin(float); 
#line 8067
extern inline float __cdecl sinh(float); 
#line 8068
extern inline float __cdecl acos(float); 
#line 8069
extern inline float __cdecl cos(float); 
#line 8070
extern inline float __cdecl cosh(float); 
#line 8071
extern inline float __cdecl atan(float); 
#line 8072
extern inline float __cdecl atan2(float, float); 
#line 8073
extern inline float __cdecl tan(float); 
#line 8074
extern inline float __cdecl tanh(float); 
#line 8080 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\math_functions.h"
static __inline float logb(float a) 
#line 8081
{ 
#line 8082
return logbf(a); 
#line 8083
} 
#line 8085
static __inline int ilogb(float a) 
#line 8086
{ 
#line 8087
return ilogbf(a); 
#line 8088
} 
#line 8090
static __inline float scalbn(float a, int b) 
#line 8091
{ 
#line 8092
return scalbnf(a, b); 
#line 8093
} 
#line 8095
static __inline float scalbln(float a, long b) 
#line 8096
{ 
#line 8097
return scalblnf(a, b); 
#line 8098
} 
#line 8100
static __inline float exp2(float a) 
#line 8101
{ 
#line 8102
return exp2f(a); 
#line 8103
} 
#line 8105
static __inline float exp10(float a) 
#line 8106
{ 
#line 8107
return exp10f(a); 
#line 8108
} 
#line 8110
static __inline float expm1(float a) 
#line 8111
{ 
#line 8112
return expm1f(a); 
#line 8113
} 
#line 8115
static __inline float log2(float a) 
#line 8116
{ 
#line 8117
return log2f(a); 
#line 8118
} 
#line 8120
static __inline float log1p(float a) 
#line 8121
{ 
#line 8122
return log1pf(a); 
#line 8123
} 
#line 8125
static __inline float rsqrt(float a) 
#line 8126
{ 
#line 8127
return rsqrtf(a); 
#line 8128
} 
#line 8130
static __inline float acosh(float a) 
#line 8131
{ 
#line 8132
return acoshf(a); 
#line 8133
} 
#line 8135
static __inline float asinh(float a) 
#line 8136
{ 
#line 8137
return asinhf(a); 
#line 8138
} 
#line 8140
static __inline float atanh(float a) 
#line 8141
{ 
#line 8142
return atanhf(a); 
#line 8143
} 
#line 8145
static __inline float hypot(float a, float b) 
#line 8146
{ 
#line 8147
return hypotf(a, b); 
#line 8148
} 
#line 8150
static __inline float cbrt(float a) 
#line 8151
{ 
#line 8152
return cbrtf(a); 
#line 8153
} 
#line 8155
static __inline float rcbrt(float a) 
#line 8156
{ 
#line 8157
return rcbrtf(a); 
#line 8158
} 
#line 8160
static __inline float sinpi(float a) 
#line 8161
{ 
#line 8162
return sinpif(a); 
#line 8163
} 
#line 8165
static __inline float cospi(float a) 
#line 8166
{ 
#line 8167
return cospif(a); 
#line 8168
} 
#line 8170
static __inline void sincospi(float a, float *sptr, float *cptr) 
#line 8171
{ 
#line 8172
sincospif(a, sptr, cptr); 
#line 8173
} 
#line 8175
static __inline void sincos(float a, float *sptr, float *cptr) 
#line 8176
{ 
#line 8177
sincosf(a, sptr, cptr); 
#line 8178
} 
#line 8180
static __inline float j0(float a) 
#line 8181
{ 
#line 8182
return j0f(a); 
#line 8183
} 
#line 8185
static __inline float j1(float a) 
#line 8186
{ 
#line 8187
return j1f(a); 
#line 8188
} 
#line 8190
static __inline float jn(int n, float a) 
#line 8191
{ 
#line 8192
return jnf(n, a); 
#line 8193
} 
#line 8195
static __inline float y0(float a) 
#line 8196
{ 
#line 8197
return y0f(a); 
#line 8198
} 
#line 8200
static __inline float y1(float a) 
#line 8201
{ 
#line 8202
return y1f(a); 
#line 8203
} 
#line 8205
static __inline float yn(int n, float a) 
#line 8206
{ 
#line 8207
return ynf(n, a); 
#line 8208
} 
#line 8210
static __inline float cyl_bessel_i0(float a) 
#line 8211
{ 
#line 8212
return cyl_bessel_i0f(a); 
#line 8213
} 
#line 8215
static __inline float cyl_bessel_i1(float a) 
#line 8216
{ 
#line 8217
return cyl_bessel_i1f(a); 
#line 8218
} 
#line 8220
static __inline float erf(float a) 
#line 8221
{ 
#line 8222
return erff(a); 
#line 8223
} 
#line 8225
static __inline float erfinv(float a) 
#line 8226
{ 
#line 8227
return erfinvf(a); 
#line 8228
} 
#line 8230
static __inline float erfc(float a) 
#line 8231
{ 
#line 8232
return erfcf(a); 
#line 8233
} 
#line 8235
static __inline float erfcinv(float a) 
#line 8236
{ 
#line 8237
return erfcinvf(a); 
#line 8238
} 
#line 8240
static __inline float normcdfinv(float a) 
#line 8241
{ 
#line 8242
return normcdfinvf(a); 
#line 8243
} 
#line 8245
static __inline float normcdf(float a) 
#line 8246
{ 
#line 8247
return normcdff(a); 
#line 8248
} 
#line 8250
static __inline float erfcx(float a) 
#line 8251
{ 
#line 8252
return erfcxf(a); 
#line 8253
} 
#line 8255
static __inline float lgamma(float a) 
#line 8256
{ 
#line 8257
return lgammaf(a); 
#line 8258
} 
#line 8260
static __inline float tgamma(float a) 
#line 8261
{ 
#line 8262
return tgammaf(a); 
#line 8263
} 
#line 8265
static __inline float copysign(float a, float b) 
#line 8266
{ 
#line 8267
return copysignf(a, b); 
#line 8268
} 
#line 8270
static __inline double copysign(double a, float b) 
#line 8271
{ 
#line 8272
return copysign(a, (double)b); 
#line 8273
} 
#line 8275
static __inline float copysign(float a, double b) 
#line 8276
{ 
#line 8277
return copysignf(a, (float)b); 
#line 8278
} 
#line 8280
static __inline float nextafter(float a, float b) 
#line 8281
{ 
#line 8282
return nextafterf(a, b); 
#line 8283
} 
#line 8285
static __inline float remainder(float a, float b) 
#line 8286
{ 
#line 8287
return remainderf(a, b); 
#line 8288
} 
#line 8290
static __inline float remquo(float a, float b, int *quo) 
#line 8291
{ 
#line 8292
return remquof(a, b, quo); 
#line 8293
} 
#line 8295
static __inline float round(float a) 
#line 8296
{ 
#line 8297
return roundf(a); 
#line 8298
} 
#line 8300
static __inline long lround(float a) 
#line 8301
{ 
#line 8302
return lroundf(a); 
#line 8303
} 
#line 8305
static __inline __int64 llround(float a) 
#line 8306
{ 
#line 8307
return llroundf(a); 
#line 8308
} 
#line 8310
static __inline float trunc(float a) 
#line 8311
{ 
#line 8312
return truncf(a); 
#line 8313
} 
#line 8315
static __inline float rint(float a) 
#line 8316
{ 
#line 8317
return rintf(a); 
#line 8318
} 
#line 8320
static __inline long lrint(float a) 
#line 8321
{ 
#line 8322
return lrintf(a); 
#line 8323
} 
#line 8325
static __inline __int64 llrint(float a) 
#line 8326
{ 
#line 8327
return llrintf(a); 
#line 8328
} 
#line 8330
static __inline float nearbyint(float a) 
#line 8331
{ 
#line 8332
return nearbyintf(a); 
#line 8333
} 
#line 8335
static __inline float fdim(float a, float b) 
#line 8336
{ 
#line 8337
return fdimf(a, b); 
#line 8338
} 
#line 8340
static __inline float fma(float a, float b, float c) 
#line 8341
{ 
#line 8342
return fmaf(a, b, c); 
#line 8343
} 
#line 8345
static __inline float fmax(float a, float b) 
#line 8346
{ 
#line 8347
return fmaxf(a, b); 
#line 8348
} 
#line 8350
static __inline float fmin(float a, float b) 
#line 8351
{ 
#line 8352
return fminf(a, b); 
#line 8353
} 
#line 8355
static __inline unsigned min(unsigned a, unsigned b) 
#line 8356
{ 
#line 8357
return umin(a, b); 
#line 8358
} 
#line 8360
static __inline unsigned min(int a, unsigned b) 
#line 8361
{ 
#line 8362
return umin((unsigned)a, b); 
#line 8363
} 
#line 8365
static __inline unsigned min(unsigned a, int b) 
#line 8366
{ 
#line 8367
return umin(a, (unsigned)b); 
#line 8368
} 
#line 8370
static __inline __int64 min(__int64 a, __int64 b) 
#line 8371
{ 
#line 8372
return llmin(a, b); 
#line 8373
} 
#line 8375
static __inline unsigned __int64 min(unsigned __int64 a, unsigned __int64 b) 
#line 8376
{ 
#line 8377
return ullmin(a, b); 
#line 8378
} 
#line 8380
static __inline unsigned __int64 min(__int64 a, unsigned __int64 b) 
#line 8381
{ 
#line 8382
return ullmin((unsigned __int64)a, b); 
#line 8383
} 
#line 8385
static __inline unsigned __int64 min(unsigned __int64 a, __int64 b) 
#line 8386
{ 
#line 8387
return ullmin(a, (unsigned __int64)b); 
#line 8388
} 
#line 8390
static __inline float min(float a, float b) 
#line 8391
{ 
#line 8392
return fminf(a, b); 
#line 8393
} 
#line 8395
static __inline double min(double a, double b) 
#line 8396
{ 
#line 8397
return fmin(a, b); 
#line 8398
} 
#line 8400
static __inline double min(float a, double b) 
#line 8401
{ 
#line 8402
return fmin((double)a, b); 
#line 8403
} 
#line 8405
static __inline double min(double a, float b) 
#line 8406
{ 
#line 8407
return fmin(a, (double)b); 
#line 8408
} 
#line 8410
static __inline unsigned max(unsigned a, unsigned b) 
#line 8411
{ 
#line 8412
return umax(a, b); 
#line 8413
} 
#line 8415
static __inline unsigned max(int a, unsigned b) 
#line 8416
{ 
#line 8417
return umax((unsigned)a, b); 
#line 8418
} 
#line 8420
static __inline unsigned max(unsigned a, int b) 
#line 8421
{ 
#line 8422
return umax(a, (unsigned)b); 
#line 8423
} 
#line 8425
static __inline __int64 max(__int64 a, __int64 b) 
#line 8426
{ 
#line 8427
return llmax(a, b); 
#line 8428
} 
#line 8430
static __inline unsigned __int64 max(unsigned __int64 a, unsigned __int64 b) 
#line 8431
{ 
#line 8432
return ullmax(a, b); 
#line 8433
} 
#line 8435
static __inline unsigned __int64 max(__int64 a, unsigned __int64 b) 
#line 8436
{ 
#line 8437
return ullmax((unsigned __int64)a, b); 
#line 8438
} 
#line 8440
static __inline unsigned __int64 max(unsigned __int64 a, __int64 b) 
#line 8441
{ 
#line 8442
return ullmax(a, (unsigned __int64)b); 
#line 8443
} 
#line 8445
static __inline float max(float a, float b) 
#line 8446
{ 
#line 8447
return fmaxf(a, b); 
#line 8448
} 
#line 8450
static __inline double max(double a, double b) 
#line 8451
{ 
#line 8452
return fmax(a, b); 
#line 8453
} 
#line 8455
static __inline double max(float a, double b) 
#line 8456
{ 
#line 8457
return fmax((double)a, b); 
#line 8458
} 
#line 8460
static __inline double max(double a, float b) 
#line 8461
{ 
#line 8462
return fmax(a, (double)b); 
#line 8463
} 
#line 73 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\cuda_surface_types.h"
template< class T, int dim = 1> 
#line 74
struct surface : public surfaceReference { 
#line 76
surface() 
#line 77
{ 
#line 78
(channelDesc) = cudaCreateChannelDesc< T> (); 
#line 79
} 
#line 81
surface(::cudaChannelFormatDesc desc) 
#line 82
{ 
#line 83
(channelDesc) = desc; 
#line 84
} 
#line 85
}; 
#line 87
template< int dim> 
#line 88
struct surface< void, dim>  : public surfaceReference { 
#line 90
surface() 
#line 91
{ 
#line 92
(channelDesc) = cudaCreateChannelDesc< void> (); 
#line 93
} 
#line 94
}; 
#line 73 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\cuda_texture_types.h"
template< class T, int texType = 1, cudaTextureReadMode mode = cudaReadModeElementType> 
#line 74
struct texture : public textureReference { 
#line 76
texture(int norm = 0, ::cudaTextureFilterMode 
#line 77
fMode = cudaFilterModePoint, ::cudaTextureAddressMode 
#line 78
aMode = cudaAddressModeClamp) 
#line 79
{ 
#line 80
(normalized) = norm; 
#line 81
(filterMode) = fMode; 
#line 82
((addressMode)[0]) = aMode; 
#line 83
((addressMode)[1]) = aMode; 
#line 84
((addressMode)[2]) = aMode; 
#line 85
(channelDesc) = cudaCreateChannelDesc< T> (); 
#line 86
(sRGB) = 0; 
#line 87
} 
#line 89
texture(int norm, ::cudaTextureFilterMode 
#line 90
fMode, ::cudaTextureAddressMode 
#line 91
aMode, ::cudaChannelFormatDesc 
#line 92
desc) 
#line 93
{ 
#line 94
(normalized) = norm; 
#line 95
(filterMode) = fMode; 
#line 96
((addressMode)[0]) = aMode; 
#line 97
((addressMode)[1]) = aMode; 
#line 98
((addressMode)[2]) = aMode; 
#line 99
(channelDesc) = desc; 
#line 100
(sRGB) = 0; 
#line 101
} 
#line 102
}; 
#line 3194 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline int mulhi(int a, int b) 
#line 3195
{int volatile ___ = 1;(void)a;(void)b;
#line 3197
::exit(___);}
#if 0
#line 3195
{ 
#line 3196
return __mulhi(a, b); 
#line 3197
} 
#endif
#line 3199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline unsigned mulhi(unsigned a, unsigned b) 
#line 3200
{int volatile ___ = 1;(void)a;(void)b;
#line 3202
::exit(___);}
#if 0
#line 3200
{ 
#line 3201
return __umulhi(a, b); 
#line 3202
} 
#endif
#line 3204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline unsigned mulhi(int a, unsigned b) 
#line 3205
{int volatile ___ = 1;(void)a;(void)b;
#line 3207
::exit(___);}
#if 0
#line 3205
{ 
#line 3206
return __umulhi((unsigned)a, b); 
#line 3207
} 
#endif
#line 3209 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline unsigned mulhi(unsigned a, int b) 
#line 3210
{int volatile ___ = 1;(void)a;(void)b;
#line 3212
::exit(___);}
#if 0
#line 3210
{ 
#line 3211
return __umulhi(a, (unsigned)b); 
#line 3212
} 
#endif
#line 3214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline __int64 mul64hi(__int64 a, __int64 b) 
#line 3215
{int volatile ___ = 1;(void)a;(void)b;
#line 3217
::exit(___);}
#if 0
#line 3215
{ 
#line 3216
return __mul64hi(a, b); 
#line 3217
} 
#endif
#line 3219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline unsigned __int64 mul64hi(unsigned __int64 a, unsigned __int64 b) 
#line 3220
{int volatile ___ = 1;(void)a;(void)b;
#line 3222
::exit(___);}
#if 0
#line 3220
{ 
#line 3221
return __umul64hi(a, b); 
#line 3222
} 
#endif
#line 3224 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline unsigned __int64 mul64hi(__int64 a, unsigned __int64 b) 
#line 3225
{int volatile ___ = 1;(void)a;(void)b;
#line 3227
::exit(___);}
#if 0
#line 3225
{ 
#line 3226
return __umul64hi((unsigned __int64)a, b); 
#line 3227
} 
#endif
#line 3229 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline unsigned __int64 mul64hi(unsigned __int64 a, __int64 b) 
#line 3230
{int volatile ___ = 1;(void)a;(void)b;
#line 3232
::exit(___);}
#if 0
#line 3230
{ 
#line 3231
return __umul64hi(a, (unsigned __int64)b); 
#line 3232
} 
#endif
#line 3234 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline int float_as_int(float a) 
#line 3235
{int volatile ___ = 1;(void)a;
#line 3237
::exit(___);}
#if 0
#line 3235
{ 
#line 3236
return __float_as_int(a); 
#line 3237
} 
#endif
#line 3239 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline float int_as_float(int a) 
#line 3240
{int volatile ___ = 1;(void)a;
#line 3242
::exit(___);}
#if 0
#line 3240
{ 
#line 3241
return __int_as_float(a); 
#line 3242
} 
#endif
#line 3244 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline float saturate(float a) 
#line 3245
{int volatile ___ = 1;(void)a;
#line 3247
::exit(___);}
#if 0
#line 3245
{ 
#line 3246
return __saturatef(a); 
#line 3247
} 
#endif
#line 3249 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline int mul24(int a, int b) 
#line 3250
{int volatile ___ = 1;(void)a;(void)b;
#line 3252
::exit(___);}
#if 0
#line 3250
{ 
#line 3251
return __mul24(a, b); 
#line 3252
} 
#endif
#line 3254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline unsigned umul24(unsigned a, unsigned b) 
#line 3255
{int volatile ___ = 1;(void)a;(void)b;
#line 3257
::exit(___);}
#if 0
#line 3255
{ 
#line 3256
return __umul24(a, b); 
#line 3257
} 
#endif
#line 3259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline void trap() 
#line 3260
{int volatile ___ = 1;
#line 3262
::exit(___);}
#if 0
#line 3260
{ 
#line 3261
__trap(); 
#line 3262
} 
#endif
#line 3265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline void brkpt(int c = 0) 
#line 3266
{int volatile ___ = 1;(void)c;
#line 3268
::exit(___);}
#if 0
#line 3266
{ 
#line 3267
__brkpt(c); 
#line 3268
} 
#endif
#line 3270 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline void syncthreads() 
#line 3271
{int volatile ___ = 1;
#line 3273
::exit(___);}
#if 0
#line 3271
{ 
#line 3272
__syncthreads(); 
#line 3273
} 
#endif
#line 3275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline void prof_trigger(int e) 
#line 3276
{int volatile ___ = 1;(void)e;
#line 3293
::exit(___);}
#if 0
#line 3276
{ 
#line 3277
if (e == 0) { __prof_trigger(0); } else { 
#line 3278
if (e == 1) { __prof_trigger(1); } else { 
#line 3279
if (e == 2) { __prof_trigger(2); } else { 
#line 3280
if (e == 3) { __prof_trigger(3); } else { 
#line 3281
if (e == 4) { __prof_trigger(4); } else { 
#line 3282
if (e == 5) { __prof_trigger(5); } else { 
#line 3283
if (e == 6) { __prof_trigger(6); } else { 
#line 3284
if (e == 7) { __prof_trigger(7); } else { 
#line 3285
if (e == 8) { __prof_trigger(8); } else { 
#line 3286
if (e == 9) { __prof_trigger(9); } else { 
#line 3287
if (e == 10) { __prof_trigger(10); } else { 
#line 3288
if (e == 11) { __prof_trigger(11); } else { 
#line 3289
if (e == 12) { __prof_trigger(12); } else { 
#line 3290
if (e == 13) { __prof_trigger(13); } else { 
#line 3291
if (e == 14) { __prof_trigger(14); } else { 
#line 3292
if (e == 15) { __prof_trigger(15); }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  
#line 3293
} 
#endif
#line 3295 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline void threadfence(bool global = true) 
#line 3296
{int volatile ___ = 1;(void)global;
#line 3298
::exit(___);}
#if 0
#line 3296
{ 
#line 3297
global ? __threadfence() : __threadfence_block(); 
#line 3298
} 
#endif
#line 3300 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline int float2int(float a, cudaRoundMode mode = cudaRoundZero) 
#line 3301
{int volatile ___ = 1;(void)a;(void)mode;
#line 3306
::exit(___);}
#if 0
#line 3301
{ 
#line 3302
return (mode == (cudaRoundNearest)) ? __float2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2int_rd(a) : __float2int_rz(a))); 
#line 3306
} 
#endif
#line 3308 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline unsigned float2uint(float a, cudaRoundMode mode = cudaRoundZero) 
#line 3309
{int volatile ___ = 1;(void)a;(void)mode;
#line 3314
::exit(___);}
#if 0
#line 3309
{ 
#line 3310
return (mode == (cudaRoundNearest)) ? __float2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2uint_rd(a) : __float2uint_rz(a))); 
#line 3314
} 
#endif
#line 3316 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline float int2float(int a, cudaRoundMode mode = cudaRoundNearest) 
#line 3317
{int volatile ___ = 1;(void)a;(void)mode;
#line 3322
::exit(___);}
#if 0
#line 3317
{ 
#line 3318
return (mode == (cudaRoundZero)) ? __int2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __int2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __int2float_rd(a) : __int2float_rn(a))); 
#line 3322
} 
#endif
#line 3324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_functions.h"
static __inline float uint2float(unsigned a, cudaRoundMode mode = cudaRoundNearest) 
#line 3325
{int volatile ___ = 1;(void)a;(void)mode;
#line 3330
::exit(___);}
#if 0
#line 3325
{ 
#line 3326
return (mode == (cudaRoundZero)) ? __uint2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __uint2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __uint2float_rd(a) : __uint2float_rn(a))); 
#line 3330
} 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline int atomicAdd(int *address, int val) 
#line 97
{int volatile ___ = 1;(void)address;(void)val;
#line 99
::exit(___);}
#if 0
#line 97
{ 
#line 98
return __iAtomicAdd(address, val); 
#line 99
} 
#endif
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicAdd(unsigned *address, unsigned val) 
#line 102
{int volatile ___ = 1;(void)address;(void)val;
#line 104
::exit(___);}
#if 0
#line 102
{ 
#line 103
return __uAtomicAdd(address, val); 
#line 104
} 
#endif
#line 106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline int atomicSub(int *address, int val) 
#line 107
{int volatile ___ = 1;(void)address;(void)val;
#line 109
::exit(___);}
#if 0
#line 107
{ 
#line 108
return __iAtomicAdd(address, (unsigned)(-val)); 
#line 109
} 
#endif
#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicSub(unsigned *address, unsigned val) 
#line 112
{int volatile ___ = 1;(void)address;(void)val;
#line 114
::exit(___);}
#if 0
#line 112
{ 
#line 113
return __uAtomicAdd(address, (unsigned)(-((int)val))); 
#line 114
} 
#endif
#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline int atomicExch(int *address, int val) 
#line 117
{int volatile ___ = 1;(void)address;(void)val;
#line 119
::exit(___);}
#if 0
#line 117
{ 
#line 118
return __iAtomicExch(address, val); 
#line 119
} 
#endif
#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicExch(unsigned *address, unsigned val) 
#line 122
{int volatile ___ = 1;(void)address;(void)val;
#line 124
::exit(___);}
#if 0
#line 122
{ 
#line 123
return __uAtomicExch(address, val); 
#line 124
} 
#endif
#line 126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline float atomicExch(float *address, float val) 
#line 127
{int volatile ___ = 1;(void)address;(void)val;
#line 129
::exit(___);}
#if 0
#line 127
{ 
#line 128
return __fAtomicExch(address, val); 
#line 129
} 
#endif
#line 131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline int atomicMin(int *address, int val) 
#line 132
{int volatile ___ = 1;(void)address;(void)val;
#line 134
::exit(___);}
#if 0
#line 132
{ 
#line 133
return __iAtomicMin(address, val); 
#line 134
} 
#endif
#line 136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicMin(unsigned *address, unsigned val) 
#line 137
{int volatile ___ = 1;(void)address;(void)val;
#line 139
::exit(___);}
#if 0
#line 137
{ 
#line 138
return __uAtomicMin(address, val); 
#line 139
} 
#endif
#line 141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline int atomicMax(int *address, int val) 
#line 142
{int volatile ___ = 1;(void)address;(void)val;
#line 144
::exit(___);}
#if 0
#line 142
{ 
#line 143
return __iAtomicMax(address, val); 
#line 144
} 
#endif
#line 146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicMax(unsigned *address, unsigned val) 
#line 147
{int volatile ___ = 1;(void)address;(void)val;
#line 149
::exit(___);}
#if 0
#line 147
{ 
#line 148
return __uAtomicMax(address, val); 
#line 149
} 
#endif
#line 151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicInc(unsigned *address, unsigned val) 
#line 152
{int volatile ___ = 1;(void)address;(void)val;
#line 154
::exit(___);}
#if 0
#line 152
{ 
#line 153
return __uAtomicInc(address, val); 
#line 154
} 
#endif
#line 156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicDec(unsigned *address, unsigned val) 
#line 157
{int volatile ___ = 1;(void)address;(void)val;
#line 159
::exit(___);}
#if 0
#line 157
{ 
#line 158
return __uAtomicDec(address, val); 
#line 159
} 
#endif
#line 161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline int atomicAnd(int *address, int val) 
#line 162
{int volatile ___ = 1;(void)address;(void)val;
#line 164
::exit(___);}
#if 0
#line 162
{ 
#line 163
return __iAtomicAnd(address, val); 
#line 164
} 
#endif
#line 166 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicAnd(unsigned *address, unsigned val) 
#line 167
{int volatile ___ = 1;(void)address;(void)val;
#line 169
::exit(___);}
#if 0
#line 167
{ 
#line 168
return __uAtomicAnd(address, val); 
#line 169
} 
#endif
#line 171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline int atomicOr(int *address, int val) 
#line 172
{int volatile ___ = 1;(void)address;(void)val;
#line 174
::exit(___);}
#if 0
#line 172
{ 
#line 173
return __iAtomicOr(address, val); 
#line 174
} 
#endif
#line 176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicOr(unsigned *address, unsigned val) 
#line 177
{int volatile ___ = 1;(void)address;(void)val;
#line 179
::exit(___);}
#if 0
#line 177
{ 
#line 178
return __uAtomicOr(address, val); 
#line 179
} 
#endif
#line 181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline int atomicXor(int *address, int val) 
#line 182
{int volatile ___ = 1;(void)address;(void)val;
#line 184
::exit(___);}
#if 0
#line 182
{ 
#line 183
return __iAtomicXor(address, val); 
#line 184
} 
#endif
#line 186 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicXor(unsigned *address, unsigned val) 
#line 187
{int volatile ___ = 1;(void)address;(void)val;
#line 189
::exit(___);}
#if 0
#line 187
{ 
#line 188
return __uAtomicXor(address, val); 
#line 189
} 
#endif
#line 191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline int atomicCAS(int *address, int compare, int val) 
#line 192
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
#line 194
::exit(___);}
#if 0
#line 192
{ 
#line 193
return __iAtomicCAS(address, compare, val); 
#line 194
} 
#endif
#line 196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_11_atomic_functions.h"
static __inline unsigned atomicCAS(unsigned *address, unsigned compare, unsigned val) 
#line 197
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
#line 199
::exit(___);}
#if 0
#line 197
{ 
#line 198
return __uAtomicCAS(address, compare, val); 
#line 199
} 
#endif
#line 81 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_12_atomic_functions.h"
static __inline unsigned __int64 atomicAdd(unsigned __int64 *address, unsigned __int64 val) 
#line 82
{int volatile ___ = 1;(void)address;(void)val;
#line 84
::exit(___);}
#if 0
#line 82
{ 
#line 83
return __ullAtomicAdd(address, val); 
#line 84
} 
#endif
#line 86 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_12_atomic_functions.h"
static __inline unsigned __int64 atomicExch(unsigned __int64 *address, unsigned __int64 val) 
#line 87
{int volatile ___ = 1;(void)address;(void)val;
#line 89
::exit(___);}
#if 0
#line 87
{ 
#line 88
return __ullAtomicExch(address, val); 
#line 89
} 
#endif
#line 91 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_12_atomic_functions.h"
static __inline unsigned __int64 atomicCAS(unsigned __int64 *address, unsigned __int64 compare, unsigned __int64 val) 
#line 92
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
#line 94
::exit(___);}
#if 0
#line 92
{ 
#line 93
return __ullAtomicCAS(address, compare, val); 
#line 94
} 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_12_atomic_functions.h"
static __inline bool any(bool cond) 
#line 97
{int volatile ___ = 1;(void)cond;
#line 99
::exit(___);}
#if 0
#line 97
{ 
#line 98
return (bool)__any((int)cond); 
#line 99
} 
#endif
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_12_atomic_functions.h"
static __inline bool all(bool cond) 
#line 102
{int volatile ___ = 1;(void)cond;
#line 104
::exit(___);}
#if 0
#line 102
{ 
#line 103
return (bool)__all((int)cond); 
#line 104
} 
#endif
#line 1133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_13_double_functions.h"
static __inline double fma(double a, double b, double c, cudaRoundMode mode) 
#line 1134
{int volatile ___ = 1;(void)a;(void)b;(void)c;(void)mode;
#line 1139
::exit(___);}
#if 0
#line 1134
{ 
#line 1135
return (mode == (cudaRoundZero)) ? __fma_rz(a, b, c) : ((mode == (cudaRoundPosInf)) ? __fma_ru(a, b, c) : ((mode == (cudaRoundMinInf)) ? __fma_rd(a, b, c) : __fma_rn(a, b, c))); 
#line 1139
} 
#endif
#line 1141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_13_double_functions.h"
static __inline double dmul(double a, double b, cudaRoundMode mode = cudaRoundNearest) 
#line 1142
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
#line 1147
::exit(___);}
#if 0
#line 1142
{ 
#line 1143
return (mode == (cudaRoundZero)) ? __dmul_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dmul_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dmul_rd(a, b) : __dmul_rn(a, b))); 
#line 1147
} 
#endif
#line 1149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_13_double_functions.h"
static __inline double dadd(double a, double b, cudaRoundMode mode = cudaRoundNearest) 
#line 1150
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
#line 1155
::exit(___);}
#if 0
#line 1150
{ 
#line 1151
return (mode == (cudaRoundZero)) ? __dadd_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dadd_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dadd_rd(a, b) : __dadd_rn(a, b))); 
#line 1155
} 
#endif
#line 1157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_13_double_functions.h"
static __inline double dsub(double a, double b, cudaRoundMode mode = cudaRoundNearest) 
#line 1158
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
#line 1163
::exit(___);}
#if 0
#line 1158
{ 
#line 1159
return (mode == (cudaRoundZero)) ? __dsub_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dsub_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dsub_rd(a, b) : __dsub_rn(a, b))); 
#line 1163
} 
#endif
#line 1165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_13_double_functions.h"
static __inline int double2int(double a, cudaRoundMode mode = cudaRoundZero) 
#line 1166
{int volatile ___ = 1;(void)a;(void)mode;
#line 1171
::exit(___);}
#if 0
#line 1166
{ 
#line 1167
return (mode == (cudaRoundNearest)) ? __double2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2int_rd(a) : __double2int_rz(a))); 
#line 1171
} 
#endif
#line 1173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_13_double_functions.h"
static __inline unsigned double2uint(double a, cudaRoundMode mode = cudaRoundZero) 
#line 1174
{int volatile ___ = 1;(void)a;(void)mode;
#line 1179
::exit(___);}
#if 0
#line 1174
{ 
#line 1175
return (mode == (cudaRoundNearest)) ? __double2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2uint_rd(a) : __double2uint_rz(a))); 
#line 1179
} 
#endif
#line 1181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_13_double_functions.h"
static __inline __int64 double2ll(double a, cudaRoundMode mode = cudaRoundZero) 
#line 1182
{int volatile ___ = 1;(void)a;(void)mode;
#line 1187
::exit(___);}
#if 0
#line 1182
{ 
#line 1183
return (mode == (cudaRoundNearest)) ? __double2ll_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ll_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ll_rd(a) : __double2ll_rz(a))); 
#line 1187
} 
#endif
#line 1189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_13_double_functions.h"
static __inline unsigned __int64 double2ull(double a, cudaRoundMode mode = cudaRoundZero) 
#line 1190
{int volatile ___ = 1;(void)a;(void)mode;
#line 1195
::exit(___);}
#if 0
#line 1190
{ 
#line 1191
return (mode == (cudaRoundNearest)) ? __double2ull_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ull_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ull_rd(a) : __double2ull_rz(a))); 
#line 1195
} 
#endif
#line 1197 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_13_double_functions.h"
static __inline double ll2double(__int64 a, cudaRoundMode mode = cudaRoundNearest) 
#line 1198
{int volatile ___ = 1;(void)a;(void)mode;
#line 1203
::exit(___);}
#if 0
#line 1198
{ 
#line 1199
return (mode == (cudaRoundZero)) ? __ll2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ll2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ll2double_rd(a) : __ll2double_rn(a))); 
#line 1203
} 
#endif
#line 1205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_13_double_functions.h"
static __inline double ull2double(unsigned __int64 a, cudaRoundMode mode = cudaRoundNearest) 
#line 1206
{int volatile ___ = 1;(void)a;(void)mode;
#line 1211
::exit(___);}
#if 0
#line 1206
{ 
#line 1207
return (mode == (cudaRoundZero)) ? __ull2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ull2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ull2double_rd(a) : __ull2double_rn(a))); 
#line 1211
} 
#endif
#line 1213 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_13_double_functions.h"
static __inline double int2double(int a, cudaRoundMode mode = cudaRoundNearest) 
#line 1214
{int volatile ___ = 1;(void)a;(void)mode;
#line 1216
::exit(___);}
#if 0
#line 1214
{ 
#line 1215
return (double)a; 
#line 1216
} 
#endif
#line 1218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_13_double_functions.h"
static __inline double uint2double(unsigned a, cudaRoundMode mode = cudaRoundNearest) 
#line 1219
{int volatile ___ = 1;(void)a;(void)mode;
#line 1221
::exit(___);}
#if 0
#line 1219
{ 
#line 1220
return (double)a; 
#line 1221
} 
#endif
#line 1223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_13_double_functions.h"
static __inline double float2double(float a, cudaRoundMode mode = cudaRoundNearest) 
#line 1224
{int volatile ___ = 1;(void)a;(void)mode;
#line 1226
::exit(___);}
#if 0
#line 1224
{ 
#line 1225
return (double)a; 
#line 1226
} 
#endif
#line 77 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_20_atomic_functions.h"
static __inline float atomicAdd(float *address, float val) 
#line 78
{int volatile ___ = 1;(void)address;(void)val;
#line 80
::exit(___);}
#if 0
#line 78
{ 
#line 79
return __fAtomicAdd(address, val); 
#line 80
} 
#endif
#line 83 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicMin(__int64 *address, __int64 val) 
#line 84
{int volatile ___ = 1;(void)address;(void)val;
#line 86
::exit(___);}
#if 0
#line 84
{ 
#line 85
return __illAtomicMin(address, val); 
#line 86
} 
#endif
#line 88 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicMax(__int64 *address, __int64 val) 
#line 89
{int volatile ___ = 1;(void)address;(void)val;
#line 91
::exit(___);}
#if 0
#line 89
{ 
#line 90
return __illAtomicMax(address, val); 
#line 91
} 
#endif
#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicMin(unsigned __int64 *address, unsigned __int64 val) 
#line 94
{int volatile ___ = 1;(void)address;(void)val;
#line 96
::exit(___);}
#if 0
#line 94
{ 
#line 95
return __ullAtomicMin(address, val); 
#line 96
} 
#endif
#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicMax(unsigned __int64 *address, unsigned __int64 val) 
#line 99
{int volatile ___ = 1;(void)address;(void)val;
#line 101
::exit(___);}
#if 0
#line 99
{ 
#line 100
return __ullAtomicMax(address, val); 
#line 101
} 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicAnd(unsigned __int64 *address, unsigned __int64 val) 
#line 104
{int volatile ___ = 1;(void)address;(void)val;
#line 106
::exit(___);}
#if 0
#line 104
{ 
#line 105
return __ullAtomicAnd(address, val); 
#line 106
} 
#endif
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicOr(unsigned __int64 *address, unsigned __int64 val) 
#line 109
{int volatile ___ = 1;(void)address;(void)val;
#line 111
::exit(___);}
#if 0
#line 109
{ 
#line 110
return __ullAtomicOr(address, val); 
#line 111
} 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicXor(unsigned __int64 *address, unsigned __int64 val) 
#line 114
{int volatile ___ = 1;(void)address;(void)val;
#line 116
::exit(___);}
#if 0
#line 114
{ 
#line 115
return __ullAtomicXor(address, val); 
#line 116
} 
#endif
#line 407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_20_intrinsics.h"
static __inline unsigned ballot(bool pred) 
#line 408
{int volatile ___ = 1;(void)pred;
#line 410
::exit(___);}
#if 0
#line 408
{ 
#line 409
return __ballot((int)pred); 
#line 410
} 
#endif
#line 412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_20_intrinsics.h"
static __inline int syncthreads_count(bool pred) 
#line 413
{int volatile ___ = 1;(void)pred;
#line 415
::exit(___);}
#if 0
#line 413
{ 
#line 414
return __syncthreads_count((int)pred); 
#line 415
} 
#endif
#line 417 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_20_intrinsics.h"
static __inline bool syncthreads_and(bool pred) 
#line 418
{int volatile ___ = 1;(void)pred;
#line 420
::exit(___);}
#if 0
#line 418
{ 
#line 419
return (bool)__syncthreads_and((int)pred); 
#line 420
} 
#endif
#line 422 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_20_intrinsics.h"
static __inline bool syncthreads_or(bool pred) 
#line 423
{int volatile ___ = 1;(void)pred;
#line 425
::exit(___);}
#if 0
#line 423
{ 
#line 424
return (bool)__syncthreads_or((int)pred); 
#line 425
} 
#endif
#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_20_intrinsics.h"
static __inline unsigned __isGlobal(const void *ptr) 
#line 431
{int volatile ___ = 1;(void)ptr;
#line 444 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_20_intrinsics.h"
::exit(___);}
#if 0
#line 431 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_20_intrinsics.h"
{ 
#line 432
unsigned ret; 
#line 433
__asm { 
	    .reg .pred p; 
	    isspacep.global p, %1; 
	    selp.u32 %0, 1, 0, p;  
	} 
	
#line 443 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_20_intrinsics.h"
return ret; 
#line 444
} 
#endif
#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_30_intrinsics.h"
static __inline int __shfl(int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
#line 98
::exit(___);}
#if 0
#line 93
{ 
#line 94
int ret, c; 
#line 95
c = (((32 - width) << 8) | 31); 
#line 96
__asm shfl.idx.b32 %0, %1, %2, %3;
return ret; 
#line 98
} 
#endif
#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_30_intrinsics.h"
static __inline int __shfl_up(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 105
::exit(___);}
#if 0
#line 100
{ 
#line 101
int ret, c; 
#line 102
c = ((32 - width) << 8); 
#line 103
__asm shfl.up.b32 %0, %1, %2, %3;
return ret; 
#line 105
} 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_30_intrinsics.h"
static __inline int __shfl_down(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 112
::exit(___);}
#if 0
#line 107
{ 
#line 108
int ret, c; 
#line 109
c = (((32 - width) << 8) | 31); 
#line 110
__asm shfl.down.b32 %0, %1, %2, %3;
return ret; 
#line 112
} 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_30_intrinsics.h"
static __inline int __shfl_xor(int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
#line 119
::exit(___);}
#if 0
#line 114
{ 
#line 115
int ret, c; 
#line 116
c = (((32 - width) << 8) | 31); 
#line 117
__asm shfl.bfly.b32 %0, %1, %2, %3;
return ret; 
#line 119
} 
#endif
#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_30_intrinsics.h"
static __inline float __shfl(float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
#line 127
::exit(___);}
#if 0
#line 121
{ 
#line 122
float ret; 
#line 123
int c; 
#line 124
c = (((32 - width) << 8) | 31); 
#line 125
__asm shfl.idx.b32 %0, %1, %2, %3;
return ret; 
#line 127
} 
#endif
#line 129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_30_intrinsics.h"
static __inline float __shfl_up(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 135
::exit(___);}
#if 0
#line 129
{ 
#line 130
float ret; 
#line 131
int c; 
#line 132
c = ((32 - width) << 8); 
#line 133
__asm shfl.up.b32 %0, %1, %2, %3;
return ret; 
#line 135
} 
#endif
#line 137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_30_intrinsics.h"
static __inline float __shfl_down(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 143
::exit(___);}
#if 0
#line 137
{ 
#line 138
float ret; 
#line 139
int c; 
#line 140
c = (((32 - width) << 8) | 31); 
#line 141
__asm shfl.down.b32 %0, %1, %2, %3;
return ret; 
#line 143
} 
#endif
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_30_intrinsics.h"
static __inline float __shfl_xor(float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
#line 151
::exit(___);}
#if 0
#line 145
{ 
#line 146
float ret; 
#line 147
int c; 
#line 148
c = (((32 - width) << 8) | 31); 
#line 149
__asm shfl.bfly.b32 %0, %1, %2, %3;
return ret; 
#line 151
} 
#endif
#line 91 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline char __ldg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 91
{ unsigned ret; __asm ld.global.nc.s8 %0, [%1];
#line 91
return (char)ret; } 
#endif
#line 92 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline short __ldg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 92
{ unsigned short ret; __asm ld.global.nc.s16 %0, [%1];
#line 92
return (short)ret; } 
#endif
#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline int __ldg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 93
{ unsigned ret; __asm ld.global.nc.s32 %0, [%1];
#line 93
return (int)ret; } 
#endif
#line 94 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldg(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 94
{ unsigned __int64 ret; __asm ld.global.nc.s64 %0, [%1];
#line 94
return (__int64)ret; } 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline char2 __ldg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 95
{ char2 ret; int2 tmp; __asm ld.global.nc.v2.s8 {%0,%1}, [%2];
#line 95
(ret.x) = ((char)(tmp.x)); (ret.y) = ((char)(tmp.y)); return ret; } 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline char4 __ldg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 96
{ char4 ret; int4 tmp; __asm ld.global.nc.v4.s8 {%0,%1,%2,%3}, [%4];
#line 96
(ret.x) = ((char)(tmp.x)); (ret.y) = ((char)(tmp.y)); (ret.z) = ((char)(tmp.z)); (ret.w) = ((char)(tmp.w)); return ret; } 
#endif
#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline short2 __ldg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 97
{ short2 ret; __asm ld.global.nc.v2.s16 {%0,%1}, [%2];
#line 97
return ret; } 
#endif
#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline short4 __ldg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 98
{ short4 ret; __asm ld.global.nc.v4.s16 {%0,%1,%2,%3}, [%4];
#line 98
return ret; } 
#endif
#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline int2 __ldg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 99
{ int2 ret; __asm ld.global.nc.v2.s32 {%0,%1}, [%2];
#line 99
return ret; } 
#endif
#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline int4 __ldg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 100
{ int4 ret; __asm ld.global.nc.v4.s32 {%0,%1,%2,%3}, [%4];
#line 100
return ret; } 
#endif
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 101
{ longlong2 ret; __asm ld.global.nc.v2.s64 %0, [%1];
#line 101
return ret; } 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 103
{ unsigned ret; __asm ld.global.nc.u8 %0, [%1];
#line 103
return (unsigned char)ret; } 
#endif
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 104
{ unsigned short ret; __asm ld.global.nc.u16 %0, [%1];
#line 104
return ret; } 
#endif
#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 105
{ unsigned ret; __asm ld.global.nc.u32 %0, [%1];
#line 105
return ret; } 
#endif
#line 106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldg(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 106
{ unsigned __int64 ret; __asm ld.global.nc.u64 %0, [%1];
#line 106
return ret; } 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 107
{ uchar2 ret; uint2 tmp; __asm ld.global.nc.v2.u8 {%0,%1}, [%2];
#line 107
(ret.x) = ((unsigned char)(tmp.x)); (ret.y) = ((unsigned char)(tmp.y)); return ret; } 
#endif
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 108
{ uchar4 ret; uint4 tmp; __asm ld.global.nc.v4.u8 {%0,%1,%2,%3}, [%4];
#line 108
(ret.x) = ((unsigned char)(tmp.x)); (ret.y) = ((unsigned char)(tmp.y)); (ret.z) = ((unsigned char)(tmp.z)); (ret.w) = ((unsigned char)(tmp.w)); return ret; } 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 109
{ ushort2 ret; __asm ld.global.nc.v2.u16 {%0,%1}, [%2];
#line 109
return ret; } 
#endif
#line 110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 110
{ ushort4 ret; __asm ld.global.nc.v4.u16 {%0,%1,%2,%3}, [%4];
#line 110
return ret; } 
#endif
#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 111
{ uint2 ret; __asm ld.global.nc.v2.u32 {%0,%1}, [%2];
#line 111
return ret; } 
#endif
#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 112
{ uint4 ret; __asm ld.global.nc.v4.u32 {%0,%1,%2,%3}, [%4];
#line 112
return ret; } 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 113
{ ulonglong2 ret; __asm ld.global.nc.v2.u64 %0, [%1];
#line 113
return ret; } 
#endif
#line 115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline float __ldg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 115
{ float ret; __asm ld.global.nc.f32 %0, [%1];
#line 115
return ret; } 
#endif
#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline double __ldg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 116
{ double ret; __asm ld.global.nc.f64 %0, [%1];
#line 116
return ret; } 
#endif
#line 117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline float2 __ldg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 117
{ float2 ret; __asm ld.global.nc.v2.f32 {%0,%1}, [%2];
#line 117
return ret; } 
#endif
#line 118 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline float4 __ldg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 118
{ float4 ret; __asm ld.global.nc.v4.f32 {%0,%1,%2,%3}, [%4];
#line 118
return ret; } 
#endif
#line 119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static __inline double2 __ldg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 119
{ double2 ret; __asm ld.global.nc.v2.f64 {%0,%1}, [%2];
#line 119
return ret; } 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift) 
#line 131
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
#line 135
::exit(___);}
#if 0
#line 131
{ 
#line 132
unsigned ret; 
#line 133
__asm shf.l.wrap.b32 %0, %1, %2, %3;
return ret; 
#line 135
} 
#endif
#line 136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift) 
#line 137
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
#line 141
::exit(___);}
#if 0
#line 137
{ 
#line 138
unsigned ret; 
#line 139
__asm shf.l.clamp.b32 %0, %1, %2, %3;
return ret; 
#line 141
} 
#endif
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift) 
#line 145
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
#line 149
::exit(___);}
#if 0
#line 145
{ 
#line 146
unsigned ret; 
#line 147
__asm shf.r.wrap.b32 %0, %1, %2, %3;
return ret; 
#line 149
} 
#endif
#line 150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\sm_32_intrinsics.h"
static inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift) 
#line 151
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
#line 155
::exit(___);}
#if 0
#line 151
{ 
#line 152
unsigned ret; 
#line 153
__asm shf.r.clamp.b32 %0, %1, %2, %3;
return ret; 
#line 155
} 
#endif
#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 100
surf1Dread(T *res, ::surface< void, 1>  surf, int x, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 101
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)s;(void)mode;
#line 108
::exit(___);}
#if 0
#line 101
{ 
#line 102
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surf1Dreadc1(surf, x, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surf1Dreads1(surf, x, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surf1Dreadu1(surf, x, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 108
} 
#endif
#line 110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 111
surf1Dread(::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 112
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 118
::exit(___);}
#if 0
#line 112
{ 
#line 113
T tmp; 
#line 115
surf1Dread(&tmp, surf, x, (int)sizeof(T), mode); 
#line 117
return tmp; 
#line 118
} 
#endif
#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 121
surf1Dread(T *res, ::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 122
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)mode;
#line 124
::exit(___);}
#if 0
#line 122
{ 
#line 123
(*res) = surf1Dread< T> (surf, x, mode); 
#line 124
} 
#endif
#line 127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 128
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 130
::exit(___);}
#if 0
#line 128
{ 
#line 129
return (char)((__surf1Dreadc1(surf, x, cudaBoundaryModeTrap)).x); 
#line 130
} 
#endif
#line 133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline signed char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 134
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 136
::exit(___);}
#if 0
#line 134
{ 
#line 135
return (signed char)((__surf1Dreadc1(surf, x, cudaBoundaryModeTrap)).x); 
#line 136
} 
#endif
#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 140
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 142
::exit(___);}
#if 0
#line 140
{ 
#line 141
return (__surf1Dreadc1(surf, x, cudaBoundaryModeTrap)).x; 
#line 142
} 
#endif
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 146
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 148
::exit(___);}
#if 0
#line 146
{ 
#line 147
return make_char1((signed char)((__surf1Dreadc1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 148
} 
#endif
#line 151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 152
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 154
::exit(___);}
#if 0
#line 152
{ 
#line 153
return __surf1Dreadc1(surf, x, cudaBoundaryModeTrap); 
#line 154
} 
#endif
#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 158
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 162
::exit(___);}
#if 0
#line 158
{ 
#line 159
uchar2 tmp = __surf1Dreadc2(surf, x, cudaBoundaryModeTrap); 
#line 161
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 162
} 
#endif
#line 165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 166
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 168
::exit(___);}
#if 0
#line 166
{ 
#line 167
return __surf1Dreadc2(surf, x, cudaBoundaryModeTrap); 
#line 168
} 
#endif
#line 171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 172
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 176
::exit(___);}
#if 0
#line 172
{ 
#line 173
uchar4 tmp = __surf1Dreadc4(surf, x, cudaBoundaryModeTrap); 
#line 175
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 176
} 
#endif
#line 179 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 180
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 182
::exit(___);}
#if 0
#line 180
{ 
#line 181
return __surf1Dreadc4(surf, x, cudaBoundaryModeTrap); 
#line 182
} 
#endif
#line 185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 186
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 188
::exit(___);}
#if 0
#line 186
{ 
#line 187
return (short)((__surf1Dreads1(surf, x, cudaBoundaryModeTrap)).x); 
#line 188
} 
#endif
#line 191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned short surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 192
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 194
::exit(___);}
#if 0
#line 192
{ 
#line 193
return (__surf1Dreads1(surf, x, cudaBoundaryModeTrap)).x; 
#line 194
} 
#endif
#line 197 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 198
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 200
::exit(___);}
#if 0
#line 198
{ 
#line 199
return make_short1((signed short)((__surf1Dreads1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 200
} 
#endif
#line 203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 204
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 206
::exit(___);}
#if 0
#line 204
{ 
#line 205
return __surf1Dreads1(surf, x, cudaBoundaryModeTrap); 
#line 206
} 
#endif
#line 209 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 210
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 214
::exit(___);}
#if 0
#line 210
{ 
#line 211
ushort2 tmp = __surf1Dreads2(surf, x, cudaBoundaryModeTrap); 
#line 213
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 214
} 
#endif
#line 217 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 218
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 220
::exit(___);}
#if 0
#line 218
{ 
#line 219
return __surf1Dreads2(surf, x, cudaBoundaryModeTrap); 
#line 220
} 
#endif
#line 223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 224
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 228
::exit(___);}
#if 0
#line 224
{ 
#line 225
ushort4 tmp = __surf1Dreads4(surf, x, cudaBoundaryModeTrap); 
#line 227
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 228
} 
#endif
#line 231 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 232
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 234
::exit(___);}
#if 0
#line 232
{ 
#line 233
return __surf1Dreads4(surf, x, cudaBoundaryModeTrap); 
#line 234
} 
#endif
#line 237 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 238
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 240
::exit(___);}
#if 0
#line 238
{ 
#line 239
return (int)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x); 
#line 240
} 
#endif
#line 243 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 244
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 246
::exit(___);}
#if 0
#line 244
{ 
#line 245
return (__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x; 
#line 246
} 
#endif
#line 249 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 250
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 252
::exit(___);}
#if 0
#line 250
{ 
#line 251
return make_int1((signed int)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 252
} 
#endif
#line 255 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 256
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 258
::exit(___);}
#if 0
#line 256
{ 
#line 257
return __surf1Dreadu1(surf, x, cudaBoundaryModeTrap); 
#line 258
} 
#endif
#line 261 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 262
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 266
::exit(___);}
#if 0
#line 262
{ 
#line 263
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 265
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 266
} 
#endif
#line 269 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 270
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 272
::exit(___);}
#if 0
#line 270
{ 
#line 271
return __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 272
} 
#endif
#line 275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 276
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 280
::exit(___);}
#if 0
#line 276
{ 
#line 277
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 279
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 280
} 
#endif
#line 283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 284
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 286
::exit(___);}
#if 0
#line 284
{ 
#line 285
return __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 286
} 
#endif
#line 289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline __int64 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 290
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 292
::exit(___);}
#if 0
#line 290
{ 
#line 291
return (__int64)((__surf1Dreadl1(surf, x, cudaBoundaryModeTrap)).x); 
#line 292
} 
#endif
#line 295 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 296
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 298
::exit(___);}
#if 0
#line 296
{ 
#line 297
return (__surf1Dreadl1(surf, x, cudaBoundaryModeTrap)).x; 
#line 298
} 
#endif
#line 301 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 302
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 304
::exit(___);}
#if 0
#line 302
{ 
#line 303
return make_longlong1((__int64)((__surf1Dreadl1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 304
} 
#endif
#line 307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 308
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 310
::exit(___);}
#if 0
#line 308
{ 
#line 309
return __surf1Dreadl1(surf, x, cudaBoundaryModeTrap); 
#line 310
} 
#endif
#line 313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 314
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 318
::exit(___);}
#if 0
#line 314
{ 
#line 315
ulonglong2 tmp = __surf1Dreadl2(surf, x, cudaBoundaryModeTrap); 
#line 317
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 318
} 
#endif
#line 321 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 322
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 324
::exit(___);}
#if 0
#line 322
{ 
#line 323
return __surf1Dreadl2(surf, x, cudaBoundaryModeTrap); 
#line 324
} 
#endif
#line 329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 330
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 332
::exit(___);}
#if 0
#line 330
{ 
#line 331
return (long)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x); 
#line 332
} 
#endif
#line 335 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned long surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 336
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 338
::exit(___);}
#if 0
#line 336
{ 
#line 337
return (unsigned long)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x); 
#line 338
} 
#endif
#line 341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 342
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 344
::exit(___);}
#if 0
#line 342
{ 
#line 343
return make_long1((long)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 344
} 
#endif
#line 347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 348
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 350
::exit(___);}
#if 0
#line 348
{ 
#line 349
return make_ulong1((unsigned long)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 350
} 
#endif
#line 353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 354
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 358
::exit(___);}
#if 0
#line 354
{ 
#line 355
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 357
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 358
} 
#endif
#line 361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 362
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 366
::exit(___);}
#if 0
#line 362
{ 
#line 363
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 365
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 366
} 
#endif
#line 369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 370
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 374
::exit(___);}
#if 0
#line 370
{ 
#line 371
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 373
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 374
} 
#endif
#line 377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 378
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 382
::exit(___);}
#if 0
#line 378
{ 
#line 379
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 381
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 382
} 
#endif
#line 387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 388
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 390
::exit(___);}
#if 0
#line 388
{ 
#line 389
return __int_as_float((int)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 390
} 
#endif
#line 393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 394
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 396
::exit(___);}
#if 0
#line 394
{ 
#line 395
return make_float1(__int_as_float((int)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x))); 
#line 396
} 
#endif
#line 399 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 400
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 404
::exit(___);}
#if 0
#line 400
{ 
#line 401
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 403
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 404
} 
#endif
#line 407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 408
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 412
::exit(___);}
#if 0
#line 408
{ 
#line 409
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 411
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 412
} 
#endif
#line 447 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 448
surf2Dread(T *res, ::surface< void, 2>  surf, int x, int y, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 449
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)s;(void)mode;
#line 456
::exit(___);}
#if 0
#line 449
{ 
#line 450
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 456
} 
#endif
#line 458 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 459
surf2Dread(::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 460
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 466
::exit(___);}
#if 0
#line 460
{ 
#line 461
T tmp; 
#line 463
surf2Dread(&tmp, surf, x, y, (int)sizeof(T), mode); 
#line 465
return tmp; 
#line 466
} 
#endif
#line 468 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 469
surf2Dread(T *res, ::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 470
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)mode;
#line 472
::exit(___);}
#if 0
#line 470
{ 
#line 471
(*res) = surf2Dread< T> (surf, x, y, mode); 
#line 472
} 
#endif
#line 475 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 476
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 478
::exit(___);}
#if 0
#line 476
{ 
#line 477
return (char)((__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 478
} 
#endif
#line 481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline signed char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 482
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 484
::exit(___);}
#if 0
#line 482
{ 
#line 483
return (signed char)((__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 484
} 
#endif
#line 487 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 488
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 490
::exit(___);}
#if 0
#line 488
{ 
#line 489
return (__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)).x; 
#line 490
} 
#endif
#line 493 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 494
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 496
::exit(___);}
#if 0
#line 494
{ 
#line 495
return make_char1((signed char)((__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 496
} 
#endif
#line 499 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 500
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 502
::exit(___);}
#if 0
#line 500
{ 
#line 501
return __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap); 
#line 502
} 
#endif
#line 505 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 506
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 510
::exit(___);}
#if 0
#line 506
{ 
#line 507
uchar2 tmp = __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap); 
#line 509
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 510
} 
#endif
#line 513 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 514
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 516
::exit(___);}
#if 0
#line 514
{ 
#line 515
return __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap); 
#line 516
} 
#endif
#line 519 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 520
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 524
::exit(___);}
#if 0
#line 520
{ 
#line 521
uchar4 tmp = __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap); 
#line 523
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 524
} 
#endif
#line 527 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 528
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 530
::exit(___);}
#if 0
#line 528
{ 
#line 529
return __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap); 
#line 530
} 
#endif
#line 533 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 534
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 536
::exit(___);}
#if 0
#line 534
{ 
#line 535
return (short)((__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 536
} 
#endif
#line 539 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned short surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 540
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 542
::exit(___);}
#if 0
#line 540
{ 
#line 541
return (__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)).x; 
#line 542
} 
#endif
#line 545 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 546
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 548
::exit(___);}
#if 0
#line 546
{ 
#line 547
return make_short1((signed short)((__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 548
} 
#endif
#line 551 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 552
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 554
::exit(___);}
#if 0
#line 552
{ 
#line 553
return __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap); 
#line 554
} 
#endif
#line 557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 558
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 562
::exit(___);}
#if 0
#line 558
{ 
#line 559
ushort2 tmp = __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap); 
#line 561
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 562
} 
#endif
#line 565 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 566
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 568
::exit(___);}
#if 0
#line 566
{ 
#line 567
return __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap); 
#line 568
} 
#endif
#line 571 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 572
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 576
::exit(___);}
#if 0
#line 572
{ 
#line 573
ushort4 tmp = __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap); 
#line 575
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 576
} 
#endif
#line 579 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 580
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 582
::exit(___);}
#if 0
#line 580
{ 
#line 581
return __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap); 
#line 582
} 
#endif
#line 585 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 586
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 588
::exit(___);}
#if 0
#line 586
{ 
#line 587
return (int)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 588
} 
#endif
#line 591 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 592
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 594
::exit(___);}
#if 0
#line 592
{ 
#line 593
return (__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x; 
#line 594
} 
#endif
#line 597 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 598
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 600
::exit(___);}
#if 0
#line 598
{ 
#line 599
return make_int1((signed int)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 600
} 
#endif
#line 603 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 604
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 606
::exit(___);}
#if 0
#line 604
{ 
#line 605
return __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap); 
#line 606
} 
#endif
#line 609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 610
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 614
::exit(___);}
#if 0
#line 610
{ 
#line 611
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 613
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 614
} 
#endif
#line 617 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 618
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 620
::exit(___);}
#if 0
#line 618
{ 
#line 619
return __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 620
} 
#endif
#line 623 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 624
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 628
::exit(___);}
#if 0
#line 624
{ 
#line 625
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 627
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 628
} 
#endif
#line 631 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 632
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 634
::exit(___);}
#if 0
#line 632
{ 
#line 633
return __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 634
} 
#endif
#line 637 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline __int64 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 638
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 640
::exit(___);}
#if 0
#line 638
{ 
#line 639
return (__int64)((__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 640
} 
#endif
#line 643 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 644
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 646
::exit(___);}
#if 0
#line 644
{ 
#line 645
return (__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap)).x; 
#line 646
} 
#endif
#line 649 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 650
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 652
::exit(___);}
#if 0
#line 650
{ 
#line 651
return make_longlong1((__int64)((__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 652
} 
#endif
#line 655 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 656
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 658
::exit(___);}
#if 0
#line 656
{ 
#line 657
return __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap); 
#line 658
} 
#endif
#line 661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 662
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 666
::exit(___);}
#if 0
#line 662
{ 
#line 663
ulonglong2 tmp = __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap); 
#line 665
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 666
} 
#endif
#line 669 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 670
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 672
::exit(___);}
#if 0
#line 670
{ 
#line 671
return __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap); 
#line 672
} 
#endif
#line 677 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 678
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 680
::exit(___);}
#if 0
#line 678
{ 
#line 679
return (long)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 680
} 
#endif
#line 683 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned long surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 684
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 686
::exit(___);}
#if 0
#line 684
{ 
#line 685
return (unsigned long)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 686
} 
#endif
#line 689 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 690
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 692
::exit(___);}
#if 0
#line 690
{ 
#line 691
return make_long1((long)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 692
} 
#endif
#line 695 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 696
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 698
::exit(___);}
#if 0
#line 696
{ 
#line 697
return make_ulong1((unsigned long)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 698
} 
#endif
#line 701 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 702
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 706
::exit(___);}
#if 0
#line 702
{ 
#line 703
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 705
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 706
} 
#endif
#line 709 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 710
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 714
::exit(___);}
#if 0
#line 710
{ 
#line 711
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 713
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 714
} 
#endif
#line 717 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 718
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 722
::exit(___);}
#if 0
#line 718
{ 
#line 719
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 721
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 722
} 
#endif
#line 725 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 726
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 730
::exit(___);}
#if 0
#line 726
{ 
#line 727
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 729
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 730
} 
#endif
#line 735 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 736
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 738
::exit(___);}
#if 0
#line 736
{ 
#line 737
return __int_as_float((int)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 738
} 
#endif
#line 741 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 742
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 744
::exit(___);}
#if 0
#line 742
{ 
#line 743
return make_float1(__int_as_float((int)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x))); 
#line 744
} 
#endif
#line 747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 748
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 752
::exit(___);}
#if 0
#line 748
{ 
#line 749
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 751
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 752
} 
#endif
#line 755 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 756
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 760
::exit(___);}
#if 0
#line 756
{ 
#line 757
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 759
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 760
} 
#endif
#line 795 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 796
surf3Dread(T *res, ::surface< void, 3>  surf, int x, int y, int z, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 797
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
#line 804
::exit(___);}
#if 0
#line 797
{ 
#line 798
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 804
} 
#endif
#line 806 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 807
surf3Dread(::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 808
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 814
::exit(___);}
#if 0
#line 808
{ 
#line 809
T tmp; 
#line 811
surf3Dread(&tmp, surf, x, y, z, (int)sizeof(T), mode); 
#line 813
return tmp; 
#line 814
} 
#endif
#line 816 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 817
surf3Dread(T *res, ::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 818
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 820
::exit(___);}
#if 0
#line 818
{ 
#line 819
(*res) = surf3Dread< T> (surf, x, y, z, mode); 
#line 820
} 
#endif
#line 823 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 824
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 826
::exit(___);}
#if 0
#line 824
{ 
#line 825
return (char)((__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 826
} 
#endif
#line 829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline signed char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 830
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 832
::exit(___);}
#if 0
#line 830
{ 
#line 831
return (signed char)((__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 832
} 
#endif
#line 835 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 836
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 838
::exit(___);}
#if 0
#line 836
{ 
#line 837
return (__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)).x; 
#line 838
} 
#endif
#line 841 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 842
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 844
::exit(___);}
#if 0
#line 842
{ 
#line 843
return make_char1((signed char)((__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 844
} 
#endif
#line 847 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 848
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 850
::exit(___);}
#if 0
#line 848
{ 
#line 849
return __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap); 
#line 850
} 
#endif
#line 853 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 854
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 858
::exit(___);}
#if 0
#line 854
{ 
#line 855
uchar2 tmp = __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 857
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 858
} 
#endif
#line 861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 862
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 864
::exit(___);}
#if 0
#line 862
{ 
#line 863
return __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 864
} 
#endif
#line 867 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 868
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 872
::exit(___);}
#if 0
#line 868
{ 
#line 869
uchar4 tmp = __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 871
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 872
} 
#endif
#line 875 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 876
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 878
::exit(___);}
#if 0
#line 876
{ 
#line 877
return __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 878
} 
#endif
#line 881 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 882
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 884
::exit(___);}
#if 0
#line 882
{ 
#line 883
return (short)((__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 884
} 
#endif
#line 887 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned short surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 888
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 890
::exit(___);}
#if 0
#line 888
{ 
#line 889
return (__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap)).x; 
#line 890
} 
#endif
#line 893 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 894
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 896
::exit(___);}
#if 0
#line 894
{ 
#line 895
return make_short1((signed short)((__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 896
} 
#endif
#line 899 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 900
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 902
::exit(___);}
#if 0
#line 900
{ 
#line 901
return __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap); 
#line 902
} 
#endif
#line 905 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 906
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 910
::exit(___);}
#if 0
#line 906
{ 
#line 907
ushort2 tmp = __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 909
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 910
} 
#endif
#line 913 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 914
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 916
::exit(___);}
#if 0
#line 914
{ 
#line 915
return __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 916
} 
#endif
#line 919 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 920
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 924
::exit(___);}
#if 0
#line 920
{ 
#line 921
ushort4 tmp = __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 923
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 924
} 
#endif
#line 927 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 928
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 930
::exit(___);}
#if 0
#line 928
{ 
#line 929
return __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 930
} 
#endif
#line 933 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 934
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 936
::exit(___);}
#if 0
#line 934
{ 
#line 935
return (int)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 936
} 
#endif
#line 939 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 940
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 942
::exit(___);}
#if 0
#line 940
{ 
#line 941
return (__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x; 
#line 942
} 
#endif
#line 945 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 946
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 948
::exit(___);}
#if 0
#line 946
{ 
#line 947
return make_int1((signed int)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 948
} 
#endif
#line 951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 952
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 954
::exit(___);}
#if 0
#line 952
{ 
#line 953
return __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap); 
#line 954
} 
#endif
#line 957 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 958
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 962
::exit(___);}
#if 0
#line 958
{ 
#line 959
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 961
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 962
} 
#endif
#line 965 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 966
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 968
::exit(___);}
#if 0
#line 966
{ 
#line 967
return __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 968
} 
#endif
#line 971 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 972
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 976
::exit(___);}
#if 0
#line 972
{ 
#line 973
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 975
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 976
} 
#endif
#line 979 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 980
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 982
::exit(___);}
#if 0
#line 980
{ 
#line 981
return __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 982
} 
#endif
#line 985 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline __int64 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 986
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 988
::exit(___);}
#if 0
#line 986
{ 
#line 987
return (__int64)((__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 988
} 
#endif
#line 991 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 992
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 994
::exit(___);}
#if 0
#line 992
{ 
#line 993
return (__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap)).x; 
#line 994
} 
#endif
#line 997 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 998
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1000
::exit(___);}
#if 0
#line 998
{ 
#line 999
return make_longlong1((__int64)((__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 1000
} 
#endif
#line 1003 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1004
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1006
::exit(___);}
#if 0
#line 1004
{ 
#line 1005
return __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1006
} 
#endif
#line 1009 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1010
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1014
::exit(___);}
#if 0
#line 1010
{ 
#line 1011
ulonglong2 tmp = __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1013
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 1014
} 
#endif
#line 1017 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1018
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1020
::exit(___);}
#if 0
#line 1018
{ 
#line 1019
return __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1020
} 
#endif
#line 1025 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1026
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1028
::exit(___);}
#if 0
#line 1026
{ 
#line 1027
return (long)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 1028
} 
#endif
#line 1031 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned long surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1032
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1034
::exit(___);}
#if 0
#line 1032
{ 
#line 1033
return (unsigned long)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 1034
} 
#endif
#line 1037 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1038
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1040
::exit(___);}
#if 0
#line 1038
{ 
#line 1039
return make_long1((long)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 1040
} 
#endif
#line 1043 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1044
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1046
::exit(___);}
#if 0
#line 1044
{ 
#line 1045
return make_ulong1((unsigned long)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 1046
} 
#endif
#line 1049 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1050
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1054
::exit(___);}
#if 0
#line 1050
{ 
#line 1051
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1053
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 1054
} 
#endif
#line 1057 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1058
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1062
::exit(___);}
#if 0
#line 1058
{ 
#line 1059
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1061
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 1062
} 
#endif
#line 1065 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1066
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1070
::exit(___);}
#if 0
#line 1066
{ 
#line 1067
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1069
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 1070
} 
#endif
#line 1073 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1074
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1078
::exit(___);}
#if 0
#line 1074
{ 
#line 1075
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1077
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 1078
} 
#endif
#line 1083 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1084
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1086
::exit(___);}
#if 0
#line 1084
{ 
#line 1085
return __int_as_float((int)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 1086
} 
#endif
#line 1089 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1090
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1092
::exit(___);}
#if 0
#line 1090
{ 
#line 1091
return make_float1(__int_as_float((int)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x))); 
#line 1092
} 
#endif
#line 1095 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1096
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1100
::exit(___);}
#if 0
#line 1096
{ 
#line 1097
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1099
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 1100
} 
#endif
#line 1103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1104
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1108
::exit(___);}
#if 0
#line 1104
{ 
#line 1105
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1107
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 1108
} 
#endif
#line 1143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1144
surf1DLayeredread(T *res, ::surface< void, 241>  surf, int x, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1145
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
#line 1152
::exit(___);}
#if 0
#line 1145
{ 
#line 1146
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 1152
} 
#endif
#line 1154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 1155
surf1DLayeredread(::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1156
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1162
::exit(___);}
#if 0
#line 1156
{ 
#line 1157
T tmp; 
#line 1159
surf1DLayeredread(&tmp, surf, x, layer, (int)sizeof(T), mode); 
#line 1161
return tmp; 
#line 1162
} 
#endif
#line 1164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1165
surf1DLayeredread(T *res, ::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1166
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)mode;
#line 1168
::exit(___);}
#if 0
#line 1166
{ 
#line 1167
(*res) = surf1DLayeredread< T> (surf, x, layer, mode); 
#line 1168
} 
#endif
#line 1171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1172
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1174
::exit(___);}
#if 0
#line 1172
{ 
#line 1173
return (char)((__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1174
} 
#endif
#line 1177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline signed char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1178
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1180
::exit(___);}
#if 0
#line 1178
{ 
#line 1179
return (signed char)((__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1180
} 
#endif
#line 1183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1184
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1186
::exit(___);}
#if 0
#line 1184
{ 
#line 1185
return (__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)).x; 
#line 1186
} 
#endif
#line 1189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1190
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1192
::exit(___);}
#if 0
#line 1190
{ 
#line 1191
return make_char1((signed char)((__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1192
} 
#endif
#line 1195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1196
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1198
::exit(___);}
#if 0
#line 1196
{ 
#line 1197
return __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap); 
#line 1198
} 
#endif
#line 1201 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1202
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1206
::exit(___);}
#if 0
#line 1202
{ 
#line 1203
uchar2 tmp = __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1205
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 1206
} 
#endif
#line 1209 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1210
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1212
::exit(___);}
#if 0
#line 1210
{ 
#line 1211
return __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1212
} 
#endif
#line 1215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1216
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1220
::exit(___);}
#if 0
#line 1216
{ 
#line 1217
uchar4 tmp = __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1219
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 1220
} 
#endif
#line 1223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1224
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1226
::exit(___);}
#if 0
#line 1224
{ 
#line 1225
return __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1226
} 
#endif
#line 1229 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1230
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1232
::exit(___);}
#if 0
#line 1230
{ 
#line 1231
return (short)((__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1232
} 
#endif
#line 1235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned short surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1236
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1238
::exit(___);}
#if 0
#line 1236
{ 
#line 1237
return (__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap)).x; 
#line 1238
} 
#endif
#line 1241 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1242
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1244
::exit(___);}
#if 0
#line 1242
{ 
#line 1243
return make_short1((signed short)((__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1244
} 
#endif
#line 1247 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1248
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1250
::exit(___);}
#if 0
#line 1248
{ 
#line 1249
return __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap); 
#line 1250
} 
#endif
#line 1253 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1254
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1258
::exit(___);}
#if 0
#line 1254
{ 
#line 1255
ushort2 tmp = __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1257
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 1258
} 
#endif
#line 1261 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1262
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1264
::exit(___);}
#if 0
#line 1262
{ 
#line 1263
return __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1264
} 
#endif
#line 1267 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1268
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1272
::exit(___);}
#if 0
#line 1268
{ 
#line 1269
ushort4 tmp = __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1271
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 1272
} 
#endif
#line 1275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1276
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1278
::exit(___);}
#if 0
#line 1276
{ 
#line 1277
return __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1278
} 
#endif
#line 1281 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1282
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1284
::exit(___);}
#if 0
#line 1282
{ 
#line 1283
return (int)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1284
} 
#endif
#line 1287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1288
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1290
::exit(___);}
#if 0
#line 1288
{ 
#line 1289
return (__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x; 
#line 1290
} 
#endif
#line 1293 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1294
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1296
::exit(___);}
#if 0
#line 1294
{ 
#line 1295
return make_int1((signed int)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1296
} 
#endif
#line 1299 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1300
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1302
::exit(___);}
#if 0
#line 1300
{ 
#line 1301
return __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap); 
#line 1302
} 
#endif
#line 1305 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1306
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1310
::exit(___);}
#if 0
#line 1306
{ 
#line 1307
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1309
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 1310
} 
#endif
#line 1313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1314
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1316
::exit(___);}
#if 0
#line 1314
{ 
#line 1315
return __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1316
} 
#endif
#line 1319 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1320
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1324
::exit(___);}
#if 0
#line 1320
{ 
#line 1321
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1323
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 1324
} 
#endif
#line 1327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1328
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1330
::exit(___);}
#if 0
#line 1328
{ 
#line 1329
return __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1330
} 
#endif
#line 1333 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline __int64 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1334
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1336
::exit(___);}
#if 0
#line 1334
{ 
#line 1335
return (__int64)((__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1336
} 
#endif
#line 1339 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1340
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1342
::exit(___);}
#if 0
#line 1340
{ 
#line 1341
return (__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap)).x; 
#line 1342
} 
#endif
#line 1345 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1346
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1348
::exit(___);}
#if 0
#line 1346
{ 
#line 1347
return make_longlong1((__int64)((__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1348
} 
#endif
#line 1351 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1352
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1354
::exit(___);}
#if 0
#line 1352
{ 
#line 1353
return __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap); 
#line 1354
} 
#endif
#line 1357 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1358
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1362
::exit(___);}
#if 0
#line 1358
{ 
#line 1359
ulonglong2 tmp = __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1361
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 1362
} 
#endif
#line 1365 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1366
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1368
::exit(___);}
#if 0
#line 1366
{ 
#line 1367
return __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1368
} 
#endif
#line 1373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1374
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1376
::exit(___);}
#if 0
#line 1374
{ 
#line 1375
return (long)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1376
} 
#endif
#line 1379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned long surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1380
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1382
::exit(___);}
#if 0
#line 1380
{ 
#line 1381
return (unsigned long)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1382
} 
#endif
#line 1385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1386
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1388
::exit(___);}
#if 0
#line 1386
{ 
#line 1387
return make_long1((long)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1388
} 
#endif
#line 1391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1392
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1394
::exit(___);}
#if 0
#line 1392
{ 
#line 1393
return make_ulong1((unsigned long)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1394
} 
#endif
#line 1397 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1398
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1402
::exit(___);}
#if 0
#line 1398
{ 
#line 1399
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1401
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 1402
} 
#endif
#line 1405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1406
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1410
::exit(___);}
#if 0
#line 1406
{ 
#line 1407
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1409
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 1410
} 
#endif
#line 1413 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1414
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1418
::exit(___);}
#if 0
#line 1414
{ 
#line 1415
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1417
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 1418
} 
#endif
#line 1421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1422
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1426
::exit(___);}
#if 0
#line 1422
{ 
#line 1423
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1425
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 1426
} 
#endif
#line 1431 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1432
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1434
::exit(___);}
#if 0
#line 1432
{ 
#line 1433
return __int_as_float((int)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1434
} 
#endif
#line 1437 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1438
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1440
::exit(___);}
#if 0
#line 1438
{ 
#line 1439
return make_float1(__int_as_float((int)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x))); 
#line 1440
} 
#endif
#line 1443 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1444
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1448
::exit(___);}
#if 0
#line 1444
{ 
#line 1445
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1447
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 1448
} 
#endif
#line 1451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1452
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1456
::exit(___);}
#if 0
#line 1452
{ 
#line 1453
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1455
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 1456
} 
#endif
#line 1491 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1492
surf2DLayeredread(T *res, ::surface< void, 242>  surf, int x, int y, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1493
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
#line 1500
::exit(___);}
#if 0
#line 1493
{ 
#line 1494
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 1500
} 
#endif
#line 1502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 1503
surf2DLayeredread(::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1504
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1510
::exit(___);}
#if 0
#line 1504
{ 
#line 1505
T tmp; 
#line 1507
surf2DLayeredread(&tmp, surf, x, y, layer, (int)sizeof(T), mode); 
#line 1509
return tmp; 
#line 1510
} 
#endif
#line 1512 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1513
surf2DLayeredread(T *res, ::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1514
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1516
::exit(___);}
#if 0
#line 1514
{ 
#line 1515
(*res) = surf2DLayeredread< T> (surf, x, y, layer, mode); 
#line 1516
} 
#endif
#line 1519 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1520
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1522
::exit(___);}
#if 0
#line 1520
{ 
#line 1521
return (char)((__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1522
} 
#endif
#line 1525 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline signed char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1526
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1528
::exit(___);}
#if 0
#line 1526
{ 
#line 1527
return (signed char)((__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1528
} 
#endif
#line 1531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1532
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1534
::exit(___);}
#if 0
#line 1532
{ 
#line 1533
return (__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)).x; 
#line 1534
} 
#endif
#line 1537 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1538
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1540
::exit(___);}
#if 0
#line 1538
{ 
#line 1539
return make_char1((signed char)((__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1540
} 
#endif
#line 1543 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1544
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1546
::exit(___);}
#if 0
#line 1544
{ 
#line 1545
return __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1546
} 
#endif
#line 1549 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1550
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1554
::exit(___);}
#if 0
#line 1550
{ 
#line 1551
uchar2 tmp = __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1553
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 1554
} 
#endif
#line 1557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1558
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1560
::exit(___);}
#if 0
#line 1558
{ 
#line 1559
return __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1560
} 
#endif
#line 1563 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1564
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1568
::exit(___);}
#if 0
#line 1564
{ 
#line 1565
uchar4 tmp = __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1567
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 1568
} 
#endif
#line 1571 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1572
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1574
::exit(___);}
#if 0
#line 1572
{ 
#line 1573
return __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1574
} 
#endif
#line 1577 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1578
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1580
::exit(___);}
#if 0
#line 1578
{ 
#line 1579
return (short)((__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1580
} 
#endif
#line 1583 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned short surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1584
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1586
::exit(___);}
#if 0
#line 1584
{ 
#line 1585
return (__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap)).x; 
#line 1586
} 
#endif
#line 1589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1590
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1592
::exit(___);}
#if 0
#line 1590
{ 
#line 1591
return make_short1((signed short)((__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1592
} 
#endif
#line 1595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1596
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1598
::exit(___);}
#if 0
#line 1596
{ 
#line 1597
return __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1598
} 
#endif
#line 1601 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1602
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1606
::exit(___);}
#if 0
#line 1602
{ 
#line 1603
ushort2 tmp = __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1605
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 1606
} 
#endif
#line 1609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1610
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1612
::exit(___);}
#if 0
#line 1610
{ 
#line 1611
return __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1612
} 
#endif
#line 1615 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1616
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1620
::exit(___);}
#if 0
#line 1616
{ 
#line 1617
ushort4 tmp = __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1619
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 1620
} 
#endif
#line 1623 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1624
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1626
::exit(___);}
#if 0
#line 1624
{ 
#line 1625
return __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1626
} 
#endif
#line 1629 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1630
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1632
::exit(___);}
#if 0
#line 1630
{ 
#line 1631
return (int)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1632
} 
#endif
#line 1635 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1636
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1638
::exit(___);}
#if 0
#line 1636
{ 
#line 1637
return (__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x; 
#line 1638
} 
#endif
#line 1641 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1642
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1644
::exit(___);}
#if 0
#line 1642
{ 
#line 1643
return make_int1((signed int)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1644
} 
#endif
#line 1647 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1648
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1650
::exit(___);}
#if 0
#line 1648
{ 
#line 1649
return __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1650
} 
#endif
#line 1653 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1654
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1658
::exit(___);}
#if 0
#line 1654
{ 
#line 1655
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1657
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 1658
} 
#endif
#line 1661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1662
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1664
::exit(___);}
#if 0
#line 1662
{ 
#line 1663
return __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1664
} 
#endif
#line 1667 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1668
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1672
::exit(___);}
#if 0
#line 1668
{ 
#line 1669
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1671
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 1672
} 
#endif
#line 1675 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1676
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1678
::exit(___);}
#if 0
#line 1676
{ 
#line 1677
return __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1678
} 
#endif
#line 1681 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline __int64 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1682
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1684
::exit(___);}
#if 0
#line 1682
{ 
#line 1683
return (__int64)((__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1684
} 
#endif
#line 1687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1688
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1690
::exit(___);}
#if 0
#line 1688
{ 
#line 1689
return (__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap)).x; 
#line 1690
} 
#endif
#line 1693 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1694
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1696
::exit(___);}
#if 0
#line 1694
{ 
#line 1695
return make_longlong1((__int64)((__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1696
} 
#endif
#line 1699 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1700
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1702
::exit(___);}
#if 0
#line 1700
{ 
#line 1701
return __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1702
} 
#endif
#line 1705 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1706
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1710
::exit(___);}
#if 0
#line 1706
{ 
#line 1707
ulonglong2 tmp = __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1709
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 1710
} 
#endif
#line 1713 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1714
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1716
::exit(___);}
#if 0
#line 1714
{ 
#line 1715
return __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1716
} 
#endif
#line 1721 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1722
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1724
::exit(___);}
#if 0
#line 1722
{ 
#line 1723
return (long)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1724
} 
#endif
#line 1727 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned long surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1728
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1730
::exit(___);}
#if 0
#line 1728
{ 
#line 1729
return (unsigned long)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1730
} 
#endif
#line 1733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1734
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1736
::exit(___);}
#if 0
#line 1734
{ 
#line 1735
return make_long1((long)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1736
} 
#endif
#line 1739 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1740
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1742
::exit(___);}
#if 0
#line 1740
{ 
#line 1741
return make_ulong1((unsigned long)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1742
} 
#endif
#line 1745 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1746
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1750
::exit(___);}
#if 0
#line 1746
{ 
#line 1747
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1749
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 1750
} 
#endif
#line 1753 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1754
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1758
::exit(___);}
#if 0
#line 1754
{ 
#line 1755
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1757
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 1758
} 
#endif
#line 1761 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1762
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1766
::exit(___);}
#if 0
#line 1762
{ 
#line 1763
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1765
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 1766
} 
#endif
#line 1769 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1770
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1774
::exit(___);}
#if 0
#line 1770
{ 
#line 1771
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1773
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 1774
} 
#endif
#line 1779 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1780
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1782
::exit(___);}
#if 0
#line 1780
{ 
#line 1781
return __int_as_float((int)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1782
} 
#endif
#line 1785 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1786
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1788
::exit(___);}
#if 0
#line 1786
{ 
#line 1787
return make_float1(__int_as_float((int)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x))); 
#line 1788
} 
#endif
#line 1791 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1792
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1796
::exit(___);}
#if 0
#line 1792
{ 
#line 1793
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1795
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 1796
} 
#endif
#line 1799 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1800
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1804
::exit(___);}
#if 0
#line 1800
{ 
#line 1801
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1803
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 1804
} 
#endif
#line 1839 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1840
surfCubemapread(T *res, ::surface< void, 12>  surf, int x, int y, int face, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1841
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
#line 1848
::exit(___);}
#if 0
#line 1841
{ 
#line 1842
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 1848
} 
#endif
#line 1850 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 1851
surfCubemapread(::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1852
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1858
::exit(___);}
#if 0
#line 1852
{ 
#line 1853
T tmp; 
#line 1855
surfCubemapread(&tmp, surf, x, y, face, (int)sizeof(T), mode); 
#line 1857
return tmp; 
#line 1858
} 
#endif
#line 1860 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1861
surfCubemapread(T *res, ::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1862
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1864
::exit(___);}
#if 0
#line 1862
{ 
#line 1863
(*res) = surfCubemapread< T> (surf, x, y, face, mode); 
#line 1864
} 
#endif
#line 1867 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1868
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1870
::exit(___);}
#if 0
#line 1868
{ 
#line 1869
return (char)((__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 1870
} 
#endif
#line 1873 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline signed char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1874
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1876
::exit(___);}
#if 0
#line 1874
{ 
#line 1875
return (signed char)((__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 1876
} 
#endif
#line 1879 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1880
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1882
::exit(___);}
#if 0
#line 1880
{ 
#line 1881
return (__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap)).x; 
#line 1882
} 
#endif
#line 1885 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1886
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1888
::exit(___);}
#if 0
#line 1886
{ 
#line 1887
return make_char1((signed char)((__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 1888
} 
#endif
#line 1891 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1892
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1894
::exit(___);}
#if 0
#line 1892
{ 
#line 1893
return __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1894
} 
#endif
#line 1897 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1898
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1902
::exit(___);}
#if 0
#line 1898
{ 
#line 1899
uchar2 tmp = __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1901
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 1902
} 
#endif
#line 1905 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1906
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1908
::exit(___);}
#if 0
#line 1906
{ 
#line 1907
return __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1908
} 
#endif
#line 1911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1912
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1916
::exit(___);}
#if 0
#line 1912
{ 
#line 1913
uchar4 tmp = __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1915
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 1916
} 
#endif
#line 1919 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1920
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1922
::exit(___);}
#if 0
#line 1920
{ 
#line 1921
return __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1922
} 
#endif
#line 1925 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1926
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1928
::exit(___);}
#if 0
#line 1926
{ 
#line 1927
return (short)((__surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 1928
} 
#endif
#line 1931 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned short surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1932
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1934
::exit(___);}
#if 0
#line 1932
{ 
#line 1933
return (__surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap)).x; 
#line 1934
} 
#endif
#line 1937 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1938
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1940
::exit(___);}
#if 0
#line 1938
{ 
#line 1939
return make_short1((signed short)((__surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 1940
} 
#endif
#line 1943 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1944
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1946
::exit(___);}
#if 0
#line 1944
{ 
#line 1945
return __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1946
} 
#endif
#line 1949 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1950
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1954
::exit(___);}
#if 0
#line 1950
{ 
#line 1951
ushort2 tmp = __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1953
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 1954
} 
#endif
#line 1957 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1958
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1960
::exit(___);}
#if 0
#line 1958
{ 
#line 1959
return __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1960
} 
#endif
#line 1963 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1964
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1968
::exit(___);}
#if 0
#line 1964
{ 
#line 1965
ushort4 tmp = __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1967
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 1968
} 
#endif
#line 1971 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1972
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1974
::exit(___);}
#if 0
#line 1972
{ 
#line 1973
return __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1974
} 
#endif
#line 1977 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1978
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1980
::exit(___);}
#if 0
#line 1978
{ 
#line 1979
return (int)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 1980
} 
#endif
#line 1983 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1984
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1986
::exit(___);}
#if 0
#line 1984
{ 
#line 1985
return (__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x; 
#line 1986
} 
#endif
#line 1989 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1990
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1992
::exit(___);}
#if 0
#line 1990
{ 
#line 1991
return make_int1((signed int)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 1992
} 
#endif
#line 1995 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1996
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1998
::exit(___);}
#if 0
#line 1996
{ 
#line 1997
return __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1998
} 
#endif
#line 2001 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2002
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2006
::exit(___);}
#if 0
#line 2002
{ 
#line 2003
uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2005
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 2006
} 
#endif
#line 2009 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2010
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2012
::exit(___);}
#if 0
#line 2010
{ 
#line 2011
return __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2012
} 
#endif
#line 2015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2016
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2020
::exit(___);}
#if 0
#line 2016
{ 
#line 2017
uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2019
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 2020
} 
#endif
#line 2023 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2024
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2026
::exit(___);}
#if 0
#line 2024
{ 
#line 2025
return __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2026
} 
#endif
#line 2029 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline __int64 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2030
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2032
::exit(___);}
#if 0
#line 2030
{ 
#line 2031
return (__int64)((__surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 2032
} 
#endif
#line 2035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2036
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2038
::exit(___);}
#if 0
#line 2036
{ 
#line 2037
return (__surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap)).x; 
#line 2038
} 
#endif
#line 2041 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2042
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2044
::exit(___);}
#if 0
#line 2042
{ 
#line 2043
return make_longlong1((__int64)((__surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 2044
} 
#endif
#line 2047 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2048
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2050
::exit(___);}
#if 0
#line 2048
{ 
#line 2049
return __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2050
} 
#endif
#line 2053 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2054
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2058
::exit(___);}
#if 0
#line 2054
{ 
#line 2055
ulonglong2 tmp = __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2057
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 2058
} 
#endif
#line 2061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2062
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2064
::exit(___);}
#if 0
#line 2062
{ 
#line 2063
return __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2064
} 
#endif
#line 2069 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2070
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2072
::exit(___);}
#if 0
#line 2070
{ 
#line 2071
return (long)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 2072
} 
#endif
#line 2075 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned long surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2076
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2078
::exit(___);}
#if 0
#line 2076
{ 
#line 2077
return (unsigned long)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 2078
} 
#endif
#line 2081 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2082
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2084
::exit(___);}
#if 0
#line 2082
{ 
#line 2083
return make_long1((long)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 2084
} 
#endif
#line 2087 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2088
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2090
::exit(___);}
#if 0
#line 2088
{ 
#line 2089
return make_ulong1((unsigned long)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 2090
} 
#endif
#line 2093 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2094
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2098
::exit(___);}
#if 0
#line 2094
{ 
#line 2095
uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2097
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 2098
} 
#endif
#line 2101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2102
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2106
::exit(___);}
#if 0
#line 2102
{ 
#line 2103
uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2105
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 2106
} 
#endif
#line 2109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2110
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2114
::exit(___);}
#if 0
#line 2110
{ 
#line 2111
uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2113
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 2114
} 
#endif
#line 2117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2118
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2122
::exit(___);}
#if 0
#line 2118
{ 
#line 2119
uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2121
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 2122
} 
#endif
#line 2127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2128
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2130
::exit(___);}
#if 0
#line 2128
{ 
#line 2129
return __int_as_float((int)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 2130
} 
#endif
#line 2133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2134
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2136
::exit(___);}
#if 0
#line 2134
{ 
#line 2135
return make_float1(__int_as_float((int)((__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x))); 
#line 2136
} 
#endif
#line 2139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2140
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2144
::exit(___);}
#if 0
#line 2140
{ 
#line 2141
uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2143
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 2144
} 
#endif
#line 2147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2148
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2152
::exit(___);}
#if 0
#line 2148
{ 
#line 2149
uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2151
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 2152
} 
#endif
#line 2188 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2189
surfCubemapLayeredread(T *res, ::surface< void, 252>  surf, int x, int y, int layerFace, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2190
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
#line 2197
::exit(___);}
#if 0
#line 2190
{ 
#line 2191
(s == 1) ? ((void)((*((::uchar1 *)res)) = __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((::ushort1 *)res)) = __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((::uint1 *)res)) = __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((::uint2 *)res)) = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((::uint4 *)res)) = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((void)0))))); 
#line 2197
} 
#endif
#line 2199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 2200
surfCubemapLayeredread(::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2201
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2207
::exit(___);}
#if 0
#line 2201
{ 
#line 2202
T tmp; 
#line 2204
surfCubemapLayeredread(&tmp, surf, x, y, layerFace, (int)sizeof(T), mode); 
#line 2206
return tmp; 
#line 2207
} 
#endif
#line 2209 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2210
surfCubemapLayeredread(T *res, ::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2211
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2213
::exit(___);}
#if 0
#line 2211
{ 
#line 2212
(*res) = surfCubemapLayeredread< T> (surf, x, y, layerFace, mode); 
#line 2213
} 
#endif
#line 2216 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2217
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2219
::exit(___);}
#if 0
#line 2217
{ 
#line 2218
return (char)((__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2219
} 
#endif
#line 2222 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline signed char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2223
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2225
::exit(___);}
#if 0
#line 2223
{ 
#line 2224
return (signed char)((__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2225
} 
#endif
#line 2228 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2229
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2231
::exit(___);}
#if 0
#line 2229
{ 
#line 2230
return (__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x; 
#line 2231
} 
#endif
#line 2234 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2235
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2237
::exit(___);}
#if 0
#line 2235
{ 
#line 2236
return make_char1((signed char)((__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2237
} 
#endif
#line 2240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2241
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2243
::exit(___);}
#if 0
#line 2241
{ 
#line 2242
return __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2243
} 
#endif
#line 2246 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2247
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2251
::exit(___);}
#if 0
#line 2247
{ 
#line 2248
uchar2 tmp = __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2250
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 2251
} 
#endif
#line 2254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2255
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2257
::exit(___);}
#if 0
#line 2255
{ 
#line 2256
return __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2257
} 
#endif
#line 2260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline char4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2261
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2265
::exit(___);}
#if 0
#line 2261
{ 
#line 2262
uchar4 tmp = __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2264
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 2265
} 
#endif
#line 2268 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uchar4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2269
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2271
::exit(___);}
#if 0
#line 2269
{ 
#line 2270
return __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2271
} 
#endif
#line 2274 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2275
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2277
::exit(___);}
#if 0
#line 2275
{ 
#line 2276
return (short)((__surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2277
} 
#endif
#line 2280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned short surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2281
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2283
::exit(___);}
#if 0
#line 2281
{ 
#line 2282
return (__surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x; 
#line 2283
} 
#endif
#line 2286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2287
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2289
::exit(___);}
#if 0
#line 2287
{ 
#line 2288
return make_short1((signed short)((__surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2289
} 
#endif
#line 2292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2293
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2295
::exit(___);}
#if 0
#line 2293
{ 
#line 2294
return __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2295
} 
#endif
#line 2298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2299
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2303
::exit(___);}
#if 0
#line 2299
{ 
#line 2300
ushort2 tmp = __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2302
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 2303
} 
#endif
#line 2306 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2307
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2309
::exit(___);}
#if 0
#line 2307
{ 
#line 2308
return __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2309
} 
#endif
#line 2312 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline short4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2313
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2317
::exit(___);}
#if 0
#line 2313
{ 
#line 2314
ushort4 tmp = __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2316
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 2317
} 
#endif
#line 2320 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ushort4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2321
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2323
::exit(___);}
#if 0
#line 2321
{ 
#line 2322
return __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2323
} 
#endif
#line 2326 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2327
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2329
::exit(___);}
#if 0
#line 2327
{ 
#line 2328
return (int)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2329
} 
#endif
#line 2332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2333
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2335
::exit(___);}
#if 0
#line 2333
{ 
#line 2334
return (__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x; 
#line 2335
} 
#endif
#line 2338 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2339
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2341
::exit(___);}
#if 0
#line 2339
{ 
#line 2340
return make_int1((signed int)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2341
} 
#endif
#line 2344 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2345
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2347
::exit(___);}
#if 0
#line 2345
{ 
#line 2346
return __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2347
} 
#endif
#line 2350 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2351
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2355
::exit(___);}
#if 0
#line 2351
{ 
#line 2352
uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2354
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 2355
} 
#endif
#line 2358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2359
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2361
::exit(___);}
#if 0
#line 2359
{ 
#line 2360
return __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2361
} 
#endif
#line 2364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline int4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2365
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2369
::exit(___);}
#if 0
#line 2365
{ 
#line 2366
uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2368
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 2369
} 
#endif
#line 2372 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline uint4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2373
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2375
::exit(___);}
#if 0
#line 2373
{ 
#line 2374
return __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2375
} 
#endif
#line 2378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline __int64 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2379
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2381
::exit(___);}
#if 0
#line 2379
{ 
#line 2380
return (__int64)((__surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2381
} 
#endif
#line 2384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2385
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2387
::exit(___);}
#if 0
#line 2385
{ 
#line 2386
return (__surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x; 
#line 2387
} 
#endif
#line 2390 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2391
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2393
::exit(___);}
#if 0
#line 2391
{ 
#line 2392
return make_longlong1((__int64)((__surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2393
} 
#endif
#line 2396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2397
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2399
::exit(___);}
#if 0
#line 2397
{ 
#line 2398
return __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2399
} 
#endif
#line 2402 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline longlong2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2403
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2407
::exit(___);}
#if 0
#line 2403
{ 
#line 2404
ulonglong2 tmp = __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2406
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 2407
} 
#endif
#line 2410 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2411
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2413
::exit(___);}
#if 0
#line 2411
{ 
#line 2412
return __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2413
} 
#endif
#line 2418 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2419
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2421
::exit(___);}
#if 0
#line 2419
{ 
#line 2420
return (long)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2421
} 
#endif
#line 2424 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline unsigned long surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2425
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2427
::exit(___);}
#if 0
#line 2425
{ 
#line 2426
return (unsigned long)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2427
} 
#endif
#line 2430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2431
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2433
::exit(___);}
#if 0
#line 2431
{ 
#line 2432
return make_long1((long)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2433
} 
#endif
#line 2436 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2437
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2439
::exit(___);}
#if 0
#line 2437
{ 
#line 2438
return make_ulong1((unsigned long)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2439
} 
#endif
#line 2442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2443
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2447
::exit(___);}
#if 0
#line 2443
{ 
#line 2444
uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2446
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 2447
} 
#endif
#line 2450 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2451
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2455
::exit(___);}
#if 0
#line 2451
{ 
#line 2452
uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2454
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 2455
} 
#endif
#line 2458 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline long4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2459
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2463
::exit(___);}
#if 0
#line 2459
{ 
#line 2460
uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2462
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 2463
} 
#endif
#line 2466 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline ulong4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2467
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2471
::exit(___);}
#if 0
#line 2467
{ 
#line 2468
uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2470
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 2471
} 
#endif
#line 2476 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2477
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2479
::exit(___);}
#if 0
#line 2477
{ 
#line 2478
return __int_as_float((int)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2479
} 
#endif
#line 2482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2483
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2485
::exit(___);}
#if 0
#line 2483
{ 
#line 2484
return make_float1(__int_as_float((int)((__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x))); 
#line 2485
} 
#endif
#line 2488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2489
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2493
::exit(___);}
#if 0
#line 2489
{ 
#line 2490
uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2492
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 2493
} 
#endif
#line 2496 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template<> __forceinline float4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2497
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2501
::exit(___);}
#if 0
#line 2497
{ 
#line 2498
uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2500
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 2501
} 
#endif
#line 2537 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2538
surf1Dwrite(T val, ::surface< void, 1>  surf, int x, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2539
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)s;(void)mode;
#line 2557
::exit(___);}
#if 0
#line 2539
{ 
#line 2540
union { 
#line 2541
T val; 
#line 2542
::uchar1 c1; 
#line 2543
::ushort1 s1; 
#line 2544
::uint1 u1; 
#line 2545
::uint2 u2; 
#line 2546
::uint4 u4; 
#line 2547
} tmp; 
#line 2549
(tmp.val) = val; 
#line 2551
(s == 1) ? ((void)__surf1Dwritec1(tmp.c1, surf, x, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf1Dwrites1(tmp.s1, surf, x, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf1Dwriteu1(tmp.u1, surf, x, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf1Dwriteu2(tmp.u2, surf, x, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf1Dwriteu4(tmp.u4, surf, x, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 2557
} 
#endif
#line 2559 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2560
surf1Dwrite(T val, ::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2561
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2563
::exit(___);}
#if 0
#line 2561
{ ; 
#line 2562
surf1Dwrite(val, surf, x, (int)sizeof(T), mode); 
#line 2563
} 
#endif
#line 2566 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2567
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2569
::exit(___);}
#if 0
#line 2567
{ 
#line 2568
__surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap); 
#line 2569
} 
#endif
#line 2571 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(signed char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2572
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2574
::exit(___);}
#if 0
#line 2572
{ 
#line 2573
__surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap); 
#line 2574
} 
#endif
#line 2576 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(unsigned char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2577
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2579
::exit(___);}
#if 0
#line 2577
{ 
#line 2578
__surf1Dwritec1(make_uchar1(val), surf, x, cudaBoundaryModeTrap); 
#line 2579
} 
#endif
#line 2581 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(char1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2582
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2584
::exit(___);}
#if 0
#line 2582
{ 
#line 2583
__surf1Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2584
} 
#endif
#line 2586 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(uchar1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2587
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2589
::exit(___);}
#if 0
#line 2587
{ 
#line 2588
__surf1Dwritec1(val, surf, x, cudaBoundaryModeTrap); 
#line 2589
} 
#endif
#line 2591 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(char2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2592
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2594
::exit(___);}
#if 0
#line 2592
{ 
#line 2593
__surf1Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 2594
} 
#endif
#line 2596 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(uchar2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2597
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2599
::exit(___);}
#if 0
#line 2597
{ 
#line 2598
__surf1Dwritec2(val, surf, x, cudaBoundaryModeTrap); 
#line 2599
} 
#endif
#line 2601 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(char4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2602
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2604
::exit(___);}
#if 0
#line 2602
{ 
#line 2603
__surf1Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 2604
} 
#endif
#line 2606 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(uchar4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2607
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2609
::exit(___);}
#if 0
#line 2607
{ 
#line 2608
__surf1Dwritec4(val, surf, x, cudaBoundaryModeTrap); 
#line 2609
} 
#endif
#line 2611 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2612
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2614
::exit(___);}
#if 0
#line 2612
{ 
#line 2613
__surf1Dwrites1(make_ushort1((unsigned short)val), surf, x, cudaBoundaryModeTrap); 
#line 2614
} 
#endif
#line 2616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(unsigned short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2617
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2619
::exit(___);}
#if 0
#line 2617
{ 
#line 2618
__surf1Dwrites1(make_ushort1(val), surf, x, cudaBoundaryModeTrap); 
#line 2619
} 
#endif
#line 2621 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(short1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2622
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2624
::exit(___);}
#if 0
#line 2622
{ 
#line 2623
__surf1Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2624
} 
#endif
#line 2626 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ushort1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2627
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2629
::exit(___);}
#if 0
#line 2627
{ 
#line 2628
__surf1Dwrites1(val, surf, x, cudaBoundaryModeTrap); 
#line 2629
} 
#endif
#line 2631 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(short2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2632
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2634
::exit(___);}
#if 0
#line 2632
{ 
#line 2633
__surf1Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 2634
} 
#endif
#line 2636 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ushort2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2637
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2639
::exit(___);}
#if 0
#line 2637
{ 
#line 2638
__surf1Dwrites2(val, surf, x, cudaBoundaryModeTrap); 
#line 2639
} 
#endif
#line 2641 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(short4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2642
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2644
::exit(___);}
#if 0
#line 2642
{ 
#line 2643
__surf1Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 2644
} 
#endif
#line 2646 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ushort4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2647
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2649
::exit(___);}
#if 0
#line 2647
{ 
#line 2648
__surf1Dwrites4(val, surf, x, cudaBoundaryModeTrap); 
#line 2649
} 
#endif
#line 2651 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(int val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2652
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2654
::exit(___);}
#if 0
#line 2652
{ 
#line 2653
__surf1Dwriteu1(make_uint1((unsigned)val), surf, x, cudaBoundaryModeTrap); 
#line 2654
} 
#endif
#line 2656 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(unsigned val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2657
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2659
::exit(___);}
#if 0
#line 2657
{ 
#line 2658
__surf1Dwriteu1(make_uint1(val), surf, x, cudaBoundaryModeTrap); 
#line 2659
} 
#endif
#line 2661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(int1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2662
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2664
::exit(___);}
#if 0
#line 2662
{ 
#line 2663
__surf1Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2664
} 
#endif
#line 2666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(uint1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2667
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2669
::exit(___);}
#if 0
#line 2667
{ 
#line 2668
__surf1Dwriteu1(val, surf, x, cudaBoundaryModeTrap); 
#line 2669
} 
#endif
#line 2671 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(int2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2672
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2674
::exit(___);}
#if 0
#line 2672
{ 
#line 2673
__surf1Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 2674
} 
#endif
#line 2676 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(uint2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2677
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2679
::exit(___);}
#if 0
#line 2677
{ 
#line 2678
__surf1Dwriteu2(val, surf, x, cudaBoundaryModeTrap); 
#line 2679
} 
#endif
#line 2681 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(int4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2682
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2684
::exit(___);}
#if 0
#line 2682
{ 
#line 2683
__surf1Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 2684
} 
#endif
#line 2686 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(uint4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2687
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2689
::exit(___);}
#if 0
#line 2687
{ 
#line 2688
__surf1Dwriteu4(val, surf, x, cudaBoundaryModeTrap); 
#line 2689
} 
#endif
#line 2691 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(__int64 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2692
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2694
::exit(___);}
#if 0
#line 2692
{ 
#line 2693
__surf1Dwritel1(make_ulonglong1((unsigned __int64)val), surf, x, cudaBoundaryModeTrap); 
#line 2694
} 
#endif
#line 2696 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(unsigned __int64 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2697
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2699
::exit(___);}
#if 0
#line 2697
{ 
#line 2698
__surf1Dwritel1(make_ulonglong1(val), surf, x, cudaBoundaryModeTrap); 
#line 2699
} 
#endif
#line 2701 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(longlong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2702
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2704
::exit(___);}
#if 0
#line 2702
{ 
#line 2703
__surf1Dwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2704
} 
#endif
#line 2706 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ulonglong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2707
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2709
::exit(___);}
#if 0
#line 2707
{ 
#line 2708
__surf1Dwritel1(val, surf, x, cudaBoundaryModeTrap); 
#line 2709
} 
#endif
#line 2711 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(longlong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2712
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2714
::exit(___);}
#if 0
#line 2712
{ 
#line 2713
__surf1Dwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 2714
} 
#endif
#line 2716 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ulonglong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2717
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2719
::exit(___);}
#if 0
#line 2717
{ 
#line 2718
__surf1Dwritel2(val, surf, x, cudaBoundaryModeTrap); 
#line 2719
} 
#endif
#line 2723 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2724
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2726
::exit(___);}
#if 0
#line 2724
{ 
#line 2725
__surf1Dwriteu1(make_uint1((unsigned)val), surf, x, cudaBoundaryModeTrap); 
#line 2726
} 
#endif
#line 2728 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(unsigned long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2729
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2731
::exit(___);}
#if 0
#line 2729
{ 
#line 2730
__surf1Dwriteu1(make_uint1((unsigned)val), surf, x, cudaBoundaryModeTrap); 
#line 2731
} 
#endif
#line 2733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(long1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2734
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2736
::exit(___);}
#if 0
#line 2734
{ 
#line 2735
__surf1Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2736
} 
#endif
#line 2738 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ulong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2739
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2741
::exit(___);}
#if 0
#line 2739
{ 
#line 2740
__surf1Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2741
} 
#endif
#line 2743 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(long2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2744
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2746
::exit(___);}
#if 0
#line 2744
{ 
#line 2745
__surf1Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 2746
} 
#endif
#line 2748 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ulong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2749
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2751
::exit(___);}
#if 0
#line 2749
{ 
#line 2750
__surf1Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 2751
} 
#endif
#line 2753 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(long4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2754
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2756
::exit(___);}
#if 0
#line 2754
{ 
#line 2755
__surf1Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 2756
} 
#endif
#line 2758 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(ulong4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2759
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2761
::exit(___);}
#if 0
#line 2759
{ 
#line 2760
__surf1Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 2761
} 
#endif
#line 2765 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(float val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2766
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2768
::exit(___);}
#if 0
#line 2766
{ 
#line 2767
__surf1Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, cudaBoundaryModeTrap); 
#line 2768
} 
#endif
#line 2770 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(float1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2771
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2773
::exit(___);}
#if 0
#line 2771
{ 
#line 2772
__surf1Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 2773
} 
#endif
#line 2775 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(float2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2776
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2778
::exit(___);}
#if 0
#line 2776
{ 
#line 2777
__surf1Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, cudaBoundaryModeTrap); 
#line 2778
} 
#endif
#line 2780 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(float4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2781
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2783
::exit(___);}
#if 0
#line 2781
{ 
#line 2782
__surf1Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 2783
} 
#endif
#line 2819 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2820
surf2Dwrite(T val, ::surface< void, 2>  surf, int x, int y, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2821
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)s;(void)mode;
#line 2839
::exit(___);}
#if 0
#line 2821
{ 
#line 2822
union { 
#line 2823
T val; 
#line 2824
::uchar1 c1; 
#line 2825
::ushort1 s1; 
#line 2826
::uint1 u1; 
#line 2827
::uint2 u2; 
#line 2828
::uint4 u4; 
#line 2829
} tmp; 
#line 2831
(tmp.val) = val; 
#line 2833
(s == 1) ? ((void)__surf2Dwritec1(tmp.c1, surf, x, y, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf2Dwrites1(tmp.s1, surf, x, y, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf2Dwriteu1(tmp.u1, surf, x, y, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf2Dwriteu2(tmp.u2, surf, x, y, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf2Dwriteu4(tmp.u4, surf, x, y, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 2839
} 
#endif
#line 2841 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2842
surf2Dwrite(T val, ::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2843
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2845
::exit(___);}
#if 0
#line 2843
{ ; 
#line 2844
surf2Dwrite(val, surf, x, y, (int)sizeof(T), mode); 
#line 2845
} 
#endif
#line 2848 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2849
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2851
::exit(___);}
#if 0
#line 2849
{ 
#line 2850
__surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap); 
#line 2851
} 
#endif
#line 2853 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(signed char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2854
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2856
::exit(___);}
#if 0
#line 2854
{ 
#line 2855
__surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap); 
#line 2856
} 
#endif
#line 2858 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(unsigned char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2859
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2861
::exit(___);}
#if 0
#line 2859
{ 
#line 2860
__surf2Dwritec1(make_uchar1(val), surf, x, y, cudaBoundaryModeTrap); 
#line 2861
} 
#endif
#line 2863 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(char1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2864
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2866
::exit(___);}
#if 0
#line 2864
{ 
#line 2865
__surf2Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 2866
} 
#endif
#line 2868 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(uchar1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2869
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2871
::exit(___);}
#if 0
#line 2869
{ 
#line 2870
__surf2Dwritec1(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2871
} 
#endif
#line 2873 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(char2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2874
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2876
::exit(___);}
#if 0
#line 2874
{ 
#line 2875
__surf2Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 2876
} 
#endif
#line 2878 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(uchar2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2879
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2881
::exit(___);}
#if 0
#line 2879
{ 
#line 2880
__surf2Dwritec2(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2881
} 
#endif
#line 2883 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(char4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2884
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2886
::exit(___);}
#if 0
#line 2884
{ 
#line 2885
__surf2Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 2886
} 
#endif
#line 2888 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(uchar4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2889
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2891
::exit(___);}
#if 0
#line 2889
{ 
#line 2890
__surf2Dwritec4(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2891
} 
#endif
#line 2893 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2894
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2896
::exit(___);}
#if 0
#line 2894
{ 
#line 2895
__surf2Dwrites1(make_ushort1((unsigned short)val), surf, x, y, cudaBoundaryModeTrap); 
#line 2896
} 
#endif
#line 2898 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(unsigned short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2899
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2901
::exit(___);}
#if 0
#line 2899
{ 
#line 2900
__surf2Dwrites1(make_ushort1(val), surf, x, y, cudaBoundaryModeTrap); 
#line 2901
} 
#endif
#line 2903 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(short1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2904
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2906
::exit(___);}
#if 0
#line 2904
{ 
#line 2905
__surf2Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 2906
} 
#endif
#line 2908 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ushort1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2909
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2911
::exit(___);}
#if 0
#line 2909
{ 
#line 2910
__surf2Dwrites1(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2911
} 
#endif
#line 2913 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(short2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2914
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2916
::exit(___);}
#if 0
#line 2914
{ 
#line 2915
__surf2Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 2916
} 
#endif
#line 2918 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ushort2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2919
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2921
::exit(___);}
#if 0
#line 2919
{ 
#line 2920
__surf2Dwrites2(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2921
} 
#endif
#line 2923 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(short4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2924
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2926
::exit(___);}
#if 0
#line 2924
{ 
#line 2925
__surf2Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 2926
} 
#endif
#line 2928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ushort4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2929
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2931
::exit(___);}
#if 0
#line 2929
{ 
#line 2930
__surf2Dwrites4(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2931
} 
#endif
#line 2933 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(int val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2934
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2936
::exit(___);}
#if 0
#line 2934
{ 
#line 2935
__surf2Dwriteu1(make_uint1((unsigned)val), surf, x, y, cudaBoundaryModeTrap); 
#line 2936
} 
#endif
#line 2938 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(unsigned val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2939
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2941
::exit(___);}
#if 0
#line 2939
{ 
#line 2940
__surf2Dwriteu1(make_uint1(val), surf, x, y, cudaBoundaryModeTrap); 
#line 2941
} 
#endif
#line 2943 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(int1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2944
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2946
::exit(___);}
#if 0
#line 2944
{ 
#line 2945
__surf2Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 2946
} 
#endif
#line 2948 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(uint1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2949
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2951
::exit(___);}
#if 0
#line 2949
{ 
#line 2950
__surf2Dwriteu1(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2951
} 
#endif
#line 2953 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(int2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2954
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2956
::exit(___);}
#if 0
#line 2954
{ 
#line 2955
__surf2Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 2956
} 
#endif
#line 2958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(uint2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2959
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2961
::exit(___);}
#if 0
#line 2959
{ 
#line 2960
__surf2Dwriteu2(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2961
} 
#endif
#line 2963 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(int4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2964
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2966
::exit(___);}
#if 0
#line 2964
{ 
#line 2965
__surf2Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 2966
} 
#endif
#line 2968 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(uint4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2969
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2971
::exit(___);}
#if 0
#line 2969
{ 
#line 2970
__surf2Dwriteu4(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2971
} 
#endif
#line 2973 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(__int64 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2974
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2976
::exit(___);}
#if 0
#line 2974
{ 
#line 2975
__surf2Dwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, cudaBoundaryModeTrap); 
#line 2976
} 
#endif
#line 2978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(unsigned __int64 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2979
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2981
::exit(___);}
#if 0
#line 2979
{ 
#line 2980
__surf2Dwritel1(make_ulonglong1(val), surf, x, y, cudaBoundaryModeTrap); 
#line 2981
} 
#endif
#line 2983 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(longlong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2984
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2986
::exit(___);}
#if 0
#line 2984
{ 
#line 2985
__surf2Dwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 2986
} 
#endif
#line 2988 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ulonglong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2989
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2991
::exit(___);}
#if 0
#line 2989
{ 
#line 2990
__surf2Dwritel1(val, surf, x, y, cudaBoundaryModeTrap); 
#line 2991
} 
#endif
#line 2993 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(longlong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2994
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2996
::exit(___);}
#if 0
#line 2994
{ 
#line 2995
__surf2Dwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 2996
} 
#endif
#line 2998 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ulonglong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2999
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3001
::exit(___);}
#if 0
#line 2999
{ 
#line 3000
__surf2Dwritel2(val, surf, x, y, cudaBoundaryModeTrap); 
#line 3001
} 
#endif
#line 3005 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3006
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3008
::exit(___);}
#if 0
#line 3006
{ 
#line 3007
__surf2Dwriteu1(make_uint1((unsigned)val), surf, x, y, cudaBoundaryModeTrap); 
#line 3008
} 
#endif
#line 3010 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(unsigned long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3011
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3013
::exit(___);}
#if 0
#line 3011
{ 
#line 3012
__surf2Dwriteu1(make_uint1((unsigned)val), surf, x, y, cudaBoundaryModeTrap); 
#line 3013
} 
#endif
#line 3015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(long1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3016
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3018
::exit(___);}
#if 0
#line 3016
{ 
#line 3017
__surf2Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 3018
} 
#endif
#line 3020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ulong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3021
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3023
::exit(___);}
#if 0
#line 3021
{ 
#line 3022
__surf2Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 3023
} 
#endif
#line 3025 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(long2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3026
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3028
::exit(___);}
#if 0
#line 3026
{ 
#line 3027
__surf2Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 3028
} 
#endif
#line 3030 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ulong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3031
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3033
::exit(___);}
#if 0
#line 3031
{ 
#line 3032
__surf2Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 3033
} 
#endif
#line 3035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(long4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3036
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3038
::exit(___);}
#if 0
#line 3036
{ 
#line 3037
__surf2Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 3038
} 
#endif
#line 3040 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(ulong4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3041
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3043
::exit(___);}
#if 0
#line 3041
{ 
#line 3042
__surf2Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 3043
} 
#endif
#line 3047 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(float val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3048
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3050
::exit(___);}
#if 0
#line 3048
{ 
#line 3049
__surf2Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, cudaBoundaryModeTrap); 
#line 3050
} 
#endif
#line 3052 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(float1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3053
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3055
::exit(___);}
#if 0
#line 3053
{ 
#line 3054
__surf2Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 3055
} 
#endif
#line 3057 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(float2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3058
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3060
::exit(___);}
#if 0
#line 3058
{ 
#line 3059
__surf2Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, cudaBoundaryModeTrap); 
#line 3060
} 
#endif
#line 3062 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(float4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3063
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 3065
::exit(___);}
#if 0
#line 3063
{ 
#line 3064
__surf2Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 3065
} 
#endif
#line 3101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3102
surf3Dwrite(T val, ::surface< void, 3>  surf, int x, int y, int z, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3103
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
#line 3121
::exit(___);}
#if 0
#line 3103
{ 
#line 3104
union { 
#line 3105
T val; 
#line 3106
::uchar1 c1; 
#line 3107
::ushort1 s1; 
#line 3108
::uint1 u1; 
#line 3109
::uint2 u2; 
#line 3110
::uint4 u4; 
#line 3111
} tmp; 
#line 3113
(tmp.val) = val; 
#line 3115
(s == 1) ? ((void)__surf3Dwritec1(tmp.c1, surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf3Dwrites1(tmp.s1, surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf3Dwriteu1(tmp.u1, surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf3Dwriteu2(tmp.u2, surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf3Dwriteu4(tmp.u4, surf, x, y, z, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 3121
} 
#endif
#line 3123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3124
surf3Dwrite(T val, ::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3125
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3127
::exit(___);}
#if 0
#line 3125
{ ; 
#line 3126
surf3Dwrite(val, surf, x, y, z, (int)sizeof(T), mode); 
#line 3127
} 
#endif
#line 3130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3131
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3133
::exit(___);}
#if 0
#line 3131
{ 
#line 3132
__surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3133
} 
#endif
#line 3135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(signed char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3136
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3138
::exit(___);}
#if 0
#line 3136
{ 
#line 3137
__surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3138
} 
#endif
#line 3140 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(unsigned char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3141
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3143
::exit(___);}
#if 0
#line 3141
{ 
#line 3142
__surf3Dwritec1(make_uchar1(val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3143
} 
#endif
#line 3145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(char1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3146
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3148
::exit(___);}
#if 0
#line 3146
{ 
#line 3147
__surf3Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3148
} 
#endif
#line 3150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(uchar1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3151
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3153
::exit(___);}
#if 0
#line 3151
{ 
#line 3152
__surf3Dwritec1(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3153
} 
#endif
#line 3155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(char2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3156
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3158
::exit(___);}
#if 0
#line 3156
{ 
#line 3157
__surf3Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3158
} 
#endif
#line 3160 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(uchar2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3161
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3163
::exit(___);}
#if 0
#line 3161
{ 
#line 3162
__surf3Dwritec2(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3163
} 
#endif
#line 3165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(char4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3166
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3168
::exit(___);}
#if 0
#line 3166
{ 
#line 3167
__surf3Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3168
} 
#endif
#line 3170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(uchar4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3171
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3173
::exit(___);}
#if 0
#line 3171
{ 
#line 3172
__surf3Dwritec4(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3173
} 
#endif
#line 3175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3176
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3178
::exit(___);}
#if 0
#line 3176
{ 
#line 3177
__surf3Dwrites1(make_ushort1((unsigned short)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3178
} 
#endif
#line 3180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(unsigned short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3181
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3183
::exit(___);}
#if 0
#line 3181
{ 
#line 3182
__surf3Dwrites1(make_ushort1(val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3183
} 
#endif
#line 3185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(short1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3186
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3188
::exit(___);}
#if 0
#line 3186
{ 
#line 3187
__surf3Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3188
} 
#endif
#line 3190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ushort1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3191
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3193
::exit(___);}
#if 0
#line 3191
{ 
#line 3192
__surf3Dwrites1(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3193
} 
#endif
#line 3195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(short2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3196
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3198
::exit(___);}
#if 0
#line 3196
{ 
#line 3197
__surf3Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3198
} 
#endif
#line 3200 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ushort2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3201
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3203
::exit(___);}
#if 0
#line 3201
{ 
#line 3202
__surf3Dwrites2(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3203
} 
#endif
#line 3205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(short4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3206
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3208
::exit(___);}
#if 0
#line 3206
{ 
#line 3207
__surf3Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3208
} 
#endif
#line 3210 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ushort4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3211
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3213
::exit(___);}
#if 0
#line 3211
{ 
#line 3212
__surf3Dwrites4(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3213
} 
#endif
#line 3215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(int val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3216
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3218
::exit(___);}
#if 0
#line 3216
{ 
#line 3217
__surf3Dwriteu1(make_uint1((unsigned)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3218
} 
#endif
#line 3220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(unsigned val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3221
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3223
::exit(___);}
#if 0
#line 3221
{ 
#line 3222
__surf3Dwriteu1(make_uint1(val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3223
} 
#endif
#line 3225 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(int1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3226
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3228
::exit(___);}
#if 0
#line 3226
{ 
#line 3227
__surf3Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3228
} 
#endif
#line 3230 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(uint1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3231
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3233
::exit(___);}
#if 0
#line 3231
{ 
#line 3232
__surf3Dwriteu1(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3233
} 
#endif
#line 3235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(int2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3236
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3238
::exit(___);}
#if 0
#line 3236
{ 
#line 3237
__surf3Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3238
} 
#endif
#line 3240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(uint2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3241
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3243
::exit(___);}
#if 0
#line 3241
{ 
#line 3242
__surf3Dwriteu2(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3243
} 
#endif
#line 3245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(int4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3246
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3248
::exit(___);}
#if 0
#line 3246
{ 
#line 3247
__surf3Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3248
} 
#endif
#line 3250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(uint4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3251
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3253
::exit(___);}
#if 0
#line 3251
{ 
#line 3252
__surf3Dwriteu4(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3253
} 
#endif
#line 3255 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(__int64 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3256
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3258
::exit(___);}
#if 0
#line 3256
{ 
#line 3257
__surf3Dwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3258
} 
#endif
#line 3260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(unsigned __int64 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3261
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3263
::exit(___);}
#if 0
#line 3261
{ 
#line 3262
__surf3Dwritel1(make_ulonglong1(val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3263
} 
#endif
#line 3265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(longlong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3266
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3268
::exit(___);}
#if 0
#line 3266
{ 
#line 3267
__surf3Dwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3268
} 
#endif
#line 3270 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ulonglong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3271
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3273
::exit(___);}
#if 0
#line 3271
{ 
#line 3272
__surf3Dwritel1(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3273
} 
#endif
#line 3275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(longlong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3276
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3278
::exit(___);}
#if 0
#line 3276
{ 
#line 3277
__surf3Dwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3278
} 
#endif
#line 3280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ulonglong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3281
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3283
::exit(___);}
#if 0
#line 3281
{ 
#line 3282
__surf3Dwritel2(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 3283
} 
#endif
#line 3287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3288
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3290
::exit(___);}
#if 0
#line 3288
{ 
#line 3289
__surf3Dwriteu1(make_uint1((unsigned)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3290
} 
#endif
#line 3292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(unsigned long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3293
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3295
::exit(___);}
#if 0
#line 3293
{ 
#line 3294
__surf3Dwriteu1(make_uint1((unsigned)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3295
} 
#endif
#line 3297 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(long1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3298
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3300
::exit(___);}
#if 0
#line 3298
{ 
#line 3299
__surf3Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3300
} 
#endif
#line 3302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ulong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3303
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3305
::exit(___);}
#if 0
#line 3303
{ 
#line 3304
__surf3Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3305
} 
#endif
#line 3307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(long2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3308
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3310
::exit(___);}
#if 0
#line 3308
{ 
#line 3309
__surf3Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3310
} 
#endif
#line 3312 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ulong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3313
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3315
::exit(___);}
#if 0
#line 3313
{ 
#line 3314
__surf3Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3315
} 
#endif
#line 3317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(long4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3318
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3320
::exit(___);}
#if 0
#line 3318
{ 
#line 3319
__surf3Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3320
} 
#endif
#line 3322 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(ulong4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3323
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3325
::exit(___);}
#if 0
#line 3323
{ 
#line 3324
__surf3Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3325
} 
#endif
#line 3329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(float val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3330
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3332
::exit(___);}
#if 0
#line 3330
{ 
#line 3331
__surf3Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3332
} 
#endif
#line 3334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(float1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3335
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3337
::exit(___);}
#if 0
#line 3335
{ 
#line 3336
__surf3Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3337
} 
#endif
#line 3339 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(float2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3340
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3342
::exit(___);}
#if 0
#line 3340
{ 
#line 3341
__surf3Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3342
} 
#endif
#line 3344 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(float4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3345
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 3347
::exit(___);}
#if 0
#line 3345
{ 
#line 3346
__surf3Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 3347
} 
#endif
#line 3383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3384
surf1DLayeredwrite(T val, ::surface< void, 241>  surf, int x, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3385
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
#line 3403
::exit(___);}
#if 0
#line 3385
{ 
#line 3386
union { 
#line 3387
T val; 
#line 3388
::uchar1 c1; 
#line 3389
::ushort1 s1; 
#line 3390
::uint1 u1; 
#line 3391
::uint2 u2; 
#line 3392
::uint4 u4; 
#line 3393
} tmp; 
#line 3395
(tmp.val) = val; 
#line 3397
(s == 1) ? ((void)__surf1DLayeredwritec1(tmp.c1, surf, x, layer, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf1DLayeredwrites1(tmp.s1, surf, x, layer, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf1DLayeredwriteu1(tmp.u1, surf, x, layer, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf1DLayeredwriteu2(tmp.u2, surf, x, layer, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf1DLayeredwriteu4(tmp.u4, surf, x, layer, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 3403
} 
#endif
#line 3405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3406
surf1DLayeredwrite(T val, ::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3407
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3409
::exit(___);}
#if 0
#line 3407
{ ; 
#line 3408
surf1DLayeredwrite(val, surf, x, layer, (int)sizeof(T), mode); 
#line 3409
} 
#endif
#line 3412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3413
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3415
::exit(___);}
#if 0
#line 3413
{ 
#line 3414
__surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3415
} 
#endif
#line 3417 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(signed char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3418
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3420
::exit(___);}
#if 0
#line 3418
{ 
#line 3419
__surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3420
} 
#endif
#line 3422 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3423
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3425
::exit(___);}
#if 0
#line 3423
{ 
#line 3424
__surf1DLayeredwritec1(make_uchar1(val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3425
} 
#endif
#line 3427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(char1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3428
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3430
::exit(___);}
#if 0
#line 3428
{ 
#line 3429
__surf1DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3430
} 
#endif
#line 3432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(uchar1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3433
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3435
::exit(___);}
#if 0
#line 3433
{ 
#line 3434
__surf1DLayeredwritec1(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3435
} 
#endif
#line 3437 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(char2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3438
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3440
::exit(___);}
#if 0
#line 3438
{ 
#line 3439
__surf1DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3440
} 
#endif
#line 3442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(uchar2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3443
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3445
::exit(___);}
#if 0
#line 3443
{ 
#line 3444
__surf1DLayeredwritec2(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3445
} 
#endif
#line 3447 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(char4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3448
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3450
::exit(___);}
#if 0
#line 3448
{ 
#line 3449
__surf1DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3450
} 
#endif
#line 3452 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(uchar4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3453
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3455
::exit(___);}
#if 0
#line 3453
{ 
#line 3454
__surf1DLayeredwritec4(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3455
} 
#endif
#line 3457 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3458
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3460
::exit(___);}
#if 0
#line 3458
{ 
#line 3459
__surf1DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3460
} 
#endif
#line 3462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3463
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3465
::exit(___);}
#if 0
#line 3463
{ 
#line 3464
__surf1DLayeredwrites1(make_ushort1(val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3465
} 
#endif
#line 3467 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(short1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3468
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3470
::exit(___);}
#if 0
#line 3468
{ 
#line 3469
__surf1DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3470
} 
#endif
#line 3472 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ushort1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3473
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3475
::exit(___);}
#if 0
#line 3473
{ 
#line 3474
__surf1DLayeredwrites1(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3475
} 
#endif
#line 3477 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(short2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3478
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3480
::exit(___);}
#if 0
#line 3478
{ 
#line 3479
__surf1DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3480
} 
#endif
#line 3482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ushort2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3483
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3485
::exit(___);}
#if 0
#line 3483
{ 
#line 3484
__surf1DLayeredwrites2(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3485
} 
#endif
#line 3487 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(short4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3488
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3490
::exit(___);}
#if 0
#line 3488
{ 
#line 3489
__surf1DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3490
} 
#endif
#line 3492 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ushort4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3493
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3495
::exit(___);}
#if 0
#line 3493
{ 
#line 3494
__surf1DLayeredwrites4(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3495
} 
#endif
#line 3497 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(int val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3498
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3500
::exit(___);}
#if 0
#line 3498
{ 
#line 3499
__surf1DLayeredwriteu1(make_uint1((unsigned)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3500
} 
#endif
#line 3502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3503
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3505
::exit(___);}
#if 0
#line 3503
{ 
#line 3504
__surf1DLayeredwriteu1(make_uint1(val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3505
} 
#endif
#line 3507 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(int1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3508
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3510
::exit(___);}
#if 0
#line 3508
{ 
#line 3509
__surf1DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3510
} 
#endif
#line 3512 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(uint1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3513
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3515
::exit(___);}
#if 0
#line 3513
{ 
#line 3514
__surf1DLayeredwriteu1(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3515
} 
#endif
#line 3517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(int2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3518
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3520
::exit(___);}
#if 0
#line 3518
{ 
#line 3519
__surf1DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3520
} 
#endif
#line 3522 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(uint2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3523
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3525
::exit(___);}
#if 0
#line 3523
{ 
#line 3524
__surf1DLayeredwriteu2(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3525
} 
#endif
#line 3527 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(int4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3528
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3530
::exit(___);}
#if 0
#line 3528
{ 
#line 3529
__surf1DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3530
} 
#endif
#line 3532 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(uint4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3533
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3535
::exit(___);}
#if 0
#line 3533
{ 
#line 3534
__surf1DLayeredwriteu4(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3535
} 
#endif
#line 3537 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(__int64 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3538
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3540
::exit(___);}
#if 0
#line 3538
{ 
#line 3539
__surf1DLayeredwritel1(make_ulonglong1((unsigned __int64)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3540
} 
#endif
#line 3542 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned __int64 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3543
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3545
::exit(___);}
#if 0
#line 3543
{ 
#line 3544
__surf1DLayeredwritel1(make_ulonglong1(val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3545
} 
#endif
#line 3547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(longlong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3548
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3550
::exit(___);}
#if 0
#line 3548
{ 
#line 3549
__surf1DLayeredwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3550
} 
#endif
#line 3552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ulonglong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3553
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3555
::exit(___);}
#if 0
#line 3553
{ 
#line 3554
__surf1DLayeredwritel1(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3555
} 
#endif
#line 3557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(longlong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3558
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3560
::exit(___);}
#if 0
#line 3558
{ 
#line 3559
__surf1DLayeredwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3560
} 
#endif
#line 3562 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ulonglong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3563
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3565
::exit(___);}
#if 0
#line 3563
{ 
#line 3564
__surf1DLayeredwritel2(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 3565
} 
#endif
#line 3569 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3570
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3572
::exit(___);}
#if 0
#line 3570
{ 
#line 3571
__surf1DLayeredwriteu1(make_uint1((unsigned)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3572
} 
#endif
#line 3574 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3575
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3577
::exit(___);}
#if 0
#line 3575
{ 
#line 3576
__surf1DLayeredwriteu1(make_uint1((unsigned)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 3577
} 
#endif
#line 3579 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(long1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3580
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3582
::exit(___);}
#if 0
#line 3580
{ 
#line 3581
__surf1DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3582
} 
#endif
#line 3584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ulong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3585
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3587
::exit(___);}
#if 0
#line 3585
{ 
#line 3586
__surf1DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3587
} 
#endif
#line 3589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(long2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3590
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3592
::exit(___);}
#if 0
#line 3590
{ 
#line 3591
__surf1DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3592
} 
#endif
#line 3594 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ulong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3595
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3597
::exit(___);}
#if 0
#line 3595
{ 
#line 3596
__surf1DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3597
} 
#endif
#line 3599 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(long4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3600
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3602
::exit(___);}
#if 0
#line 3600
{ 
#line 3601
__surf1DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3602
} 
#endif
#line 3604 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(ulong4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3605
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3607
::exit(___);}
#if 0
#line 3605
{ 
#line 3606
__surf1DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3607
} 
#endif
#line 3611 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(float val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3612
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3614
::exit(___);}
#if 0
#line 3612
{ 
#line 3613
__surf1DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3614
} 
#endif
#line 3616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(float1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3617
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3619
::exit(___);}
#if 0
#line 3617
{ 
#line 3618
__surf1DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3619
} 
#endif
#line 3621 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(float2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3622
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3624
::exit(___);}
#if 0
#line 3622
{ 
#line 3623
__surf1DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, layer, cudaBoundaryModeTrap); 
#line 3624
} 
#endif
#line 3626 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(float4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3627
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3629
::exit(___);}
#if 0
#line 3627
{ 
#line 3628
__surf1DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 3629
} 
#endif
#line 3665 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3666
surf2DLayeredwrite(T val, ::surface< void, 242>  surf, int x, int y, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3667
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
#line 3685
::exit(___);}
#if 0
#line 3667
{ 
#line 3668
union { 
#line 3669
T val; 
#line 3670
::uchar1 c1; 
#line 3671
::ushort1 s1; 
#line 3672
::uint1 u1; 
#line 3673
::uint2 u2; 
#line 3674
::uint4 u4; 
#line 3675
} tmp; 
#line 3677
(tmp.val) = val; 
#line 3679
(s == 1) ? ((void)__surf2DLayeredwritec1(tmp.c1, surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf2DLayeredwrites1(tmp.s1, surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf2DLayeredwriteu1(tmp.u1, surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf2DLayeredwriteu2(tmp.u2, surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf2DLayeredwriteu4(tmp.u4, surf, x, y, layer, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 3685
} 
#endif
#line 3687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3688
surf2DLayeredwrite(T val, ::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3689
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3691
::exit(___);}
#if 0
#line 3689
{ ; 
#line 3690
surf2DLayeredwrite(val, surf, x, y, layer, (int)sizeof(T), mode); 
#line 3691
} 
#endif
#line 3694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3695
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3697
::exit(___);}
#if 0
#line 3695
{ 
#line 3696
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3697
} 
#endif
#line 3699 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(signed char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3700
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3702
::exit(___);}
#if 0
#line 3700
{ 
#line 3701
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3702
} 
#endif
#line 3704 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3705
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3707
::exit(___);}
#if 0
#line 3705
{ 
#line 3706
__surf2DLayeredwritec1(make_uchar1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3707
} 
#endif
#line 3709 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(char1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3710
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3712
::exit(___);}
#if 0
#line 3710
{ 
#line 3711
__surf2DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3712
} 
#endif
#line 3714 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(uchar1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3715
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3717
::exit(___);}
#if 0
#line 3715
{ 
#line 3716
__surf2DLayeredwritec1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3717
} 
#endif
#line 3719 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(char2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3720
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3722
::exit(___);}
#if 0
#line 3720
{ 
#line 3721
__surf2DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3722
} 
#endif
#line 3724 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(uchar2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3725
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3727
::exit(___);}
#if 0
#line 3725
{ 
#line 3726
__surf2DLayeredwritec2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3727
} 
#endif
#line 3729 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(char4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3730
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3732
::exit(___);}
#if 0
#line 3730
{ 
#line 3731
__surf2DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3732
} 
#endif
#line 3734 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(uchar4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3735
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3737
::exit(___);}
#if 0
#line 3735
{ 
#line 3736
__surf2DLayeredwritec4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3737
} 
#endif
#line 3739 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3740
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3742
::exit(___);}
#if 0
#line 3740
{ 
#line 3741
__surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3742
} 
#endif
#line 3744 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3745
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3747
::exit(___);}
#if 0
#line 3745
{ 
#line 3746
__surf2DLayeredwrites1(make_ushort1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3747
} 
#endif
#line 3749 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(short1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3750
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3752
::exit(___);}
#if 0
#line 3750
{ 
#line 3751
__surf2DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3752
} 
#endif
#line 3754 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ushort1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3755
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3757
::exit(___);}
#if 0
#line 3755
{ 
#line 3756
__surf2DLayeredwrites1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3757
} 
#endif
#line 3759 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(short2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3760
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3762
::exit(___);}
#if 0
#line 3760
{ 
#line 3761
__surf2DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3762
} 
#endif
#line 3764 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ushort2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3765
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3767
::exit(___);}
#if 0
#line 3765
{ 
#line 3766
__surf2DLayeredwrites2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3767
} 
#endif
#line 3769 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(short4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3770
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3772
::exit(___);}
#if 0
#line 3770
{ 
#line 3771
__surf2DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3772
} 
#endif
#line 3774 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ushort4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3775
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3777
::exit(___);}
#if 0
#line 3775
{ 
#line 3776
__surf2DLayeredwrites4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3777
} 
#endif
#line 3779 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(int val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3780
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3782
::exit(___);}
#if 0
#line 3780
{ 
#line 3781
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3782
} 
#endif
#line 3784 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3785
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3787
::exit(___);}
#if 0
#line 3785
{ 
#line 3786
__surf2DLayeredwriteu1(make_uint1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3787
} 
#endif
#line 3789 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(int1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3790
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3792
::exit(___);}
#if 0
#line 3790
{ 
#line 3791
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3792
} 
#endif
#line 3794 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(uint1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3795
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3797
::exit(___);}
#if 0
#line 3795
{ 
#line 3796
__surf2DLayeredwriteu1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3797
} 
#endif
#line 3799 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(int2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3800
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3802
::exit(___);}
#if 0
#line 3800
{ 
#line 3801
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3802
} 
#endif
#line 3804 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(uint2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3805
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3807
::exit(___);}
#if 0
#line 3805
{ 
#line 3806
__surf2DLayeredwriteu2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3807
} 
#endif
#line 3809 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(int4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3810
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3812
::exit(___);}
#if 0
#line 3810
{ 
#line 3811
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3812
} 
#endif
#line 3814 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(uint4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3815
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3817
::exit(___);}
#if 0
#line 3815
{ 
#line 3816
__surf2DLayeredwriteu4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3817
} 
#endif
#line 3819 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(__int64 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3820
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3822
::exit(___);}
#if 0
#line 3820
{ 
#line 3821
__surf2DLayeredwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3822
} 
#endif
#line 3824 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned __int64 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3825
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3827
::exit(___);}
#if 0
#line 3825
{ 
#line 3826
__surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3827
} 
#endif
#line 3829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(longlong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3830
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3832
::exit(___);}
#if 0
#line 3830
{ 
#line 3831
__surf2DLayeredwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3832
} 
#endif
#line 3834 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ulonglong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3835
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3837
::exit(___);}
#if 0
#line 3835
{ 
#line 3836
__surf2DLayeredwritel1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3837
} 
#endif
#line 3839 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(longlong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3840
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3842
::exit(___);}
#if 0
#line 3840
{ 
#line 3841
__surf2DLayeredwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3842
} 
#endif
#line 3844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ulonglong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3845
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3847
::exit(___);}
#if 0
#line 3845
{ 
#line 3846
__surf2DLayeredwritel2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3847
} 
#endif
#line 3851 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3852
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3854
::exit(___);}
#if 0
#line 3852
{ 
#line 3853
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3854
} 
#endif
#line 3856 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3857
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3859
::exit(___);}
#if 0
#line 3857
{ 
#line 3858
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3859
} 
#endif
#line 3861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(long1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3862
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3864
::exit(___);}
#if 0
#line 3862
{ 
#line 3863
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3864
} 
#endif
#line 3866 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ulong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3867
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3869
::exit(___);}
#if 0
#line 3867
{ 
#line 3868
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3869
} 
#endif
#line 3871 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(long2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3872
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3874
::exit(___);}
#if 0
#line 3872
{ 
#line 3873
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3874
} 
#endif
#line 3876 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ulong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3877
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3879
::exit(___);}
#if 0
#line 3877
{ 
#line 3878
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3879
} 
#endif
#line 3881 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(long4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3882
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3884
::exit(___);}
#if 0
#line 3882
{ 
#line 3883
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3884
} 
#endif
#line 3886 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(ulong4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3887
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3889
::exit(___);}
#if 0
#line 3887
{ 
#line 3888
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3889
} 
#endif
#line 3893 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(float val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3894
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3896
::exit(___);}
#if 0
#line 3894
{ 
#line 3895
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3896
} 
#endif
#line 3898 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(float1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3899
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3901
::exit(___);}
#if 0
#line 3899
{ 
#line 3900
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3901
} 
#endif
#line 3903 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(float2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3904
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3906
::exit(___);}
#if 0
#line 3904
{ 
#line 3905
__surf2DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3906
} 
#endif
#line 3908 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(float4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3909
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3911
::exit(___);}
#if 0
#line 3909
{ 
#line 3910
__surf2DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 3911
} 
#endif
#line 3947 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3948
surfCubemapwrite(T val, ::surface< void, 12>  surf, int x, int y, int face, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3949
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
#line 3967
::exit(___);}
#if 0
#line 3949
{ 
#line 3950
union { 
#line 3951
T val; 
#line 3952
::uchar1 c1; 
#line 3953
::ushort1 s1; 
#line 3954
::uint1 u1; 
#line 3955
::uint2 u2; 
#line 3956
::uint4 u4; 
#line 3957
} tmp; 
#line 3959
(tmp.val) = val; 
#line 3961
(s == 1) ? ((void)__surfCubemapwritec1(tmp.c1, surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surfCubemapwrites1(tmp.s1, surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surfCubemapwriteu1(tmp.u1, surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surfCubemapwriteu2(tmp.u2, surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surfCubemapwriteu4(tmp.u4, surf, x, y, face, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 3967
} 
#endif
#line 3969 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3970
surfCubemapwrite(T val, ::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3971
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 3973
::exit(___);}
#if 0
#line 3971
{ ; 
#line 3972
surfCubemapwrite(val, surf, x, y, face, (int)sizeof(T), mode); 
#line 3973
} 
#endif
#line 3976 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3977
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 3979
::exit(___);}
#if 0
#line 3977
{ 
#line 3978
__surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 3979
} 
#endif
#line 3981 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(signed char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3982
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 3984
::exit(___);}
#if 0
#line 3982
{ 
#line 3983
__surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 3984
} 
#endif
#line 3986 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(unsigned char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3987
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 3989
::exit(___);}
#if 0
#line 3987
{ 
#line 3988
__surfCubemapwritec1(make_uchar1(val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 3989
} 
#endif
#line 3991 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(char1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3992
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 3994
::exit(___);}
#if 0
#line 3992
{ 
#line 3993
__surfCubemapwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 3994
} 
#endif
#line 3996 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(uchar1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3997
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 3999
::exit(___);}
#if 0
#line 3997
{ 
#line 3998
__surfCubemapwritec1(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 3999
} 
#endif
#line 4001 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(char2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4002
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4004
::exit(___);}
#if 0
#line 4002
{ 
#line 4003
__surfCubemapwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4004
} 
#endif
#line 4006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(uchar2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4007
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4009
::exit(___);}
#if 0
#line 4007
{ 
#line 4008
__surfCubemapwritec2(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4009
} 
#endif
#line 4011 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(char4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4012
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4014
::exit(___);}
#if 0
#line 4012
{ 
#line 4013
__surfCubemapwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4014
} 
#endif
#line 4016 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(uchar4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4017
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4019
::exit(___);}
#if 0
#line 4017
{ 
#line 4018
__surfCubemapwritec4(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4019
} 
#endif
#line 4021 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4022
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4024
::exit(___);}
#if 0
#line 4022
{ 
#line 4023
__surfCubemapwrites1(make_ushort1((unsigned short)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4024
} 
#endif
#line 4026 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(unsigned short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4027
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4029
::exit(___);}
#if 0
#line 4027
{ 
#line 4028
__surfCubemapwrites1(make_ushort1(val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4029
} 
#endif
#line 4031 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(short1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4032
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4034
::exit(___);}
#if 0
#line 4032
{ 
#line 4033
__surfCubemapwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4034
} 
#endif
#line 4036 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ushort1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4037
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4039
::exit(___);}
#if 0
#line 4037
{ 
#line 4038
__surfCubemapwrites1(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4039
} 
#endif
#line 4041 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(short2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4042
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4044
::exit(___);}
#if 0
#line 4042
{ 
#line 4043
__surfCubemapwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4044
} 
#endif
#line 4046 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ushort2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4047
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4049
::exit(___);}
#if 0
#line 4047
{ 
#line 4048
__surfCubemapwrites2(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4049
} 
#endif
#line 4051 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(short4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4052
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4054
::exit(___);}
#if 0
#line 4052
{ 
#line 4053
__surfCubemapwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4054
} 
#endif
#line 4056 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ushort4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4057
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4059
::exit(___);}
#if 0
#line 4057
{ 
#line 4058
__surfCubemapwrites4(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4059
} 
#endif
#line 4061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(int val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4062
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4064
::exit(___);}
#if 0
#line 4062
{ 
#line 4063
__surfCubemapwriteu1(make_uint1((unsigned)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4064
} 
#endif
#line 4066 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(unsigned val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4067
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4069
::exit(___);}
#if 0
#line 4067
{ 
#line 4068
__surfCubemapwriteu1(make_uint1(val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4069
} 
#endif
#line 4071 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(int1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4072
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4074
::exit(___);}
#if 0
#line 4072
{ 
#line 4073
__surfCubemapwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4074
} 
#endif
#line 4076 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(uint1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4077
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4079
::exit(___);}
#if 0
#line 4077
{ 
#line 4078
__surfCubemapwriteu1(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4079
} 
#endif
#line 4081 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(int2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4082
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4084
::exit(___);}
#if 0
#line 4082
{ 
#line 4083
__surfCubemapwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4084
} 
#endif
#line 4086 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(uint2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4087
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4089
::exit(___);}
#if 0
#line 4087
{ 
#line 4088
__surfCubemapwriteu2(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4089
} 
#endif
#line 4091 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(int4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4092
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4094
::exit(___);}
#if 0
#line 4092
{ 
#line 4093
__surfCubemapwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4094
} 
#endif
#line 4096 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(uint4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4097
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4099
::exit(___);}
#if 0
#line 4097
{ 
#line 4098
__surfCubemapwriteu4(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4099
} 
#endif
#line 4101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(__int64 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4102
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4104
::exit(___);}
#if 0
#line 4102
{ 
#line 4103
__surfCubemapwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4104
} 
#endif
#line 4106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(unsigned __int64 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4107
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4109
::exit(___);}
#if 0
#line 4107
{ 
#line 4108
__surfCubemapwritel1(make_ulonglong1(val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4109
} 
#endif
#line 4111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(longlong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4112
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4114
::exit(___);}
#if 0
#line 4112
{ 
#line 4113
__surfCubemapwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4114
} 
#endif
#line 4116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ulonglong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4117
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4119
::exit(___);}
#if 0
#line 4117
{ 
#line 4118
__surfCubemapwritel1(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4119
} 
#endif
#line 4121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(longlong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4122
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4124
::exit(___);}
#if 0
#line 4122
{ 
#line 4123
__surfCubemapwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4124
} 
#endif
#line 4126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ulonglong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4127
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4129
::exit(___);}
#if 0
#line 4127
{ 
#line 4128
__surfCubemapwritel2(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 4129
} 
#endif
#line 4133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4134
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4136
::exit(___);}
#if 0
#line 4134
{ 
#line 4135
__surfCubemapwriteu1(make_uint1((unsigned)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4136
} 
#endif
#line 4138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(unsigned long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4139
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4141
::exit(___);}
#if 0
#line 4139
{ 
#line 4140
__surfCubemapwriteu1(make_uint1((unsigned)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4141
} 
#endif
#line 4143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(long1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4144
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4146
::exit(___);}
#if 0
#line 4144
{ 
#line 4145
__surfCubemapwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4146
} 
#endif
#line 4148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ulong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4149
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4151
::exit(___);}
#if 0
#line 4149
{ 
#line 4150
__surfCubemapwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4151
} 
#endif
#line 4153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(long2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4154
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4156
::exit(___);}
#if 0
#line 4154
{ 
#line 4155
__surfCubemapwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4156
} 
#endif
#line 4158 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ulong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4159
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4161
::exit(___);}
#if 0
#line 4159
{ 
#line 4160
__surfCubemapwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4161
} 
#endif
#line 4163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(long4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4164
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4166
::exit(___);}
#if 0
#line 4164
{ 
#line 4165
__surfCubemapwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4166
} 
#endif
#line 4168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(ulong4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4169
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4171
::exit(___);}
#if 0
#line 4169
{ 
#line 4170
__surfCubemapwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4171
} 
#endif
#line 4175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(float val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4176
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4178
::exit(___);}
#if 0
#line 4176
{ 
#line 4177
__surfCubemapwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4178
} 
#endif
#line 4180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(float1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4181
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4183
::exit(___);}
#if 0
#line 4181
{ 
#line 4182
__surfCubemapwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4183
} 
#endif
#line 4185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(float2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4186
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4188
::exit(___);}
#if 0
#line 4186
{ 
#line 4187
__surfCubemapwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4188
} 
#endif
#line 4190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(float4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4191
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 4193
::exit(___);}
#if 0
#line 4191
{ 
#line 4192
__surfCubemapwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 4193
} 
#endif
#line 4229 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 4230
surfCubemapLayeredwrite(T val, ::surface< void, 252>  surf, int x, int y, int layerFace, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4231
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
#line 4249
::exit(___);}
#if 0
#line 4231
{ 
#line 4232
union { 
#line 4233
T val; 
#line 4234
::uchar1 c1; 
#line 4235
::ushort1 s1; 
#line 4236
::uint1 u1; 
#line 4237
::uint2 u2; 
#line 4238
::uint4 u4; 
#line 4239
} tmp; 
#line 4241
(tmp.val) = val; 
#line 4243
(s == 1) ? ((void)__surfCubemapLayeredwritec1(tmp.c1, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surfCubemapLayeredwrites1(tmp.s1, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surfCubemapLayeredwriteu1(tmp.u1, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surfCubemapLayeredwriteu2(tmp.u2, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surfCubemapLayeredwriteu4(tmp.u4, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 4249
} 
#endif
#line 4251 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 4252
surfCubemapLayeredwrite(T val, ::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4253
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4255
::exit(___);}
#if 0
#line 4253
{ ; 
#line 4254
surfCubemapLayeredwrite(val, surf, x, y, layerFace, (int)sizeof(T), mode); 
#line 4255
} 
#endif
#line 4258 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4259
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4261
::exit(___);}
#if 0
#line 4259
{ 
#line 4260
__surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4261
} 
#endif
#line 4263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(signed char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4264
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4266
::exit(___);}
#if 0
#line 4264
{ 
#line 4265
__surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4266
} 
#endif
#line 4268 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4269
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4271
::exit(___);}
#if 0
#line 4269
{ 
#line 4270
__surfCubemapLayeredwritec1(make_uchar1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4271
} 
#endif
#line 4273 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(char1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4274
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4276
::exit(___);}
#if 0
#line 4274
{ 
#line 4275
__surfCubemapLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4276
} 
#endif
#line 4278 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(uchar1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4279
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4281
::exit(___);}
#if 0
#line 4279
{ 
#line 4280
__surfCubemapLayeredwritec1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4281
} 
#endif
#line 4283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(char2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4284
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4286
::exit(___);}
#if 0
#line 4284
{ 
#line 4285
__surfCubemapLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4286
} 
#endif
#line 4288 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(uchar2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4289
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4291
::exit(___);}
#if 0
#line 4289
{ 
#line 4290
__surfCubemapLayeredwritec2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4291
} 
#endif
#line 4293 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(char4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4294
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4296
::exit(___);}
#if 0
#line 4294
{ 
#line 4295
__surfCubemapLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4296
} 
#endif
#line 4298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(uchar4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4299
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4301
::exit(___);}
#if 0
#line 4299
{ 
#line 4300
__surfCubemapLayeredwritec4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4301
} 
#endif
#line 4303 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4304
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4306
::exit(___);}
#if 0
#line 4304
{ 
#line 4305
__surfCubemapLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4306
} 
#endif
#line 4308 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4309
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4311
::exit(___);}
#if 0
#line 4309
{ 
#line 4310
__surfCubemapLayeredwrites1(make_ushort1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4311
} 
#endif
#line 4313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(short1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4314
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4316
::exit(___);}
#if 0
#line 4314
{ 
#line 4315
__surfCubemapLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4316
} 
#endif
#line 4318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ushort1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4319
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4321
::exit(___);}
#if 0
#line 4319
{ 
#line 4320
__surfCubemapLayeredwrites1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4321
} 
#endif
#line 4323 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(short2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4324
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4326
::exit(___);}
#if 0
#line 4324
{ 
#line 4325
__surfCubemapLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4326
} 
#endif
#line 4328 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ushort2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4329
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4331
::exit(___);}
#if 0
#line 4329
{ 
#line 4330
__surfCubemapLayeredwrites2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4331
} 
#endif
#line 4333 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(short4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4334
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4336
::exit(___);}
#if 0
#line 4334
{ 
#line 4335
__surfCubemapLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4336
} 
#endif
#line 4338 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ushort4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4339
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4341
::exit(___);}
#if 0
#line 4339
{ 
#line 4340
__surfCubemapLayeredwrites4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4341
} 
#endif
#line 4343 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(int val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4344
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4346
::exit(___);}
#if 0
#line 4344
{ 
#line 4345
__surfCubemapLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4346
} 
#endif
#line 4348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4349
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4351
::exit(___);}
#if 0
#line 4349
{ 
#line 4350
__surfCubemapLayeredwriteu1(make_uint1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4351
} 
#endif
#line 4353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(int1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4354
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4356
::exit(___);}
#if 0
#line 4354
{ 
#line 4355
__surfCubemapLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4356
} 
#endif
#line 4358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(uint1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4359
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4361
::exit(___);}
#if 0
#line 4359
{ 
#line 4360
__surfCubemapLayeredwriteu1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4361
} 
#endif
#line 4363 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(int2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4364
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4366
::exit(___);}
#if 0
#line 4364
{ 
#line 4365
__surfCubemapLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4366
} 
#endif
#line 4368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(uint2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4369
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4371
::exit(___);}
#if 0
#line 4369
{ 
#line 4370
__surfCubemapLayeredwriteu2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4371
} 
#endif
#line 4373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(int4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4374
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4376
::exit(___);}
#if 0
#line 4374
{ 
#line 4375
__surfCubemapLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4376
} 
#endif
#line 4378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(uint4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4379
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4381
::exit(___);}
#if 0
#line 4379
{ 
#line 4380
__surfCubemapLayeredwriteu4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4381
} 
#endif
#line 4383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(__int64 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4384
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4386
::exit(___);}
#if 0
#line 4384
{ 
#line 4385
__surfCubemapLayeredwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4386
} 
#endif
#line 4388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned __int64 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4389
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4391
::exit(___);}
#if 0
#line 4389
{ 
#line 4390
__surfCubemapLayeredwritel1(make_ulonglong1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4391
} 
#endif
#line 4393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(longlong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4394
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4396
::exit(___);}
#if 0
#line 4394
{ 
#line 4395
__surfCubemapLayeredwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4396
} 
#endif
#line 4398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulonglong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4399
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4401
::exit(___);}
#if 0
#line 4399
{ 
#line 4400
__surfCubemapLayeredwritel1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4401
} 
#endif
#line 4403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(longlong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4404
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4406
::exit(___);}
#if 0
#line 4404
{ 
#line 4405
__surfCubemapLayeredwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4406
} 
#endif
#line 4408 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulonglong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4409
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4411
::exit(___);}
#if 0
#line 4409
{ 
#line 4410
__surfCubemapLayeredwritel2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4411
} 
#endif
#line 4415 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4416
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4418
::exit(___);}
#if 0
#line 4416
{ 
#line 4417
__surfCubemapLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4418
} 
#endif
#line 4420 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4421
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4423
::exit(___);}
#if 0
#line 4421
{ 
#line 4422
__surfCubemapLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4423
} 
#endif
#line 4425 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(long1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4426
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4428
::exit(___);}
#if 0
#line 4426
{ 
#line 4427
__surfCubemapLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4428
} 
#endif
#line 4430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4431
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4433
::exit(___);}
#if 0
#line 4431
{ 
#line 4432
__surfCubemapLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4433
} 
#endif
#line 4435 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(long2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4436
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4438
::exit(___);}
#if 0
#line 4436
{ 
#line 4437
__surfCubemapLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4438
} 
#endif
#line 4440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4441
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4443
::exit(___);}
#if 0
#line 4441
{ 
#line 4442
__surfCubemapLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4443
} 
#endif
#line 4445 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(long4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4446
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4448
::exit(___);}
#if 0
#line 4446
{ 
#line 4447
__surfCubemapLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4448
} 
#endif
#line 4450 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulong4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4451
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4453
::exit(___);}
#if 0
#line 4451
{ 
#line 4452
__surfCubemapLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4453
} 
#endif
#line 4457 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(float val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4458
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4460
::exit(___);}
#if 0
#line 4458
{ 
#line 4459
__surfCubemapLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4460
} 
#endif
#line 4462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(float1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4463
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4465
::exit(___);}
#if 0
#line 4463
{ 
#line 4464
__surfCubemapLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4465
} 
#endif
#line 4467 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(float2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4468
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4470
::exit(___);}
#if 0
#line 4468
{ 
#line 4469
__surfCubemapLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4470
} 
#endif
#line 4472 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(float4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 4473
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 4475
::exit(___);}
#if 0
#line 4473
{ 
#line 4474
__surfCubemapLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 4475
} 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex1Dfetch(texture< char, 1, cudaReadModeElementType>  t, int x) 
#line 97
{int volatile ___ = 1;(void)t;(void)x;
#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 105
} 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1Dfetch(texture< signed char, 1, cudaReadModeElementType>  t, int x) 
#line 108
{int volatile ___ = 1;(void)t;(void)x;
#line 112
::exit(___);}
#if 0
#line 108
{ 
#line 109
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 111
return (signed char)(v.x); 
#line 112
} 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1Dfetch(texture< unsigned char, 1, cudaReadModeElementType>  t, int x) 
#line 115
{int volatile ___ = 1;(void)t;(void)x;
#line 119
::exit(___);}
#if 0
#line 115
{ 
#line 116
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 118
return (unsigned char)(v.x); 
#line 119
} 
#endif
#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1Dfetch(texture< char1, 1, cudaReadModeElementType>  t, int x) 
#line 122
{int volatile ___ = 1;(void)t;(void)x;
#line 126
::exit(___);}
#if 0
#line 122
{ 
#line 123
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 125
return make_char1(v.x); 
#line 126
} 
#endif
#line 128 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1Dfetch(texture< uchar1, 1, cudaReadModeElementType>  t, int x) 
#line 129
{int volatile ___ = 1;(void)t;(void)x;
#line 133
::exit(___);}
#if 0
#line 129
{ 
#line 130
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 132
return make_uchar1(v.x); 
#line 133
} 
#endif
#line 135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1Dfetch(texture< char2, 1, cudaReadModeElementType>  t, int x) 
#line 136
{int volatile ___ = 1;(void)t;(void)x;
#line 140
::exit(___);}
#if 0
#line 136
{ 
#line 137
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 139
return make_char2(v.x, v.y); 
#line 140
} 
#endif
#line 142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1Dfetch(texture< uchar2, 1, cudaReadModeElementType>  t, int x) 
#line 143
{int volatile ___ = 1;(void)t;(void)x;
#line 147
::exit(___);}
#if 0
#line 143
{ 
#line 144
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 146
return make_uchar2(v.x, v.y); 
#line 147
} 
#endif
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1Dfetch(texture< char4, 1, cudaReadModeElementType>  t, int x) 
#line 150
{int volatile ___ = 1;(void)t;(void)x;
#line 154
::exit(___);}
#if 0
#line 150
{ 
#line 151
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 153
return make_char4(v.x, v.y, v.z, v.w); 
#line 154
} 
#endif
#line 156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1Dfetch(texture< uchar4, 1, cudaReadModeElementType>  t, int x) 
#line 157
{int volatile ___ = 1;(void)t;(void)x;
#line 161
::exit(___);}
#if 0
#line 157
{ 
#line 158
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 160
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 161
} 
#endif
#line 169 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex1Dfetch(texture< short, 1, cudaReadModeElementType>  t, int x) 
#line 170
{int volatile ___ = 1;(void)t;(void)x;
#line 174
::exit(___);}
#if 0
#line 170
{ 
#line 171
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 173
return (short)(v.x); 
#line 174
} 
#endif
#line 176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1Dfetch(texture< unsigned short, 1, cudaReadModeElementType>  t, int x) 
#line 177
{int volatile ___ = 1;(void)t;(void)x;
#line 181
::exit(___);}
#if 0
#line 177
{ 
#line 178
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 180
return (unsigned short)(v.x); 
#line 181
} 
#endif
#line 183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1Dfetch(texture< short1, 1, cudaReadModeElementType>  t, int x) 
#line 184
{int volatile ___ = 1;(void)t;(void)x;
#line 188
::exit(___);}
#if 0
#line 184
{ 
#line 185
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 187
return make_short1(v.x); 
#line 188
} 
#endif
#line 190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1Dfetch(texture< ushort1, 1, cudaReadModeElementType>  t, int x) 
#line 191
{int volatile ___ = 1;(void)t;(void)x;
#line 195
::exit(___);}
#if 0
#line 191
{ 
#line 192
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 194
return make_ushort1(v.x); 
#line 195
} 
#endif
#line 197 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1Dfetch(texture< short2, 1, cudaReadModeElementType>  t, int x) 
#line 198
{int volatile ___ = 1;(void)t;(void)x;
#line 202
::exit(___);}
#if 0
#line 198
{ 
#line 199
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 201
return make_short2(v.x, v.y); 
#line 202
} 
#endif
#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1Dfetch(texture< ushort2, 1, cudaReadModeElementType>  t, int x) 
#line 205
{int volatile ___ = 1;(void)t;(void)x;
#line 209
::exit(___);}
#if 0
#line 205
{ 
#line 206
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 208
return make_ushort2(v.x, v.y); 
#line 209
} 
#endif
#line 211 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1Dfetch(texture< short4, 1, cudaReadModeElementType>  t, int x) 
#line 212
{int volatile ___ = 1;(void)t;(void)x;
#line 216
::exit(___);}
#if 0
#line 212
{ 
#line 213
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 215
return make_short4(v.x, v.y, v.z, v.w); 
#line 216
} 
#endif
#line 218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1Dfetch(texture< ushort4, 1, cudaReadModeElementType>  t, int x) 
#line 219
{int volatile ___ = 1;(void)t;(void)x;
#line 223
::exit(___);}
#if 0
#line 219
{ 
#line 220
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 222
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 223
} 
#endif
#line 231 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex1Dfetch(texture< int, 1, cudaReadModeElementType>  t, int x) 
#line 232
{int volatile ___ = 1;(void)t;(void)x;
#line 236
::exit(___);}
#if 0
#line 232
{ 
#line 233
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 235
return v.x; 
#line 236
} 
#endif
#line 238 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1Dfetch(texture< unsigned, 1, cudaReadModeElementType>  t, int x) 
#line 239
{int volatile ___ = 1;(void)t;(void)x;
#line 243
::exit(___);}
#if 0
#line 239
{ 
#line 240
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 242
return v.x; 
#line 243
} 
#endif
#line 245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1Dfetch(texture< int1, 1, cudaReadModeElementType>  t, int x) 
#line 246
{int volatile ___ = 1;(void)t;(void)x;
#line 250
::exit(___);}
#if 0
#line 246
{ 
#line 247
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 249
return make_int1(v.x); 
#line 250
} 
#endif
#line 252 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1Dfetch(texture< uint1, 1, cudaReadModeElementType>  t, int x) 
#line 253
{int volatile ___ = 1;(void)t;(void)x;
#line 257
::exit(___);}
#if 0
#line 253
{ 
#line 254
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 256
return make_uint1(v.x); 
#line 257
} 
#endif
#line 259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1Dfetch(texture< int2, 1, cudaReadModeElementType>  t, int x) 
#line 260
{int volatile ___ = 1;(void)t;(void)x;
#line 264
::exit(___);}
#if 0
#line 260
{ 
#line 261
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 263
return make_int2(v.x, v.y); 
#line 264
} 
#endif
#line 266 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1Dfetch(texture< uint2, 1, cudaReadModeElementType>  t, int x) 
#line 267
{int volatile ___ = 1;(void)t;(void)x;
#line 271
::exit(___);}
#if 0
#line 267
{ 
#line 268
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 270
return make_uint2(v.x, v.y); 
#line 271
} 
#endif
#line 273 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1Dfetch(texture< int4, 1, cudaReadModeElementType>  t, int x) 
#line 274
{int volatile ___ = 1;(void)t;(void)x;
#line 278
::exit(___);}
#if 0
#line 274
{ 
#line 275
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 277
return make_int4(v.x, v.y, v.z, v.w); 
#line 278
} 
#endif
#line 280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1Dfetch(texture< uint4, 1, cudaReadModeElementType>  t, int x) 
#line 281
{int volatile ___ = 1;(void)t;(void)x;
#line 285
::exit(___);}
#if 0
#line 281
{ 
#line 282
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 284
return make_uint4(v.x, v.y, v.z, v.w); 
#line 285
} 
#endif
#line 295 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex1Dfetch(texture< long, 1, cudaReadModeElementType>  t, int x) 
#line 296
{int volatile ___ = 1;(void)t;(void)x;
#line 300
::exit(___);}
#if 0
#line 296
{ 
#line 297
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 299
return (long)(v.x); 
#line 300
} 
#endif
#line 302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1Dfetch(texture< unsigned long, 1, cudaReadModeElementType>  t, int x) 
#line 303
{int volatile ___ = 1;(void)t;(void)x;
#line 307
::exit(___);}
#if 0
#line 303
{ 
#line 304
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 306
return (unsigned long)(v.x); 
#line 307
} 
#endif
#line 309 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1Dfetch(texture< long1, 1, cudaReadModeElementType>  t, int x) 
#line 310
{int volatile ___ = 1;(void)t;(void)x;
#line 314
::exit(___);}
#if 0
#line 310
{ 
#line 311
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 313
return make_long1(v.x); 
#line 314
} 
#endif
#line 316 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1Dfetch(texture< ulong1, 1, cudaReadModeElementType>  t, int x) 
#line 317
{int volatile ___ = 1;(void)t;(void)x;
#line 321
::exit(___);}
#if 0
#line 317
{ 
#line 318
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 320
return make_ulong1(v.x); 
#line 321
} 
#endif
#line 323 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1Dfetch(texture< long2, 1, cudaReadModeElementType>  t, int x) 
#line 324
{int volatile ___ = 1;(void)t;(void)x;
#line 328
::exit(___);}
#if 0
#line 324
{ 
#line 325
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 327
return make_long2(v.x, v.y); 
#line 328
} 
#endif
#line 330 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1Dfetch(texture< ulong2, 1, cudaReadModeElementType>  t, int x) 
#line 331
{int volatile ___ = 1;(void)t;(void)x;
#line 335
::exit(___);}
#if 0
#line 331
{ 
#line 332
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 334
return make_ulong2(v.x, v.y); 
#line 335
} 
#endif
#line 337 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1Dfetch(texture< long4, 1, cudaReadModeElementType>  t, int x) 
#line 338
{int volatile ___ = 1;(void)t;(void)x;
#line 342
::exit(___);}
#if 0
#line 338
{ 
#line 339
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 341
return make_long4(v.x, v.y, v.z, v.w); 
#line 342
} 
#endif
#line 344 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1Dfetch(texture< ulong4, 1, cudaReadModeElementType>  t, int x) 
#line 345
{int volatile ___ = 1;(void)t;(void)x;
#line 349
::exit(___);}
#if 0
#line 345
{ 
#line 346
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 348
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 349
} 
#endif
#line 359 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1Dfetch(texture< float, 1, cudaReadModeElementType>  t, int x) 
#line 360
{int volatile ___ = 1;(void)t;(void)x;
#line 364
::exit(___);}
#if 0
#line 360
{ 
#line 361
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 363
return v.x; 
#line 364
} 
#endif
#line 366 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1Dfetch(texture< float1, 1, cudaReadModeElementType>  t, int x) 
#line 367
{int volatile ___ = 1;(void)t;(void)x;
#line 371
::exit(___);}
#if 0
#line 367
{ 
#line 368
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 370
return make_float1(v.x); 
#line 371
} 
#endif
#line 373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1Dfetch(texture< float2, 1, cudaReadModeElementType>  t, int x) 
#line 374
{int volatile ___ = 1;(void)t;(void)x;
#line 378
::exit(___);}
#if 0
#line 374
{ 
#line 375
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 377
return make_float2(v.x, v.y); 
#line 378
} 
#endif
#line 380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1Dfetch(texture< float4, 1, cudaReadModeElementType>  t, int x) 
#line 381
{int volatile ___ = 1;(void)t;(void)x;
#line 385
::exit(___);}
#if 0
#line 381
{ 
#line 382
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 384
return make_float4(v.x, v.y, v.z, v.w); 
#line 385
} 
#endif
#line 393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1Dfetch(texture< char, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 394
{int volatile ___ = 1;(void)t;(void)x;
#line 403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 402
return w.x; 
#line 403
} 
#endif
#line 405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1Dfetch(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 406
{int volatile ___ = 1;(void)t;(void)x;
#line 411
::exit(___);}
#if 0
#line 406
{ 
#line 407
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 408
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 410
return w.x; 
#line 411
} 
#endif
#line 413 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1Dfetch(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 414
{int volatile ___ = 1;(void)t;(void)x;
#line 419
::exit(___);}
#if 0
#line 414
{ 
#line 415
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 416
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 418
return w.x; 
#line 419
} 
#endif
#line 421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1Dfetch(texture< char1, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 422
{int volatile ___ = 1;(void)t;(void)x;
#line 427
::exit(___);}
#if 0
#line 422
{ 
#line 423
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 424
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 426
return make_float1(w.x); 
#line 427
} 
#endif
#line 429 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1Dfetch(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 430
{int volatile ___ = 1;(void)t;(void)x;
#line 435
::exit(___);}
#if 0
#line 430
{ 
#line 431
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 432
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 434
return make_float1(w.x); 
#line 435
} 
#endif
#line 437 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1Dfetch(texture< char2, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 438
{int volatile ___ = 1;(void)t;(void)x;
#line 443
::exit(___);}
#if 0
#line 438
{ 
#line 439
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 440
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 442
return make_float2(w.x, w.y); 
#line 443
} 
#endif
#line 445 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1Dfetch(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 446
{int volatile ___ = 1;(void)t;(void)x;
#line 451
::exit(___);}
#if 0
#line 446
{ 
#line 447
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 448
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 450
return make_float2(w.x, w.y); 
#line 451
} 
#endif
#line 453 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1Dfetch(texture< char4, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 454
{int volatile ___ = 1;(void)t;(void)x;
#line 459
::exit(___);}
#if 0
#line 454
{ 
#line 455
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 456
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 458
return make_float4(w.x, w.y, w.z, w.w); 
#line 459
} 
#endif
#line 461 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1Dfetch(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 462
{int volatile ___ = 1;(void)t;(void)x;
#line 467
::exit(___);}
#if 0
#line 462
{ 
#line 463
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 464
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 466
return make_float4(w.x, w.y, w.z, w.w); 
#line 467
} 
#endif
#line 475 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1Dfetch(texture< short, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 476
{int volatile ___ = 1;(void)t;(void)x;
#line 481
::exit(___);}
#if 0
#line 476
{ 
#line 477
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 478
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 480
return w.x; 
#line 481
} 
#endif
#line 483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1Dfetch(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 484
{int volatile ___ = 1;(void)t;(void)x;
#line 489
::exit(___);}
#if 0
#line 484
{ 
#line 485
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 486
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 488
return w.x; 
#line 489
} 
#endif
#line 491 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1Dfetch(texture< short1, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 492
{int volatile ___ = 1;(void)t;(void)x;
#line 497
::exit(___);}
#if 0
#line 492
{ 
#line 493
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 494
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 496
return make_float1(w.x); 
#line 497
} 
#endif
#line 499 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1Dfetch(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 500
{int volatile ___ = 1;(void)t;(void)x;
#line 505
::exit(___);}
#if 0
#line 500
{ 
#line 501
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 502
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 504
return make_float1(w.x); 
#line 505
} 
#endif
#line 507 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1Dfetch(texture< short2, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 508
{int volatile ___ = 1;(void)t;(void)x;
#line 513
::exit(___);}
#if 0
#line 508
{ 
#line 509
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 510
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 512
return make_float2(w.x, w.y); 
#line 513
} 
#endif
#line 515 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1Dfetch(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 516
{int volatile ___ = 1;(void)t;(void)x;
#line 521
::exit(___);}
#if 0
#line 516
{ 
#line 517
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 518
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 520
return make_float2(w.x, w.y); 
#line 521
} 
#endif
#line 523 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1Dfetch(texture< short4, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 524
{int volatile ___ = 1;(void)t;(void)x;
#line 529
::exit(___);}
#if 0
#line 524
{ 
#line 525
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 526
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 528
return make_float4(w.x, w.y, w.z, w.w); 
#line 529
} 
#endif
#line 531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1Dfetch(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 532
{int volatile ___ = 1;(void)t;(void)x;
#line 537
::exit(___);}
#if 0
#line 532
{ 
#line 533
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 534
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 536
return make_float4(w.x, w.y, w.z, w.w); 
#line 537
} 
#endif
#line 545 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex1D(texture< char, 1, cudaReadModeElementType>  t, float x) 
#line 546
{int volatile ___ = 1;(void)t;(void)x;
#line 554 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 546 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 553 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 554
} 
#endif
#line 556 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1D(texture< signed char, 1, cudaReadModeElementType>  t, float x) 
#line 557
{int volatile ___ = 1;(void)t;(void)x;
#line 561
::exit(___);}
#if 0
#line 557
{ 
#line 558
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 560
return (signed char)(v.x); 
#line 561
} 
#endif
#line 563 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1D(texture< unsigned char, 1, cudaReadModeElementType>  t, float x) 
#line 564
{int volatile ___ = 1;(void)t;(void)x;
#line 568
::exit(___);}
#if 0
#line 564
{ 
#line 565
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 567
return (unsigned char)(v.x); 
#line 568
} 
#endif
#line 570 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1D(texture< char1, 1, cudaReadModeElementType>  t, float x) 
#line 571
{int volatile ___ = 1;(void)t;(void)x;
#line 575
::exit(___);}
#if 0
#line 571
{ 
#line 572
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 574
return make_char1(v.x); 
#line 575
} 
#endif
#line 577 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1D(texture< uchar1, 1, cudaReadModeElementType>  t, float x) 
#line 578
{int volatile ___ = 1;(void)t;(void)x;
#line 582
::exit(___);}
#if 0
#line 578
{ 
#line 579
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 581
return make_uchar1(v.x); 
#line 582
} 
#endif
#line 584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1D(texture< char2, 1, cudaReadModeElementType>  t, float x) 
#line 585
{int volatile ___ = 1;(void)t;(void)x;
#line 589
::exit(___);}
#if 0
#line 585
{ 
#line 586
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 588
return make_char2(v.x, v.y); 
#line 589
} 
#endif
#line 591 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1D(texture< uchar2, 1, cudaReadModeElementType>  t, float x) 
#line 592
{int volatile ___ = 1;(void)t;(void)x;
#line 596
::exit(___);}
#if 0
#line 592
{ 
#line 593
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 595
return make_uchar2(v.x, v.y); 
#line 596
} 
#endif
#line 598 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1D(texture< char4, 1, cudaReadModeElementType>  t, float x) 
#line 599
{int volatile ___ = 1;(void)t;(void)x;
#line 603
::exit(___);}
#if 0
#line 599
{ 
#line 600
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 602
return make_char4(v.x, v.y, v.z, v.w); 
#line 603
} 
#endif
#line 605 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1D(texture< uchar4, 1, cudaReadModeElementType>  t, float x) 
#line 606
{int volatile ___ = 1;(void)t;(void)x;
#line 610
::exit(___);}
#if 0
#line 606
{ 
#line 607
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 609
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 610
} 
#endif
#line 618 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex1D(texture< short, 1, cudaReadModeElementType>  t, float x) 
#line 619
{int volatile ___ = 1;(void)t;(void)x;
#line 623
::exit(___);}
#if 0
#line 619
{ 
#line 620
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 622
return (short)(v.x); 
#line 623
} 
#endif
#line 625 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1D(texture< unsigned short, 1, cudaReadModeElementType>  t, float x) 
#line 626
{int volatile ___ = 1;(void)t;(void)x;
#line 630
::exit(___);}
#if 0
#line 626
{ 
#line 627
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 629
return (unsigned short)(v.x); 
#line 630
} 
#endif
#line 632 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1D(texture< short1, 1, cudaReadModeElementType>  t, float x) 
#line 633
{int volatile ___ = 1;(void)t;(void)x;
#line 637
::exit(___);}
#if 0
#line 633
{ 
#line 634
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 636
return make_short1(v.x); 
#line 637
} 
#endif
#line 639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1D(texture< ushort1, 1, cudaReadModeElementType>  t, float x) 
#line 640
{int volatile ___ = 1;(void)t;(void)x;
#line 644
::exit(___);}
#if 0
#line 640
{ 
#line 641
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 643
return make_ushort1(v.x); 
#line 644
} 
#endif
#line 646 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1D(texture< short2, 1, cudaReadModeElementType>  t, float x) 
#line 647
{int volatile ___ = 1;(void)t;(void)x;
#line 651
::exit(___);}
#if 0
#line 647
{ 
#line 648
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 650
return make_short2(v.x, v.y); 
#line 651
} 
#endif
#line 653 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1D(texture< ushort2, 1, cudaReadModeElementType>  t, float x) 
#line 654
{int volatile ___ = 1;(void)t;(void)x;
#line 658
::exit(___);}
#if 0
#line 654
{ 
#line 655
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 657
return make_ushort2(v.x, v.y); 
#line 658
} 
#endif
#line 660 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1D(texture< short4, 1, cudaReadModeElementType>  t, float x) 
#line 661
{int volatile ___ = 1;(void)t;(void)x;
#line 665
::exit(___);}
#if 0
#line 661
{ 
#line 662
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 664
return make_short4(v.x, v.y, v.z, v.w); 
#line 665
} 
#endif
#line 667 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1D(texture< ushort4, 1, cudaReadModeElementType>  t, float x) 
#line 668
{int volatile ___ = 1;(void)t;(void)x;
#line 672
::exit(___);}
#if 0
#line 668
{ 
#line 669
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 671
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 672
} 
#endif
#line 680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex1D(texture< int, 1, cudaReadModeElementType>  t, float x) 
#line 681
{int volatile ___ = 1;(void)t;(void)x;
#line 685
::exit(___);}
#if 0
#line 681
{ 
#line 682
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 684
return v.x; 
#line 685
} 
#endif
#line 687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1D(texture< unsigned, 1, cudaReadModeElementType>  t, float x) 
#line 688
{int volatile ___ = 1;(void)t;(void)x;
#line 692
::exit(___);}
#if 0
#line 688
{ 
#line 689
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 691
return v.x; 
#line 692
} 
#endif
#line 694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1D(texture< int1, 1, cudaReadModeElementType>  t, float x) 
#line 695
{int volatile ___ = 1;(void)t;(void)x;
#line 699
::exit(___);}
#if 0
#line 695
{ 
#line 696
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 698
return make_int1(v.x); 
#line 699
} 
#endif
#line 701 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1D(texture< uint1, 1, cudaReadModeElementType>  t, float x) 
#line 702
{int volatile ___ = 1;(void)t;(void)x;
#line 706
::exit(___);}
#if 0
#line 702
{ 
#line 703
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 705
return make_uint1(v.x); 
#line 706
} 
#endif
#line 708 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1D(texture< int2, 1, cudaReadModeElementType>  t, float x) 
#line 709
{int volatile ___ = 1;(void)t;(void)x;
#line 713
::exit(___);}
#if 0
#line 709
{ 
#line 710
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 712
return make_int2(v.x, v.y); 
#line 713
} 
#endif
#line 715 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1D(texture< uint2, 1, cudaReadModeElementType>  t, float x) 
#line 716
{int volatile ___ = 1;(void)t;(void)x;
#line 720
::exit(___);}
#if 0
#line 716
{ 
#line 717
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 719
return make_uint2(v.x, v.y); 
#line 720
} 
#endif
#line 722 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1D(texture< int4, 1, cudaReadModeElementType>  t, float x) 
#line 723
{int volatile ___ = 1;(void)t;(void)x;
#line 727
::exit(___);}
#if 0
#line 723
{ 
#line 724
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 726
return make_int4(v.x, v.y, v.z, v.w); 
#line 727
} 
#endif
#line 729 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1D(texture< uint4, 1, cudaReadModeElementType>  t, float x) 
#line 730
{int volatile ___ = 1;(void)t;(void)x;
#line 734
::exit(___);}
#if 0
#line 730
{ 
#line 731
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 733
return make_uint4(v.x, v.y, v.z, v.w); 
#line 734
} 
#endif
#line 750 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex1D(texture< long, 1, cudaReadModeElementType>  t, float x) 
#line 751
{int volatile ___ = 1;(void)t;(void)x;
#line 755
::exit(___);}
#if 0
#line 751
{ 
#line 752
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 754
return (long)(v.x); 
#line 755
} 
#endif
#line 757 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1D(texture< unsigned long, 1, cudaReadModeElementType>  t, float x) 
#line 758
{int volatile ___ = 1;(void)t;(void)x;
#line 762
::exit(___);}
#if 0
#line 758
{ 
#line 759
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 761
return (unsigned long)(v.x); 
#line 762
} 
#endif
#line 764 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1D(texture< long1, 1, cudaReadModeElementType>  t, float x) 
#line 765
{int volatile ___ = 1;(void)t;(void)x;
#line 769
::exit(___);}
#if 0
#line 765
{ 
#line 766
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 768
return make_long1(v.x); 
#line 769
} 
#endif
#line 771 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1D(texture< ulong1, 1, cudaReadModeElementType>  t, float x) 
#line 772
{int volatile ___ = 1;(void)t;(void)x;
#line 776
::exit(___);}
#if 0
#line 772
{ 
#line 773
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 775
return make_ulong1(v.x); 
#line 776
} 
#endif
#line 778 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1D(texture< long2, 1, cudaReadModeElementType>  t, float x) 
#line 779
{int volatile ___ = 1;(void)t;(void)x;
#line 783
::exit(___);}
#if 0
#line 779
{ 
#line 780
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 782
return make_long2(v.x, v.y); 
#line 783
} 
#endif
#line 785 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1D(texture< ulong2, 1, cudaReadModeElementType>  t, float x) 
#line 786
{int volatile ___ = 1;(void)t;(void)x;
#line 790
::exit(___);}
#if 0
#line 786
{ 
#line 787
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 789
return make_ulong2(v.x, v.y); 
#line 790
} 
#endif
#line 792 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1D(texture< long4, 1, cudaReadModeElementType>  t, float x) 
#line 793
{int volatile ___ = 1;(void)t;(void)x;
#line 797
::exit(___);}
#if 0
#line 793
{ 
#line 794
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 796
return make_long4(v.x, v.y, v.z, v.w); 
#line 797
} 
#endif
#line 799 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1D(texture< ulong4, 1, cudaReadModeElementType>  t, float x) 
#line 800
{int volatile ___ = 1;(void)t;(void)x;
#line 804
::exit(___);}
#if 0
#line 800
{ 
#line 801
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 803
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 804
} 
#endif
#line 814 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1D(texture< float, 1, cudaReadModeElementType>  t, float x) 
#line 815
{int volatile ___ = 1;(void)t;(void)x;
#line 819
::exit(___);}
#if 0
#line 815
{ 
#line 816
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
#line 818
return v.x; 
#line 819
} 
#endif
#line 821 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1D(texture< float1, 1, cudaReadModeElementType>  t, float x) 
#line 822
{int volatile ___ = 1;(void)t;(void)x;
#line 826
::exit(___);}
#if 0
#line 822
{ 
#line 823
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
#line 825
return make_float1(v.x); 
#line 826
} 
#endif
#line 828 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1D(texture< float2, 1, cudaReadModeElementType>  t, float x) 
#line 829
{int volatile ___ = 1;(void)t;(void)x;
#line 833
::exit(___);}
#if 0
#line 829
{ 
#line 830
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
#line 832
return make_float2(v.x, v.y); 
#line 833
} 
#endif
#line 835 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1D(texture< float4, 1, cudaReadModeElementType>  t, float x) 
#line 836
{int volatile ___ = 1;(void)t;(void)x;
#line 840
::exit(___);}
#if 0
#line 836
{ 
#line 837
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
#line 839
return make_float4(v.x, v.y, v.z, v.w); 
#line 840
} 
#endif
#line 848 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1D(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 849
{int volatile ___ = 1;(void)t;(void)x;
#line 858 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 849 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 853 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 855 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 857
return w.x; 
#line 858
} 
#endif
#line 860 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1D(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 861
{int volatile ___ = 1;(void)t;(void)x;
#line 866
::exit(___);}
#if 0
#line 861
{ 
#line 862
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 863
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 865
return w.x; 
#line 866
} 
#endif
#line 868 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1D(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 869
{int volatile ___ = 1;(void)t;(void)x;
#line 874
::exit(___);}
#if 0
#line 869
{ 
#line 870
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 871
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 873
return w.x; 
#line 874
} 
#endif
#line 876 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1D(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 877
{int volatile ___ = 1;(void)t;(void)x;
#line 882
::exit(___);}
#if 0
#line 877
{ 
#line 878
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 879
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 881
return make_float1(w.x); 
#line 882
} 
#endif
#line 884 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1D(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 885
{int volatile ___ = 1;(void)t;(void)x;
#line 890
::exit(___);}
#if 0
#line 885
{ 
#line 886
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 887
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 889
return make_float1(w.x); 
#line 890
} 
#endif
#line 892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1D(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 893
{int volatile ___ = 1;(void)t;(void)x;
#line 898
::exit(___);}
#if 0
#line 893
{ 
#line 894
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 895
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 897
return make_float2(w.x, w.y); 
#line 898
} 
#endif
#line 900 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1D(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 901
{int volatile ___ = 1;(void)t;(void)x;
#line 906
::exit(___);}
#if 0
#line 901
{ 
#line 902
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 903
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 905
return make_float2(w.x, w.y); 
#line 906
} 
#endif
#line 908 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1D(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 909
{int volatile ___ = 1;(void)t;(void)x;
#line 914
::exit(___);}
#if 0
#line 909
{ 
#line 910
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 911
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 913
return make_float4(w.x, w.y, w.z, w.w); 
#line 914
} 
#endif
#line 916 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1D(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 917
{int volatile ___ = 1;(void)t;(void)x;
#line 922
::exit(___);}
#if 0
#line 917
{ 
#line 918
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 919
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 921
return make_float4(w.x, w.y, w.z, w.w); 
#line 922
} 
#endif
#line 930 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1D(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 931
{int volatile ___ = 1;(void)t;(void)x;
#line 936
::exit(___);}
#if 0
#line 931
{ 
#line 932
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 933
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 935
return w.x; 
#line 936
} 
#endif
#line 938 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1D(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 939
{int volatile ___ = 1;(void)t;(void)x;
#line 944
::exit(___);}
#if 0
#line 939
{ 
#line 940
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 941
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 943
return w.x; 
#line 944
} 
#endif
#line 946 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1D(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 947
{int volatile ___ = 1;(void)t;(void)x;
#line 952
::exit(___);}
#if 0
#line 947
{ 
#line 948
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 949
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 951
return make_float1(w.x); 
#line 952
} 
#endif
#line 954 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1D(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 955
{int volatile ___ = 1;(void)t;(void)x;
#line 960
::exit(___);}
#if 0
#line 955
{ 
#line 956
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 957
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 959
return make_float1(w.x); 
#line 960
} 
#endif
#line 962 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1D(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 963
{int volatile ___ = 1;(void)t;(void)x;
#line 968
::exit(___);}
#if 0
#line 963
{ 
#line 964
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 965
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 967
return make_float2(w.x, w.y); 
#line 968
} 
#endif
#line 970 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1D(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 971
{int volatile ___ = 1;(void)t;(void)x;
#line 976
::exit(___);}
#if 0
#line 971
{ 
#line 972
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 973
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 975
return make_float2(w.x, w.y); 
#line 976
} 
#endif
#line 978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1D(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 979
{int volatile ___ = 1;(void)t;(void)x;
#line 984
::exit(___);}
#if 0
#line 979
{ 
#line 980
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 981
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 983
return make_float4(w.x, w.y, w.z, w.w); 
#line 984
} 
#endif
#line 986 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1D(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 987
{int volatile ___ = 1;(void)t;(void)x;
#line 992
::exit(___);}
#if 0
#line 987
{ 
#line 988
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 989
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 991
return make_float4(w.x, w.y, w.z, w.w); 
#line 992
} 
#endif
#line 1000 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex2D(texture< char, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1001
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1009 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 1001 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 1005 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1008 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 1009
} 
#endif
#line 1011 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex2D(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1012
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1016
::exit(___);}
#if 0
#line 1012
{ 
#line 1013
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1015
return (signed char)(v.x); 
#line 1016
} 
#endif
#line 1018 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex2D(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1019
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1023
::exit(___);}
#if 0
#line 1019
{ 
#line 1020
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1022
return (unsigned char)(v.x); 
#line 1023
} 
#endif
#line 1025 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex2D(texture< char1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1026
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1030
::exit(___);}
#if 0
#line 1026
{ 
#line 1027
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1029
return make_char1(v.x); 
#line 1030
} 
#endif
#line 1032 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex2D(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1033
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1037
::exit(___);}
#if 0
#line 1033
{ 
#line 1034
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1036
return make_uchar1(v.x); 
#line 1037
} 
#endif
#line 1039 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex2D(texture< char2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1040
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1044
::exit(___);}
#if 0
#line 1040
{ 
#line 1041
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1043
return make_char2(v.x, v.y); 
#line 1044
} 
#endif
#line 1046 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex2D(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1047
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1051
::exit(___);}
#if 0
#line 1047
{ 
#line 1048
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1050
return make_uchar2(v.x, v.y); 
#line 1051
} 
#endif
#line 1053 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2D(texture< char4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1054
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1058
::exit(___);}
#if 0
#line 1054
{ 
#line 1055
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1057
return make_char4(v.x, v.y, v.z, v.w); 
#line 1058
} 
#endif
#line 1060 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2D(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1061
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1065
::exit(___);}
#if 0
#line 1061
{ 
#line 1062
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1064
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 1065
} 
#endif
#line 1073 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex2D(texture< short, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1074
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1078
::exit(___);}
#if 0
#line 1074
{ 
#line 1075
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1077
return (short)(v.x); 
#line 1078
} 
#endif
#line 1080 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex2D(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1081
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1085
::exit(___);}
#if 0
#line 1081
{ 
#line 1082
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1084
return (unsigned short)(v.x); 
#line 1085
} 
#endif
#line 1087 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex2D(texture< short1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1088
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1092
::exit(___);}
#if 0
#line 1088
{ 
#line 1089
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1091
return make_short1(v.x); 
#line 1092
} 
#endif
#line 1094 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex2D(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1095
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1099
::exit(___);}
#if 0
#line 1095
{ 
#line 1096
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1098
return make_ushort1(v.x); 
#line 1099
} 
#endif
#line 1101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex2D(texture< short2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1102
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1106
::exit(___);}
#if 0
#line 1102
{ 
#line 1103
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1105
return make_short2(v.x, v.y); 
#line 1106
} 
#endif
#line 1108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex2D(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1109
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1113
::exit(___);}
#if 0
#line 1109
{ 
#line 1110
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1112
return make_ushort2(v.x, v.y); 
#line 1113
} 
#endif
#line 1115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2D(texture< short4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1116
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1120
::exit(___);}
#if 0
#line 1116
{ 
#line 1117
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1119
return make_short4(v.x, v.y, v.z, v.w); 
#line 1120
} 
#endif
#line 1122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2D(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1123
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1127
::exit(___);}
#if 0
#line 1123
{ 
#line 1124
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1126
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 1127
} 
#endif
#line 1135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex2D(texture< int, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1136
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1140
::exit(___);}
#if 0
#line 1136
{ 
#line 1137
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1139
return v.x; 
#line 1140
} 
#endif
#line 1142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex2D(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1143
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1147
::exit(___);}
#if 0
#line 1143
{ 
#line 1144
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1146
return v.x; 
#line 1147
} 
#endif
#line 1149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex2D(texture< int1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1150
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1154
::exit(___);}
#if 0
#line 1150
{ 
#line 1151
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1153
return make_int1(v.x); 
#line 1154
} 
#endif
#line 1156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex2D(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1157
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1161
::exit(___);}
#if 0
#line 1157
{ 
#line 1158
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1160
return make_uint1(v.x); 
#line 1161
} 
#endif
#line 1163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex2D(texture< int2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1164
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1168
::exit(___);}
#if 0
#line 1164
{ 
#line 1165
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1167
return make_int2(v.x, v.y); 
#line 1168
} 
#endif
#line 1170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex2D(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1171
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1175
::exit(___);}
#if 0
#line 1171
{ 
#line 1172
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1174
return make_uint2(v.x, v.y); 
#line 1175
} 
#endif
#line 1177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2D(texture< int4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1178
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1182
::exit(___);}
#if 0
#line 1178
{ 
#line 1179
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1181
return make_int4(v.x, v.y, v.z, v.w); 
#line 1182
} 
#endif
#line 1184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2D(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1185
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1189
::exit(___);}
#if 0
#line 1185
{ 
#line 1186
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1188
return make_uint4(v.x, v.y, v.z, v.w); 
#line 1189
} 
#endif
#line 1199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex2D(texture< long, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1200
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1204
::exit(___);}
#if 0
#line 1200
{ 
#line 1201
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1203
return (long)(v.x); 
#line 1204
} 
#endif
#line 1206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex2D(texture< unsigned long, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1207
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1211
::exit(___);}
#if 0
#line 1207
{ 
#line 1208
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1210
return (unsigned long)(v.x); 
#line 1211
} 
#endif
#line 1213 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex2D(texture< long1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1214
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1218
::exit(___);}
#if 0
#line 1214
{ 
#line 1215
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1217
return make_long1(v.x); 
#line 1218
} 
#endif
#line 1220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex2D(texture< ulong1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1221
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1225
::exit(___);}
#if 0
#line 1221
{ 
#line 1222
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1224
return make_ulong1(v.x); 
#line 1225
} 
#endif
#line 1227 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex2D(texture< long2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1228
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1232
::exit(___);}
#if 0
#line 1228
{ 
#line 1229
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1231
return make_long2(v.x, v.y); 
#line 1232
} 
#endif
#line 1234 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex2D(texture< ulong2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1235
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1239
::exit(___);}
#if 0
#line 1235
{ 
#line 1236
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1238
return make_ulong2(v.x, v.y); 
#line 1239
} 
#endif
#line 1241 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex2D(texture< long4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1242
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1246
::exit(___);}
#if 0
#line 1242
{ 
#line 1243
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1245
return make_long4(v.x, v.y, v.z, v.w); 
#line 1246
} 
#endif
#line 1248 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex2D(texture< ulong4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1249
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1253
::exit(___);}
#if 0
#line 1249
{ 
#line 1250
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1252
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 1253
} 
#endif
#line 1263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2D(texture< float, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1264
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1268
::exit(___);}
#if 0
#line 1264
{ 
#line 1265
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
#line 1267
return v.x; 
#line 1268
} 
#endif
#line 1270 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2D(texture< float1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1271
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1275
::exit(___);}
#if 0
#line 1271
{ 
#line 1272
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
#line 1274
return make_float1(v.x); 
#line 1275
} 
#endif
#line 1277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2D(texture< float2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1278
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1282
::exit(___);}
#if 0
#line 1278
{ 
#line 1279
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
#line 1281
return make_float2(v.x, v.y); 
#line 1282
} 
#endif
#line 1284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2D(texture< float4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1285
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1289
::exit(___);}
#if 0
#line 1285
{ 
#line 1286
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
#line 1288
return make_float4(v.x, v.y, v.z, v.w); 
#line 1289
} 
#endif
#line 1297 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2D(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1298
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 1298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 1302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1306
return w.x; 
#line 1307
} 
#endif
#line 1309 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2D(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1310
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1315
::exit(___);}
#if 0
#line 1310
{ 
#line 1311
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1312
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1314
return w.x; 
#line 1315
} 
#endif
#line 1317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2D(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1318
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1323
::exit(___);}
#if 0
#line 1318
{ 
#line 1319
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1320
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1322
return w.x; 
#line 1323
} 
#endif
#line 1325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2D(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1326
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1331
::exit(___);}
#if 0
#line 1326
{ 
#line 1327
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1328
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1330
return make_float1(w.x); 
#line 1331
} 
#endif
#line 1333 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2D(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1334
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1339
::exit(___);}
#if 0
#line 1334
{ 
#line 1335
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1336
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1338
return make_float1(w.x); 
#line 1339
} 
#endif
#line 1341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2D(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1342
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1347
::exit(___);}
#if 0
#line 1342
{ 
#line 1343
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1344
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1346
return make_float2(w.x, w.y); 
#line 1347
} 
#endif
#line 1349 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2D(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1350
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1355
::exit(___);}
#if 0
#line 1350
{ 
#line 1351
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1352
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1354
return make_float2(w.x, w.y); 
#line 1355
} 
#endif
#line 1357 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2D(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1358
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1363
::exit(___);}
#if 0
#line 1358
{ 
#line 1359
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1360
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1362
return make_float4(w.x, w.y, w.z, w.w); 
#line 1363
} 
#endif
#line 1365 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2D(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1366
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1371
::exit(___);}
#if 0
#line 1366
{ 
#line 1367
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1368
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1370
return make_float4(w.x, w.y, w.z, w.w); 
#line 1371
} 
#endif
#line 1379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2D(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1380
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1385
::exit(___);}
#if 0
#line 1380
{ 
#line 1381
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1382
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1384
return w.x; 
#line 1385
} 
#endif
#line 1387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2D(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1388
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1393
::exit(___);}
#if 0
#line 1388
{ 
#line 1389
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1390
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1392
return w.x; 
#line 1393
} 
#endif
#line 1395 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2D(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1396
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1401
::exit(___);}
#if 0
#line 1396
{ 
#line 1397
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1398
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1400
return make_float1(w.x); 
#line 1401
} 
#endif
#line 1403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2D(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1404
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1409
::exit(___);}
#if 0
#line 1404
{ 
#line 1405
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1406
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1408
return make_float1(w.x); 
#line 1409
} 
#endif
#line 1411 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2D(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1412
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1417
::exit(___);}
#if 0
#line 1412
{ 
#line 1413
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1414
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1416
return make_float2(w.x, w.y); 
#line 1417
} 
#endif
#line 1419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2D(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1420
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1425
::exit(___);}
#if 0
#line 1420
{ 
#line 1421
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1422
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1424
return make_float2(w.x, w.y); 
#line 1425
} 
#endif
#line 1427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2D(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1428
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1433
::exit(___);}
#if 0
#line 1428
{ 
#line 1429
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1430
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1432
return make_float4(w.x, w.y, w.z, w.w); 
#line 1433
} 
#endif
#line 1435 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2D(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1436
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1441
::exit(___);}
#if 0
#line 1436
{ 
#line 1437
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1438
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1440
return make_float4(w.x, w.y, w.z, w.w); 
#line 1441
} 
#endif
#line 1449 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex1DLayered(texture< char, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1450
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1458 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 1450 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 1454 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1457 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 1458
} 
#endif
#line 1460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1DLayered(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1461
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1465
::exit(___);}
#if 0
#line 1461
{ 
#line 1462
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1464
return (signed char)(v.x); 
#line 1465
} 
#endif
#line 1467 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1DLayered(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1468
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1472
::exit(___);}
#if 0
#line 1468
{ 
#line 1469
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1471
return (unsigned char)(v.x); 
#line 1472
} 
#endif
#line 1474 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1DLayered(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1475
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1479
::exit(___);}
#if 0
#line 1475
{ 
#line 1476
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1478
return make_char1(v.x); 
#line 1479
} 
#endif
#line 1481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1DLayered(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1482
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1486
::exit(___);}
#if 0
#line 1482
{ 
#line 1483
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1485
return make_uchar1(v.x); 
#line 1486
} 
#endif
#line 1488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1DLayered(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1489
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1493
::exit(___);}
#if 0
#line 1489
{ 
#line 1490
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1492
return make_char2(v.x, v.y); 
#line 1493
} 
#endif
#line 1495 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1DLayered(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1496
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1500
::exit(___);}
#if 0
#line 1496
{ 
#line 1497
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1499
return make_uchar2(v.x, v.y); 
#line 1500
} 
#endif
#line 1502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1DLayered(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1503
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1507
::exit(___);}
#if 0
#line 1503
{ 
#line 1504
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1506
return make_char4(v.x, v.y, v.z, v.w); 
#line 1507
} 
#endif
#line 1509 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1DLayered(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1510
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1514
::exit(___);}
#if 0
#line 1510
{ 
#line 1511
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1513
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 1514
} 
#endif
#line 1522 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex1DLayered(texture< short, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1523
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1527
::exit(___);}
#if 0
#line 1523
{ 
#line 1524
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1526
return (short)(v.x); 
#line 1527
} 
#endif
#line 1529 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1DLayered(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1530
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1534
::exit(___);}
#if 0
#line 1530
{ 
#line 1531
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1533
return (unsigned short)(v.x); 
#line 1534
} 
#endif
#line 1536 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1DLayered(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1537
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1541
::exit(___);}
#if 0
#line 1537
{ 
#line 1538
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1540
return make_short1(v.x); 
#line 1541
} 
#endif
#line 1543 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1DLayered(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1544
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1548
::exit(___);}
#if 0
#line 1544
{ 
#line 1545
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1547
return make_ushort1(v.x); 
#line 1548
} 
#endif
#line 1550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1DLayered(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1551
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1555
::exit(___);}
#if 0
#line 1551
{ 
#line 1552
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1554
return make_short2(v.x, v.y); 
#line 1555
} 
#endif
#line 1557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1DLayered(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1558
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1562
::exit(___);}
#if 0
#line 1558
{ 
#line 1559
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1561
return make_ushort2(v.x, v.y); 
#line 1562
} 
#endif
#line 1564 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1DLayered(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1565
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1569
::exit(___);}
#if 0
#line 1565
{ 
#line 1566
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1568
return make_short4(v.x, v.y, v.z, v.w); 
#line 1569
} 
#endif
#line 1571 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1DLayered(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1572
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1576
::exit(___);}
#if 0
#line 1572
{ 
#line 1573
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1575
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 1576
} 
#endif
#line 1584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex1DLayered(texture< int, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1585
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1589
::exit(___);}
#if 0
#line 1585
{ 
#line 1586
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1588
return v.x; 
#line 1589
} 
#endif
#line 1591 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1DLayered(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1592
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1596
::exit(___);}
#if 0
#line 1592
{ 
#line 1593
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1595
return v.x; 
#line 1596
} 
#endif
#line 1598 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1DLayered(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1599
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1603
::exit(___);}
#if 0
#line 1599
{ 
#line 1600
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1602
return make_int1(v.x); 
#line 1603
} 
#endif
#line 1605 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1DLayered(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1606
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1610
::exit(___);}
#if 0
#line 1606
{ 
#line 1607
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1609
return make_uint1(v.x); 
#line 1610
} 
#endif
#line 1612 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1DLayered(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1613
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1617
::exit(___);}
#if 0
#line 1613
{ 
#line 1614
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1616
return make_int2(v.x, v.y); 
#line 1617
} 
#endif
#line 1619 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1DLayered(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1620
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1624
::exit(___);}
#if 0
#line 1620
{ 
#line 1621
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1623
return make_uint2(v.x, v.y); 
#line 1624
} 
#endif
#line 1626 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1DLayered(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1627
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1631
::exit(___);}
#if 0
#line 1627
{ 
#line 1628
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1630
return make_int4(v.x, v.y, v.z, v.w); 
#line 1631
} 
#endif
#line 1633 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1DLayered(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1634
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1638
::exit(___);}
#if 0
#line 1634
{ 
#line 1635
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1637
return make_uint4(v.x, v.y, v.z, v.w); 
#line 1638
} 
#endif
#line 1648 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex1DLayered(texture< long, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1649
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1653
::exit(___);}
#if 0
#line 1649
{ 
#line 1650
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1652
return (long)(v.x); 
#line 1653
} 
#endif
#line 1655 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1DLayered(texture< unsigned long, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1656
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1660
::exit(___);}
#if 0
#line 1656
{ 
#line 1657
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1659
return (unsigned long)(v.x); 
#line 1660
} 
#endif
#line 1662 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1DLayered(texture< long1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1663
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1667
::exit(___);}
#if 0
#line 1663
{ 
#line 1664
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1666
return make_long1(v.x); 
#line 1667
} 
#endif
#line 1669 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1DLayered(texture< ulong1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1670
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1674
::exit(___);}
#if 0
#line 1670
{ 
#line 1671
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1673
return make_ulong1(v.x); 
#line 1674
} 
#endif
#line 1676 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1DLayered(texture< long2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1677
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1681
::exit(___);}
#if 0
#line 1677
{ 
#line 1678
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1680
return make_long2(v.x, v.y); 
#line 1681
} 
#endif
#line 1683 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1DLayered(texture< ulong2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1684
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1688
::exit(___);}
#if 0
#line 1684
{ 
#line 1685
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1687
return make_ulong2(v.x, v.y); 
#line 1688
} 
#endif
#line 1690 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1DLayered(texture< long4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1691
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1695
::exit(___);}
#if 0
#line 1691
{ 
#line 1692
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1694
return make_long4(v.x, v.y, v.z, v.w); 
#line 1695
} 
#endif
#line 1697 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1DLayered(texture< ulong4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1698
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1702
::exit(___);}
#if 0
#line 1698
{ 
#line 1699
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1701
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 1702
} 
#endif
#line 1712 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayered(texture< float, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1713
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1717
::exit(___);}
#if 0
#line 1713
{ 
#line 1714
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1716
return v.x; 
#line 1717
} 
#endif
#line 1719 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayered(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1720
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1724
::exit(___);}
#if 0
#line 1720
{ 
#line 1721
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1723
return make_float1(v.x); 
#line 1724
} 
#endif
#line 1726 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayered(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1727
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1731
::exit(___);}
#if 0
#line 1727
{ 
#line 1728
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1730
return make_float2(v.x, v.y); 
#line 1731
} 
#endif
#line 1733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayered(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1734
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1738
::exit(___);}
#if 0
#line 1734
{ 
#line 1735
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1737
return make_float4(v.x, v.y, v.z, v.w); 
#line 1738
} 
#endif
#line 1746 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayered(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1747
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1756 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 1747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 1751 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1753 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1755
return w.x; 
#line 1756
} 
#endif
#line 1758 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayered(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1759
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1764
::exit(___);}
#if 0
#line 1759
{ 
#line 1760
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1761
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1763
return w.x; 
#line 1764
} 
#endif
#line 1766 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayered(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1767
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1772
::exit(___);}
#if 0
#line 1767
{ 
#line 1768
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1769
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1771
return w.x; 
#line 1772
} 
#endif
#line 1774 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayered(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1775
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1780
::exit(___);}
#if 0
#line 1775
{ 
#line 1776
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1777
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1779
return make_float1(w.x); 
#line 1780
} 
#endif
#line 1782 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayered(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1783
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1788
::exit(___);}
#if 0
#line 1783
{ 
#line 1784
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1785
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1787
return make_float1(w.x); 
#line 1788
} 
#endif
#line 1790 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayered(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1791
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1796
::exit(___);}
#if 0
#line 1791
{ 
#line 1792
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1793
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1795
return make_float2(w.x, w.y); 
#line 1796
} 
#endif
#line 1798 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayered(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1799
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1804
::exit(___);}
#if 0
#line 1799
{ 
#line 1800
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1801
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1803
return make_float2(w.x, w.y); 
#line 1804
} 
#endif
#line 1806 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayered(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1807
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1812
::exit(___);}
#if 0
#line 1807
{ 
#line 1808
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1809
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1811
return make_float4(w.x, w.y, w.z, w.w); 
#line 1812
} 
#endif
#line 1814 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayered(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1815
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1820
::exit(___);}
#if 0
#line 1815
{ 
#line 1816
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1817
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1819
return make_float4(w.x, w.y, w.z, w.w); 
#line 1820
} 
#endif
#line 1828 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayered(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1829
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1834
::exit(___);}
#if 0
#line 1829
{ 
#line 1830
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1831
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1833
return w.x; 
#line 1834
} 
#endif
#line 1836 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayered(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1837
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1842
::exit(___);}
#if 0
#line 1837
{ 
#line 1838
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1839
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1841
return w.x; 
#line 1842
} 
#endif
#line 1844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayered(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1845
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1850
::exit(___);}
#if 0
#line 1845
{ 
#line 1846
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1847
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1849
return make_float1(w.x); 
#line 1850
} 
#endif
#line 1852 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayered(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1853
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1858
::exit(___);}
#if 0
#line 1853
{ 
#line 1854
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1855
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1857
return make_float1(w.x); 
#line 1858
} 
#endif
#line 1860 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayered(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1861
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1866
::exit(___);}
#if 0
#line 1861
{ 
#line 1862
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1863
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1865
return make_float2(w.x, w.y); 
#line 1866
} 
#endif
#line 1868 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayered(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1869
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1874
::exit(___);}
#if 0
#line 1869
{ 
#line 1870
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1871
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1873
return make_float2(w.x, w.y); 
#line 1874
} 
#endif
#line 1876 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayered(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1877
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1882
::exit(___);}
#if 0
#line 1877
{ 
#line 1878
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1879
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1881
return make_float4(w.x, w.y, w.z, w.w); 
#line 1882
} 
#endif
#line 1884 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayered(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1885
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1890
::exit(___);}
#if 0
#line 1885
{ 
#line 1886
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1887
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1889
return make_float4(w.x, w.y, w.z, w.w); 
#line 1890
} 
#endif
#line 1898 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex2DLayered(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1899
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1907 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 1899 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 1903 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1906 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 1907
} 
#endif
#line 1909 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex2DLayered(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1910
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1914
::exit(___);}
#if 0
#line 1910
{ 
#line 1911
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1913
return (signed char)(v.x); 
#line 1914
} 
#endif
#line 1916 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex2DLayered(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1917
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1921
::exit(___);}
#if 0
#line 1917
{ 
#line 1918
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1920
return (unsigned char)(v.x); 
#line 1921
} 
#endif
#line 1923 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex2DLayered(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1924
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1928
::exit(___);}
#if 0
#line 1924
{ 
#line 1925
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1927
return make_char1(v.x); 
#line 1928
} 
#endif
#line 1930 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex2DLayered(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1931
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1935
::exit(___);}
#if 0
#line 1931
{ 
#line 1932
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1934
return make_uchar1(v.x); 
#line 1935
} 
#endif
#line 1937 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex2DLayered(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1938
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1942
::exit(___);}
#if 0
#line 1938
{ 
#line 1939
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1941
return make_char2(v.x, v.y); 
#line 1942
} 
#endif
#line 1944 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex2DLayered(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1945
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1949
::exit(___);}
#if 0
#line 1945
{ 
#line 1946
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1948
return make_uchar2(v.x, v.y); 
#line 1949
} 
#endif
#line 1951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2DLayered(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1952
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1956
::exit(___);}
#if 0
#line 1952
{ 
#line 1953
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1955
return make_char4(v.x, v.y, v.z, v.w); 
#line 1956
} 
#endif
#line 1958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2DLayered(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1959
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1963
::exit(___);}
#if 0
#line 1959
{ 
#line 1960
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1962
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 1963
} 
#endif
#line 1971 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex2DLayered(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1972
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1976
::exit(___);}
#if 0
#line 1972
{ 
#line 1973
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1975
return (short)(v.x); 
#line 1976
} 
#endif
#line 1978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex2DLayered(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1979
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1983
::exit(___);}
#if 0
#line 1979
{ 
#line 1980
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1982
return (unsigned short)(v.x); 
#line 1983
} 
#endif
#line 1985 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex2DLayered(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1986
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1990
::exit(___);}
#if 0
#line 1986
{ 
#line 1987
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1989
return make_short1(v.x); 
#line 1990
} 
#endif
#line 1992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex2DLayered(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1993
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1997
::exit(___);}
#if 0
#line 1993
{ 
#line 1994
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1996
return make_ushort1(v.x); 
#line 1997
} 
#endif
#line 1999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex2DLayered(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2004
::exit(___);}
#if 0
#line 2000
{ 
#line 2001
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2003
return make_short2(v.x, v.y); 
#line 2004
} 
#endif
#line 2006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex2DLayered(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2007
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2011
::exit(___);}
#if 0
#line 2007
{ 
#line 2008
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2010
return make_ushort2(v.x, v.y); 
#line 2011
} 
#endif
#line 2013 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2DLayered(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2014
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2018
::exit(___);}
#if 0
#line 2014
{ 
#line 2015
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2017
return make_short4(v.x, v.y, v.z, v.w); 
#line 2018
} 
#endif
#line 2020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2DLayered(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2021
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2025
::exit(___);}
#if 0
#line 2021
{ 
#line 2022
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2024
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 2025
} 
#endif
#line 2033 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex2DLayered(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2034
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2038
::exit(___);}
#if 0
#line 2034
{ 
#line 2035
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2037
return v.x; 
#line 2038
} 
#endif
#line 2040 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex2DLayered(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2041
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2045
::exit(___);}
#if 0
#line 2041
{ 
#line 2042
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2044
return v.x; 
#line 2045
} 
#endif
#line 2047 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex2DLayered(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2048
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2052
::exit(___);}
#if 0
#line 2048
{ 
#line 2049
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2051
return make_int1(v.x); 
#line 2052
} 
#endif
#line 2054 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex2DLayered(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2055
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2059
::exit(___);}
#if 0
#line 2055
{ 
#line 2056
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2058
return make_uint1(v.x); 
#line 2059
} 
#endif
#line 2061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex2DLayered(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2062
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2066
::exit(___);}
#if 0
#line 2062
{ 
#line 2063
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2065
return make_int2(v.x, v.y); 
#line 2066
} 
#endif
#line 2068 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex2DLayered(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2069
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2073
::exit(___);}
#if 0
#line 2069
{ 
#line 2070
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2072
return make_uint2(v.x, v.y); 
#line 2073
} 
#endif
#line 2075 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2DLayered(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2076
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2080
::exit(___);}
#if 0
#line 2076
{ 
#line 2077
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2079
return make_int4(v.x, v.y, v.z, v.w); 
#line 2080
} 
#endif
#line 2082 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2DLayered(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2083
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2087
::exit(___);}
#if 0
#line 2083
{ 
#line 2084
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2086
return make_uint4(v.x, v.y, v.z, v.w); 
#line 2087
} 
#endif
#line 2097 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex2DLayered(texture< long, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2098
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2102
::exit(___);}
#if 0
#line 2098
{ 
#line 2099
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2101
return (long)(v.x); 
#line 2102
} 
#endif
#line 2104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex2DLayered(texture< unsigned long, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2105
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2109
::exit(___);}
#if 0
#line 2105
{ 
#line 2106
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2108
return (unsigned long)(v.x); 
#line 2109
} 
#endif
#line 2111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex2DLayered(texture< long1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2112
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2116
::exit(___);}
#if 0
#line 2112
{ 
#line 2113
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2115
return make_long1(v.x); 
#line 2116
} 
#endif
#line 2118 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex2DLayered(texture< ulong1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2119
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2123
::exit(___);}
#if 0
#line 2119
{ 
#line 2120
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2122
return make_ulong1(v.x); 
#line 2123
} 
#endif
#line 2125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex2DLayered(texture< long2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2126
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2130
::exit(___);}
#if 0
#line 2126
{ 
#line 2127
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2129
return make_long2(v.x, v.y); 
#line 2130
} 
#endif
#line 2132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex2DLayered(texture< ulong2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2133
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2137
::exit(___);}
#if 0
#line 2133
{ 
#line 2134
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2136
return make_ulong2(v.x, v.y); 
#line 2137
} 
#endif
#line 2139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex2DLayered(texture< long4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2140
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2144
::exit(___);}
#if 0
#line 2140
{ 
#line 2141
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2143
return make_long4(v.x, v.y, v.z, v.w); 
#line 2144
} 
#endif
#line 2146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex2DLayered(texture< ulong4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2147
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2151
::exit(___);}
#if 0
#line 2147
{ 
#line 2148
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2150
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 2151
} 
#endif
#line 2161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayered(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2162
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2166
::exit(___);}
#if 0
#line 2162
{ 
#line 2163
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2165
return v.x; 
#line 2166
} 
#endif
#line 2168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayered(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2169
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2173
::exit(___);}
#if 0
#line 2169
{ 
#line 2170
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2172
return make_float1(v.x); 
#line 2173
} 
#endif
#line 2175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayered(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2176
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2180
::exit(___);}
#if 0
#line 2176
{ 
#line 2177
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2179
return make_float2(v.x, v.y); 
#line 2180
} 
#endif
#line 2182 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayered(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2183
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2187
::exit(___);}
#if 0
#line 2183
{ 
#line 2184
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2186
return make_float4(v.x, v.y, v.z, v.w); 
#line 2187
} 
#endif
#line 2195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayered(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2196
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 2196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 2200 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2204
return w.x; 
#line 2205
} 
#endif
#line 2207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayered(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2208
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2213
::exit(___);}
#if 0
#line 2208
{ 
#line 2209
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2210
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2212
return w.x; 
#line 2213
} 
#endif
#line 2215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayered(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2216
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2221
::exit(___);}
#if 0
#line 2216
{ 
#line 2217
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2218
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2220
return w.x; 
#line 2221
} 
#endif
#line 2223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayered(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2224
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2229
::exit(___);}
#if 0
#line 2224
{ 
#line 2225
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2226
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2228
return make_float1(w.x); 
#line 2229
} 
#endif
#line 2231 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayered(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2232
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2237
::exit(___);}
#if 0
#line 2232
{ 
#line 2233
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2234
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2236
return make_float1(w.x); 
#line 2237
} 
#endif
#line 2239 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayered(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2240
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2245
::exit(___);}
#if 0
#line 2240
{ 
#line 2241
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2242
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2244
return make_float2(w.x, w.y); 
#line 2245
} 
#endif
#line 2247 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayered(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2248
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2253
::exit(___);}
#if 0
#line 2248
{ 
#line 2249
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2250
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2252
return make_float2(w.x, w.y); 
#line 2253
} 
#endif
#line 2255 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayered(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2256
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2261
::exit(___);}
#if 0
#line 2256
{ 
#line 2257
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2258
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2260
return make_float4(w.x, w.y, w.z, w.w); 
#line 2261
} 
#endif
#line 2263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayered(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2264
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2269
::exit(___);}
#if 0
#line 2264
{ 
#line 2265
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2266
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2268
return make_float4(w.x, w.y, w.z, w.w); 
#line 2269
} 
#endif
#line 2277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayered(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2278
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2283
::exit(___);}
#if 0
#line 2278
{ 
#line 2279
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2280
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2282
return w.x; 
#line 2283
} 
#endif
#line 2285 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayered(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2286
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2291
::exit(___);}
#if 0
#line 2286
{ 
#line 2287
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2288
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2290
return w.x; 
#line 2291
} 
#endif
#line 2293 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayered(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2294
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2299
::exit(___);}
#if 0
#line 2294
{ 
#line 2295
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2296
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2298
return make_float1(w.x); 
#line 2299
} 
#endif
#line 2301 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayered(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2302
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2307
::exit(___);}
#if 0
#line 2302
{ 
#line 2303
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2304
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2306
return make_float1(w.x); 
#line 2307
} 
#endif
#line 2309 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayered(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2310
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2315
::exit(___);}
#if 0
#line 2310
{ 
#line 2311
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2312
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2314
return make_float2(w.x, w.y); 
#line 2315
} 
#endif
#line 2317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayered(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2318
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2323
::exit(___);}
#if 0
#line 2318
{ 
#line 2319
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2320
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2322
return make_float2(w.x, w.y); 
#line 2323
} 
#endif
#line 2325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayered(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2326
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2331
::exit(___);}
#if 0
#line 2326
{ 
#line 2327
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2328
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2330
return make_float4(w.x, w.y, w.z, w.w); 
#line 2331
} 
#endif
#line 2333 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayered(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2334
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2339
::exit(___);}
#if 0
#line 2334
{ 
#line 2335
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2336
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2338
return make_float4(w.x, w.y, w.z, w.w); 
#line 2339
} 
#endif
#line 2347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex3D(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2348
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2356 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 2348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 2352 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2355 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 2356
} 
#endif
#line 2358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex3D(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2359
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2363
::exit(___);}
#if 0
#line 2359
{ 
#line 2360
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2362
return (signed char)(v.x); 
#line 2363
} 
#endif
#line 2365 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex3D(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2366
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2370
::exit(___);}
#if 0
#line 2366
{ 
#line 2367
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2369
return (unsigned char)(v.x); 
#line 2370
} 
#endif
#line 2372 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex3D(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2373
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2377
::exit(___);}
#if 0
#line 2373
{ 
#line 2374
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2376
return make_char1(v.x); 
#line 2377
} 
#endif
#line 2379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex3D(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2380
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2384
::exit(___);}
#if 0
#line 2380
{ 
#line 2381
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2383
return make_uchar1(v.x); 
#line 2384
} 
#endif
#line 2386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex3D(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2387
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2391
::exit(___);}
#if 0
#line 2387
{ 
#line 2388
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2390
return make_char2(v.x, v.y); 
#line 2391
} 
#endif
#line 2393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex3D(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2394
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2398
::exit(___);}
#if 0
#line 2394
{ 
#line 2395
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2397
return make_uchar2(v.x, v.y); 
#line 2398
} 
#endif
#line 2400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex3D(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2401
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2405
::exit(___);}
#if 0
#line 2401
{ 
#line 2402
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2404
return make_char4(v.x, v.y, v.z, v.w); 
#line 2405
} 
#endif
#line 2407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex3D(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2408
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2412
::exit(___);}
#if 0
#line 2408
{ 
#line 2409
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2411
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 2412
} 
#endif
#line 2420 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex3D(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2421
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2425
::exit(___);}
#if 0
#line 2421
{ 
#line 2422
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2424
return (short)(v.x); 
#line 2425
} 
#endif
#line 2427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex3D(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2428
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2432
::exit(___);}
#if 0
#line 2428
{ 
#line 2429
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2431
return (unsigned short)(v.x); 
#line 2432
} 
#endif
#line 2434 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex3D(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2435
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2439
::exit(___);}
#if 0
#line 2435
{ 
#line 2436
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2438
return make_short1(v.x); 
#line 2439
} 
#endif
#line 2441 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex3D(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2442
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2446
::exit(___);}
#if 0
#line 2442
{ 
#line 2443
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2445
return make_ushort1(v.x); 
#line 2446
} 
#endif
#line 2448 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex3D(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2449
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2453
::exit(___);}
#if 0
#line 2449
{ 
#line 2450
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2452
return make_short2(v.x, v.y); 
#line 2453
} 
#endif
#line 2455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex3D(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2456
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2460
::exit(___);}
#if 0
#line 2456
{ 
#line 2457
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2459
return make_ushort2(v.x, v.y); 
#line 2460
} 
#endif
#line 2462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex3D(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2463
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2467
::exit(___);}
#if 0
#line 2463
{ 
#line 2464
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2466
return make_short4(v.x, v.y, v.z, v.w); 
#line 2467
} 
#endif
#line 2469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex3D(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2470
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2474
::exit(___);}
#if 0
#line 2470
{ 
#line 2471
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2473
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 2474
} 
#endif
#line 2482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex3D(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2483
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2487
::exit(___);}
#if 0
#line 2483
{ 
#line 2484
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2486
return v.x; 
#line 2487
} 
#endif
#line 2489 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex3D(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2490
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2494
::exit(___);}
#if 0
#line 2490
{ 
#line 2491
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2493
return v.x; 
#line 2494
} 
#endif
#line 2496 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex3D(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2497
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2501
::exit(___);}
#if 0
#line 2497
{ 
#line 2498
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2500
return make_int1(v.x); 
#line 2501
} 
#endif
#line 2503 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex3D(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2504
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2508
::exit(___);}
#if 0
#line 2504
{ 
#line 2505
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2507
return make_uint1(v.x); 
#line 2508
} 
#endif
#line 2510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex3D(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2511
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2515
::exit(___);}
#if 0
#line 2511
{ 
#line 2512
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2514
return make_int2(v.x, v.y); 
#line 2515
} 
#endif
#line 2517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex3D(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2518
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2522
::exit(___);}
#if 0
#line 2518
{ 
#line 2519
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2521
return make_uint2(v.x, v.y); 
#line 2522
} 
#endif
#line 2524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex3D(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2525
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2529
::exit(___);}
#if 0
#line 2525
{ 
#line 2526
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2528
return make_int4(v.x, v.y, v.z, v.w); 
#line 2529
} 
#endif
#line 2531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex3D(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2532
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2536
::exit(___);}
#if 0
#line 2532
{ 
#line 2533
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2535
return make_uint4(v.x, v.y, v.z, v.w); 
#line 2536
} 
#endif
#line 2546 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex3D(texture< long, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2547
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2551
::exit(___);}
#if 0
#line 2547
{ 
#line 2548
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2550
return (long)(v.x); 
#line 2551
} 
#endif
#line 2553 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex3D(texture< unsigned long, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2554
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2558
::exit(___);}
#if 0
#line 2554
{ 
#line 2555
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2557
return (unsigned long)(v.x); 
#line 2558
} 
#endif
#line 2560 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex3D(texture< long1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2561
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2565
::exit(___);}
#if 0
#line 2561
{ 
#line 2562
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2564
return make_long1(v.x); 
#line 2565
} 
#endif
#line 2567 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex3D(texture< ulong1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2568
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2572
::exit(___);}
#if 0
#line 2568
{ 
#line 2569
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2571
return make_ulong1(v.x); 
#line 2572
} 
#endif
#line 2574 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex3D(texture< long2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2575
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2579
::exit(___);}
#if 0
#line 2575
{ 
#line 2576
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2578
return make_long2(v.x, v.y); 
#line 2579
} 
#endif
#line 2581 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex3D(texture< ulong2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2582
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2586
::exit(___);}
#if 0
#line 2582
{ 
#line 2583
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2585
return make_ulong2(v.x, v.y); 
#line 2586
} 
#endif
#line 2588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex3D(texture< long4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2589
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2593
::exit(___);}
#if 0
#line 2589
{ 
#line 2590
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2592
return make_long4(v.x, v.y, v.z, v.w); 
#line 2593
} 
#endif
#line 2595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex3D(texture< ulong4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2596
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2600
::exit(___);}
#if 0
#line 2596
{ 
#line 2597
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2599
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 2600
} 
#endif
#line 2610 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3D(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2611
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2615
::exit(___);}
#if 0
#line 2611
{ 
#line 2612
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
#line 2614
return v.x; 
#line 2615
} 
#endif
#line 2617 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3D(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2618
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2622
::exit(___);}
#if 0
#line 2618
{ 
#line 2619
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
#line 2621
return make_float1(v.x); 
#line 2622
} 
#endif
#line 2624 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3D(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2625
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2629
::exit(___);}
#if 0
#line 2625
{ 
#line 2626
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
#line 2628
return make_float2(v.x, v.y); 
#line 2629
} 
#endif
#line 2631 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3D(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2632
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2636
::exit(___);}
#if 0
#line 2632
{ 
#line 2633
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
#line 2635
return make_float4(v.x, v.y, v.z, v.w); 
#line 2636
} 
#endif
#line 2644 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3D(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2645
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2654 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 2645 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 2649 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2651 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2653
return w.x; 
#line 2654
} 
#endif
#line 2656 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3D(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2657
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2662
::exit(___);}
#if 0
#line 2657
{ 
#line 2658
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2659
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2661
return w.x; 
#line 2662
} 
#endif
#line 2664 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3D(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2665
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2670
::exit(___);}
#if 0
#line 2665
{ 
#line 2666
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2667
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2669
return w.x; 
#line 2670
} 
#endif
#line 2672 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3D(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2673
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2678
::exit(___);}
#if 0
#line 2673
{ 
#line 2674
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2675
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2677
return make_float1(w.x); 
#line 2678
} 
#endif
#line 2680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3D(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2686
::exit(___);}
#if 0
#line 2681
{ 
#line 2682
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2683
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2685
return make_float1(w.x); 
#line 2686
} 
#endif
#line 2688 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3D(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2689
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2694
::exit(___);}
#if 0
#line 2689
{ 
#line 2690
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2691
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2693
return make_float2(w.x, w.y); 
#line 2694
} 
#endif
#line 2696 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3D(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2697
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2702
::exit(___);}
#if 0
#line 2697
{ 
#line 2698
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2699
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2701
return make_float2(w.x, w.y); 
#line 2702
} 
#endif
#line 2704 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3D(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2705
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2710
::exit(___);}
#if 0
#line 2705
{ 
#line 2706
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2707
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2709
return make_float4(w.x, w.y, w.z, w.w); 
#line 2710
} 
#endif
#line 2712 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3D(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2713
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2718
::exit(___);}
#if 0
#line 2713
{ 
#line 2714
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2715
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2717
return make_float4(w.x, w.y, w.z, w.w); 
#line 2718
} 
#endif
#line 2726 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3D(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2727
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2732
::exit(___);}
#if 0
#line 2727
{ 
#line 2728
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2729
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2731
return w.x; 
#line 2732
} 
#endif
#line 2734 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3D(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2735
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2740
::exit(___);}
#if 0
#line 2735
{ 
#line 2736
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2737
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2739
return w.x; 
#line 2740
} 
#endif
#line 2742 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3D(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2743
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2748
::exit(___);}
#if 0
#line 2743
{ 
#line 2744
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2745
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2747
return make_float1(w.x); 
#line 2748
} 
#endif
#line 2750 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3D(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2751
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2756
::exit(___);}
#if 0
#line 2751
{ 
#line 2752
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2753
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2755
return make_float1(w.x); 
#line 2756
} 
#endif
#line 2758 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3D(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2759
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2764
::exit(___);}
#if 0
#line 2759
{ 
#line 2760
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2761
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2763
return make_float2(w.x, w.y); 
#line 2764
} 
#endif
#line 2766 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3D(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2767
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2772
::exit(___);}
#if 0
#line 2767
{ 
#line 2768
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2769
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2771
return make_float2(w.x, w.y); 
#line 2772
} 
#endif
#line 2774 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3D(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2775
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2780
::exit(___);}
#if 0
#line 2775
{ 
#line 2776
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2777
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2779
return make_float4(w.x, w.y, w.z, w.w); 
#line 2780
} 
#endif
#line 2782 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3D(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2783
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2788
::exit(___);}
#if 0
#line 2783
{ 
#line 2784
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2785
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2787
return make_float4(w.x, w.y, w.z, w.w); 
#line 2788
} 
#endif
#line 2796 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char texCubemap(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2797
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2805 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 2797 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 2801 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2804 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 2805
} 
#endif
#line 2807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char texCubemap(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2808
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2812
::exit(___);}
#if 0
#line 2808
{ 
#line 2809
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2811
return (signed char)(v.x); 
#line 2812
} 
#endif
#line 2814 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char texCubemap(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2815
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2819
::exit(___);}
#if 0
#line 2815
{ 
#line 2816
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2818
return (unsigned char)(v.x); 
#line 2819
} 
#endif
#line 2821 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 texCubemap(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2822
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2826
::exit(___);}
#if 0
#line 2822
{ 
#line 2823
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2825
return make_char1(v.x); 
#line 2826
} 
#endif
#line 2828 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 texCubemap(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2829
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2833
::exit(___);}
#if 0
#line 2829
{ 
#line 2830
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2832
return make_uchar1(v.x); 
#line 2833
} 
#endif
#line 2835 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 texCubemap(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2836
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2840
::exit(___);}
#if 0
#line 2836
{ 
#line 2837
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2839
return make_char2(v.x, v.y); 
#line 2840
} 
#endif
#line 2842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 texCubemap(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2847
::exit(___);}
#if 0
#line 2843
{ 
#line 2844
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2846
return make_uchar2(v.x, v.y); 
#line 2847
} 
#endif
#line 2849 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 texCubemap(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2850
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2854
::exit(___);}
#if 0
#line 2850
{ 
#line 2851
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2853
return make_char4(v.x, v.y, v.z, v.w); 
#line 2854
} 
#endif
#line 2856 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 texCubemap(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2861
::exit(___);}
#if 0
#line 2857
{ 
#line 2858
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2860
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 2861
} 
#endif
#line 2869 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short texCubemap(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2870
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2874
::exit(___);}
#if 0
#line 2870
{ 
#line 2871
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2873
return (short)(v.x); 
#line 2874
} 
#endif
#line 2876 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short texCubemap(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2877
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2881
::exit(___);}
#if 0
#line 2877
{ 
#line 2878
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2880
return (unsigned short)(v.x); 
#line 2881
} 
#endif
#line 2883 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 texCubemap(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2884
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2888
::exit(___);}
#if 0
#line 2884
{ 
#line 2885
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2887
return make_short1(v.x); 
#line 2888
} 
#endif
#line 2890 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 texCubemap(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2891
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2895
::exit(___);}
#if 0
#line 2891
{ 
#line 2892
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2894
return make_ushort1(v.x); 
#line 2895
} 
#endif
#line 2897 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 texCubemap(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2902
::exit(___);}
#if 0
#line 2898
{ 
#line 2899
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2901
return make_short2(v.x, v.y); 
#line 2902
} 
#endif
#line 2904 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 texCubemap(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2909
::exit(___);}
#if 0
#line 2905
{ 
#line 2906
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2908
return make_ushort2(v.x, v.y); 
#line 2909
} 
#endif
#line 2911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 texCubemap(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2912
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2916
::exit(___);}
#if 0
#line 2912
{ 
#line 2913
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2915
return make_short4(v.x, v.y, v.z, v.w); 
#line 2916
} 
#endif
#line 2918 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 texCubemap(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2919
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2923
::exit(___);}
#if 0
#line 2919
{ 
#line 2920
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2922
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 2923
} 
#endif
#line 2931 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int texCubemap(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2932
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2936
::exit(___);}
#if 0
#line 2932
{ 
#line 2933
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2935
return v.x; 
#line 2936
} 
#endif
#line 2938 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned texCubemap(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2939
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2943
::exit(___);}
#if 0
#line 2939
{ 
#line 2940
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2942
return v.x; 
#line 2943
} 
#endif
#line 2945 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 texCubemap(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2946
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2950
::exit(___);}
#if 0
#line 2946
{ 
#line 2947
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2949
return make_int1(v.x); 
#line 2950
} 
#endif
#line 2952 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 texCubemap(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2953
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2957
::exit(___);}
#if 0
#line 2953
{ 
#line 2954
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2956
return make_uint1(v.x); 
#line 2957
} 
#endif
#line 2959 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 texCubemap(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2960
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2964
::exit(___);}
#if 0
#line 2960
{ 
#line 2961
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2963
return make_int2(v.x, v.y); 
#line 2964
} 
#endif
#line 2966 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 texCubemap(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2967
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2971
::exit(___);}
#if 0
#line 2967
{ 
#line 2968
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2970
return make_uint2(v.x, v.y); 
#line 2971
} 
#endif
#line 2973 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 texCubemap(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2974
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2978
::exit(___);}
#if 0
#line 2974
{ 
#line 2975
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2977
return make_int4(v.x, v.y, v.z, v.w); 
#line 2978
} 
#endif
#line 2980 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 texCubemap(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2981
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2985
::exit(___);}
#if 0
#line 2981
{ 
#line 2982
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2984
return make_uint4(v.x, v.y, v.z, v.w); 
#line 2985
} 
#endif
#line 2995 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long texCubemap(texture< long, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2996
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3000
::exit(___);}
#if 0
#line 2996
{ 
#line 2997
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2999
return (long)(v.x); 
#line 3000
} 
#endif
#line 3002 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long texCubemap(texture< unsigned long, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3003
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3007
::exit(___);}
#if 0
#line 3003
{ 
#line 3004
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3006
return (unsigned long)(v.x); 
#line 3007
} 
#endif
#line 3009 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 texCubemap(texture< long1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3010
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3014
::exit(___);}
#if 0
#line 3010
{ 
#line 3011
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3013
return make_long1(v.x); 
#line 3014
} 
#endif
#line 3016 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 texCubemap(texture< ulong1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3017
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3021
::exit(___);}
#if 0
#line 3017
{ 
#line 3018
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3020
return make_ulong1(v.x); 
#line 3021
} 
#endif
#line 3023 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 texCubemap(texture< long2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3024
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3028
::exit(___);}
#if 0
#line 3024
{ 
#line 3025
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3027
return make_long2(v.x, v.y); 
#line 3028
} 
#endif
#line 3030 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 texCubemap(texture< ulong2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3031
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3035
::exit(___);}
#if 0
#line 3031
{ 
#line 3032
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3034
return make_ulong2(v.x, v.y); 
#line 3035
} 
#endif
#line 3037 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 texCubemap(texture< long4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3038
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3042
::exit(___);}
#if 0
#line 3038
{ 
#line 3039
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3041
return make_long4(v.x, v.y, v.z, v.w); 
#line 3042
} 
#endif
#line 3044 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 texCubemap(texture< ulong4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3045
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3049
::exit(___);}
#if 0
#line 3045
{ 
#line 3046
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3048
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 3049
} 
#endif
#line 3059 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemap(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3060
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3064
::exit(___);}
#if 0
#line 3060
{ 
#line 3061
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
#line 3063
return v.x; 
#line 3064
} 
#endif
#line 3066 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemap(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3067
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3071
::exit(___);}
#if 0
#line 3067
{ 
#line 3068
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
#line 3070
return make_float1(v.x); 
#line 3071
} 
#endif
#line 3073 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemap(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3074
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3078
::exit(___);}
#if 0
#line 3074
{ 
#line 3075
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
#line 3077
return make_float2(v.x, v.y); 
#line 3078
} 
#endif
#line 3080 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemap(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3081
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3085
::exit(___);}
#if 0
#line 3081
{ 
#line 3082
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
#line 3084
return make_float4(v.x, v.y, v.z, v.w); 
#line 3085
} 
#endif
#line 3093 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemap(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3094
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 3094 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 3098 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3102
return w.x; 
#line 3103
} 
#endif
#line 3105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemap(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3106
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3111
::exit(___);}
#if 0
#line 3106
{ 
#line 3107
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3108
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3110
return w.x; 
#line 3111
} 
#endif
#line 3113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemap(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3114
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3119
::exit(___);}
#if 0
#line 3114
{ 
#line 3115
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3116
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3118
return w.x; 
#line 3119
} 
#endif
#line 3121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemap(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3122
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3127
::exit(___);}
#if 0
#line 3122
{ 
#line 3123
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3124
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3126
return make_float1(w.x); 
#line 3127
} 
#endif
#line 3129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemap(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3130
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3135
::exit(___);}
#if 0
#line 3130
{ 
#line 3131
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3132
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3134
return make_float1(w.x); 
#line 3135
} 
#endif
#line 3137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemap(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3138
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3143
::exit(___);}
#if 0
#line 3138
{ 
#line 3139
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3140
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3142
return make_float2(w.x, w.y); 
#line 3143
} 
#endif
#line 3145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemap(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3146
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3151
::exit(___);}
#if 0
#line 3146
{ 
#line 3147
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3148
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3150
return make_float2(w.x, w.y); 
#line 3151
} 
#endif
#line 3153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemap(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3154
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3159
::exit(___);}
#if 0
#line 3154
{ 
#line 3155
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3156
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3158
return make_float4(w.x, w.y, w.z, w.w); 
#line 3159
} 
#endif
#line 3161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemap(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3162
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3167
::exit(___);}
#if 0
#line 3162
{ 
#line 3163
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3164
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3166
return make_float4(w.x, w.y, w.z, w.w); 
#line 3167
} 
#endif
#line 3175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemap(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3176
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3181
::exit(___);}
#if 0
#line 3176
{ 
#line 3177
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3178
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3180
return w.x; 
#line 3181
} 
#endif
#line 3183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemap(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3184
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3189
::exit(___);}
#if 0
#line 3184
{ 
#line 3185
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3186
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3188
return w.x; 
#line 3189
} 
#endif
#line 3191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemap(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3192
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3197
::exit(___);}
#if 0
#line 3192
{ 
#line 3193
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3194
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3196
return make_float1(w.x); 
#line 3197
} 
#endif
#line 3199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemap(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3200
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3205
::exit(___);}
#if 0
#line 3200
{ 
#line 3201
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3202
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3204
return make_float1(w.x); 
#line 3205
} 
#endif
#line 3207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemap(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3208
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3213
::exit(___);}
#if 0
#line 3208
{ 
#line 3209
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3210
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3212
return make_float2(w.x, w.y); 
#line 3213
} 
#endif
#line 3215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemap(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3216
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3221
::exit(___);}
#if 0
#line 3216
{ 
#line 3217
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3218
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3220
return make_float2(w.x, w.y); 
#line 3221
} 
#endif
#line 3223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemap(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3224
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3229
::exit(___);}
#if 0
#line 3224
{ 
#line 3225
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3226
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3228
return make_float4(w.x, w.y, w.z, w.w); 
#line 3229
} 
#endif
#line 3231 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemap(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3232
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3237
::exit(___);}
#if 0
#line 3232
{ 
#line 3233
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3234
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3236
return make_float4(w.x, w.y, w.z, w.w); 
#line 3237
} 
#endif
#line 3245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char texCubemapLayered(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3246
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 3246 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 3250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3253 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 3254
} 
#endif
#line 3256 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char texCubemapLayered(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3257
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3261
::exit(___);}
#if 0
#line 3257
{ 
#line 3258
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3260
return (signed char)(v.x); 
#line 3261
} 
#endif
#line 3263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char texCubemapLayered(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3264
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3268
::exit(___);}
#if 0
#line 3264
{ 
#line 3265
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3267
return (unsigned char)(v.x); 
#line 3268
} 
#endif
#line 3270 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 texCubemapLayered(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3271
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3275
::exit(___);}
#if 0
#line 3271
{ 
#line 3272
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3274
return make_char1(v.x); 
#line 3275
} 
#endif
#line 3277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 texCubemapLayered(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3278
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3282
::exit(___);}
#if 0
#line 3278
{ 
#line 3279
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3281
return make_uchar1(v.x); 
#line 3282
} 
#endif
#line 3284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 texCubemapLayered(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3285
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3289
::exit(___);}
#if 0
#line 3285
{ 
#line 3286
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3288
return make_char2(v.x, v.y); 
#line 3289
} 
#endif
#line 3291 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 texCubemapLayered(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3292
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3296
::exit(___);}
#if 0
#line 3292
{ 
#line 3293
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3295
return make_uchar2(v.x, v.y); 
#line 3296
} 
#endif
#line 3298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 texCubemapLayered(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3299
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3303
::exit(___);}
#if 0
#line 3299
{ 
#line 3300
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3302
return make_char4(v.x, v.y, v.z, v.w); 
#line 3303
} 
#endif
#line 3305 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 texCubemapLayered(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3306
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3310
::exit(___);}
#if 0
#line 3306
{ 
#line 3307
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3309
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 3310
} 
#endif
#line 3318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short texCubemapLayered(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3319
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3323
::exit(___);}
#if 0
#line 3319
{ 
#line 3320
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3322
return (short)(v.x); 
#line 3323
} 
#endif
#line 3325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short texCubemapLayered(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3326
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3330
::exit(___);}
#if 0
#line 3326
{ 
#line 3327
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3329
return (unsigned short)(v.x); 
#line 3330
} 
#endif
#line 3332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 texCubemapLayered(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3333
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3337
::exit(___);}
#if 0
#line 3333
{ 
#line 3334
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3336
return make_short1(v.x); 
#line 3337
} 
#endif
#line 3339 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 texCubemapLayered(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3340
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3344
::exit(___);}
#if 0
#line 3340
{ 
#line 3341
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3343
return make_ushort1(v.x); 
#line 3344
} 
#endif
#line 3346 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 texCubemapLayered(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3347
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3351
::exit(___);}
#if 0
#line 3347
{ 
#line 3348
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3350
return make_short2(v.x, v.y); 
#line 3351
} 
#endif
#line 3353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 texCubemapLayered(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3354
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3358
::exit(___);}
#if 0
#line 3354
{ 
#line 3355
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3357
return make_ushort2(v.x, v.y); 
#line 3358
} 
#endif
#line 3360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 texCubemapLayered(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3361
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3365
::exit(___);}
#if 0
#line 3361
{ 
#line 3362
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3364
return make_short4(v.x, v.y, v.z, v.w); 
#line 3365
} 
#endif
#line 3367 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 texCubemapLayered(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3368
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3372
::exit(___);}
#if 0
#line 3368
{ 
#line 3369
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3371
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 3372
} 
#endif
#line 3380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int texCubemapLayered(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3381
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3385
::exit(___);}
#if 0
#line 3381
{ 
#line 3382
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3384
return v.x; 
#line 3385
} 
#endif
#line 3387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned texCubemapLayered(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3388
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3392
::exit(___);}
#if 0
#line 3388
{ 
#line 3389
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3391
return v.x; 
#line 3392
} 
#endif
#line 3394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 texCubemapLayered(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3395
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3399
::exit(___);}
#if 0
#line 3395
{ 
#line 3396
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3398
return make_int1(v.x); 
#line 3399
} 
#endif
#line 3401 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 texCubemapLayered(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3402
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3406
::exit(___);}
#if 0
#line 3402
{ 
#line 3403
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3405
return make_uint1(v.x); 
#line 3406
} 
#endif
#line 3408 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 texCubemapLayered(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3409
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3413
::exit(___);}
#if 0
#line 3409
{ 
#line 3410
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3412
return make_int2(v.x, v.y); 
#line 3413
} 
#endif
#line 3415 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 texCubemapLayered(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3416
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3420
::exit(___);}
#if 0
#line 3416
{ 
#line 3417
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3419
return make_uint2(v.x, v.y); 
#line 3420
} 
#endif
#line 3422 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 texCubemapLayered(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3423
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3427
::exit(___);}
#if 0
#line 3423
{ 
#line 3424
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3426
return make_int4(v.x, v.y, v.z, v.w); 
#line 3427
} 
#endif
#line 3429 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 texCubemapLayered(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3430
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3434
::exit(___);}
#if 0
#line 3430
{ 
#line 3431
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3433
return make_uint4(v.x, v.y, v.z, v.w); 
#line 3434
} 
#endif
#line 3444 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long texCubemapLayered(texture< long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3445
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3449
::exit(___);}
#if 0
#line 3445
{ 
#line 3446
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3448
return (long)(v.x); 
#line 3449
} 
#endif
#line 3451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long texCubemapLayered(texture< unsigned long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3452
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3456
::exit(___);}
#if 0
#line 3452
{ 
#line 3453
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3455
return (unsigned long)(v.x); 
#line 3456
} 
#endif
#line 3458 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 texCubemapLayered(texture< long1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3459
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3463
::exit(___);}
#if 0
#line 3459
{ 
#line 3460
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3462
return make_long1(v.x); 
#line 3463
} 
#endif
#line 3465 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 texCubemapLayered(texture< ulong1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3466
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3470
::exit(___);}
#if 0
#line 3466
{ 
#line 3467
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3469
return make_ulong1(v.x); 
#line 3470
} 
#endif
#line 3472 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 texCubemapLayered(texture< long2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3473
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3477
::exit(___);}
#if 0
#line 3473
{ 
#line 3474
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3476
return make_long2(v.x, v.y); 
#line 3477
} 
#endif
#line 3479 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 texCubemapLayered(texture< ulong2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3480
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3484
::exit(___);}
#if 0
#line 3480
{ 
#line 3481
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3483
return make_ulong2(v.x, v.y); 
#line 3484
} 
#endif
#line 3486 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 texCubemapLayered(texture< long4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3487
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3491
::exit(___);}
#if 0
#line 3487
{ 
#line 3488
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3490
return make_long4(v.x, v.y, v.z, v.w); 
#line 3491
} 
#endif
#line 3493 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 texCubemapLayered(texture< ulong4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3494
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3498
::exit(___);}
#if 0
#line 3494
{ 
#line 3495
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3497
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 3498
} 
#endif
#line 3508 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayered(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3509
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3513
::exit(___);}
#if 0
#line 3509
{ 
#line 3510
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3512
return v.x; 
#line 3513
} 
#endif
#line 3515 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayered(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3516
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3520
::exit(___);}
#if 0
#line 3516
{ 
#line 3517
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3519
return make_float1(v.x); 
#line 3520
} 
#endif
#line 3522 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayered(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3523
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3527
::exit(___);}
#if 0
#line 3523
{ 
#line 3524
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3526
return make_float2(v.x, v.y); 
#line 3527
} 
#endif
#line 3529 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayered(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3530
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3534
::exit(___);}
#if 0
#line 3530
{ 
#line 3531
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3533
return make_float4(v.x, v.y, v.z, v.w); 
#line 3534
} 
#endif
#line 3542 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayered(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3543
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 3543 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 3547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3549 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3551
return w.x; 
#line 3552
} 
#endif
#line 3554 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayered(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3555
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3560
::exit(___);}
#if 0
#line 3555
{ 
#line 3556
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3557
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3559
return w.x; 
#line 3560
} 
#endif
#line 3562 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayered(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3563
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3568
::exit(___);}
#if 0
#line 3563
{ 
#line 3564
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3565
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3567
return w.x; 
#line 3568
} 
#endif
#line 3570 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayered(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3571
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3576
::exit(___);}
#if 0
#line 3571
{ 
#line 3572
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3573
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3575
return make_float1(w.x); 
#line 3576
} 
#endif
#line 3578 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayered(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3579
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3584
::exit(___);}
#if 0
#line 3579
{ 
#line 3580
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3581
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3583
return make_float1(w.x); 
#line 3584
} 
#endif
#line 3586 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayered(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3587
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3592
::exit(___);}
#if 0
#line 3587
{ 
#line 3588
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3589
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3591
return make_float2(w.x, w.y); 
#line 3592
} 
#endif
#line 3594 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayered(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3595
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3600
::exit(___);}
#if 0
#line 3595
{ 
#line 3596
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3597
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3599
return make_float2(w.x, w.y); 
#line 3600
} 
#endif
#line 3602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayered(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3603
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3608
::exit(___);}
#if 0
#line 3603
{ 
#line 3604
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3605
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3607
return make_float4(w.x, w.y, w.z, w.w); 
#line 3608
} 
#endif
#line 3610 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayered(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3611
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3616
::exit(___);}
#if 0
#line 3611
{ 
#line 3612
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3613
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3615
return make_float4(w.x, w.y, w.z, w.w); 
#line 3616
} 
#endif
#line 3624 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayered(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3625
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3630
::exit(___);}
#if 0
#line 3625
{ 
#line 3626
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3627
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3629
return w.x; 
#line 3630
} 
#endif
#line 3632 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayered(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3633
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3638
::exit(___);}
#if 0
#line 3633
{ 
#line 3634
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3635
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3637
return w.x; 
#line 3638
} 
#endif
#line 3640 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayered(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3641
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3646
::exit(___);}
#if 0
#line 3641
{ 
#line 3642
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3643
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3645
return make_float1(w.x); 
#line 3646
} 
#endif
#line 3648 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayered(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3649
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3654
::exit(___);}
#if 0
#line 3649
{ 
#line 3650
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3651
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3653
return make_float1(w.x); 
#line 3654
} 
#endif
#line 3656 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayered(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3657
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3662
::exit(___);}
#if 0
#line 3657
{ 
#line 3658
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3659
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3661
return make_float2(w.x, w.y); 
#line 3662
} 
#endif
#line 3664 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayered(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3665
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3670
::exit(___);}
#if 0
#line 3665
{ 
#line 3666
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3667
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3669
return make_float2(w.x, w.y); 
#line 3670
} 
#endif
#line 3672 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayered(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3673
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3678
::exit(___);}
#if 0
#line 3673
{ 
#line 3674
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3675
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3677
return make_float4(w.x, w.y, w.z, w.w); 
#line 3678
} 
#endif
#line 3680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayered(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3686
::exit(___);}
#if 0
#line 3681
{ 
#line 3682
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3683
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3685
return make_float4(w.x, w.y, w.z, w.w); 
#line 3686
} 
#endif
#line 3807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2Dgather(texture< char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3808
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3810
::exit(___);}
#if 0
#line 3808
{ 
#line 3809
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
#line 3810
} 
#endif
#line 3812 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2Dgather(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3813
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3815
::exit(___);}
#if 0
#line 3813
{ 
#line 3814
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
#line 3815
} 
#endif
#line 3817 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2Dgather(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3818
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3820
::exit(___);}
#if 0
#line 3818
{ 
#line 3819
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } ; 
#line 3820
} 
#endif
#line 3822 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2Dgather(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3823
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3825
::exit(___);}
#if 0
#line 3823
{ 
#line 3824
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
#line 3825
} 
#endif
#line 3827 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2Dgather(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3828
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3830
::exit(___);}
#if 0
#line 3828
{ 
#line 3829
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } ; 
#line 3830
} 
#endif
#line 3832 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2Dgather(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3833
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3835
::exit(___);}
#if 0
#line 3833
{ 
#line 3834
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  ; 
#line 3835
} 
#endif
#line 3837 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2Dgather(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3838
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3840
::exit(___);}
#if 0
#line 3838
{ 
#line 3839
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  ; 
#line 3840
} 
#endif
#line 3842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2Dgather(texture< char3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3845
::exit(___);}
#if 0
#line 3843
{ 
#line 3844
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  }  ; 
#line 3845
} 
#endif
#line 3847 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2Dgather(texture< uchar3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3848
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3850
::exit(___);}
#if 0
#line 3848
{ 
#line 3849
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  }  ; 
#line 3850
} 
#endif
#line 3852 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2Dgather(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3853
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3855
::exit(___);}
#if 0
#line 3853
{ 
#line 3854
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  }  }  ; 
#line 3855
} 
#endif
#line 3857 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2Dgather(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3858
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3860
::exit(___);}
#if 0
#line 3858
{ 
#line 3859
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  }  }  ; 
#line 3860
} 
#endif
#line 3862 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2Dgather(texture< short, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3863
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3865
::exit(___);}
#if 0
#line 3863
{ 
#line 3864
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } ; 
#line 3865
} 
#endif
#line 3867 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2Dgather(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3868
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3870
::exit(___);}
#if 0
#line 3868
{ 
#line 3869
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } ; 
#line 3870
} 
#endif
#line 3872 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2Dgather(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3873
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3875
::exit(___);}
#if 0
#line 3873
{ 
#line 3874
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } ; 
#line 3875
} 
#endif
#line 3877 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2Dgather(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3878
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3880
::exit(___);}
#if 0
#line 3878
{ 
#line 3879
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } ; 
#line 3880
} 
#endif
#line 3882 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2Dgather(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3883
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3885
::exit(___);}
#if 0
#line 3883
{ 
#line 3884
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  ; 
#line 3885
} 
#endif
#line 3887 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2Dgather(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3888
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3890
::exit(___);}
#if 0
#line 3888
{ 
#line 3889
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  ; 
#line 3890
} 
#endif
#line 3892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2Dgather(texture< short3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3893
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3895
::exit(___);}
#if 0
#line 3893
{ 
#line 3894
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  }  ; 
#line 3895
} 
#endif
#line 3897 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2Dgather(texture< ushort3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3900
::exit(___);}
#if 0
#line 3898
{ 
#line 3899
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  }  ; 
#line 3900
} 
#endif
#line 3902 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2Dgather(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3903
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3905
::exit(___);}
#if 0
#line 3903
{ 
#line 3904
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  }  }  ; 
#line 3905
} 
#endif
#line 3907 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2Dgather(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3908
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3910
::exit(___);}
#if 0
#line 3908
{ 
#line 3909
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  }  }  ; 
#line 3910
} 
#endif
#line 3912 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2Dgather(texture< int, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3913
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3915
::exit(___);}
#if 0
#line 3913
{ 
#line 3914
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3915
} 
#endif
#line 3917 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2Dgather(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3918
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3920
::exit(___);}
#if 0
#line 3918
{ 
#line 3919
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3920
} 
#endif
#line 3922 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2Dgather(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3923
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3925
::exit(___);}
#if 0
#line 3923
{ 
#line 3924
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3925
} 
#endif
#line 3927 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2Dgather(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3928
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3930
::exit(___);}
#if 0
#line 3928
{ 
#line 3929
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3930
} 
#endif
#line 3932 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2Dgather(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3933
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3935
::exit(___);}
#if 0
#line 3933
{ 
#line 3934
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
#line 3935
} 
#endif
#line 3937 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2Dgather(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3938
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3940
::exit(___);}
#if 0
#line 3938
{ 
#line 3939
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
#line 3940
} 
#endif
#line 3942 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2Dgather(texture< int3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3943
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3945
::exit(___);}
#if 0
#line 3943
{ 
#line 3944
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
#line 3945
} 
#endif
#line 3947 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2Dgather(texture< uint3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3948
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3950
::exit(___);}
#if 0
#line 3948
{ 
#line 3949
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
#line 3950
} 
#endif
#line 3952 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2Dgather(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3953
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3955
::exit(___);}
#if 0
#line 3953
{ 
#line 3954
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
#line 3955
} 
#endif
#line 3957 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2Dgather(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3958
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3960
::exit(___);}
#if 0
#line 3958
{ 
#line 3959
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
#line 3960
} 
#endif
#line 3962 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< float, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3963
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3965
::exit(___);}
#if 0
#line 3963
{ 
#line 3964
{ float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3965
} 
#endif
#line 3967 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3968
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3970
::exit(___);}
#if 0
#line 3968
{ 
#line 3969
{ float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3970
} 
#endif
#line 3972 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3973
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3975
::exit(___);}
#if 0
#line 3973
{ 
#line 3974
if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
#line 3975
} 
#endif
#line 3977 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< float3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3978
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3980
::exit(___);}
#if 0
#line 3978
{ 
#line 3979
if (comp == 2) { float4 v = __ftex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
#line 3980
} 
#endif
#line 3982 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 3983
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3985
::exit(___);}
#if 0
#line 3983
{ 
#line 3984
if (comp == 3) { float4 v = __ftex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { float4 v = __ftex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
#line 3985
} 
#endif
#line 3994 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 3995
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3997
::exit(___);}
#if 0
#line 3995
{ 
#line 3996
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 3997
} 
#endif
#line 3999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4002
::exit(___);}
#if 0
#line 4000
{ 
#line 4001
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4002
} 
#endif
#line 4004 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4005
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4007
::exit(___);}
#if 0
#line 4005
{ 
#line 4006
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4007
} 
#endif
#line 4009 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4010
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4012
::exit(___);}
#if 0
#line 4010
{ 
#line 4011
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4012
} 
#endif
#line 4014 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4015
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4017
::exit(___);}
#if 0
#line 4015
{ 
#line 4016
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4017
} 
#endif
#line 4019 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4020
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4022
::exit(___);}
#if 0
#line 4020
{ 
#line 4021
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
#line 4022
} 
#endif
#line 4024 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4025
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4027
::exit(___);}
#if 0
#line 4025
{ 
#line 4026
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
#line 4027
} 
#endif
#line 4029 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< char3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4030
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4032
::exit(___);}
#if 0
#line 4030
{ 
#line 4031
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
#line 4032
} 
#endif
#line 4034 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< uchar3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4035
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4037
::exit(___);}
#if 0
#line 4035
{ 
#line 4036
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
#line 4037
} 
#endif
#line 4039 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4040
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4042
::exit(___);}
#if 0
#line 4040
{ 
#line 4041
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
#line 4042
} 
#endif
#line 4044 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4045
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4047
::exit(___);}
#if 0
#line 4045
{ 
#line 4046
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
#line 4047
} 
#endif
#line 4049 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4050
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4052
::exit(___);}
#if 0
#line 4050
{ 
#line 4051
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4052
} 
#endif
#line 4054 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4055
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4057
::exit(___);}
#if 0
#line 4055
{ 
#line 4056
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4057
} 
#endif
#line 4059 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4060
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4062
::exit(___);}
#if 0
#line 4060
{ 
#line 4061
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4062
} 
#endif
#line 4064 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4065
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4067
::exit(___);}
#if 0
#line 4065
{ 
#line 4066
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 4067
} 
#endif
#line 4069 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4070
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4072
::exit(___);}
#if 0
#line 4070
{ 
#line 4071
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
#line 4072
} 
#endif
#line 4074 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4075
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4077
::exit(___);}
#if 0
#line 4075
{ 
#line 4076
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
#line 4077
} 
#endif
#line 4079 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< short3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4080
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4082
::exit(___);}
#if 0
#line 4080
{ 
#line 4081
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
#line 4082
} 
#endif
#line 4084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< ushort3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4085
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4087
::exit(___);}
#if 0
#line 4085
{ 
#line 4086
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
#line 4087
} 
#endif
#line 4089 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4090
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4092
::exit(___);}
#if 0
#line 4090
{ 
#line 4091
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
#line 4092
} 
#endif
#line 4094 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2Dgather(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 4095
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 4097
::exit(___);}
#if 0
#line 4095
{ 
#line 4096
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
#line 4097
} 
#endif
#line 4124 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex1DLod(texture< char, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4125
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 4125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 4129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 4133
} 
#endif
#line 4135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1DLod(texture< signed char, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4136
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4140
::exit(___);}
#if 0
#line 4136
{ 
#line 4137
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4139
return (signed char)(v.x); 
#line 4140
} 
#endif
#line 4142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1DLod(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4143
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4147
::exit(___);}
#if 0
#line 4143
{ 
#line 4144
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4146
return (unsigned char)(v.x); 
#line 4147
} 
#endif
#line 4149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1DLod(texture< char1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4150
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4154
::exit(___);}
#if 0
#line 4150
{ 
#line 4151
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4153
return make_char1(v.x); 
#line 4154
} 
#endif
#line 4156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1DLod(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4157
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4161
::exit(___);}
#if 0
#line 4157
{ 
#line 4158
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4160
return make_uchar1(v.x); 
#line 4161
} 
#endif
#line 4163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1DLod(texture< char2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4164
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4168
::exit(___);}
#if 0
#line 4164
{ 
#line 4165
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4167
return make_char2(v.x, v.y); 
#line 4168
} 
#endif
#line 4170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1DLod(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4171
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4175
::exit(___);}
#if 0
#line 4171
{ 
#line 4172
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4174
return make_uchar2(v.x, v.y); 
#line 4175
} 
#endif
#line 4177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1DLod(texture< char4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4178
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4182
::exit(___);}
#if 0
#line 4178
{ 
#line 4179
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4181
return make_char4(v.x, v.y, v.z, v.w); 
#line 4182
} 
#endif
#line 4184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1DLod(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4185
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4189
::exit(___);}
#if 0
#line 4185
{ 
#line 4186
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4188
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 4189
} 
#endif
#line 4197 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex1DLod(texture< short, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4198
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4202
::exit(___);}
#if 0
#line 4198
{ 
#line 4199
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4201
return (short)(v.x); 
#line 4202
} 
#endif
#line 4204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1DLod(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4205
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4209
::exit(___);}
#if 0
#line 4205
{ 
#line 4206
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4208
return (unsigned short)(v.x); 
#line 4209
} 
#endif
#line 4211 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1DLod(texture< short1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4212
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4216
::exit(___);}
#if 0
#line 4212
{ 
#line 4213
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4215
return make_short1(v.x); 
#line 4216
} 
#endif
#line 4218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1DLod(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4219
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4223
::exit(___);}
#if 0
#line 4219
{ 
#line 4220
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4222
return make_ushort1(v.x); 
#line 4223
} 
#endif
#line 4225 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1DLod(texture< short2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4226
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4230
::exit(___);}
#if 0
#line 4226
{ 
#line 4227
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4229
return make_short2(v.x, v.y); 
#line 4230
} 
#endif
#line 4232 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1DLod(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4233
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4237
::exit(___);}
#if 0
#line 4233
{ 
#line 4234
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4236
return make_ushort2(v.x, v.y); 
#line 4237
} 
#endif
#line 4239 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1DLod(texture< short4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4240
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4244
::exit(___);}
#if 0
#line 4240
{ 
#line 4241
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4243
return make_short4(v.x, v.y, v.z, v.w); 
#line 4244
} 
#endif
#line 4246 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1DLod(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4247
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4251
::exit(___);}
#if 0
#line 4247
{ 
#line 4248
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4250
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 4251
} 
#endif
#line 4259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex1DLod(texture< int, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4260
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4264
::exit(___);}
#if 0
#line 4260
{ 
#line 4261
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4263
return v.x; 
#line 4264
} 
#endif
#line 4266 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1DLod(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4267
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4271
::exit(___);}
#if 0
#line 4267
{ 
#line 4268
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4270
return v.x; 
#line 4271
} 
#endif
#line 4273 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1DLod(texture< int1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4274
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4278
::exit(___);}
#if 0
#line 4274
{ 
#line 4275
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4277
return make_int1(v.x); 
#line 4278
} 
#endif
#line 4280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1DLod(texture< uint1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4281
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4285
::exit(___);}
#if 0
#line 4281
{ 
#line 4282
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4284
return make_uint1(v.x); 
#line 4285
} 
#endif
#line 4287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1DLod(texture< int2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4288
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4292
::exit(___);}
#if 0
#line 4288
{ 
#line 4289
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4291
return make_int2(v.x, v.y); 
#line 4292
} 
#endif
#line 4294 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1DLod(texture< uint2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4295
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4299
::exit(___);}
#if 0
#line 4295
{ 
#line 4296
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4298
return make_uint2(v.x, v.y); 
#line 4299
} 
#endif
#line 4301 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1DLod(texture< int4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4302
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4306
::exit(___);}
#if 0
#line 4302
{ 
#line 4303
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4305
return make_int4(v.x, v.y, v.z, v.w); 
#line 4306
} 
#endif
#line 4308 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1DLod(texture< uint4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4309
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4313
::exit(___);}
#if 0
#line 4309
{ 
#line 4310
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4312
return make_uint4(v.x, v.y, v.z, v.w); 
#line 4313
} 
#endif
#line 4329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex1DLod(texture< long, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4330
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4334
::exit(___);}
#if 0
#line 4330
{ 
#line 4331
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4333
return (long)(v.x); 
#line 4334
} 
#endif
#line 4336 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1DLod(texture< unsigned long, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4337
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4341
::exit(___);}
#if 0
#line 4337
{ 
#line 4338
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4340
return (unsigned long)(v.x); 
#line 4341
} 
#endif
#line 4343 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1DLod(texture< long1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4344
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4348
::exit(___);}
#if 0
#line 4344
{ 
#line 4345
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4347
return make_long1(v.x); 
#line 4348
} 
#endif
#line 4350 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1DLod(texture< ulong1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4351
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4355
::exit(___);}
#if 0
#line 4351
{ 
#line 4352
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4354
return make_ulong1(v.x); 
#line 4355
} 
#endif
#line 4357 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1DLod(texture< long2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4358
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4362
::exit(___);}
#if 0
#line 4358
{ 
#line 4359
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4361
return make_long2(v.x, v.y); 
#line 4362
} 
#endif
#line 4364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1DLod(texture< ulong2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4365
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4369
::exit(___);}
#if 0
#line 4365
{ 
#line 4366
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4368
return make_ulong2(v.x, v.y); 
#line 4369
} 
#endif
#line 4371 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1DLod(texture< long4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4372
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4376
::exit(___);}
#if 0
#line 4372
{ 
#line 4373
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4375
return make_long4(v.x, v.y, v.z, v.w); 
#line 4376
} 
#endif
#line 4378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1DLod(texture< ulong4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4379
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4383
::exit(___);}
#if 0
#line 4379
{ 
#line 4380
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4382
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 4383
} 
#endif
#line 4393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLod(texture< float, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4394
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4398
::exit(___);}
#if 0
#line 4394
{ 
#line 4395
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4397
return v.x; 
#line 4398
} 
#endif
#line 4400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLod(texture< float1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4401
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4405
::exit(___);}
#if 0
#line 4401
{ 
#line 4402
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4404
return make_float1(v.x); 
#line 4405
} 
#endif
#line 4407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLod(texture< float2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4408
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4412
::exit(___);}
#if 0
#line 4408
{ 
#line 4409
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4411
return make_float2(v.x, v.y); 
#line 4412
} 
#endif
#line 4414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLod(texture< float4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4415
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4419
::exit(___);}
#if 0
#line 4415
{ 
#line 4416
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4418
return make_float4(v.x, v.y, v.z, v.w); 
#line 4419
} 
#endif
#line 4427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLod(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4428
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4437 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 4428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 4432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4434 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4436
return w.x; 
#line 4437
} 
#endif
#line 4439 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLod(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4440
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4445
::exit(___);}
#if 0
#line 4440
{ 
#line 4441
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4442
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4444
return w.x; 
#line 4445
} 
#endif
#line 4447 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLod(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4448
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4453
::exit(___);}
#if 0
#line 4448
{ 
#line 4449
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4450
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4452
return w.x; 
#line 4453
} 
#endif
#line 4455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLod(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4456
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4461
::exit(___);}
#if 0
#line 4456
{ 
#line 4457
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4458
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4460
return make_float1(w.x); 
#line 4461
} 
#endif
#line 4463 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLod(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4464
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4469
::exit(___);}
#if 0
#line 4464
{ 
#line 4465
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4466
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4468
return make_float1(w.x); 
#line 4469
} 
#endif
#line 4471 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLod(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4472
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4477
::exit(___);}
#if 0
#line 4472
{ 
#line 4473
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4474
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4476
return make_float2(w.x, w.y); 
#line 4477
} 
#endif
#line 4479 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLod(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4480
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4485
::exit(___);}
#if 0
#line 4480
{ 
#line 4481
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4482
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4484
return make_float2(w.x, w.y); 
#line 4485
} 
#endif
#line 4487 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLod(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4488
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4493
::exit(___);}
#if 0
#line 4488
{ 
#line 4489
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4490
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4492
return make_float4(w.x, w.y, w.z, w.w); 
#line 4493
} 
#endif
#line 4495 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLod(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4496
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4501
::exit(___);}
#if 0
#line 4496
{ 
#line 4497
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4498
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4500
return make_float4(w.x, w.y, w.z, w.w); 
#line 4501
} 
#endif
#line 4509 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLod(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4510
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4515
::exit(___);}
#if 0
#line 4510
{ 
#line 4511
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4512
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4514
return w.x; 
#line 4515
} 
#endif
#line 4517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLod(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4518
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4523
::exit(___);}
#if 0
#line 4518
{ 
#line 4519
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4520
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4522
return w.x; 
#line 4523
} 
#endif
#line 4525 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLod(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4526
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4531
::exit(___);}
#if 0
#line 4526
{ 
#line 4527
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4528
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4530
return make_float1(w.x); 
#line 4531
} 
#endif
#line 4533 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLod(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4534
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4539
::exit(___);}
#if 0
#line 4534
{ 
#line 4535
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4536
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4538
return make_float1(w.x); 
#line 4539
} 
#endif
#line 4541 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLod(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4542
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4547
::exit(___);}
#if 0
#line 4542
{ 
#line 4543
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4544
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4546
return make_float2(w.x, w.y); 
#line 4547
} 
#endif
#line 4549 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLod(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4550
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4555
::exit(___);}
#if 0
#line 4550
{ 
#line 4551
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4552
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4554
return make_float2(w.x, w.y); 
#line 4555
} 
#endif
#line 4557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLod(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4558
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4563
::exit(___);}
#if 0
#line 4558
{ 
#line 4559
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4560
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4562
return make_float4(w.x, w.y, w.z, w.w); 
#line 4563
} 
#endif
#line 4565 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLod(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4566
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4571
::exit(___);}
#if 0
#line 4566
{ 
#line 4567
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4568
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4570
return make_float4(w.x, w.y, w.z, w.w); 
#line 4571
} 
#endif
#line 4579 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex2DLod(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4580
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 4580 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 4584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4587 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 4588
} 
#endif
#line 4590 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex2DLod(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4591
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4595
::exit(___);}
#if 0
#line 4591
{ 
#line 4592
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4594
return (signed char)(v.x); 
#line 4595
} 
#endif
#line 4597 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex2DLod(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4598
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4602
::exit(___);}
#if 0
#line 4598
{ 
#line 4599
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4601
return (unsigned char)(v.x); 
#line 4602
} 
#endif
#line 4604 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex2DLod(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4605
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4609
::exit(___);}
#if 0
#line 4605
{ 
#line 4606
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4608
return make_char1(v.x); 
#line 4609
} 
#endif
#line 4611 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex2DLod(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4612
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4616
::exit(___);}
#if 0
#line 4612
{ 
#line 4613
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4615
return make_uchar1(v.x); 
#line 4616
} 
#endif
#line 4618 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex2DLod(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4619
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4623
::exit(___);}
#if 0
#line 4619
{ 
#line 4620
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4622
return make_char2(v.x, v.y); 
#line 4623
} 
#endif
#line 4625 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex2DLod(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4626
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4630
::exit(___);}
#if 0
#line 4626
{ 
#line 4627
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4629
return make_uchar2(v.x, v.y); 
#line 4630
} 
#endif
#line 4632 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2DLod(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4633
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4637
::exit(___);}
#if 0
#line 4633
{ 
#line 4634
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4636
return make_char4(v.x, v.y, v.z, v.w); 
#line 4637
} 
#endif
#line 4639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2DLod(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4640
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4644
::exit(___);}
#if 0
#line 4640
{ 
#line 4641
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4643
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 4644
} 
#endif
#line 4652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex2DLod(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4653
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4657
::exit(___);}
#if 0
#line 4653
{ 
#line 4654
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4656
return (short)(v.x); 
#line 4657
} 
#endif
#line 4659 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex2DLod(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4660
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4664
::exit(___);}
#if 0
#line 4660
{ 
#line 4661
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4663
return (unsigned short)(v.x); 
#line 4664
} 
#endif
#line 4666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex2DLod(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4667
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4671
::exit(___);}
#if 0
#line 4667
{ 
#line 4668
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4670
return make_short1(v.x); 
#line 4671
} 
#endif
#line 4673 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex2DLod(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4674
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4678
::exit(___);}
#if 0
#line 4674
{ 
#line 4675
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4677
return make_ushort1(v.x); 
#line 4678
} 
#endif
#line 4680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex2DLod(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4685
::exit(___);}
#if 0
#line 4681
{ 
#line 4682
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4684
return make_short2(v.x, v.y); 
#line 4685
} 
#endif
#line 4687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex2DLod(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4688
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4692
::exit(___);}
#if 0
#line 4688
{ 
#line 4689
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4691
return make_ushort2(v.x, v.y); 
#line 4692
} 
#endif
#line 4694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2DLod(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4695
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4699
::exit(___);}
#if 0
#line 4695
{ 
#line 4696
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4698
return make_short4(v.x, v.y, v.z, v.w); 
#line 4699
} 
#endif
#line 4701 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2DLod(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4702
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4706
::exit(___);}
#if 0
#line 4702
{ 
#line 4703
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4705
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 4706
} 
#endif
#line 4714 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex2DLod(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4715
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4719
::exit(___);}
#if 0
#line 4715
{ 
#line 4716
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4718
return v.x; 
#line 4719
} 
#endif
#line 4721 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex2DLod(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4722
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4726
::exit(___);}
#if 0
#line 4722
{ 
#line 4723
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4725
return v.x; 
#line 4726
} 
#endif
#line 4728 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex2DLod(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4729
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4733
::exit(___);}
#if 0
#line 4729
{ 
#line 4730
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4732
return make_int1(v.x); 
#line 4733
} 
#endif
#line 4735 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex2DLod(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4736
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4740
::exit(___);}
#if 0
#line 4736
{ 
#line 4737
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4739
return make_uint1(v.x); 
#line 4740
} 
#endif
#line 4742 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex2DLod(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4743
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4747
::exit(___);}
#if 0
#line 4743
{ 
#line 4744
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4746
return make_int2(v.x, v.y); 
#line 4747
} 
#endif
#line 4749 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex2DLod(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4750
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4754
::exit(___);}
#if 0
#line 4750
{ 
#line 4751
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4753
return make_uint2(v.x, v.y); 
#line 4754
} 
#endif
#line 4756 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2DLod(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4757
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4761
::exit(___);}
#if 0
#line 4757
{ 
#line 4758
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4760
return make_int4(v.x, v.y, v.z, v.w); 
#line 4761
} 
#endif
#line 4763 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2DLod(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4764
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4768
::exit(___);}
#if 0
#line 4764
{ 
#line 4765
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4767
return make_uint4(v.x, v.y, v.z, v.w); 
#line 4768
} 
#endif
#line 4778 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex2DLod(texture< long, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4779
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4783
::exit(___);}
#if 0
#line 4779
{ 
#line 4780
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4782
return (long)(v.x); 
#line 4783
} 
#endif
#line 4785 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex2DLod(texture< unsigned long, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4786
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4790
::exit(___);}
#if 0
#line 4786
{ 
#line 4787
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4789
return (unsigned long)(v.x); 
#line 4790
} 
#endif
#line 4792 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex2DLod(texture< long1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4793
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4797
::exit(___);}
#if 0
#line 4793
{ 
#line 4794
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4796
return make_long1(v.x); 
#line 4797
} 
#endif
#line 4799 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex2DLod(texture< ulong1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4800
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4804
::exit(___);}
#if 0
#line 4800
{ 
#line 4801
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4803
return make_ulong1(v.x); 
#line 4804
} 
#endif
#line 4806 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex2DLod(texture< long2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4807
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4811
::exit(___);}
#if 0
#line 4807
{ 
#line 4808
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4810
return make_long2(v.x, v.y); 
#line 4811
} 
#endif
#line 4813 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex2DLod(texture< ulong2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4814
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4818
::exit(___);}
#if 0
#line 4814
{ 
#line 4815
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4817
return make_ulong2(v.x, v.y); 
#line 4818
} 
#endif
#line 4820 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex2DLod(texture< long4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4821
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4825
::exit(___);}
#if 0
#line 4821
{ 
#line 4822
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4824
return make_long4(v.x, v.y, v.z, v.w); 
#line 4825
} 
#endif
#line 4827 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex2DLod(texture< ulong4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4828
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4832
::exit(___);}
#if 0
#line 4828
{ 
#line 4829
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4831
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 4832
} 
#endif
#line 4842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLod(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4847
::exit(___);}
#if 0
#line 4843
{ 
#line 4844
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4846
return v.x; 
#line 4847
} 
#endif
#line 4849 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLod(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4850
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4854
::exit(___);}
#if 0
#line 4850
{ 
#line 4851
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4853
return make_float1(v.x); 
#line 4854
} 
#endif
#line 4856 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLod(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4861
::exit(___);}
#if 0
#line 4857
{ 
#line 4858
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4860
return make_float2(v.x, v.y); 
#line 4861
} 
#endif
#line 4863 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLod(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4864
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4868
::exit(___);}
#if 0
#line 4864
{ 
#line 4865
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4867
return make_float4(v.x, v.y, v.z, v.w); 
#line 4868
} 
#endif
#line 4876 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLod(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4877
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4886 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 4877 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 4881 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4883 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4885
return w.x; 
#line 4886
} 
#endif
#line 4888 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLod(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4889
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4894
::exit(___);}
#if 0
#line 4889
{ 
#line 4890
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4891
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4893
return w.x; 
#line 4894
} 
#endif
#line 4896 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLod(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4897
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4902
::exit(___);}
#if 0
#line 4897
{ 
#line 4898
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4899
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4901
return w.x; 
#line 4902
} 
#endif
#line 4904 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLod(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4910
::exit(___);}
#if 0
#line 4905
{ 
#line 4906
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4907
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4909
return make_float1(w.x); 
#line 4910
} 
#endif
#line 4912 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLod(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4913
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4918
::exit(___);}
#if 0
#line 4913
{ 
#line 4914
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4915
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4917
return make_float1(w.x); 
#line 4918
} 
#endif
#line 4920 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLod(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4921
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4926
::exit(___);}
#if 0
#line 4921
{ 
#line 4922
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4923
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4925
return make_float2(w.x, w.y); 
#line 4926
} 
#endif
#line 4928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLod(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4929
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4934
::exit(___);}
#if 0
#line 4929
{ 
#line 4930
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4931
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4933
return make_float2(w.x, w.y); 
#line 4934
} 
#endif
#line 4936 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLod(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4937
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4942
::exit(___);}
#if 0
#line 4937
{ 
#line 4938
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4939
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4941
return make_float4(w.x, w.y, w.z, w.w); 
#line 4942
} 
#endif
#line 4944 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLod(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4945
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4950
::exit(___);}
#if 0
#line 4945
{ 
#line 4946
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4947
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4949
return make_float4(w.x, w.y, w.z, w.w); 
#line 4950
} 
#endif
#line 4958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLod(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4959
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4964
::exit(___);}
#if 0
#line 4959
{ 
#line 4960
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4961
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4963
return w.x; 
#line 4964
} 
#endif
#line 4966 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLod(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4967
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4972
::exit(___);}
#if 0
#line 4967
{ 
#line 4968
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4969
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4971
return w.x; 
#line 4972
} 
#endif
#line 4974 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLod(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4975
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4980
::exit(___);}
#if 0
#line 4975
{ 
#line 4976
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4977
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4979
return make_float1(w.x); 
#line 4980
} 
#endif
#line 4982 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLod(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4983
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4988
::exit(___);}
#if 0
#line 4983
{ 
#line 4984
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4985
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4987
return make_float1(w.x); 
#line 4988
} 
#endif
#line 4990 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLod(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4991
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4996
::exit(___);}
#if 0
#line 4991
{ 
#line 4992
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4993
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4995
return make_float2(w.x, w.y); 
#line 4996
} 
#endif
#line 4998 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLod(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4999
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 5004
::exit(___);}
#if 0
#line 4999
{ 
#line 5000
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 5001
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5003
return make_float2(w.x, w.y); 
#line 5004
} 
#endif
#line 5006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLod(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 5007
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 5012
::exit(___);}
#if 0
#line 5007
{ 
#line 5008
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 5009
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5011
return make_float4(w.x, w.y, w.z, w.w); 
#line 5012
} 
#endif
#line 5014 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLod(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 5015
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 5020
::exit(___);}
#if 0
#line 5015
{ 
#line 5016
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 5017
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5019
return make_float4(w.x, w.y, w.z, w.w); 
#line 5020
} 
#endif
#line 5028 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex1DLayeredLod(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5029
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5037 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 5029 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 5033 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5036 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 5037
} 
#endif
#line 5039 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1DLayeredLod(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5040
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5044
::exit(___);}
#if 0
#line 5040
{ 
#line 5041
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5043
return (signed char)(v.x); 
#line 5044
} 
#endif
#line 5046 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5047
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5051
::exit(___);}
#if 0
#line 5047
{ 
#line 5048
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5050
return (unsigned char)(v.x); 
#line 5051
} 
#endif
#line 5053 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1DLayeredLod(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5054
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5058
::exit(___);}
#if 0
#line 5054
{ 
#line 5055
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5057
return make_char1(v.x); 
#line 5058
} 
#endif
#line 5060 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5061
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5065
::exit(___);}
#if 0
#line 5061
{ 
#line 5062
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5064
return make_uchar1(v.x); 
#line 5065
} 
#endif
#line 5067 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1DLayeredLod(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5068
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5072
::exit(___);}
#if 0
#line 5068
{ 
#line 5069
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5071
return make_char2(v.x, v.y); 
#line 5072
} 
#endif
#line 5074 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5075
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5079
::exit(___);}
#if 0
#line 5075
{ 
#line 5076
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5078
return make_uchar2(v.x, v.y); 
#line 5079
} 
#endif
#line 5081 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1DLayeredLod(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5082
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5086
::exit(___);}
#if 0
#line 5082
{ 
#line 5083
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5085
return make_char4(v.x, v.y, v.z, v.w); 
#line 5086
} 
#endif
#line 5088 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5089
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5093
::exit(___);}
#if 0
#line 5089
{ 
#line 5090
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5092
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 5093
} 
#endif
#line 5101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex1DLayeredLod(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5102
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5106
::exit(___);}
#if 0
#line 5102
{ 
#line 5103
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5105
return (short)(v.x); 
#line 5106
} 
#endif
#line 5108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5109
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5113
::exit(___);}
#if 0
#line 5109
{ 
#line 5110
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5112
return (unsigned short)(v.x); 
#line 5113
} 
#endif
#line 5115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1DLayeredLod(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5116
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5120
::exit(___);}
#if 0
#line 5116
{ 
#line 5117
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5119
return make_short1(v.x); 
#line 5120
} 
#endif
#line 5122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5123
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5127
::exit(___);}
#if 0
#line 5123
{ 
#line 5124
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5126
return make_ushort1(v.x); 
#line 5127
} 
#endif
#line 5129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1DLayeredLod(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5130
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5134
::exit(___);}
#if 0
#line 5130
{ 
#line 5131
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5133
return make_short2(v.x, v.y); 
#line 5134
} 
#endif
#line 5136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5137
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5141
::exit(___);}
#if 0
#line 5137
{ 
#line 5138
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5140
return make_ushort2(v.x, v.y); 
#line 5141
} 
#endif
#line 5143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1DLayeredLod(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5144
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5148
::exit(___);}
#if 0
#line 5144
{ 
#line 5145
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5147
return make_short4(v.x, v.y, v.z, v.w); 
#line 5148
} 
#endif
#line 5150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5151
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5155
::exit(___);}
#if 0
#line 5151
{ 
#line 5152
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5154
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 5155
} 
#endif
#line 5163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex1DLayeredLod(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5164
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5168
::exit(___);}
#if 0
#line 5164
{ 
#line 5165
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5167
return v.x; 
#line 5168
} 
#endif
#line 5170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1DLayeredLod(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5171
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5175
::exit(___);}
#if 0
#line 5171
{ 
#line 5172
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5174
return v.x; 
#line 5175
} 
#endif
#line 5177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1DLayeredLod(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5178
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5182
::exit(___);}
#if 0
#line 5178
{ 
#line 5179
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5181
return make_int1(v.x); 
#line 5182
} 
#endif
#line 5184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1DLayeredLod(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5185
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5189
::exit(___);}
#if 0
#line 5185
{ 
#line 5186
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5188
return make_uint1(v.x); 
#line 5189
} 
#endif
#line 5191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1DLayeredLod(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5192
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5196
::exit(___);}
#if 0
#line 5192
{ 
#line 5193
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5195
return make_int2(v.x, v.y); 
#line 5196
} 
#endif
#line 5198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1DLayeredLod(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5199
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5203
::exit(___);}
#if 0
#line 5199
{ 
#line 5200
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5202
return make_uint2(v.x, v.y); 
#line 5203
} 
#endif
#line 5205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1DLayeredLod(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5206
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5210
::exit(___);}
#if 0
#line 5206
{ 
#line 5207
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5209
return make_int4(v.x, v.y, v.z, v.w); 
#line 5210
} 
#endif
#line 5212 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1DLayeredLod(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5213
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5217
::exit(___);}
#if 0
#line 5213
{ 
#line 5214
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5216
return make_uint4(v.x, v.y, v.z, v.w); 
#line 5217
} 
#endif
#line 5227 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex1DLayeredLod(texture< long, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5228
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5232
::exit(___);}
#if 0
#line 5228
{ 
#line 5229
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5231
return (long)(v.x); 
#line 5232
} 
#endif
#line 5234 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1DLayeredLod(texture< unsigned long, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5235
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5239
::exit(___);}
#if 0
#line 5235
{ 
#line 5236
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5238
return (unsigned long)(v.x); 
#line 5239
} 
#endif
#line 5241 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1DLayeredLod(texture< long1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5242
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5246
::exit(___);}
#if 0
#line 5242
{ 
#line 5243
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5245
return make_long1(v.x); 
#line 5246
} 
#endif
#line 5248 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1DLayeredLod(texture< ulong1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5249
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5253
::exit(___);}
#if 0
#line 5249
{ 
#line 5250
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5252
return make_ulong1(v.x); 
#line 5253
} 
#endif
#line 5255 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1DLayeredLod(texture< long2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5256
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5260
::exit(___);}
#if 0
#line 5256
{ 
#line 5257
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5259
return make_long2(v.x, v.y); 
#line 5260
} 
#endif
#line 5262 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1DLayeredLod(texture< ulong2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5263
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5267
::exit(___);}
#if 0
#line 5263
{ 
#line 5264
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5266
return make_ulong2(v.x, v.y); 
#line 5267
} 
#endif
#line 5269 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1DLayeredLod(texture< long4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5270
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5274
::exit(___);}
#if 0
#line 5270
{ 
#line 5271
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5273
return make_long4(v.x, v.y, v.z, v.w); 
#line 5274
} 
#endif
#line 5276 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1DLayeredLod(texture< ulong4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5277
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5281
::exit(___);}
#if 0
#line 5277
{ 
#line 5278
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5280
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 5281
} 
#endif
#line 5291 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredLod(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5292
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5296
::exit(___);}
#if 0
#line 5292
{ 
#line 5293
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5295
return v.x; 
#line 5296
} 
#endif
#line 5298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredLod(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5299
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5303
::exit(___);}
#if 0
#line 5299
{ 
#line 5300
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5302
return make_float1(v.x); 
#line 5303
} 
#endif
#line 5305 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredLod(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5306
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5310
::exit(___);}
#if 0
#line 5306
{ 
#line 5307
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5309
return make_float2(v.x, v.y); 
#line 5310
} 
#endif
#line 5312 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredLod(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5313
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5317
::exit(___);}
#if 0
#line 5313
{ 
#line 5314
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5316
return make_float4(v.x, v.y, v.z, v.w); 
#line 5317
} 
#endif
#line 5325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredLod(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5326
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5335 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 5326 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 5330 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5334
return w.x; 
#line 5335
} 
#endif
#line 5337 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredLod(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5338
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5343
::exit(___);}
#if 0
#line 5338
{ 
#line 5339
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5340
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5342
return w.x; 
#line 5343
} 
#endif
#line 5345 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5346
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5351
::exit(___);}
#if 0
#line 5346
{ 
#line 5347
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5348
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5350
return w.x; 
#line 5351
} 
#endif
#line 5353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredLod(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5354
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5359
::exit(___);}
#if 0
#line 5354
{ 
#line 5355
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5356
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5358
return make_float1(w.x); 
#line 5359
} 
#endif
#line 5361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5362
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5367
::exit(___);}
#if 0
#line 5362
{ 
#line 5363
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5364
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5366
return make_float1(w.x); 
#line 5367
} 
#endif
#line 5369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredLod(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5370
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5375
::exit(___);}
#if 0
#line 5370
{ 
#line 5371
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5372
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5374
return make_float2(w.x, w.y); 
#line 5375
} 
#endif
#line 5377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5378
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5383
::exit(___);}
#if 0
#line 5378
{ 
#line 5379
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5380
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5382
return make_float2(w.x, w.y); 
#line 5383
} 
#endif
#line 5385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredLod(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5386
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5391
::exit(___);}
#if 0
#line 5386
{ 
#line 5387
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5388
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5390
return make_float4(w.x, w.y, w.z, w.w); 
#line 5391
} 
#endif
#line 5393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5394
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5399
::exit(___);}
#if 0
#line 5394
{ 
#line 5395
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5396
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5398
return make_float4(w.x, w.y, w.z, w.w); 
#line 5399
} 
#endif
#line 5407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredLod(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5408
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5413
::exit(___);}
#if 0
#line 5408
{ 
#line 5409
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5410
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5412
return w.x; 
#line 5413
} 
#endif
#line 5415 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5416
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5421
::exit(___);}
#if 0
#line 5416
{ 
#line 5417
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5418
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5420
return w.x; 
#line 5421
} 
#endif
#line 5423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredLod(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5424
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5429
::exit(___);}
#if 0
#line 5424
{ 
#line 5425
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5426
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5428
return make_float1(w.x); 
#line 5429
} 
#endif
#line 5431 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5432
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5437
::exit(___);}
#if 0
#line 5432
{ 
#line 5433
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5434
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5436
return make_float1(w.x); 
#line 5437
} 
#endif
#line 5439 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredLod(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5440
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5445
::exit(___);}
#if 0
#line 5440
{ 
#line 5441
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5442
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5444
return make_float2(w.x, w.y); 
#line 5445
} 
#endif
#line 5447 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5448
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5453
::exit(___);}
#if 0
#line 5448
{ 
#line 5449
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5450
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5452
return make_float2(w.x, w.y); 
#line 5453
} 
#endif
#line 5455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredLod(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5456
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5461
::exit(___);}
#if 0
#line 5456
{ 
#line 5457
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5458
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5460
return make_float4(w.x, w.y, w.z, w.w); 
#line 5461
} 
#endif
#line 5463 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5464
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5469
::exit(___);}
#if 0
#line 5464
{ 
#line 5465
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5466
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5468
return make_float4(w.x, w.y, w.z, w.w); 
#line 5469
} 
#endif
#line 5477 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex2DLayeredLod(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5478
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5486 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 5478 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 5482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5485 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 5486
} 
#endif
#line 5488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex2DLayeredLod(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5489
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5493
::exit(___);}
#if 0
#line 5489
{ 
#line 5490
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5492
return (signed char)(v.x); 
#line 5493
} 
#endif
#line 5495 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5496
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5500
::exit(___);}
#if 0
#line 5496
{ 
#line 5497
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5499
return (unsigned char)(v.x); 
#line 5500
} 
#endif
#line 5502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex2DLayeredLod(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5503
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5507
::exit(___);}
#if 0
#line 5503
{ 
#line 5504
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5506
return make_char1(v.x); 
#line 5507
} 
#endif
#line 5509 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5510
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5514
::exit(___);}
#if 0
#line 5510
{ 
#line 5511
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5513
return make_uchar1(v.x); 
#line 5514
} 
#endif
#line 5516 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex2DLayeredLod(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5517
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5521
::exit(___);}
#if 0
#line 5517
{ 
#line 5518
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5520
return make_char2(v.x, v.y); 
#line 5521
} 
#endif
#line 5523 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5524
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5528
::exit(___);}
#if 0
#line 5524
{ 
#line 5525
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5527
return make_uchar2(v.x, v.y); 
#line 5528
} 
#endif
#line 5530 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2DLayeredLod(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5531
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5535
::exit(___);}
#if 0
#line 5531
{ 
#line 5532
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5534
return make_char4(v.x, v.y, v.z, v.w); 
#line 5535
} 
#endif
#line 5537 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5538
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5542
::exit(___);}
#if 0
#line 5538
{ 
#line 5539
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5541
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 5542
} 
#endif
#line 5550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex2DLayeredLod(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5551
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5555
::exit(___);}
#if 0
#line 5551
{ 
#line 5552
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5554
return (short)(v.x); 
#line 5555
} 
#endif
#line 5557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5558
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5562
::exit(___);}
#if 0
#line 5558
{ 
#line 5559
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5561
return (unsigned short)(v.x); 
#line 5562
} 
#endif
#line 5564 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex2DLayeredLod(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5565
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5569
::exit(___);}
#if 0
#line 5565
{ 
#line 5566
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5568
return make_short1(v.x); 
#line 5569
} 
#endif
#line 5571 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5572
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5576
::exit(___);}
#if 0
#line 5572
{ 
#line 5573
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5575
return make_ushort1(v.x); 
#line 5576
} 
#endif
#line 5578 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex2DLayeredLod(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5579
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5583
::exit(___);}
#if 0
#line 5579
{ 
#line 5580
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5582
return make_short2(v.x, v.y); 
#line 5583
} 
#endif
#line 5585 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5586
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5590
::exit(___);}
#if 0
#line 5586
{ 
#line 5587
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5589
return make_ushort2(v.x, v.y); 
#line 5590
} 
#endif
#line 5592 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2DLayeredLod(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5593
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5597
::exit(___);}
#if 0
#line 5593
{ 
#line 5594
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5596
return make_short4(v.x, v.y, v.z, v.w); 
#line 5597
} 
#endif
#line 5599 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5600
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5604
::exit(___);}
#if 0
#line 5600
{ 
#line 5601
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5603
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 5604
} 
#endif
#line 5612 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex2DLayeredLod(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5613
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5617
::exit(___);}
#if 0
#line 5613
{ 
#line 5614
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5616
return v.x; 
#line 5617
} 
#endif
#line 5619 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex2DLayeredLod(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5620
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5624
::exit(___);}
#if 0
#line 5620
{ 
#line 5621
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5623
return v.x; 
#line 5624
} 
#endif
#line 5626 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex2DLayeredLod(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5627
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5631
::exit(___);}
#if 0
#line 5627
{ 
#line 5628
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5630
return make_int1(v.x); 
#line 5631
} 
#endif
#line 5633 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex2DLayeredLod(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5634
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5638
::exit(___);}
#if 0
#line 5634
{ 
#line 5635
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5637
return make_uint1(v.x); 
#line 5638
} 
#endif
#line 5640 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex2DLayeredLod(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5641
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5645
::exit(___);}
#if 0
#line 5641
{ 
#line 5642
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5644
return make_int2(v.x, v.y); 
#line 5645
} 
#endif
#line 5647 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex2DLayeredLod(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5648
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5652
::exit(___);}
#if 0
#line 5648
{ 
#line 5649
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5651
return make_uint2(v.x, v.y); 
#line 5652
} 
#endif
#line 5654 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2DLayeredLod(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5655
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5659
::exit(___);}
#if 0
#line 5655
{ 
#line 5656
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5658
return make_int4(v.x, v.y, v.z, v.w); 
#line 5659
} 
#endif
#line 5661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2DLayeredLod(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5662
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5666
::exit(___);}
#if 0
#line 5662
{ 
#line 5663
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5665
return make_uint4(v.x, v.y, v.z, v.w); 
#line 5666
} 
#endif
#line 5676 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex2DLayeredLod(texture< long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5677
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5681
::exit(___);}
#if 0
#line 5677
{ 
#line 5678
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5680
return (long)(v.x); 
#line 5681
} 
#endif
#line 5683 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex2DLayeredLod(texture< unsigned long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5684
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5688
::exit(___);}
#if 0
#line 5684
{ 
#line 5685
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5687
return (unsigned long)(v.x); 
#line 5688
} 
#endif
#line 5690 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex2DLayeredLod(texture< long1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5691
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5695
::exit(___);}
#if 0
#line 5691
{ 
#line 5692
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5694
return make_long1(v.x); 
#line 5695
} 
#endif
#line 5697 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex2DLayeredLod(texture< ulong1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5698
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5702
::exit(___);}
#if 0
#line 5698
{ 
#line 5699
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5701
return make_ulong1(v.x); 
#line 5702
} 
#endif
#line 5704 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex2DLayeredLod(texture< long2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5705
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5709
::exit(___);}
#if 0
#line 5705
{ 
#line 5706
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5708
return make_long2(v.x, v.y); 
#line 5709
} 
#endif
#line 5711 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex2DLayeredLod(texture< ulong2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5712
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5716
::exit(___);}
#if 0
#line 5712
{ 
#line 5713
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5715
return make_ulong2(v.x, v.y); 
#line 5716
} 
#endif
#line 5718 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex2DLayeredLod(texture< long4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5719
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5723
::exit(___);}
#if 0
#line 5719
{ 
#line 5720
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5722
return make_long4(v.x, v.y, v.z, v.w); 
#line 5723
} 
#endif
#line 5725 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex2DLayeredLod(texture< ulong4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5726
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5730
::exit(___);}
#if 0
#line 5726
{ 
#line 5727
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5729
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 5730
} 
#endif
#line 5740 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredLod(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5741
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5745
::exit(___);}
#if 0
#line 5741
{ 
#line 5742
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5744
return v.x; 
#line 5745
} 
#endif
#line 5747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredLod(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5748
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5752
::exit(___);}
#if 0
#line 5748
{ 
#line 5749
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5751
return make_float1(v.x); 
#line 5752
} 
#endif
#line 5754 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredLod(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5755
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5759
::exit(___);}
#if 0
#line 5755
{ 
#line 5756
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5758
return make_float2(v.x, v.y); 
#line 5759
} 
#endif
#line 5761 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredLod(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5762
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5766
::exit(___);}
#if 0
#line 5762
{ 
#line 5763
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5765
return make_float4(v.x, v.y, v.z, v.w); 
#line 5766
} 
#endif
#line 5774 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredLod(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5775
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5784 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 5775 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 5779 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5781 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5783
return w.x; 
#line 5784
} 
#endif
#line 5786 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredLod(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5787
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5792
::exit(___);}
#if 0
#line 5787
{ 
#line 5788
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5789
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5791
return w.x; 
#line 5792
} 
#endif
#line 5794 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5795
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5800
::exit(___);}
#if 0
#line 5795
{ 
#line 5796
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5797
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5799
return w.x; 
#line 5800
} 
#endif
#line 5802 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredLod(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5803
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5808
::exit(___);}
#if 0
#line 5803
{ 
#line 5804
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5805
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5807
return make_float1(w.x); 
#line 5808
} 
#endif
#line 5810 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5811
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5816
::exit(___);}
#if 0
#line 5811
{ 
#line 5812
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5813
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5815
return make_float1(w.x); 
#line 5816
} 
#endif
#line 5818 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredLod(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5819
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5824
::exit(___);}
#if 0
#line 5819
{ 
#line 5820
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5821
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5823
return make_float2(w.x, w.y); 
#line 5824
} 
#endif
#line 5826 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5827
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5832
::exit(___);}
#if 0
#line 5827
{ 
#line 5828
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5829
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5831
return make_float2(w.x, w.y); 
#line 5832
} 
#endif
#line 5834 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredLod(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5835
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5840
::exit(___);}
#if 0
#line 5835
{ 
#line 5836
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5837
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5839
return make_float4(w.x, w.y, w.z, w.w); 
#line 5840
} 
#endif
#line 5842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5848
::exit(___);}
#if 0
#line 5843
{ 
#line 5844
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5845
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5847
return make_float4(w.x, w.y, w.z, w.w); 
#line 5848
} 
#endif
#line 5856 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredLod(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5862
::exit(___);}
#if 0
#line 5857
{ 
#line 5858
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5859
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5861
return w.x; 
#line 5862
} 
#endif
#line 5864 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5865
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5870
::exit(___);}
#if 0
#line 5865
{ 
#line 5866
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5867
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5869
return w.x; 
#line 5870
} 
#endif
#line 5872 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredLod(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5873
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5878
::exit(___);}
#if 0
#line 5873
{ 
#line 5874
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5875
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5877
return make_float1(w.x); 
#line 5878
} 
#endif
#line 5880 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5881
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5886
::exit(___);}
#if 0
#line 5881
{ 
#line 5882
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5883
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5885
return make_float1(w.x); 
#line 5886
} 
#endif
#line 5888 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredLod(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5889
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5894
::exit(___);}
#if 0
#line 5889
{ 
#line 5890
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5891
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5893
return make_float2(w.x, w.y); 
#line 5894
} 
#endif
#line 5896 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5897
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5902
::exit(___);}
#if 0
#line 5897
{ 
#line 5898
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5899
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5901
return make_float2(w.x, w.y); 
#line 5902
} 
#endif
#line 5904 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredLod(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5910
::exit(___);}
#if 0
#line 5905
{ 
#line 5906
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5907
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5909
return make_float4(w.x, w.y, w.z, w.w); 
#line 5910
} 
#endif
#line 5912 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5913
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5918
::exit(___);}
#if 0
#line 5913
{ 
#line 5914
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5915
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5917
return make_float4(w.x, w.y, w.z, w.w); 
#line 5918
} 
#endif
#line 5926 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex3DLod(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5927
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5935 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 5927 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 5931 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5934 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 5935
} 
#endif
#line 5937 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex3DLod(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5938
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5942
::exit(___);}
#if 0
#line 5938
{ 
#line 5939
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5941
return (signed char)(v.x); 
#line 5942
} 
#endif
#line 5944 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex3DLod(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5945
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5949
::exit(___);}
#if 0
#line 5945
{ 
#line 5946
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5948
return (unsigned char)(v.x); 
#line 5949
} 
#endif
#line 5951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex3DLod(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5952
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5956
::exit(___);}
#if 0
#line 5952
{ 
#line 5953
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5955
return make_char1(v.x); 
#line 5956
} 
#endif
#line 5958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex3DLod(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5959
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5963
::exit(___);}
#if 0
#line 5959
{ 
#line 5960
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5962
return make_uchar1(v.x); 
#line 5963
} 
#endif
#line 5965 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex3DLod(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5966
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5970
::exit(___);}
#if 0
#line 5966
{ 
#line 5967
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5969
return make_char2(v.x, v.y); 
#line 5970
} 
#endif
#line 5972 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex3DLod(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5973
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5977
::exit(___);}
#if 0
#line 5973
{ 
#line 5974
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5976
return make_uchar2(v.x, v.y); 
#line 5977
} 
#endif
#line 5979 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex3DLod(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5980
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5984
::exit(___);}
#if 0
#line 5980
{ 
#line 5981
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5983
return make_char4(v.x, v.y, v.z, v.w); 
#line 5984
} 
#endif
#line 5986 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex3DLod(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5987
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5991
::exit(___);}
#if 0
#line 5987
{ 
#line 5988
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5990
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 5991
} 
#endif
#line 5999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex3DLod(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6004
::exit(___);}
#if 0
#line 6000
{ 
#line 6001
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6003
return (short)(v.x); 
#line 6004
} 
#endif
#line 6006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex3DLod(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6007
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6011
::exit(___);}
#if 0
#line 6007
{ 
#line 6008
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6010
return (unsigned short)(v.x); 
#line 6011
} 
#endif
#line 6013 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex3DLod(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6014
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6018
::exit(___);}
#if 0
#line 6014
{ 
#line 6015
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6017
return make_short1(v.x); 
#line 6018
} 
#endif
#line 6020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex3DLod(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6021
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6025
::exit(___);}
#if 0
#line 6021
{ 
#line 6022
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6024
return make_ushort1(v.x); 
#line 6025
} 
#endif
#line 6027 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex3DLod(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6028
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6032
::exit(___);}
#if 0
#line 6028
{ 
#line 6029
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6031
return make_short2(v.x, v.y); 
#line 6032
} 
#endif
#line 6034 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex3DLod(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6035
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6039
::exit(___);}
#if 0
#line 6035
{ 
#line 6036
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6038
return make_ushort2(v.x, v.y); 
#line 6039
} 
#endif
#line 6041 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex3DLod(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6042
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6046
::exit(___);}
#if 0
#line 6042
{ 
#line 6043
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6045
return make_short4(v.x, v.y, v.z, v.w); 
#line 6046
} 
#endif
#line 6048 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex3DLod(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6049
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6053
::exit(___);}
#if 0
#line 6049
{ 
#line 6050
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6052
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 6053
} 
#endif
#line 6061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex3DLod(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6062
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6066
::exit(___);}
#if 0
#line 6062
{ 
#line 6063
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6065
return v.x; 
#line 6066
} 
#endif
#line 6068 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex3DLod(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6069
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6073
::exit(___);}
#if 0
#line 6069
{ 
#line 6070
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6072
return v.x; 
#line 6073
} 
#endif
#line 6075 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex3DLod(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6076
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6080
::exit(___);}
#if 0
#line 6076
{ 
#line 6077
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6079
return make_int1(v.x); 
#line 6080
} 
#endif
#line 6082 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex3DLod(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6083
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6087
::exit(___);}
#if 0
#line 6083
{ 
#line 6084
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6086
return make_uint1(v.x); 
#line 6087
} 
#endif
#line 6089 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex3DLod(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6090
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6094
::exit(___);}
#if 0
#line 6090
{ 
#line 6091
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6093
return make_int2(v.x, v.y); 
#line 6094
} 
#endif
#line 6096 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex3DLod(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6097
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6101
::exit(___);}
#if 0
#line 6097
{ 
#line 6098
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6100
return make_uint2(v.x, v.y); 
#line 6101
} 
#endif
#line 6103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex3DLod(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6104
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6108
::exit(___);}
#if 0
#line 6104
{ 
#line 6105
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6107
return make_int4(v.x, v.y, v.z, v.w); 
#line 6108
} 
#endif
#line 6110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex3DLod(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6111
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6115
::exit(___);}
#if 0
#line 6111
{ 
#line 6112
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6114
return make_uint4(v.x, v.y, v.z, v.w); 
#line 6115
} 
#endif
#line 6125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex3DLod(texture< long, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6126
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6130
::exit(___);}
#if 0
#line 6126
{ 
#line 6127
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6129
return (long)(v.x); 
#line 6130
} 
#endif
#line 6132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex3DLod(texture< unsigned long, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6133
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6137
::exit(___);}
#if 0
#line 6133
{ 
#line 6134
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6136
return (unsigned long)(v.x); 
#line 6137
} 
#endif
#line 6139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex3DLod(texture< long1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6140
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6144
::exit(___);}
#if 0
#line 6140
{ 
#line 6141
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6143
return make_long1(v.x); 
#line 6144
} 
#endif
#line 6146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex3DLod(texture< ulong1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6147
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6151
::exit(___);}
#if 0
#line 6147
{ 
#line 6148
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6150
return make_ulong1(v.x); 
#line 6151
} 
#endif
#line 6153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex3DLod(texture< long2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6154
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6158
::exit(___);}
#if 0
#line 6154
{ 
#line 6155
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6157
return make_long2(v.x, v.y); 
#line 6158
} 
#endif
#line 6160 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex3DLod(texture< ulong2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6161
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6165
::exit(___);}
#if 0
#line 6161
{ 
#line 6162
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6164
return make_ulong2(v.x, v.y); 
#line 6165
} 
#endif
#line 6167 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex3DLod(texture< long4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6168
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6172
::exit(___);}
#if 0
#line 6168
{ 
#line 6169
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6171
return make_long4(v.x, v.y, v.z, v.w); 
#line 6172
} 
#endif
#line 6174 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex3DLod(texture< ulong4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6175
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6179
::exit(___);}
#if 0
#line 6175
{ 
#line 6176
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6178
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 6179
} 
#endif
#line 6189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3DLod(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6190
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6194
::exit(___);}
#if 0
#line 6190
{ 
#line 6191
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6193
return v.x; 
#line 6194
} 
#endif
#line 6196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DLod(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6197
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6201
::exit(___);}
#if 0
#line 6197
{ 
#line 6198
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6200
return make_float1(v.x); 
#line 6201
} 
#endif
#line 6203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DLod(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6204
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6208
::exit(___);}
#if 0
#line 6204
{ 
#line 6205
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6207
return make_float2(v.x, v.y); 
#line 6208
} 
#endif
#line 6210 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DLod(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6211
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6215
::exit(___);}
#if 0
#line 6211
{ 
#line 6212
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6214
return make_float4(v.x, v.y, v.z, v.w); 
#line 6215
} 
#endif
#line 6223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3DLod(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6224
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6233 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 6224 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 6228 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6230 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6232
return w.x; 
#line 6233
} 
#endif
#line 6235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3DLod(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6236
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6241
::exit(___);}
#if 0
#line 6236
{ 
#line 6237
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6238
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6240
return w.x; 
#line 6241
} 
#endif
#line 6243 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3DLod(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6244
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6249
::exit(___);}
#if 0
#line 6244
{ 
#line 6245
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6246
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6248
return w.x; 
#line 6249
} 
#endif
#line 6251 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DLod(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6252
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6257
::exit(___);}
#if 0
#line 6252
{ 
#line 6253
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6254
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6256
return make_float1(w.x); 
#line 6257
} 
#endif
#line 6259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DLod(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6260
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6265
::exit(___);}
#if 0
#line 6260
{ 
#line 6261
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6262
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6264
return make_float1(w.x); 
#line 6265
} 
#endif
#line 6267 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DLod(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6268
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6273
::exit(___);}
#if 0
#line 6268
{ 
#line 6269
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6270
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6272
return make_float2(w.x, w.y); 
#line 6273
} 
#endif
#line 6275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DLod(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6276
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6281
::exit(___);}
#if 0
#line 6276
{ 
#line 6277
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6278
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6280
return make_float2(w.x, w.y); 
#line 6281
} 
#endif
#line 6283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DLod(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6284
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6289
::exit(___);}
#if 0
#line 6284
{ 
#line 6285
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6286
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6288
return make_float4(w.x, w.y, w.z, w.w); 
#line 6289
} 
#endif
#line 6291 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DLod(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6292
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6297
::exit(___);}
#if 0
#line 6292
{ 
#line 6293
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6294
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6296
return make_float4(w.x, w.y, w.z, w.w); 
#line 6297
} 
#endif
#line 6305 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3DLod(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6306
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6311
::exit(___);}
#if 0
#line 6306
{ 
#line 6307
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6308
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6310
return w.x; 
#line 6311
} 
#endif
#line 6313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3DLod(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6314
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6319
::exit(___);}
#if 0
#line 6314
{ 
#line 6315
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6316
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6318
return w.x; 
#line 6319
} 
#endif
#line 6321 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DLod(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6322
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6327
::exit(___);}
#if 0
#line 6322
{ 
#line 6323
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6324
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6326
return make_float1(w.x); 
#line 6327
} 
#endif
#line 6329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DLod(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6330
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6335
::exit(___);}
#if 0
#line 6330
{ 
#line 6331
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6332
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6334
return make_float1(w.x); 
#line 6335
} 
#endif
#line 6337 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DLod(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6338
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6343
::exit(___);}
#if 0
#line 6338
{ 
#line 6339
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6340
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6342
return make_float2(w.x, w.y); 
#line 6343
} 
#endif
#line 6345 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DLod(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6346
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6351
::exit(___);}
#if 0
#line 6346
{ 
#line 6347
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6348
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6350
return make_float2(w.x, w.y); 
#line 6351
} 
#endif
#line 6353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DLod(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6354
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6359
::exit(___);}
#if 0
#line 6354
{ 
#line 6355
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6356
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6358
return make_float4(w.x, w.y, w.z, w.w); 
#line 6359
} 
#endif
#line 6361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DLod(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6362
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6367
::exit(___);}
#if 0
#line 6362
{ 
#line 6363
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6364
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6366
return make_float4(w.x, w.y, w.z, w.w); 
#line 6367
} 
#endif
#line 6375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char texCubemapLod(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6376
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 6376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 6380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 6384
} 
#endif
#line 6386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char texCubemapLod(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6387
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6391
::exit(___);}
#if 0
#line 6387
{ 
#line 6388
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6390
return (signed char)(v.x); 
#line 6391
} 
#endif
#line 6393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char texCubemapLod(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6394
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6398
::exit(___);}
#if 0
#line 6394
{ 
#line 6395
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6397
return (unsigned char)(v.x); 
#line 6398
} 
#endif
#line 6400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 texCubemapLod(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6401
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6405
::exit(___);}
#if 0
#line 6401
{ 
#line 6402
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6404
return make_char1(v.x); 
#line 6405
} 
#endif
#line 6407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 texCubemapLod(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6408
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6412
::exit(___);}
#if 0
#line 6408
{ 
#line 6409
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6411
return make_uchar1(v.x); 
#line 6412
} 
#endif
#line 6414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 texCubemapLod(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6415
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6419
::exit(___);}
#if 0
#line 6415
{ 
#line 6416
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6418
return make_char2(v.x, v.y); 
#line 6419
} 
#endif
#line 6421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 texCubemapLod(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6422
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6426
::exit(___);}
#if 0
#line 6422
{ 
#line 6423
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6425
return make_uchar2(v.x, v.y); 
#line 6426
} 
#endif
#line 6428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 texCubemapLod(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6429
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6433
::exit(___);}
#if 0
#line 6429
{ 
#line 6430
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6432
return make_char4(v.x, v.y, v.z, v.w); 
#line 6433
} 
#endif
#line 6435 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 texCubemapLod(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6436
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6440
::exit(___);}
#if 0
#line 6436
{ 
#line 6437
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6439
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 6440
} 
#endif
#line 6448 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short texCubemapLod(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6449
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6453
::exit(___);}
#if 0
#line 6449
{ 
#line 6450
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6452
return (short)(v.x); 
#line 6453
} 
#endif
#line 6455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short texCubemapLod(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6456
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6460
::exit(___);}
#if 0
#line 6456
{ 
#line 6457
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6459
return (unsigned short)(v.x); 
#line 6460
} 
#endif
#line 6462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 texCubemapLod(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6463
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6467
::exit(___);}
#if 0
#line 6463
{ 
#line 6464
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6466
return make_short1(v.x); 
#line 6467
} 
#endif
#line 6469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 texCubemapLod(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6470
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6474
::exit(___);}
#if 0
#line 6470
{ 
#line 6471
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6473
return make_ushort1(v.x); 
#line 6474
} 
#endif
#line 6476 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 texCubemapLod(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6477
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6481
::exit(___);}
#if 0
#line 6477
{ 
#line 6478
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6480
return make_short2(v.x, v.y); 
#line 6481
} 
#endif
#line 6483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 texCubemapLod(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6484
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6488
::exit(___);}
#if 0
#line 6484
{ 
#line 6485
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6487
return make_ushort2(v.x, v.y); 
#line 6488
} 
#endif
#line 6490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 texCubemapLod(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6491
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6495
::exit(___);}
#if 0
#line 6491
{ 
#line 6492
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6494
return make_short4(v.x, v.y, v.z, v.w); 
#line 6495
} 
#endif
#line 6497 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 texCubemapLod(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6498
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6502
::exit(___);}
#if 0
#line 6498
{ 
#line 6499
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6501
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 6502
} 
#endif
#line 6510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int texCubemapLod(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6511
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6515
::exit(___);}
#if 0
#line 6511
{ 
#line 6512
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6514
return v.x; 
#line 6515
} 
#endif
#line 6517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned texCubemapLod(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6518
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6522
::exit(___);}
#if 0
#line 6518
{ 
#line 6519
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6521
return v.x; 
#line 6522
} 
#endif
#line 6524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 texCubemapLod(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6525
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6529
::exit(___);}
#if 0
#line 6525
{ 
#line 6526
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6528
return make_int1(v.x); 
#line 6529
} 
#endif
#line 6531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 texCubemapLod(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6532
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6536
::exit(___);}
#if 0
#line 6532
{ 
#line 6533
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6535
return make_uint1(v.x); 
#line 6536
} 
#endif
#line 6538 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 texCubemapLod(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6539
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6543
::exit(___);}
#if 0
#line 6539
{ 
#line 6540
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6542
return make_int2(v.x, v.y); 
#line 6543
} 
#endif
#line 6545 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 texCubemapLod(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6546
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6550
::exit(___);}
#if 0
#line 6546
{ 
#line 6547
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6549
return make_uint2(v.x, v.y); 
#line 6550
} 
#endif
#line 6552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 texCubemapLod(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6553
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6557
::exit(___);}
#if 0
#line 6553
{ 
#line 6554
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6556
return make_int4(v.x, v.y, v.z, v.w); 
#line 6557
} 
#endif
#line 6559 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 texCubemapLod(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6560
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6564
::exit(___);}
#if 0
#line 6560
{ 
#line 6561
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6563
return make_uint4(v.x, v.y, v.z, v.w); 
#line 6564
} 
#endif
#line 6574 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long texCubemapLod(texture< long, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6575
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6579
::exit(___);}
#if 0
#line 6575
{ 
#line 6576
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6578
return (long)(v.x); 
#line 6579
} 
#endif
#line 6581 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long texCubemapLod(texture< unsigned long, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6582
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6586
::exit(___);}
#if 0
#line 6582
{ 
#line 6583
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6585
return (unsigned long)(v.x); 
#line 6586
} 
#endif
#line 6588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 texCubemapLod(texture< long1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6589
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6593
::exit(___);}
#if 0
#line 6589
{ 
#line 6590
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6592
return make_long1(v.x); 
#line 6593
} 
#endif
#line 6595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 texCubemapLod(texture< ulong1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6596
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6600
::exit(___);}
#if 0
#line 6596
{ 
#line 6597
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6599
return make_ulong1(v.x); 
#line 6600
} 
#endif
#line 6602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 texCubemapLod(texture< long2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6603
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6607
::exit(___);}
#if 0
#line 6603
{ 
#line 6604
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6606
return make_long2(v.x, v.y); 
#line 6607
} 
#endif
#line 6609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 texCubemapLod(texture< ulong2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6610
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6614
::exit(___);}
#if 0
#line 6610
{ 
#line 6611
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6613
return make_ulong2(v.x, v.y); 
#line 6614
} 
#endif
#line 6616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 texCubemapLod(texture< long4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6617
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6621
::exit(___);}
#if 0
#line 6617
{ 
#line 6618
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6620
return make_long4(v.x, v.y, v.z, v.w); 
#line 6621
} 
#endif
#line 6623 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 texCubemapLod(texture< ulong4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6624
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6628
::exit(___);}
#if 0
#line 6624
{ 
#line 6625
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6627
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 6628
} 
#endif
#line 6638 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLod(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6639
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6643
::exit(___);}
#if 0
#line 6639
{ 
#line 6640
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6642
return v.x; 
#line 6643
} 
#endif
#line 6645 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLod(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6646
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6650
::exit(___);}
#if 0
#line 6646
{ 
#line 6647
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6649
return make_float1(v.x); 
#line 6650
} 
#endif
#line 6652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLod(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6653
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6657
::exit(___);}
#if 0
#line 6653
{ 
#line 6654
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6656
return make_float2(v.x, v.y); 
#line 6657
} 
#endif
#line 6659 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLod(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6660
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6664
::exit(___);}
#if 0
#line 6660
{ 
#line 6661
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6663
return make_float4(v.x, v.y, v.z, v.w); 
#line 6664
} 
#endif
#line 6672 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLod(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6673
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6682 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 6673 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 6677 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6679 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6681
return w.x; 
#line 6682
} 
#endif
#line 6684 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLod(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6685
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6690
::exit(___);}
#if 0
#line 6685
{ 
#line 6686
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6687
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6689
return w.x; 
#line 6690
} 
#endif
#line 6692 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLod(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6693
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6698
::exit(___);}
#if 0
#line 6693
{ 
#line 6694
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6695
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6697
return w.x; 
#line 6698
} 
#endif
#line 6700 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLod(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6701
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6706
::exit(___);}
#if 0
#line 6701
{ 
#line 6702
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6703
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6705
return make_float1(w.x); 
#line 6706
} 
#endif
#line 6708 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLod(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6709
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6714
::exit(___);}
#if 0
#line 6709
{ 
#line 6710
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6711
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6713
return make_float1(w.x); 
#line 6714
} 
#endif
#line 6716 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLod(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6717
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6722
::exit(___);}
#if 0
#line 6717
{ 
#line 6718
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6719
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6721
return make_float2(w.x, w.y); 
#line 6722
} 
#endif
#line 6724 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLod(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6725
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6730
::exit(___);}
#if 0
#line 6725
{ 
#line 6726
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6727
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6729
return make_float2(w.x, w.y); 
#line 6730
} 
#endif
#line 6732 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLod(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6733
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6738
::exit(___);}
#if 0
#line 6733
{ 
#line 6734
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6735
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6737
return make_float4(w.x, w.y, w.z, w.w); 
#line 6738
} 
#endif
#line 6740 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLod(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6741
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6746
::exit(___);}
#if 0
#line 6741
{ 
#line 6742
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6743
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6745
return make_float4(w.x, w.y, w.z, w.w); 
#line 6746
} 
#endif
#line 6754 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLod(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6755
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6760
::exit(___);}
#if 0
#line 6755
{ 
#line 6756
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6757
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6759
return w.x; 
#line 6760
} 
#endif
#line 6762 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLod(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6763
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6768
::exit(___);}
#if 0
#line 6763
{ 
#line 6764
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6765
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6767
return w.x; 
#line 6768
} 
#endif
#line 6770 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLod(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6771
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6776
::exit(___);}
#if 0
#line 6771
{ 
#line 6772
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6773
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6775
return make_float1(w.x); 
#line 6776
} 
#endif
#line 6778 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLod(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6779
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6784
::exit(___);}
#if 0
#line 6779
{ 
#line 6780
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6781
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6783
return make_float1(w.x); 
#line 6784
} 
#endif
#line 6786 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLod(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6787
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6792
::exit(___);}
#if 0
#line 6787
{ 
#line 6788
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6789
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6791
return make_float2(w.x, w.y); 
#line 6792
} 
#endif
#line 6794 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLod(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6795
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6800
::exit(___);}
#if 0
#line 6795
{ 
#line 6796
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6797
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6799
return make_float2(w.x, w.y); 
#line 6800
} 
#endif
#line 6802 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLod(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6803
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6808
::exit(___);}
#if 0
#line 6803
{ 
#line 6804
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6805
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6807
return make_float4(w.x, w.y, w.z, w.w); 
#line 6808
} 
#endif
#line 6810 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLod(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6811
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6816
::exit(___);}
#if 0
#line 6811
{ 
#line 6812
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6813
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6815
return make_float4(w.x, w.y, w.z, w.w); 
#line 6816
} 
#endif
#line 6824 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char texCubemapLayeredLod(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6825
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6833 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 6825 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 6829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6832 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 6833
} 
#endif
#line 6835 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char texCubemapLayeredLod(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6836
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6840
::exit(___);}
#if 0
#line 6836
{ 
#line 6837
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6839
return (signed char)(v.x); 
#line 6840
} 
#endif
#line 6842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6847
::exit(___);}
#if 0
#line 6843
{ 
#line 6844
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6846
return (unsigned char)(v.x); 
#line 6847
} 
#endif
#line 6849 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6850
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6854
::exit(___);}
#if 0
#line 6850
{ 
#line 6851
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6853
return make_char1(v.x); 
#line 6854
} 
#endif
#line 6856 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6861
::exit(___);}
#if 0
#line 6857
{ 
#line 6858
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6860
return make_uchar1(v.x); 
#line 6861
} 
#endif
#line 6863 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6864
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6868
::exit(___);}
#if 0
#line 6864
{ 
#line 6865
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6867
return make_char2(v.x, v.y); 
#line 6868
} 
#endif
#line 6870 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6871
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6875
::exit(___);}
#if 0
#line 6871
{ 
#line 6872
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6874
return make_uchar2(v.x, v.y); 
#line 6875
} 
#endif
#line 6877 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6878
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6882
::exit(___);}
#if 0
#line 6878
{ 
#line 6879
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6881
return make_char4(v.x, v.y, v.z, v.w); 
#line 6882
} 
#endif
#line 6884 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6885
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6889
::exit(___);}
#if 0
#line 6885
{ 
#line 6886
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6888
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 6889
} 
#endif
#line 6897 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short texCubemapLayeredLod(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6902
::exit(___);}
#if 0
#line 6898
{ 
#line 6899
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6901
return (short)(v.x); 
#line 6902
} 
#endif
#line 6904 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6909
::exit(___);}
#if 0
#line 6905
{ 
#line 6906
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6908
return (unsigned short)(v.x); 
#line 6909
} 
#endif
#line 6911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6912
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6916
::exit(___);}
#if 0
#line 6912
{ 
#line 6913
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6915
return make_short1(v.x); 
#line 6916
} 
#endif
#line 6918 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6919
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6923
::exit(___);}
#if 0
#line 6919
{ 
#line 6920
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6922
return make_ushort1(v.x); 
#line 6923
} 
#endif
#line 6925 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6926
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6930
::exit(___);}
#if 0
#line 6926
{ 
#line 6927
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6929
return make_short2(v.x, v.y); 
#line 6930
} 
#endif
#line 6932 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6933
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6937
::exit(___);}
#if 0
#line 6933
{ 
#line 6934
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6936
return make_ushort2(v.x, v.y); 
#line 6937
} 
#endif
#line 6939 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6940
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6944
::exit(___);}
#if 0
#line 6940
{ 
#line 6941
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6943
return make_short4(v.x, v.y, v.z, v.w); 
#line 6944
} 
#endif
#line 6946 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6947
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6951
::exit(___);}
#if 0
#line 6947
{ 
#line 6948
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6950
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 6951
} 
#endif
#line 6959 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int texCubemapLayeredLod(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6960
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6964
::exit(___);}
#if 0
#line 6960
{ 
#line 6961
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6963
return v.x; 
#line 6964
} 
#endif
#line 6966 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned texCubemapLayeredLod(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6967
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6971
::exit(___);}
#if 0
#line 6967
{ 
#line 6968
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6970
return v.x; 
#line 6971
} 
#endif
#line 6973 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 texCubemapLayeredLod(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6974
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6978
::exit(___);}
#if 0
#line 6974
{ 
#line 6975
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6977
return make_int1(v.x); 
#line 6978
} 
#endif
#line 6980 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 texCubemapLayeredLod(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6981
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6985
::exit(___);}
#if 0
#line 6981
{ 
#line 6982
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6984
return make_uint1(v.x); 
#line 6985
} 
#endif
#line 6987 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 texCubemapLayeredLod(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6988
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6992
::exit(___);}
#if 0
#line 6988
{ 
#line 6989
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6991
return make_int2(v.x, v.y); 
#line 6992
} 
#endif
#line 6994 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 texCubemapLayeredLod(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6995
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6999
::exit(___);}
#if 0
#line 6995
{ 
#line 6996
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6998
return make_uint2(v.x, v.y); 
#line 6999
} 
#endif
#line 7001 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 texCubemapLayeredLod(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7002
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7006
::exit(___);}
#if 0
#line 7002
{ 
#line 7003
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7005
return make_int4(v.x, v.y, v.z, v.w); 
#line 7006
} 
#endif
#line 7008 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 texCubemapLayeredLod(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7009
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7013
::exit(___);}
#if 0
#line 7009
{ 
#line 7010
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7012
return make_uint4(v.x, v.y, v.z, v.w); 
#line 7013
} 
#endif
#line 7023 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long texCubemapLayeredLod(texture< long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7024
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7028
::exit(___);}
#if 0
#line 7024
{ 
#line 7025
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7027
return (long)(v.x); 
#line 7028
} 
#endif
#line 7030 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long texCubemapLayeredLod(texture< unsigned long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7031
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7035
::exit(___);}
#if 0
#line 7031
{ 
#line 7032
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7034
return (unsigned long)(v.x); 
#line 7035
} 
#endif
#line 7037 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 texCubemapLayeredLod(texture< long1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7038
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7042
::exit(___);}
#if 0
#line 7038
{ 
#line 7039
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7041
return make_long1(v.x); 
#line 7042
} 
#endif
#line 7044 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 texCubemapLayeredLod(texture< ulong1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7045
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7049
::exit(___);}
#if 0
#line 7045
{ 
#line 7046
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7048
return make_ulong1(v.x); 
#line 7049
} 
#endif
#line 7051 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 texCubemapLayeredLod(texture< long2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7052
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7056
::exit(___);}
#if 0
#line 7052
{ 
#line 7053
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7055
return make_long2(v.x, v.y); 
#line 7056
} 
#endif
#line 7058 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 texCubemapLayeredLod(texture< ulong2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7059
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7063
::exit(___);}
#if 0
#line 7059
{ 
#line 7060
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7062
return make_ulong2(v.x, v.y); 
#line 7063
} 
#endif
#line 7065 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 texCubemapLayeredLod(texture< long4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7066
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7070
::exit(___);}
#if 0
#line 7066
{ 
#line 7067
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7069
return make_long4(v.x, v.y, v.z, v.w); 
#line 7070
} 
#endif
#line 7072 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 texCubemapLayeredLod(texture< ulong4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7073
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7077
::exit(___);}
#if 0
#line 7073
{ 
#line 7074
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7076
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 7077
} 
#endif
#line 7087 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayeredLod(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7088
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7092
::exit(___);}
#if 0
#line 7088
{ 
#line 7089
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7091
return v.x; 
#line 7092
} 
#endif
#line 7094 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayeredLod(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7095
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7099
::exit(___);}
#if 0
#line 7095
{ 
#line 7096
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7098
return make_float1(v.x); 
#line 7099
} 
#endif
#line 7101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayeredLod(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7102
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7106
::exit(___);}
#if 0
#line 7102
{ 
#line 7103
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7105
return make_float2(v.x, v.y); 
#line 7106
} 
#endif
#line 7108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayeredLod(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 7109
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7113
::exit(___);}
#if 0
#line 7109
{ 
#line 7110
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7112
return make_float4(v.x, v.y, v.z, v.w); 
#line 7113
} 
#endif
#line 7121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayeredLod(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7122
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 7122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 7126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7128 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7130
return w.x; 
#line 7131
} 
#endif
#line 7133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayeredLod(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7134
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7139
::exit(___);}
#if 0
#line 7134
{ 
#line 7135
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7136
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7138
return w.x; 
#line 7139
} 
#endif
#line 7141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7142
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7147
::exit(___);}
#if 0
#line 7142
{ 
#line 7143
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7144
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7146
return w.x; 
#line 7147
} 
#endif
#line 7149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7150
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7155
::exit(___);}
#if 0
#line 7150
{ 
#line 7151
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7152
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7154
return make_float1(w.x); 
#line 7155
} 
#endif
#line 7157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7158
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7163
::exit(___);}
#if 0
#line 7158
{ 
#line 7159
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7160
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7162
return make_float1(w.x); 
#line 7163
} 
#endif
#line 7165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7166
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7171
::exit(___);}
#if 0
#line 7166
{ 
#line 7167
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7168
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7170
return make_float2(w.x, w.y); 
#line 7171
} 
#endif
#line 7173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7174
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7179
::exit(___);}
#if 0
#line 7174
{ 
#line 7175
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7176
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7178
return make_float2(w.x, w.y); 
#line 7179
} 
#endif
#line 7181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7182
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7187
::exit(___);}
#if 0
#line 7182
{ 
#line 7183
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7184
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7186
return make_float4(w.x, w.y, w.z, w.w); 
#line 7187
} 
#endif
#line 7189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7190
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7195
::exit(___);}
#if 0
#line 7190
{ 
#line 7191
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7192
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7194
return make_float4(w.x, w.y, w.z, w.w); 
#line 7195
} 
#endif
#line 7203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayeredLod(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7204
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7209
::exit(___);}
#if 0
#line 7204
{ 
#line 7205
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7206
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7208
return w.x; 
#line 7209
} 
#endif
#line 7211 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7212
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7217
::exit(___);}
#if 0
#line 7212
{ 
#line 7213
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7214
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7216
return w.x; 
#line 7217
} 
#endif
#line 7219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7220
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7225
::exit(___);}
#if 0
#line 7220
{ 
#line 7221
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7222
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7224
return make_float1(w.x); 
#line 7225
} 
#endif
#line 7227 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7228
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7233
::exit(___);}
#if 0
#line 7228
{ 
#line 7229
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7230
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7232
return make_float1(w.x); 
#line 7233
} 
#endif
#line 7235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7236
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7241
::exit(___);}
#if 0
#line 7236
{ 
#line 7237
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7238
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7240
return make_float2(w.x, w.y); 
#line 7241
} 
#endif
#line 7243 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7244
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7249
::exit(___);}
#if 0
#line 7244
{ 
#line 7245
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7246
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7248
return make_float2(w.x, w.y); 
#line 7249
} 
#endif
#line 7251 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7252
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7257
::exit(___);}
#if 0
#line 7252
{ 
#line 7253
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7254
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7256
return make_float4(w.x, w.y, w.z, w.w); 
#line 7257
} 
#endif
#line 7259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7260
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7265
::exit(___);}
#if 0
#line 7260
{ 
#line 7261
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7262
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7264
return make_float4(w.x, w.y, w.z, w.w); 
#line 7265
} 
#endif
#line 7281 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex1DGrad(texture< char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7282
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7290 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 7282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 7286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 7290
} 
#endif
#line 7292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1DGrad(texture< signed char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7293
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7297
::exit(___);}
#if 0
#line 7293
{ 
#line 7294
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7296
return (signed char)(v.x); 
#line 7297
} 
#endif
#line 7299 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1DGrad(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7300
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7304
::exit(___);}
#if 0
#line 7300
{ 
#line 7301
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7303
return (unsigned char)(v.x); 
#line 7304
} 
#endif
#line 7306 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1DGrad(texture< char1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7307
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7311
::exit(___);}
#if 0
#line 7307
{ 
#line 7308
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7310
return make_char1(v.x); 
#line 7311
} 
#endif
#line 7313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1DGrad(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7314
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7318
::exit(___);}
#if 0
#line 7314
{ 
#line 7315
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7317
return make_uchar1(v.x); 
#line 7318
} 
#endif
#line 7320 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1DGrad(texture< char2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7321
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7325
::exit(___);}
#if 0
#line 7321
{ 
#line 7322
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7324
return make_char2(v.x, v.y); 
#line 7325
} 
#endif
#line 7327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1DGrad(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7328
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7332
::exit(___);}
#if 0
#line 7328
{ 
#line 7329
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7331
return make_uchar2(v.x, v.y); 
#line 7332
} 
#endif
#line 7334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1DGrad(texture< char4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7335
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7339
::exit(___);}
#if 0
#line 7335
{ 
#line 7336
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7338
return make_char4(v.x, v.y, v.z, v.w); 
#line 7339
} 
#endif
#line 7341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1DGrad(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7342
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7346
::exit(___);}
#if 0
#line 7342
{ 
#line 7343
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7345
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 7346
} 
#endif
#line 7354 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex1DGrad(texture< short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7355
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7359
::exit(___);}
#if 0
#line 7355
{ 
#line 7356
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7358
return (short)(v.x); 
#line 7359
} 
#endif
#line 7361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1DGrad(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7362
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7366
::exit(___);}
#if 0
#line 7362
{ 
#line 7363
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7365
return (unsigned short)(v.x); 
#line 7366
} 
#endif
#line 7368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1DGrad(texture< short1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7369
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7373
::exit(___);}
#if 0
#line 7369
{ 
#line 7370
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7372
return make_short1(v.x); 
#line 7373
} 
#endif
#line 7375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1DGrad(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7376
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7380
::exit(___);}
#if 0
#line 7376
{ 
#line 7377
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7379
return make_ushort1(v.x); 
#line 7380
} 
#endif
#line 7382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1DGrad(texture< short2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7383
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7387
::exit(___);}
#if 0
#line 7383
{ 
#line 7384
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7386
return make_short2(v.x, v.y); 
#line 7387
} 
#endif
#line 7389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1DGrad(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7390
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7394
::exit(___);}
#if 0
#line 7390
{ 
#line 7391
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7393
return make_ushort2(v.x, v.y); 
#line 7394
} 
#endif
#line 7396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1DGrad(texture< short4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7397
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7401
::exit(___);}
#if 0
#line 7397
{ 
#line 7398
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7400
return make_short4(v.x, v.y, v.z, v.w); 
#line 7401
} 
#endif
#line 7403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1DGrad(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7404
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7408
::exit(___);}
#if 0
#line 7404
{ 
#line 7405
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7407
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 7408
} 
#endif
#line 7416 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex1DGrad(texture< int, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7417
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7421
::exit(___);}
#if 0
#line 7417
{ 
#line 7418
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7420
return v.x; 
#line 7421
} 
#endif
#line 7423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1DGrad(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7424
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7428
::exit(___);}
#if 0
#line 7424
{ 
#line 7425
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7427
return v.x; 
#line 7428
} 
#endif
#line 7430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1DGrad(texture< int1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7431
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7435
::exit(___);}
#if 0
#line 7431
{ 
#line 7432
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7434
return make_int1(v.x); 
#line 7435
} 
#endif
#line 7437 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1DGrad(texture< uint1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7438
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7442
::exit(___);}
#if 0
#line 7438
{ 
#line 7439
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7441
return make_uint1(v.x); 
#line 7442
} 
#endif
#line 7444 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1DGrad(texture< int2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7445
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7449
::exit(___);}
#if 0
#line 7445
{ 
#line 7446
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7448
return make_int2(v.x, v.y); 
#line 7449
} 
#endif
#line 7451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1DGrad(texture< uint2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7452
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7456
::exit(___);}
#if 0
#line 7452
{ 
#line 7453
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7455
return make_uint2(v.x, v.y); 
#line 7456
} 
#endif
#line 7458 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1DGrad(texture< int4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7459
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7463
::exit(___);}
#if 0
#line 7459
{ 
#line 7460
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7462
return make_int4(v.x, v.y, v.z, v.w); 
#line 7463
} 
#endif
#line 7465 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1DGrad(texture< uint4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7466
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7470
::exit(___);}
#if 0
#line 7466
{ 
#line 7467
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7469
return make_uint4(v.x, v.y, v.z, v.w); 
#line 7470
} 
#endif
#line 7486 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex1DGrad(texture< long, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7487
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7491
::exit(___);}
#if 0
#line 7487
{ 
#line 7488
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7490
return (long)(v.x); 
#line 7491
} 
#endif
#line 7493 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1DGrad(texture< unsigned long, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7494
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7498
::exit(___);}
#if 0
#line 7494
{ 
#line 7495
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7497
return (unsigned long)(v.x); 
#line 7498
} 
#endif
#line 7500 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1DGrad(texture< long1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7501
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7505
::exit(___);}
#if 0
#line 7501
{ 
#line 7502
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7504
return make_long1(v.x); 
#line 7505
} 
#endif
#line 7507 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1DGrad(texture< ulong1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7508
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7512
::exit(___);}
#if 0
#line 7508
{ 
#line 7509
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7511
return make_ulong1(v.x); 
#line 7512
} 
#endif
#line 7514 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1DGrad(texture< long2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7515
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7519
::exit(___);}
#if 0
#line 7515
{ 
#line 7516
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7518
return make_long2(v.x, v.y); 
#line 7519
} 
#endif
#line 7521 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1DGrad(texture< ulong2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7522
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7526
::exit(___);}
#if 0
#line 7522
{ 
#line 7523
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7525
return make_ulong2(v.x, v.y); 
#line 7526
} 
#endif
#line 7528 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1DGrad(texture< long4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7529
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7533
::exit(___);}
#if 0
#line 7529
{ 
#line 7530
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7532
return make_long4(v.x, v.y, v.z, v.w); 
#line 7533
} 
#endif
#line 7535 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1DGrad(texture< ulong4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7536
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7540
::exit(___);}
#if 0
#line 7536
{ 
#line 7537
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7539
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 7540
} 
#endif
#line 7550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DGrad(texture< float, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7551
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7555
::exit(___);}
#if 0
#line 7551
{ 
#line 7552
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7554
return v.x; 
#line 7555
} 
#endif
#line 7557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DGrad(texture< float1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7558
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7562
::exit(___);}
#if 0
#line 7558
{ 
#line 7559
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7561
return make_float1(v.x); 
#line 7562
} 
#endif
#line 7564 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DGrad(texture< float2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7565
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7569
::exit(___);}
#if 0
#line 7565
{ 
#line 7566
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7568
return make_float2(v.x, v.y); 
#line 7569
} 
#endif
#line 7571 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DGrad(texture< float4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7572
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7576
::exit(___);}
#if 0
#line 7572
{ 
#line 7573
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7575
return make_float4(v.x, v.y, v.z, v.w); 
#line 7576
} 
#endif
#line 7584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DGrad(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7585
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7594 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 7585 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 7589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7591 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7593
return w.x; 
#line 7594
} 
#endif
#line 7596 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DGrad(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7597
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7602
::exit(___);}
#if 0
#line 7597
{ 
#line 7598
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7599
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7601
return w.x; 
#line 7602
} 
#endif
#line 7604 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DGrad(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7605
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7610
::exit(___);}
#if 0
#line 7605
{ 
#line 7606
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7607
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7609
return w.x; 
#line 7610
} 
#endif
#line 7612 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DGrad(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7613
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7618
::exit(___);}
#if 0
#line 7613
{ 
#line 7614
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7615
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7617
return make_float1(w.x); 
#line 7618
} 
#endif
#line 7620 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DGrad(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7621
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7626
::exit(___);}
#if 0
#line 7621
{ 
#line 7622
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7623
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7625
return make_float1(w.x); 
#line 7626
} 
#endif
#line 7628 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DGrad(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7629
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7634
::exit(___);}
#if 0
#line 7629
{ 
#line 7630
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7631
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7633
return make_float2(w.x, w.y); 
#line 7634
} 
#endif
#line 7636 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DGrad(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7637
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7642
::exit(___);}
#if 0
#line 7637
{ 
#line 7638
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7639
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7641
return make_float2(w.x, w.y); 
#line 7642
} 
#endif
#line 7644 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DGrad(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7645
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7650
::exit(___);}
#if 0
#line 7645
{ 
#line 7646
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7647
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7649
return make_float4(w.x, w.y, w.z, w.w); 
#line 7650
} 
#endif
#line 7652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DGrad(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7653
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7658
::exit(___);}
#if 0
#line 7653
{ 
#line 7654
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7655
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7657
return make_float4(w.x, w.y, w.z, w.w); 
#line 7658
} 
#endif
#line 7666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DGrad(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7667
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7672
::exit(___);}
#if 0
#line 7667
{ 
#line 7668
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7669
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7671
return w.x; 
#line 7672
} 
#endif
#line 7674 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DGrad(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7675
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7680
::exit(___);}
#if 0
#line 7675
{ 
#line 7676
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7677
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7679
return w.x; 
#line 7680
} 
#endif
#line 7682 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DGrad(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7683
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7688
::exit(___);}
#if 0
#line 7683
{ 
#line 7684
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7685
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7687
return make_float1(w.x); 
#line 7688
} 
#endif
#line 7690 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DGrad(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7691
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7696
::exit(___);}
#if 0
#line 7691
{ 
#line 7692
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7693
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7695
return make_float1(w.x); 
#line 7696
} 
#endif
#line 7698 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DGrad(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7699
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7704
::exit(___);}
#if 0
#line 7699
{ 
#line 7700
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7701
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7703
return make_float2(w.x, w.y); 
#line 7704
} 
#endif
#line 7706 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DGrad(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7707
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7712
::exit(___);}
#if 0
#line 7707
{ 
#line 7708
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7709
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7711
return make_float2(w.x, w.y); 
#line 7712
} 
#endif
#line 7714 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DGrad(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7715
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7720
::exit(___);}
#if 0
#line 7715
{ 
#line 7716
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7717
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7719
return make_float4(w.x, w.y, w.z, w.w); 
#line 7720
} 
#endif
#line 7722 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DGrad(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7723
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7728
::exit(___);}
#if 0
#line 7723
{ 
#line 7724
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7725
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7727
return make_float4(w.x, w.y, w.z, w.w); 
#line 7728
} 
#endif
#line 7736 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex2DGrad(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7737
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7745 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 7737 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 7741 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7744 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 7745
} 
#endif
#line 7747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex2DGrad(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7748
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7752
::exit(___);}
#if 0
#line 7748
{ 
#line 7749
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7751
return (signed char)(v.x); 
#line 7752
} 
#endif
#line 7754 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex2DGrad(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7755
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7759
::exit(___);}
#if 0
#line 7755
{ 
#line 7756
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7758
return (unsigned char)(v.x); 
#line 7759
} 
#endif
#line 7761 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex2DGrad(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7762
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7766
::exit(___);}
#if 0
#line 7762
{ 
#line 7763
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7765
return make_char1(v.x); 
#line 7766
} 
#endif
#line 7768 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex2DGrad(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7769
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7773
::exit(___);}
#if 0
#line 7769
{ 
#line 7770
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7772
return make_uchar1(v.x); 
#line 7773
} 
#endif
#line 7775 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex2DGrad(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7776
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7780
::exit(___);}
#if 0
#line 7776
{ 
#line 7777
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7779
return make_char2(v.x, v.y); 
#line 7780
} 
#endif
#line 7782 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex2DGrad(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7783
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7787
::exit(___);}
#if 0
#line 7783
{ 
#line 7784
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7786
return make_uchar2(v.x, v.y); 
#line 7787
} 
#endif
#line 7789 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2DGrad(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7790
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7794
::exit(___);}
#if 0
#line 7790
{ 
#line 7791
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7793
return make_char4(v.x, v.y, v.z, v.w); 
#line 7794
} 
#endif
#line 7796 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2DGrad(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7797
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7801
::exit(___);}
#if 0
#line 7797
{ 
#line 7798
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7800
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 7801
} 
#endif
#line 7809 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex2DGrad(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7810
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7814
::exit(___);}
#if 0
#line 7810
{ 
#line 7811
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7813
return (short)(v.x); 
#line 7814
} 
#endif
#line 7816 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex2DGrad(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7817
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7821
::exit(___);}
#if 0
#line 7817
{ 
#line 7818
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7820
return (unsigned short)(v.x); 
#line 7821
} 
#endif
#line 7823 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex2DGrad(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7824
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7828
::exit(___);}
#if 0
#line 7824
{ 
#line 7825
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7827
return make_short1(v.x); 
#line 7828
} 
#endif
#line 7830 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex2DGrad(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7831
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7835
::exit(___);}
#if 0
#line 7831
{ 
#line 7832
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7834
return make_ushort1(v.x); 
#line 7835
} 
#endif
#line 7837 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex2DGrad(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7838
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7842
::exit(___);}
#if 0
#line 7838
{ 
#line 7839
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7841
return make_short2(v.x, v.y); 
#line 7842
} 
#endif
#line 7844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex2DGrad(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7845
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7849
::exit(___);}
#if 0
#line 7845
{ 
#line 7846
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7848
return make_ushort2(v.x, v.y); 
#line 7849
} 
#endif
#line 7851 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2DGrad(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7852
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7856
::exit(___);}
#if 0
#line 7852
{ 
#line 7853
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7855
return make_short4(v.x, v.y, v.z, v.w); 
#line 7856
} 
#endif
#line 7858 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2DGrad(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7859
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7863
::exit(___);}
#if 0
#line 7859
{ 
#line 7860
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7862
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 7863
} 
#endif
#line 7871 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex2DGrad(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7872
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7876
::exit(___);}
#if 0
#line 7872
{ 
#line 7873
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7875
return v.x; 
#line 7876
} 
#endif
#line 7878 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex2DGrad(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7879
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7883
::exit(___);}
#if 0
#line 7879
{ 
#line 7880
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7882
return v.x; 
#line 7883
} 
#endif
#line 7885 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex2DGrad(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7886
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7890
::exit(___);}
#if 0
#line 7886
{ 
#line 7887
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7889
return make_int1(v.x); 
#line 7890
} 
#endif
#line 7892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex2DGrad(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7893
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7897
::exit(___);}
#if 0
#line 7893
{ 
#line 7894
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7896
return make_uint1(v.x); 
#line 7897
} 
#endif
#line 7899 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex2DGrad(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7900
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7904
::exit(___);}
#if 0
#line 7900
{ 
#line 7901
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7903
return make_int2(v.x, v.y); 
#line 7904
} 
#endif
#line 7906 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex2DGrad(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7907
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7911
::exit(___);}
#if 0
#line 7907
{ 
#line 7908
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7910
return make_uint2(v.x, v.y); 
#line 7911
} 
#endif
#line 7913 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2DGrad(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7914
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7918
::exit(___);}
#if 0
#line 7914
{ 
#line 7915
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7917
return make_int4(v.x, v.y, v.z, v.w); 
#line 7918
} 
#endif
#line 7920 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2DGrad(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7921
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7925
::exit(___);}
#if 0
#line 7921
{ 
#line 7922
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7924
return make_uint4(v.x, v.y, v.z, v.w); 
#line 7925
} 
#endif
#line 7935 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex2DGrad(texture< long, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7936
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7940
::exit(___);}
#if 0
#line 7936
{ 
#line 7937
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7939
return (long)(v.x); 
#line 7940
} 
#endif
#line 7942 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex2DGrad(texture< unsigned long, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7943
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7947
::exit(___);}
#if 0
#line 7943
{ 
#line 7944
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7946
return (unsigned long)(v.x); 
#line 7947
} 
#endif
#line 7949 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex2DGrad(texture< long1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7950
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7954
::exit(___);}
#if 0
#line 7950
{ 
#line 7951
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7953
return make_long1(v.x); 
#line 7954
} 
#endif
#line 7956 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex2DGrad(texture< ulong1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7957
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7961
::exit(___);}
#if 0
#line 7957
{ 
#line 7958
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7960
return make_ulong1(v.x); 
#line 7961
} 
#endif
#line 7963 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex2DGrad(texture< long2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7964
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7968
::exit(___);}
#if 0
#line 7964
{ 
#line 7965
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7967
return make_long2(v.x, v.y); 
#line 7968
} 
#endif
#line 7970 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex2DGrad(texture< ulong2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7971
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7975
::exit(___);}
#if 0
#line 7971
{ 
#line 7972
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7974
return make_ulong2(v.x, v.y); 
#line 7975
} 
#endif
#line 7977 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex2DGrad(texture< long4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7978
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7982
::exit(___);}
#if 0
#line 7978
{ 
#line 7979
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7981
return make_long4(v.x, v.y, v.z, v.w); 
#line 7982
} 
#endif
#line 7984 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex2DGrad(texture< ulong4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7985
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7989
::exit(___);}
#if 0
#line 7985
{ 
#line 7986
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7988
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 7989
} 
#endif
#line 7999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DGrad(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8004
::exit(___);}
#if 0
#line 8000
{ 
#line 8001
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8003
return v.x; 
#line 8004
} 
#endif
#line 8006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DGrad(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8007
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8011
::exit(___);}
#if 0
#line 8007
{ 
#line 8008
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8010
return make_float1(v.x); 
#line 8011
} 
#endif
#line 8013 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DGrad(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8014
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8018
::exit(___);}
#if 0
#line 8014
{ 
#line 8015
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8017
return make_float2(v.x, v.y); 
#line 8018
} 
#endif
#line 8020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DGrad(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8021
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8025
::exit(___);}
#if 0
#line 8021
{ 
#line 8022
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8024
return make_float4(v.x, v.y, v.z, v.w); 
#line 8025
} 
#endif
#line 8033 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DGrad(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8034
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8043 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 8034 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 8038 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8040 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8042
return w.x; 
#line 8043
} 
#endif
#line 8045 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DGrad(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8046
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8051
::exit(___);}
#if 0
#line 8046
{ 
#line 8047
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8048
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8050
return w.x; 
#line 8051
} 
#endif
#line 8053 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DGrad(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8054
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8059
::exit(___);}
#if 0
#line 8054
{ 
#line 8055
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8056
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8058
return w.x; 
#line 8059
} 
#endif
#line 8061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DGrad(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8062
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8067
::exit(___);}
#if 0
#line 8062
{ 
#line 8063
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8064
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8066
return make_float1(w.x); 
#line 8067
} 
#endif
#line 8069 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DGrad(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8070
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8075
::exit(___);}
#if 0
#line 8070
{ 
#line 8071
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8072
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8074
return make_float1(w.x); 
#line 8075
} 
#endif
#line 8077 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DGrad(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8078
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8083
::exit(___);}
#if 0
#line 8078
{ 
#line 8079
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8080
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8082
return make_float2(w.x, w.y); 
#line 8083
} 
#endif
#line 8085 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DGrad(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8086
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8091
::exit(___);}
#if 0
#line 8086
{ 
#line 8087
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8088
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8090
return make_float2(w.x, w.y); 
#line 8091
} 
#endif
#line 8093 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DGrad(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8094
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8099
::exit(___);}
#if 0
#line 8094
{ 
#line 8095
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8096
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8098
return make_float4(w.x, w.y, w.z, w.w); 
#line 8099
} 
#endif
#line 8101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DGrad(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8102
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8107
::exit(___);}
#if 0
#line 8102
{ 
#line 8103
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8104
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8106
return make_float4(w.x, w.y, w.z, w.w); 
#line 8107
} 
#endif
#line 8115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DGrad(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8116
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8121
::exit(___);}
#if 0
#line 8116
{ 
#line 8117
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8118
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8120
return w.x; 
#line 8121
} 
#endif
#line 8123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DGrad(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8124
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8129
::exit(___);}
#if 0
#line 8124
{ 
#line 8125
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8126
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8128
return w.x; 
#line 8129
} 
#endif
#line 8131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DGrad(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8132
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8137
::exit(___);}
#if 0
#line 8132
{ 
#line 8133
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8134
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8136
return make_float1(w.x); 
#line 8137
} 
#endif
#line 8139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DGrad(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8140
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8145
::exit(___);}
#if 0
#line 8140
{ 
#line 8141
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8142
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8144
return make_float1(w.x); 
#line 8145
} 
#endif
#line 8147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DGrad(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8148
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8153
::exit(___);}
#if 0
#line 8148
{ 
#line 8149
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8150
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8152
return make_float2(w.x, w.y); 
#line 8153
} 
#endif
#line 8155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DGrad(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8156
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8161
::exit(___);}
#if 0
#line 8156
{ 
#line 8157
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8158
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8160
return make_float2(w.x, w.y); 
#line 8161
} 
#endif
#line 8163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DGrad(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8164
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8169
::exit(___);}
#if 0
#line 8164
{ 
#line 8165
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8166
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8168
return make_float4(w.x, w.y, w.z, w.w); 
#line 8169
} 
#endif
#line 8171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DGrad(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8172
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8177
::exit(___);}
#if 0
#line 8172
{ 
#line 8173
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8174
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8176
return make_float4(w.x, w.y, w.z, w.w); 
#line 8177
} 
#endif
#line 8185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex1DLayeredGrad(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8186
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8194 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 8186 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 8190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8193 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 8194
} 
#endif
#line 8196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex1DLayeredGrad(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8197
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8201
::exit(___);}
#if 0
#line 8197
{ 
#line 8198
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8200
return (signed char)(v.x); 
#line 8201
} 
#endif
#line 8203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8204
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8208
::exit(___);}
#if 0
#line 8204
{ 
#line 8205
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8207
return (unsigned char)(v.x); 
#line 8208
} 
#endif
#line 8210 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8211
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8215
::exit(___);}
#if 0
#line 8211
{ 
#line 8212
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8214
return make_char1(v.x); 
#line 8215
} 
#endif
#line 8217 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8218
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8222
::exit(___);}
#if 0
#line 8218
{ 
#line 8219
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8221
return make_uchar1(v.x); 
#line 8222
} 
#endif
#line 8224 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8225
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8229
::exit(___);}
#if 0
#line 8225
{ 
#line 8226
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8228
return make_char2(v.x, v.y); 
#line 8229
} 
#endif
#line 8231 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8232
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8236
::exit(___);}
#if 0
#line 8232
{ 
#line 8233
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8235
return make_uchar2(v.x, v.y); 
#line 8236
} 
#endif
#line 8238 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8239
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8243
::exit(___);}
#if 0
#line 8239
{ 
#line 8240
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8242
return make_char4(v.x, v.y, v.z, v.w); 
#line 8243
} 
#endif
#line 8245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8246
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8250
::exit(___);}
#if 0
#line 8246
{ 
#line 8247
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8249
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 8250
} 
#endif
#line 8258 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex1DLayeredGrad(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8259
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8263
::exit(___);}
#if 0
#line 8259
{ 
#line 8260
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8262
return (short)(v.x); 
#line 8263
} 
#endif
#line 8265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8266
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8270
::exit(___);}
#if 0
#line 8266
{ 
#line 8267
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8269
return (unsigned short)(v.x); 
#line 8270
} 
#endif
#line 8272 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8273
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8277
::exit(___);}
#if 0
#line 8273
{ 
#line 8274
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8276
return make_short1(v.x); 
#line 8277
} 
#endif
#line 8279 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8280
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8284
::exit(___);}
#if 0
#line 8280
{ 
#line 8281
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8283
return make_ushort1(v.x); 
#line 8284
} 
#endif
#line 8286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8287
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8291
::exit(___);}
#if 0
#line 8287
{ 
#line 8288
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8290
return make_short2(v.x, v.y); 
#line 8291
} 
#endif
#line 8293 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8294
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8298
::exit(___);}
#if 0
#line 8294
{ 
#line 8295
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8297
return make_ushort2(v.x, v.y); 
#line 8298
} 
#endif
#line 8300 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8301
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8305
::exit(___);}
#if 0
#line 8301
{ 
#line 8302
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8304
return make_short4(v.x, v.y, v.z, v.w); 
#line 8305
} 
#endif
#line 8307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8308
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8312
::exit(___);}
#if 0
#line 8308
{ 
#line 8309
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8311
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 8312
} 
#endif
#line 8320 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex1DLayeredGrad(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8321
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8325
::exit(___);}
#if 0
#line 8321
{ 
#line 8322
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8324
return v.x; 
#line 8325
} 
#endif
#line 8327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex1DLayeredGrad(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8328
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8332
::exit(___);}
#if 0
#line 8328
{ 
#line 8329
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8331
return v.x; 
#line 8332
} 
#endif
#line 8334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex1DLayeredGrad(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8335
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8339
::exit(___);}
#if 0
#line 8335
{ 
#line 8336
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8338
return make_int1(v.x); 
#line 8339
} 
#endif
#line 8341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex1DLayeredGrad(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8342
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8346
::exit(___);}
#if 0
#line 8342
{ 
#line 8343
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8345
return make_uint1(v.x); 
#line 8346
} 
#endif
#line 8348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex1DLayeredGrad(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8349
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8353
::exit(___);}
#if 0
#line 8349
{ 
#line 8350
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8352
return make_int2(v.x, v.y); 
#line 8353
} 
#endif
#line 8355 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex1DLayeredGrad(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8356
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8360
::exit(___);}
#if 0
#line 8356
{ 
#line 8357
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8359
return make_uint2(v.x, v.y); 
#line 8360
} 
#endif
#line 8362 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex1DLayeredGrad(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8363
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8367
::exit(___);}
#if 0
#line 8363
{ 
#line 8364
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8366
return make_int4(v.x, v.y, v.z, v.w); 
#line 8367
} 
#endif
#line 8369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex1DLayeredGrad(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8370
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8374
::exit(___);}
#if 0
#line 8370
{ 
#line 8371
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8373
return make_uint4(v.x, v.y, v.z, v.w); 
#line 8374
} 
#endif
#line 8384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex1DLayeredGrad(texture< long, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8385
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8389
::exit(___);}
#if 0
#line 8385
{ 
#line 8386
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8388
return (long)(v.x); 
#line 8389
} 
#endif
#line 8391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex1DLayeredGrad(texture< unsigned long, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8392
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8396
::exit(___);}
#if 0
#line 8392
{ 
#line 8393
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8395
return (unsigned long)(v.x); 
#line 8396
} 
#endif
#line 8398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex1DLayeredGrad(texture< long1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8399
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8403
::exit(___);}
#if 0
#line 8399
{ 
#line 8400
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8402
return make_long1(v.x); 
#line 8403
} 
#endif
#line 8405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex1DLayeredGrad(texture< ulong1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8406
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8410
::exit(___);}
#if 0
#line 8406
{ 
#line 8407
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8409
return make_ulong1(v.x); 
#line 8410
} 
#endif
#line 8412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex1DLayeredGrad(texture< long2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8413
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8417
::exit(___);}
#if 0
#line 8413
{ 
#line 8414
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8416
return make_long2(v.x, v.y); 
#line 8417
} 
#endif
#line 8419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex1DLayeredGrad(texture< ulong2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8420
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8424
::exit(___);}
#if 0
#line 8420
{ 
#line 8421
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8423
return make_ulong2(v.x, v.y); 
#line 8424
} 
#endif
#line 8426 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex1DLayeredGrad(texture< long4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8427
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8431
::exit(___);}
#if 0
#line 8427
{ 
#line 8428
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8430
return make_long4(v.x, v.y, v.z, v.w); 
#line 8431
} 
#endif
#line 8433 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex1DLayeredGrad(texture< ulong4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8434
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8438
::exit(___);}
#if 0
#line 8434
{ 
#line 8435
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8437
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 8438
} 
#endif
#line 8448 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredGrad(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8449
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8453
::exit(___);}
#if 0
#line 8449
{ 
#line 8450
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8452
return v.x; 
#line 8453
} 
#endif
#line 8455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredGrad(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8456
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8460
::exit(___);}
#if 0
#line 8456
{ 
#line 8457
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8459
return make_float1(v.x); 
#line 8460
} 
#endif
#line 8462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredGrad(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8463
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8467
::exit(___);}
#if 0
#line 8463
{ 
#line 8464
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8466
return make_float2(v.x, v.y); 
#line 8467
} 
#endif
#line 8469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredGrad(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8470
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8474
::exit(___);}
#if 0
#line 8470
{ 
#line 8471
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8473
return make_float4(v.x, v.y, v.z, v.w); 
#line 8474
} 
#endif
#line 8482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredGrad(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8483
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8492 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 8483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 8487 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8489 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8491
return w.x; 
#line 8492
} 
#endif
#line 8494 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredGrad(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8495
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8500
::exit(___);}
#if 0
#line 8495
{ 
#line 8496
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8497
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8499
return w.x; 
#line 8500
} 
#endif
#line 8502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8503
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8508
::exit(___);}
#if 0
#line 8503
{ 
#line 8504
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8505
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8507
return w.x; 
#line 8508
} 
#endif
#line 8510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8511
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8516
::exit(___);}
#if 0
#line 8511
{ 
#line 8512
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8513
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8515
return make_float1(w.x); 
#line 8516
} 
#endif
#line 8518 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8519
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8524
::exit(___);}
#if 0
#line 8519
{ 
#line 8520
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8521
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8523
return make_float1(w.x); 
#line 8524
} 
#endif
#line 8526 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8527
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8532
::exit(___);}
#if 0
#line 8527
{ 
#line 8528
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8529
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8531
return make_float2(w.x, w.y); 
#line 8532
} 
#endif
#line 8534 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8535
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8540
::exit(___);}
#if 0
#line 8535
{ 
#line 8536
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8537
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8539
return make_float2(w.x, w.y); 
#line 8540
} 
#endif
#line 8542 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8543
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8548
::exit(___);}
#if 0
#line 8543
{ 
#line 8544
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8545
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8547
return make_float4(w.x, w.y, w.z, w.w); 
#line 8548
} 
#endif
#line 8550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8551
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8556
::exit(___);}
#if 0
#line 8551
{ 
#line 8552
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8553
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8555
return make_float4(w.x, w.y, w.z, w.w); 
#line 8556
} 
#endif
#line 8564 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredGrad(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8565
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8570
::exit(___);}
#if 0
#line 8565
{ 
#line 8566
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8567
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8569
return w.x; 
#line 8570
} 
#endif
#line 8572 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8573
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8578
::exit(___);}
#if 0
#line 8573
{ 
#line 8574
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8575
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8577
return w.x; 
#line 8578
} 
#endif
#line 8580 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8581
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8586
::exit(___);}
#if 0
#line 8581
{ 
#line 8582
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8583
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8585
return make_float1(w.x); 
#line 8586
} 
#endif
#line 8588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8589
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8594
::exit(___);}
#if 0
#line 8589
{ 
#line 8590
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8591
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8593
return make_float1(w.x); 
#line 8594
} 
#endif
#line 8596 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8597
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8602
::exit(___);}
#if 0
#line 8597
{ 
#line 8598
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8599
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8601
return make_float2(w.x, w.y); 
#line 8602
} 
#endif
#line 8604 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8605
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8610
::exit(___);}
#if 0
#line 8605
{ 
#line 8606
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8607
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8609
return make_float2(w.x, w.y); 
#line 8610
} 
#endif
#line 8612 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8613
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8618
::exit(___);}
#if 0
#line 8613
{ 
#line 8614
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8615
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8617
return make_float4(w.x, w.y, w.z, w.w); 
#line 8618
} 
#endif
#line 8620 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8621
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8626
::exit(___);}
#if 0
#line 8621
{ 
#line 8622
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8623
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8625
return make_float4(w.x, w.y, w.z, w.w); 
#line 8626
} 
#endif
#line 8634 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex2DLayeredGrad(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8635
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8643 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 8635 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 8639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8642 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 8643
} 
#endif
#line 8645 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex2DLayeredGrad(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8646
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8650
::exit(___);}
#if 0
#line 8646
{ 
#line 8647
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8649
return (signed char)(v.x); 
#line 8650
} 
#endif
#line 8652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8653
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8657
::exit(___);}
#if 0
#line 8653
{ 
#line 8654
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8656
return (unsigned char)(v.x); 
#line 8657
} 
#endif
#line 8659 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8660
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8664
::exit(___);}
#if 0
#line 8660
{ 
#line 8661
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8663
return make_char1(v.x); 
#line 8664
} 
#endif
#line 8666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8667
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8671
::exit(___);}
#if 0
#line 8667
{ 
#line 8668
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8670
return make_uchar1(v.x); 
#line 8671
} 
#endif
#line 8673 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8674
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8678
::exit(___);}
#if 0
#line 8674
{ 
#line 8675
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8677
return make_char2(v.x, v.y); 
#line 8678
} 
#endif
#line 8680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8685
::exit(___);}
#if 0
#line 8681
{ 
#line 8682
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8684
return make_uchar2(v.x, v.y); 
#line 8685
} 
#endif
#line 8687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8688
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8692
::exit(___);}
#if 0
#line 8688
{ 
#line 8689
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8691
return make_char4(v.x, v.y, v.z, v.w); 
#line 8692
} 
#endif
#line 8694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8695
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8699
::exit(___);}
#if 0
#line 8695
{ 
#line 8696
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8698
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 8699
} 
#endif
#line 8707 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex2DLayeredGrad(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8708
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8712
::exit(___);}
#if 0
#line 8708
{ 
#line 8709
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8711
return (short)(v.x); 
#line 8712
} 
#endif
#line 8714 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8715
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8719
::exit(___);}
#if 0
#line 8715
{ 
#line 8716
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8718
return (unsigned short)(v.x); 
#line 8719
} 
#endif
#line 8721 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8722
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8726
::exit(___);}
#if 0
#line 8722
{ 
#line 8723
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8725
return make_short1(v.x); 
#line 8726
} 
#endif
#line 8728 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8729
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8733
::exit(___);}
#if 0
#line 8729
{ 
#line 8730
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8732
return make_ushort1(v.x); 
#line 8733
} 
#endif
#line 8735 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8736
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8740
::exit(___);}
#if 0
#line 8736
{ 
#line 8737
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8739
return make_short2(v.x, v.y); 
#line 8740
} 
#endif
#line 8742 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8743
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8747
::exit(___);}
#if 0
#line 8743
{ 
#line 8744
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8746
return make_ushort2(v.x, v.y); 
#line 8747
} 
#endif
#line 8749 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8750
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8754
::exit(___);}
#if 0
#line 8750
{ 
#line 8751
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8753
return make_short4(v.x, v.y, v.z, v.w); 
#line 8754
} 
#endif
#line 8756 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8757
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8761
::exit(___);}
#if 0
#line 8757
{ 
#line 8758
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8760
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 8761
} 
#endif
#line 8769 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex2DLayeredGrad(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8770
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8774
::exit(___);}
#if 0
#line 8770
{ 
#line 8771
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8773
return v.x; 
#line 8774
} 
#endif
#line 8776 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex2DLayeredGrad(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8777
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8781
::exit(___);}
#if 0
#line 8777
{ 
#line 8778
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8780
return v.x; 
#line 8781
} 
#endif
#line 8783 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex2DLayeredGrad(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8784
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8788
::exit(___);}
#if 0
#line 8784
{ 
#line 8785
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8787
return make_int1(v.x); 
#line 8788
} 
#endif
#line 8790 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex2DLayeredGrad(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8791
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8795
::exit(___);}
#if 0
#line 8791
{ 
#line 8792
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8794
return make_uint1(v.x); 
#line 8795
} 
#endif
#line 8797 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex2DLayeredGrad(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8798
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8802
::exit(___);}
#if 0
#line 8798
{ 
#line 8799
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8801
return make_int2(v.x, v.y); 
#line 8802
} 
#endif
#line 8804 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex2DLayeredGrad(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8805
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8809
::exit(___);}
#if 0
#line 8805
{ 
#line 8806
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8808
return make_uint2(v.x, v.y); 
#line 8809
} 
#endif
#line 8811 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex2DLayeredGrad(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8812
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8816
::exit(___);}
#if 0
#line 8812
{ 
#line 8813
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8815
return make_int4(v.x, v.y, v.z, v.w); 
#line 8816
} 
#endif
#line 8818 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex2DLayeredGrad(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8819
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8823
::exit(___);}
#if 0
#line 8819
{ 
#line 8820
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8822
return make_uint4(v.x, v.y, v.z, v.w); 
#line 8823
} 
#endif
#line 8833 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex2DLayeredGrad(texture< long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8834
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8838
::exit(___);}
#if 0
#line 8834
{ 
#line 8835
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8837
return (long)(v.x); 
#line 8838
} 
#endif
#line 8840 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex2DLayeredGrad(texture< unsigned long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8841
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8845
::exit(___);}
#if 0
#line 8841
{ 
#line 8842
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8844
return (unsigned long)(v.x); 
#line 8845
} 
#endif
#line 8847 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex2DLayeredGrad(texture< long1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8848
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8852
::exit(___);}
#if 0
#line 8848
{ 
#line 8849
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8851
return make_long1(v.x); 
#line 8852
} 
#endif
#line 8854 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex2DLayeredGrad(texture< ulong1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8855
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8859
::exit(___);}
#if 0
#line 8855
{ 
#line 8856
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8858
return make_ulong1(v.x); 
#line 8859
} 
#endif
#line 8861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex2DLayeredGrad(texture< long2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8862
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8866
::exit(___);}
#if 0
#line 8862
{ 
#line 8863
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8865
return make_long2(v.x, v.y); 
#line 8866
} 
#endif
#line 8868 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex2DLayeredGrad(texture< ulong2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8869
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8873
::exit(___);}
#if 0
#line 8869
{ 
#line 8870
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8872
return make_ulong2(v.x, v.y); 
#line 8873
} 
#endif
#line 8875 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex2DLayeredGrad(texture< long4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8876
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8880
::exit(___);}
#if 0
#line 8876
{ 
#line 8877
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8879
return make_long4(v.x, v.y, v.z, v.w); 
#line 8880
} 
#endif
#line 8882 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex2DLayeredGrad(texture< ulong4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8883
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8887
::exit(___);}
#if 0
#line 8883
{ 
#line 8884
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8886
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 8887
} 
#endif
#line 8897 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredGrad(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8902
::exit(___);}
#if 0
#line 8898
{ 
#line 8899
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8901
return v.x; 
#line 8902
} 
#endif
#line 8904 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredGrad(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8909
::exit(___);}
#if 0
#line 8905
{ 
#line 8906
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8908
return make_float1(v.x); 
#line 8909
} 
#endif
#line 8911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredGrad(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8912
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8916
::exit(___);}
#if 0
#line 8912
{ 
#line 8913
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8915
return make_float2(v.x, v.y); 
#line 8916
} 
#endif
#line 8918 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredGrad(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8919
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8923
::exit(___);}
#if 0
#line 8919
{ 
#line 8920
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8922
return make_float4(v.x, v.y, v.z, v.w); 
#line 8923
} 
#endif
#line 8931 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredGrad(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8932
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8941 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 8932 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 8936 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8938 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8940
return w.x; 
#line 8941
} 
#endif
#line 8943 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredGrad(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8944
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8949
::exit(___);}
#if 0
#line 8944
{ 
#line 8945
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8946
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8948
return w.x; 
#line 8949
} 
#endif
#line 8951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8952
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8957
::exit(___);}
#if 0
#line 8952
{ 
#line 8953
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8954
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8956
return w.x; 
#line 8957
} 
#endif
#line 8959 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8960
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8965
::exit(___);}
#if 0
#line 8960
{ 
#line 8961
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8962
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8964
return make_float1(w.x); 
#line 8965
} 
#endif
#line 8967 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8968
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8973
::exit(___);}
#if 0
#line 8968
{ 
#line 8969
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8970
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8972
return make_float1(w.x); 
#line 8973
} 
#endif
#line 8975 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8976
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8981
::exit(___);}
#if 0
#line 8976
{ 
#line 8977
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8978
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8980
return make_float2(w.x, w.y); 
#line 8981
} 
#endif
#line 8983 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8984
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8989
::exit(___);}
#if 0
#line 8984
{ 
#line 8985
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8986
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8988
return make_float2(w.x, w.y); 
#line 8989
} 
#endif
#line 8991 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8992
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8997
::exit(___);}
#if 0
#line 8992
{ 
#line 8993
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8994
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8996
return make_float4(w.x, w.y, w.z, w.w); 
#line 8997
} 
#endif
#line 8999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9005
::exit(___);}
#if 0
#line 9000
{ 
#line 9001
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9002
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9004
return make_float4(w.x, w.y, w.z, w.w); 
#line 9005
} 
#endif
#line 9013 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredGrad(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9014
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9019
::exit(___);}
#if 0
#line 9014
{ 
#line 9015
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9016
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9018
return w.x; 
#line 9019
} 
#endif
#line 9021 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9022
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9027
::exit(___);}
#if 0
#line 9022
{ 
#line 9023
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9024
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9026
return w.x; 
#line 9027
} 
#endif
#line 9029 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9030
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9035
::exit(___);}
#if 0
#line 9030
{ 
#line 9031
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9032
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9034
return make_float1(w.x); 
#line 9035
} 
#endif
#line 9037 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9038
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9043
::exit(___);}
#if 0
#line 9038
{ 
#line 9039
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9040
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9042
return make_float1(w.x); 
#line 9043
} 
#endif
#line 9045 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9046
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9051
::exit(___);}
#if 0
#line 9046
{ 
#line 9047
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9048
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9050
return make_float2(w.x, w.y); 
#line 9051
} 
#endif
#line 9053 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9054
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9059
::exit(___);}
#if 0
#line 9054
{ 
#line 9055
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9056
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9058
return make_float2(w.x, w.y); 
#line 9059
} 
#endif
#line 9061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9062
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9067
::exit(___);}
#if 0
#line 9062
{ 
#line 9063
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9064
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9066
return make_float4(w.x, w.y, w.z, w.w); 
#line 9067
} 
#endif
#line 9069 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 9070
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 9075
::exit(___);}
#if 0
#line 9070
{ 
#line 9071
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 9072
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9074
return make_float4(w.x, w.y, w.z, w.w); 
#line 9075
} 
#endif
#line 9083 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char tex3DGrad(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9084
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9092 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 9084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 9088 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9091 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
return (char)(v.x); 
#line 9092
} 
#endif
#line 9094 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline signed char tex3DGrad(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9095
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9099
::exit(___);}
#if 0
#line 9095
{ 
#line 9096
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9098
return (signed char)(v.x); 
#line 9099
} 
#endif
#line 9101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned char tex3DGrad(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9102
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9106
::exit(___);}
#if 0
#line 9102
{ 
#line 9103
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9105
return (unsigned char)(v.x); 
#line 9106
} 
#endif
#line 9108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char1 tex3DGrad(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9109
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9113
::exit(___);}
#if 0
#line 9109
{ 
#line 9110
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9112
return make_char1(v.x); 
#line 9113
} 
#endif
#line 9115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar1 tex3DGrad(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9116
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9120
::exit(___);}
#if 0
#line 9116
{ 
#line 9117
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9119
return make_uchar1(v.x); 
#line 9120
} 
#endif
#line 9122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char2 tex3DGrad(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9123
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9127
::exit(___);}
#if 0
#line 9123
{ 
#line 9124
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9126
return make_char2(v.x, v.y); 
#line 9127
} 
#endif
#line 9129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar2 tex3DGrad(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9130
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9134
::exit(___);}
#if 0
#line 9130
{ 
#line 9131
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9133
return make_uchar2(v.x, v.y); 
#line 9134
} 
#endif
#line 9136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline char4 tex3DGrad(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9137
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9141
::exit(___);}
#if 0
#line 9137
{ 
#line 9138
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9140
return make_char4(v.x, v.y, v.z, v.w); 
#line 9141
} 
#endif
#line 9143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uchar4 tex3DGrad(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9144
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9148
::exit(___);}
#if 0
#line 9144
{ 
#line 9145
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9147
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 9148
} 
#endif
#line 9156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short tex3DGrad(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9157
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9161
::exit(___);}
#if 0
#line 9157
{ 
#line 9158
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9160
return (short)(v.x); 
#line 9161
} 
#endif
#line 9163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned short tex3DGrad(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9164
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9168
::exit(___);}
#if 0
#line 9164
{ 
#line 9165
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9167
return (unsigned short)(v.x); 
#line 9168
} 
#endif
#line 9170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short1 tex3DGrad(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9171
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9175
::exit(___);}
#if 0
#line 9171
{ 
#line 9172
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9174
return make_short1(v.x); 
#line 9175
} 
#endif
#line 9177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort1 tex3DGrad(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9178
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9182
::exit(___);}
#if 0
#line 9178
{ 
#line 9179
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9181
return make_ushort1(v.x); 
#line 9182
} 
#endif
#line 9184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short2 tex3DGrad(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9185
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9189
::exit(___);}
#if 0
#line 9185
{ 
#line 9186
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9188
return make_short2(v.x, v.y); 
#line 9189
} 
#endif
#line 9191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort2 tex3DGrad(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9192
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9196
::exit(___);}
#if 0
#line 9192
{ 
#line 9193
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9195
return make_ushort2(v.x, v.y); 
#line 9196
} 
#endif
#line 9198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline short4 tex3DGrad(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9199
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9203
::exit(___);}
#if 0
#line 9199
{ 
#line 9200
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9202
return make_short4(v.x, v.y, v.z, v.w); 
#line 9203
} 
#endif
#line 9205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ushort4 tex3DGrad(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9206
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9210
::exit(___);}
#if 0
#line 9206
{ 
#line 9207
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9209
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 9210
} 
#endif
#line 9218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int tex3DGrad(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9219
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9223
::exit(___);}
#if 0
#line 9219
{ 
#line 9220
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9222
return v.x; 
#line 9223
} 
#endif
#line 9225 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned tex3DGrad(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9226
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9230
::exit(___);}
#if 0
#line 9226
{ 
#line 9227
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9229
return v.x; 
#line 9230
} 
#endif
#line 9232 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int1 tex3DGrad(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9233
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9237
::exit(___);}
#if 0
#line 9233
{ 
#line 9234
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9236
return make_int1(v.x); 
#line 9237
} 
#endif
#line 9239 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint1 tex3DGrad(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9240
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9244
::exit(___);}
#if 0
#line 9240
{ 
#line 9241
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9243
return make_uint1(v.x); 
#line 9244
} 
#endif
#line 9246 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int2 tex3DGrad(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9247
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9251
::exit(___);}
#if 0
#line 9247
{ 
#line 9248
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9250
return make_int2(v.x, v.y); 
#line 9251
} 
#endif
#line 9253 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint2 tex3DGrad(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9254
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9258
::exit(___);}
#if 0
#line 9254
{ 
#line 9255
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9257
return make_uint2(v.x, v.y); 
#line 9258
} 
#endif
#line 9260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline int4 tex3DGrad(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9261
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9265
::exit(___);}
#if 0
#line 9261
{ 
#line 9262
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9264
return make_int4(v.x, v.y, v.z, v.w); 
#line 9265
} 
#endif
#line 9267 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline uint4 tex3DGrad(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9268
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9272
::exit(___);}
#if 0
#line 9268
{ 
#line 9269
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9271
return make_uint4(v.x, v.y, v.z, v.w); 
#line 9272
} 
#endif
#line 9282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long tex3DGrad(texture< long, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9283
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9287
::exit(___);}
#if 0
#line 9283
{ 
#line 9284
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9286
return (long)(v.x); 
#line 9287
} 
#endif
#line 9289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline unsigned long tex3DGrad(texture< unsigned long, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9290
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9294
::exit(___);}
#if 0
#line 9290
{ 
#line 9291
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9293
return (unsigned long)(v.x); 
#line 9294
} 
#endif
#line 9296 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long1 tex3DGrad(texture< long1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9297
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9301
::exit(___);}
#if 0
#line 9297
{ 
#line 9298
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9300
return make_long1(v.x); 
#line 9301
} 
#endif
#line 9303 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong1 tex3DGrad(texture< ulong1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9304
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9308
::exit(___);}
#if 0
#line 9304
{ 
#line 9305
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9307
return make_ulong1(v.x); 
#line 9308
} 
#endif
#line 9310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long2 tex3DGrad(texture< long2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9311
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9315
::exit(___);}
#if 0
#line 9311
{ 
#line 9312
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9314
return make_long2(v.x, v.y); 
#line 9315
} 
#endif
#line 9317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong2 tex3DGrad(texture< ulong2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9318
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9322
::exit(___);}
#if 0
#line 9318
{ 
#line 9319
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9321
return make_ulong2(v.x, v.y); 
#line 9322
} 
#endif
#line 9324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline long4 tex3DGrad(texture< long4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9325
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9329
::exit(___);}
#if 0
#line 9325
{ 
#line 9326
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9328
return make_long4(v.x, v.y, v.z, v.w); 
#line 9329
} 
#endif
#line 9331 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline ulong4 tex3DGrad(texture< ulong4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9332
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9336
::exit(___);}
#if 0
#line 9332
{ 
#line 9333
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9335
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 9336
} 
#endif
#line 9346 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3DGrad(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9347
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9351
::exit(___);}
#if 0
#line 9347
{ 
#line 9348
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9350
return v.x; 
#line 9351
} 
#endif
#line 9353 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DGrad(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9354
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9358
::exit(___);}
#if 0
#line 9354
{ 
#line 9355
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9357
return make_float1(v.x); 
#line 9358
} 
#endif
#line 9360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DGrad(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9361
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9365
::exit(___);}
#if 0
#line 9361
{ 
#line 9362
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9364
return make_float2(v.x, v.y); 
#line 9365
} 
#endif
#line 9367 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DGrad(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9368
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9372
::exit(___);}
#if 0
#line 9368
{ 
#line 9369
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9371
return make_float4(v.x, v.y, v.z, v.w); 
#line 9372
} 
#endif
#line 9380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3DGrad(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9381
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9390 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
::exit(___);}
#if 0
#line 9381 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
{ 
#line 9385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9389
return w.x; 
#line 9390
} 
#endif
#line 9392 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3DGrad(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9393
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9398
::exit(___);}
#if 0
#line 9393
{ 
#line 9394
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9395
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9397
return w.x; 
#line 9398
} 
#endif
#line 9400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3DGrad(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9401
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9406
::exit(___);}
#if 0
#line 9401
{ 
#line 9402
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9403
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9405
return w.x; 
#line 9406
} 
#endif
#line 9408 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DGrad(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9409
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9414
::exit(___);}
#if 0
#line 9409
{ 
#line 9410
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9411
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9413
return make_float1(w.x); 
#line 9414
} 
#endif
#line 9416 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DGrad(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9417
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9422
::exit(___);}
#if 0
#line 9417
{ 
#line 9418
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9419
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9421
return make_float1(w.x); 
#line 9422
} 
#endif
#line 9424 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DGrad(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9425
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9430
::exit(___);}
#if 0
#line 9425
{ 
#line 9426
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9427
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9429
return make_float2(w.x, w.y); 
#line 9430
} 
#endif
#line 9432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DGrad(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9433
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9438
::exit(___);}
#if 0
#line 9433
{ 
#line 9434
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9435
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9437
return make_float2(w.x, w.y); 
#line 9438
} 
#endif
#line 9440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DGrad(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9441
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9446
::exit(___);}
#if 0
#line 9441
{ 
#line 9442
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9443
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9445
return make_float4(w.x, w.y, w.z, w.w); 
#line 9446
} 
#endif
#line 9448 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DGrad(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9449
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9454
::exit(___);}
#if 0
#line 9449
{ 
#line 9450
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9451
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9453
return make_float4(w.x, w.y, w.z, w.w); 
#line 9454
} 
#endif
#line 9462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3DGrad(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9463
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9468
::exit(___);}
#if 0
#line 9463
{ 
#line 9464
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9465
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9467
return w.x; 
#line 9468
} 
#endif
#line 9470 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float tex3DGrad(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9471
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9476
::exit(___);}
#if 0
#line 9471
{ 
#line 9472
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9473
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9475
return w.x; 
#line 9476
} 
#endif
#line 9478 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DGrad(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9479
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9484
::exit(___);}
#if 0
#line 9479
{ 
#line 9480
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9481
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9483
return make_float1(w.x); 
#line 9484
} 
#endif
#line 9486 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float1 tex3DGrad(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9487
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9492
::exit(___);}
#if 0
#line 9487
{ 
#line 9488
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9489
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9491
return make_float1(w.x); 
#line 9492
} 
#endif
#line 9494 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DGrad(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9495
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9500
::exit(___);}
#if 0
#line 9495
{ 
#line 9496
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9497
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9499
return make_float2(w.x, w.y); 
#line 9500
} 
#endif
#line 9502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float2 tex3DGrad(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9503
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9508
::exit(___);}
#if 0
#line 9503
{ 
#line 9504
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9505
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9507
return make_float2(w.x, w.y); 
#line 9508
} 
#endif
#line 9510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DGrad(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9511
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9516
::exit(___);}
#if 0
#line 9511
{ 
#line 9512
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9513
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9515
return make_float4(w.x, w.y, w.z, w.w); 
#line 9516
} 
#endif
#line 9518 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_fetch_functions.h"
static __forceinline float4 tex3DGrad(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9519
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9524
::exit(___);}
#if 0
#line 9519
{ 
#line 9520
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9521
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9523
return make_float4(w.x, w.y, w.z, w.w); 
#line 9524
} 
#endif
#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(char *retVal, cudaTextureObject_t texObject, int x) 
#line 71
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 80 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 71 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 76 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 77
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
#line 79 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 80
} 
#endif
#line 81 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(signed char *retVal, cudaTextureObject_t texObject, int x) 
#line 82
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 86
::exit(___);}
#if 0
#line 82
{ 
#line 83
int4 tmp; 
#line 84
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((signed char)(tmp.x)); 
#line 86
} 
#endif
#line 88 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(char1 *retVal, cudaTextureObject_t texObject, int x) 
#line 89
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 93
::exit(___);}
#if 0
#line 89
{ 
#line 90
int4 tmp; 
#line 91
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_char1(tmp.x); 
#line 93
} 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(char2 *retVal, cudaTextureObject_t texObject, int x) 
#line 96
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 100
::exit(___);}
#if 0
#line 96
{ 
#line 97
int4 tmp; 
#line 98
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 100
} 
#endif
#line 102 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(char4 *retVal, cudaTextureObject_t texObject, int x) 
#line 103
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 107
::exit(___);}
#if 0
#line 103
{ 
#line 104
int4 tmp; 
#line 105
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 107
} 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(unsigned char *retVal, cudaTextureObject_t texObject, int x) 
#line 110
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 114
::exit(___);}
#if 0
#line 110
{ 
#line 111
uint4 tmp; 
#line 112
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 114
} 
#endif
#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(uchar1 *retVal, cudaTextureObject_t texObject, int x) 
#line 117
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 121
::exit(___);}
#if 0
#line 117
{ 
#line 118
uint4 tmp; 
#line 119
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uchar1(tmp.x); 
#line 121
} 
#endif
#line 123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(uchar2 *retVal, cudaTextureObject_t texObject, int x) 
#line 124
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 128
::exit(___);}
#if 0
#line 124
{ 
#line 125
uint4 tmp; 
#line 126
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 128
} 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(uchar4 *retVal, cudaTextureObject_t texObject, int x) 
#line 131
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 135
::exit(___);}
#if 0
#line 131
{ 
#line 132
uint4 tmp; 
#line 133
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 135
} 
#endif
#line 143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(short *retVal, cudaTextureObject_t texObject, int x) 
#line 144
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 148
::exit(___);}
#if 0
#line 144
{ 
#line 145
int4 tmp; 
#line 146
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((short)(tmp.x)); 
#line 148
} 
#endif
#line 150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(short1 *retVal, cudaTextureObject_t texObject, int x) 
#line 151
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 155
::exit(___);}
#if 0
#line 151
{ 
#line 152
int4 tmp; 
#line 153
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_short1(tmp.x); 
#line 155
} 
#endif
#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(short2 *retVal, cudaTextureObject_t texObject, int x) 
#line 158
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 162
::exit(___);}
#if 0
#line 158
{ 
#line 159
int4 tmp; 
#line 160
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 162
} 
#endif
#line 164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(short4 *retVal, cudaTextureObject_t texObject, int x) 
#line 165
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 169
::exit(___);}
#if 0
#line 165
{ 
#line 166
int4 tmp; 
#line 167
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 169
} 
#endif
#line 171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(unsigned short *retVal, cudaTextureObject_t texObject, int x) 
#line 172
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 176
::exit(___);}
#if 0
#line 172
{ 
#line 173
uint4 tmp; 
#line 174
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 176
} 
#endif
#line 178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(ushort1 *retVal, cudaTextureObject_t texObject, int x) 
#line 179
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 183
::exit(___);}
#if 0
#line 179
{ 
#line 180
uint4 tmp; 
#line 181
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ushort1(tmp.x); 
#line 183
} 
#endif
#line 185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(ushort2 *retVal, cudaTextureObject_t texObject, int x) 
#line 186
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 190
::exit(___);}
#if 0
#line 186
{ 
#line 187
uint4 tmp; 
#line 188
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 190
} 
#endif
#line 192 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(ushort4 *retVal, cudaTextureObject_t texObject, int x) 
#line 193
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 197
::exit(___);}
#if 0
#line 193
{ 
#line 194
uint4 tmp; 
#line 195
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 197
} 
#endif
#line 205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(int *retVal, cudaTextureObject_t texObject, int x) 
#line 206
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 210
::exit(___);}
#if 0
#line 206
{ 
#line 207
int4 tmp; 
#line 208
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = (tmp.x); 
#line 210
} 
#endif
#line 212 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(int1 *retVal, cudaTextureObject_t texObject, int x) 
#line 213
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 217
::exit(___);}
#if 0
#line 213
{ 
#line 214
int4 tmp; 
#line 215
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_int1(tmp.x); 
#line 217
} 
#endif
#line 219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(int2 *retVal, cudaTextureObject_t texObject, int x) 
#line 220
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 224
::exit(___);}
#if 0
#line 220
{ 
#line 221
int4 tmp; 
#line 222
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 224
} 
#endif
#line 226 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(int4 *retVal, cudaTextureObject_t texObject, int x) 
#line 227
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 231
::exit(___);}
#if 0
#line 227
{ 
#line 228
int4 tmp; 
#line 229
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 231
} 
#endif
#line 233 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(unsigned *retVal, cudaTextureObject_t texObject, int x) 
#line 234
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 238
::exit(___);}
#if 0
#line 234
{ 
#line 235
uint4 tmp; 
#line 236
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = (tmp.x); 
#line 238
} 
#endif
#line 240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(uint1 *retVal, cudaTextureObject_t texObject, int x) 
#line 241
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 245
::exit(___);}
#if 0
#line 241
{ 
#line 242
uint4 tmp; 
#line 243
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uint1(tmp.x); 
#line 245
} 
#endif
#line 247 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(uint2 *retVal, cudaTextureObject_t texObject, int x) 
#line 248
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 252
::exit(___);}
#if 0
#line 248
{ 
#line 249
uint4 tmp; 
#line 250
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 252
} 
#endif
#line 254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(uint4 *retVal, cudaTextureObject_t texObject, int x) 
#line 255
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 259
::exit(___);}
#if 0
#line 255
{ 
#line 256
uint4 tmp; 
#line 257
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 259
} 
#endif
#line 269 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(long *retVal, cudaTextureObject_t texObject, int x) 
#line 270
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 274
::exit(___);}
#if 0
#line 270
{ 
#line 271
int4 tmp; 
#line 272
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((long)(tmp.x)); 
#line 274
} 
#endif
#line 276 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(long1 *retVal, cudaTextureObject_t texObject, int x) 
#line 277
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 281
::exit(___);}
#if 0
#line 277
{ 
#line 278
int4 tmp; 
#line 279
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_long1(tmp.x); 
#line 281
} 
#endif
#line 283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(long2 *retVal, cudaTextureObject_t texObject, int x) 
#line 284
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 288
::exit(___);}
#if 0
#line 284
{ 
#line 285
int4 tmp; 
#line 286
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 288
} 
#endif
#line 290 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(long4 *retVal, cudaTextureObject_t texObject, int x) 
#line 291
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 295
::exit(___);}
#if 0
#line 291
{ 
#line 292
int4 tmp; 
#line 293
__asm tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 295
} 
#endif
#line 297 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(unsigned long *retVal, cudaTextureObject_t texObject, int x) 
#line 298
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 302
::exit(___);}
#if 0
#line 298
{ 
#line 299
uint4 tmp; 
#line 300
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 302
} 
#endif
#line 304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(ulong1 *retVal, cudaTextureObject_t texObject, int x) 
#line 305
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 309
::exit(___);}
#if 0
#line 305
{ 
#line 306
uint4 tmp; 
#line 307
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ulong1(tmp.x); 
#line 309
} 
#endif
#line 311 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(ulong2 *retVal, cudaTextureObject_t texObject, int x) 
#line 312
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 316
::exit(___);}
#if 0
#line 312
{ 
#line 313
uint4 tmp; 
#line 314
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 316
} 
#endif
#line 318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(ulong4 *retVal, cudaTextureObject_t texObject, int x) 
#line 319
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 323
::exit(___);}
#if 0
#line 319
{ 
#line 320
uint4 tmp; 
#line 321
__asm tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 323
} 
#endif
#line 334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(float *retVal, cudaTextureObject_t texObject, int x) 
#line 335
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 339
::exit(___);}
#if 0
#line 335
{ 
#line 336
float4 tmp; 
#line 337
__asm tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = (tmp.x); 
#line 339
} 
#endif
#line 341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(float1 *retVal, cudaTextureObject_t texObject, int x) 
#line 342
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 346
::exit(___);}
#if 0
#line 342
{ 
#line 343
float4 tmp; 
#line 344
__asm tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_float1(tmp.x); 
#line 346
} 
#endif
#line 348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(float2 *retVal, cudaTextureObject_t texObject, int x) 
#line 349
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 353
::exit(___);}
#if 0
#line 349
{ 
#line 350
float4 tmp; 
#line 351
__asm tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 353
} 
#endif
#line 355 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(float4 *retVal, cudaTextureObject_t texObject, int x) 
#line 356
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 360
::exit(___);}
#if 0
#line 356
{ 
#line 357
float4 tmp; 
#line 358
__asm tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 360
} 
#endif
#line 368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 369
tex1Dfetch(::cudaTextureObject_t texObject, int x) 
#line 370
{int volatile ___ = 1;(void)texObject;(void)x;
#line 374
::exit(___);}
#if 0
#line 370
{ 
#line 371
T ret; 
#line 372
tex1Dfetch(&ret, texObject, x); 
#line 373
return ret; 
#line 374
} 
#endif
#line 382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(char *retVal, cudaTextureObject_t texObject, float x) 
#line 383
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 392 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 389
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
#line 391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 392
} 
#endif
#line 393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(signed char *retVal, cudaTextureObject_t texObject, float x) 
#line 394
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 398
::exit(___);}
#if 0
#line 394
{ 
#line 395
int4 tmp; 
#line 396
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((signed char)(tmp.x)); 
#line 398
} 
#endif
#line 400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(char1 *retVal, cudaTextureObject_t texObject, float x) 
#line 401
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 405
::exit(___);}
#if 0
#line 401
{ 
#line 402
int4 tmp; 
#line 403
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_char1(tmp.x); 
#line 405
} 
#endif
#line 407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(char2 *retVal, cudaTextureObject_t texObject, float x) 
#line 408
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 412
::exit(___);}
#if 0
#line 408
{ 
#line 409
int4 tmp; 
#line 410
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 412
} 
#endif
#line 414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(char4 *retVal, cudaTextureObject_t texObject, float x) 
#line 415
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 419
::exit(___);}
#if 0
#line 415
{ 
#line 416
int4 tmp; 
#line 417
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 419
} 
#endif
#line 421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(unsigned char *retVal, cudaTextureObject_t texObject, float x) 
#line 422
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 426
::exit(___);}
#if 0
#line 422
{ 
#line 423
uint4 tmp; 
#line 424
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 426
} 
#endif
#line 428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(uchar1 *retVal, cudaTextureObject_t texObject, float x) 
#line 429
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 433
::exit(___);}
#if 0
#line 429
{ 
#line 430
uint4 tmp; 
#line 431
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uchar1(tmp.x); 
#line 433
} 
#endif
#line 435 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(uchar2 *retVal, cudaTextureObject_t texObject, float x) 
#line 436
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 440
::exit(___);}
#if 0
#line 436
{ 
#line 437
uint4 tmp; 
#line 438
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 440
} 
#endif
#line 442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(uchar4 *retVal, cudaTextureObject_t texObject, float x) 
#line 443
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 447
::exit(___);}
#if 0
#line 443
{ 
#line 444
uint4 tmp; 
#line 445
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 447
} 
#endif
#line 455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(short *retVal, cudaTextureObject_t texObject, float x) 
#line 456
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 460
::exit(___);}
#if 0
#line 456
{ 
#line 457
int4 tmp; 
#line 458
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((short)(tmp.x)); 
#line 460
} 
#endif
#line 462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(short1 *retVal, cudaTextureObject_t texObject, float x) 
#line 463
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 467
::exit(___);}
#if 0
#line 463
{ 
#line 464
int4 tmp; 
#line 465
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_short1(tmp.x); 
#line 467
} 
#endif
#line 469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(short2 *retVal, cudaTextureObject_t texObject, float x) 
#line 470
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 474
::exit(___);}
#if 0
#line 470
{ 
#line 471
int4 tmp; 
#line 472
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 474
} 
#endif
#line 476 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(short4 *retVal, cudaTextureObject_t texObject, float x) 
#line 477
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 481
::exit(___);}
#if 0
#line 477
{ 
#line 478
int4 tmp; 
#line 479
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 481
} 
#endif
#line 483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(unsigned short *retVal, cudaTextureObject_t texObject, float x) 
#line 484
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 488
::exit(___);}
#if 0
#line 484
{ 
#line 485
uint4 tmp; 
#line 486
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 488
} 
#endif
#line 490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(ushort1 *retVal, cudaTextureObject_t texObject, float x) 
#line 491
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 495
::exit(___);}
#if 0
#line 491
{ 
#line 492
uint4 tmp; 
#line 493
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ushort1(tmp.x); 
#line 495
} 
#endif
#line 497 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(ushort2 *retVal, cudaTextureObject_t texObject, float x) 
#line 498
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 502
::exit(___);}
#if 0
#line 498
{ 
#line 499
uint4 tmp; 
#line 500
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 502
} 
#endif
#line 504 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(ushort4 *retVal, cudaTextureObject_t texObject, float x) 
#line 505
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 509
::exit(___);}
#if 0
#line 505
{ 
#line 506
uint4 tmp; 
#line 507
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 509
} 
#endif
#line 517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(int *retVal, cudaTextureObject_t texObject, float x) 
#line 518
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 522
::exit(___);}
#if 0
#line 518
{ 
#line 519
int4 tmp; 
#line 520
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = (tmp.x); 
#line 522
} 
#endif
#line 524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(int1 *retVal, cudaTextureObject_t texObject, float x) 
#line 525
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 529
::exit(___);}
#if 0
#line 525
{ 
#line 526
int4 tmp; 
#line 527
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_int1(tmp.x); 
#line 529
} 
#endif
#line 531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(int2 *retVal, cudaTextureObject_t texObject, float x) 
#line 532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 536
::exit(___);}
#if 0
#line 532
{ 
#line 533
int4 tmp; 
#line 534
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 536
} 
#endif
#line 538 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(int4 *retVal, cudaTextureObject_t texObject, float x) 
#line 539
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 543
::exit(___);}
#if 0
#line 539
{ 
#line 540
int4 tmp; 
#line 541
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 543
} 
#endif
#line 545 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(unsigned *retVal, cudaTextureObject_t texObject, float x) 
#line 546
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 550
::exit(___);}
#if 0
#line 546
{ 
#line 547
uint4 tmp; 
#line 548
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = (tmp.x); 
#line 550
} 
#endif
#line 552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(uint1 *retVal, cudaTextureObject_t texObject, float x) 
#line 553
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 557
::exit(___);}
#if 0
#line 553
{ 
#line 554
uint4 tmp; 
#line 555
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uint1(tmp.x); 
#line 557
} 
#endif
#line 559 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(uint2 *retVal, cudaTextureObject_t texObject, float x) 
#line 560
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 564
::exit(___);}
#if 0
#line 560
{ 
#line 561
uint4 tmp; 
#line 562
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 564
} 
#endif
#line 566 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(uint4 *retVal, cudaTextureObject_t texObject, float x) 
#line 567
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 571
::exit(___);}
#if 0
#line 567
{ 
#line 568
uint4 tmp; 
#line 569
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 571
} 
#endif
#line 581 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(long *retVal, cudaTextureObject_t texObject, float x) 
#line 582
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 586
::exit(___);}
#if 0
#line 582
{ 
#line 583
int4 tmp; 
#line 584
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((long)(tmp.x)); 
#line 586
} 
#endif
#line 588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(long1 *retVal, cudaTextureObject_t texObject, float x) 
#line 589
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 593
::exit(___);}
#if 0
#line 589
{ 
#line 590
int4 tmp; 
#line 591
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_long1(tmp.x); 
#line 593
} 
#endif
#line 595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(long2 *retVal, cudaTextureObject_t texObject, float x) 
#line 596
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 600
::exit(___);}
#if 0
#line 596
{ 
#line 597
int4 tmp; 
#line 598
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 600
} 
#endif
#line 602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(long4 *retVal, cudaTextureObject_t texObject, float x) 
#line 603
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 607
::exit(___);}
#if 0
#line 603
{ 
#line 604
int4 tmp; 
#line 605
__asm tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 607
} 
#endif
#line 609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(unsigned long *retVal, cudaTextureObject_t texObject, float x) 
#line 610
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 614
::exit(___);}
#if 0
#line 610
{ 
#line 611
uint4 tmp; 
#line 612
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 614
} 
#endif
#line 616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(ulong1 *retVal, cudaTextureObject_t texObject, float x) 
#line 617
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 621
::exit(___);}
#if 0
#line 617
{ 
#line 618
uint4 tmp; 
#line 619
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ulong1(tmp.x); 
#line 621
} 
#endif
#line 623 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(ulong2 *retVal, cudaTextureObject_t texObject, float x) 
#line 624
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 628
::exit(___);}
#if 0
#line 624
{ 
#line 625
uint4 tmp; 
#line 626
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 628
} 
#endif
#line 630 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(ulong4 *retVal, cudaTextureObject_t texObject, float x) 
#line 631
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 635
::exit(___);}
#if 0
#line 631
{ 
#line 632
uint4 tmp; 
#line 633
__asm tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 635
} 
#endif
#line 646 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(float *retVal, cudaTextureObject_t texObject, float x) 
#line 647
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 651
::exit(___);}
#if 0
#line 647
{ 
#line 648
float4 tmp; 
#line 649
__asm tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = (tmp.x); 
#line 651
} 
#endif
#line 653 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(float1 *retVal, cudaTextureObject_t texObject, float x) 
#line 654
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 658
::exit(___);}
#if 0
#line 654
{ 
#line 655
float4 tmp; 
#line 656
__asm tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_float1(tmp.x); 
#line 658
} 
#endif
#line 660 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(float2 *retVal, cudaTextureObject_t texObject, float x) 
#line 661
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 665
::exit(___);}
#if 0
#line 661
{ 
#line 662
float4 tmp; 
#line 663
__asm tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 665
} 
#endif
#line 667 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(float4 *retVal, cudaTextureObject_t texObject, float x) 
#line 668
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 672
::exit(___);}
#if 0
#line 668
{ 
#line 669
float4 tmp; 
#line 670
__asm tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 672
} 
#endif
#line 680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 681
tex1D(::cudaTextureObject_t texObject, float x) 
#line 682
{int volatile ___ = 1;(void)texObject;(void)x;
#line 686
::exit(___);}
#if 0
#line 682
{ 
#line 683
T ret; 
#line 684
tex1D(&ret, texObject, x); 
#line 685
return ret; 
#line 686
} 
#endif
#line 694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(char *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 695
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 704 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 695 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 700 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 701
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
#line 703 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 704
} 
#endif
#line 705 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(signed char *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 706
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 710
::exit(___);}
#if 0
#line 706
{ 
#line 707
int4 tmp; 
#line 708
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((signed char)(tmp.x)); 
#line 710
} 
#endif
#line 712 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(char1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 713
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 717
::exit(___);}
#if 0
#line 713
{ 
#line 714
int4 tmp; 
#line 715
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_char1(tmp.x); 
#line 717
} 
#endif
#line 719 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(char2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 720
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 724
::exit(___);}
#if 0
#line 720
{ 
#line 721
int4 tmp; 
#line 722
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 724
} 
#endif
#line 726 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(char4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 727
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 731
::exit(___);}
#if 0
#line 727
{ 
#line 728
int4 tmp; 
#line 729
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 731
} 
#endif
#line 733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 734
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 738
::exit(___);}
#if 0
#line 734
{ 
#line 735
uint4 tmp; 
#line 736
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 738
} 
#endif
#line 740 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 741
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 745
::exit(___);}
#if 0
#line 741
{ 
#line 742
uint4 tmp; 
#line 743
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uchar1(tmp.x); 
#line 745
} 
#endif
#line 747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 748
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 752
::exit(___);}
#if 0
#line 748
{ 
#line 749
uint4 tmp; 
#line 750
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 752
} 
#endif
#line 754 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 755
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 759
::exit(___);}
#if 0
#line 755
{ 
#line 756
uint4 tmp; 
#line 757
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 759
} 
#endif
#line 767 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(short *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 768
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 772
::exit(___);}
#if 0
#line 768
{ 
#line 769
int4 tmp; 
#line 770
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((short)(tmp.x)); 
#line 772
} 
#endif
#line 774 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(short1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 775
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 779
::exit(___);}
#if 0
#line 775
{ 
#line 776
int4 tmp; 
#line 777
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_short1(tmp.x); 
#line 779
} 
#endif
#line 781 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(short2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 782
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 786
::exit(___);}
#if 0
#line 782
{ 
#line 783
int4 tmp; 
#line 784
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 786
} 
#endif
#line 788 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(short4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 789
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 793
::exit(___);}
#if 0
#line 789
{ 
#line 790
int4 tmp; 
#line 791
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 793
} 
#endif
#line 795 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 796
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 800
::exit(___);}
#if 0
#line 796
{ 
#line 797
uint4 tmp; 
#line 798
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 800
} 
#endif
#line 802 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 803
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 807
::exit(___);}
#if 0
#line 803
{ 
#line 804
uint4 tmp; 
#line 805
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ushort1(tmp.x); 
#line 807
} 
#endif
#line 809 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 810
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 814
::exit(___);}
#if 0
#line 810
{ 
#line 811
uint4 tmp; 
#line 812
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 814
} 
#endif
#line 816 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 817
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 821
::exit(___);}
#if 0
#line 817
{ 
#line 818
uint4 tmp; 
#line 819
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 821
} 
#endif
#line 829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(int *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 830
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 834
::exit(___);}
#if 0
#line 830
{ 
#line 831
int4 tmp; 
#line 832
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = (tmp.x); 
#line 834
} 
#endif
#line 836 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(int1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 837
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 841
::exit(___);}
#if 0
#line 837
{ 
#line 838
int4 tmp; 
#line 839
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_int1(tmp.x); 
#line 841
} 
#endif
#line 843 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(int2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 844
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 848
::exit(___);}
#if 0
#line 844
{ 
#line 845
int4 tmp; 
#line 846
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 848
} 
#endif
#line 850 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(int4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 851
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 855
::exit(___);}
#if 0
#line 851
{ 
#line 852
int4 tmp; 
#line 853
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 855
} 
#endif
#line 857 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(unsigned *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 858
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 862
::exit(___);}
#if 0
#line 858
{ 
#line 859
uint4 tmp; 
#line 860
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = (tmp.x); 
#line 862
} 
#endif
#line 864 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 865
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 869
::exit(___);}
#if 0
#line 865
{ 
#line 866
uint4 tmp; 
#line 867
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uint1(tmp.x); 
#line 869
} 
#endif
#line 871 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 872
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 876
::exit(___);}
#if 0
#line 872
{ 
#line 873
uint4 tmp; 
#line 874
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 876
} 
#endif
#line 878 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 879
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 883
::exit(___);}
#if 0
#line 879
{ 
#line 880
uint4 tmp; 
#line 881
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 883
} 
#endif
#line 893 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(long *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 894
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 898
::exit(___);}
#if 0
#line 894
{ 
#line 895
int4 tmp; 
#line 896
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((long)(tmp.x)); 
#line 898
} 
#endif
#line 900 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(long1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 901
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 905
::exit(___);}
#if 0
#line 901
{ 
#line 902
int4 tmp; 
#line 903
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_long1(tmp.x); 
#line 905
} 
#endif
#line 907 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(long2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 908
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 912
::exit(___);}
#if 0
#line 908
{ 
#line 909
int4 tmp; 
#line 910
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 912
} 
#endif
#line 914 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(long4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 915
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 919
::exit(___);}
#if 0
#line 915
{ 
#line 916
int4 tmp; 
#line 917
__asm tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 919
} 
#endif
#line 921 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 922
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 926
::exit(___);}
#if 0
#line 922
{ 
#line 923
uint4 tmp; 
#line 924
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 926
} 
#endif
#line 928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 929
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 933
::exit(___);}
#if 0
#line 929
{ 
#line 930
uint4 tmp; 
#line 931
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ulong1(tmp.x); 
#line 933
} 
#endif
#line 935 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 936
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 940
::exit(___);}
#if 0
#line 936
{ 
#line 937
uint4 tmp; 
#line 938
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 940
} 
#endif
#line 942 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 943
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 947
::exit(___);}
#if 0
#line 943
{ 
#line 944
uint4 tmp; 
#line 945
__asm tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 947
} 
#endif
#line 958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(float *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 959
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 963
::exit(___);}
#if 0
#line 959
{ 
#line 960
float4 tmp; 
#line 961
__asm tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = (tmp.x); 
#line 963
} 
#endif
#line 965 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(float1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 966
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 970
::exit(___);}
#if 0
#line 966
{ 
#line 967
float4 tmp; 
#line 968
__asm tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_float1(tmp.x); 
#line 970
} 
#endif
#line 972 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(float2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 973
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 977
::exit(___);}
#if 0
#line 973
{ 
#line 974
float4 tmp; 
#line 975
__asm tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 977
} 
#endif
#line 979 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(float4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 980
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 984
::exit(___);}
#if 0
#line 980
{ 
#line 981
float4 tmp; 
#line 982
__asm tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 984
} 
#endif
#line 992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 993
tex2D(::cudaTextureObject_t texObject, float x, float y) 
#line 994
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;
#line 998
::exit(___);}
#if 0
#line 994
{ 
#line 995
T ret; 
#line 996
tex2D(&ret, texObject, x, y); 
#line 997
return ret; 
#line 998
} 
#endif
#line 1006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1007
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1016 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 1007 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 1012 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 1013
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
#line 1015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 1016
} 
#endif
#line 1017 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1018
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1022
::exit(___);}
#if 0
#line 1018
{ 
#line 1019
int4 tmp; 
#line 1020
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((signed char)(tmp.x)); 
#line 1022
} 
#endif
#line 1024 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1025
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1029
::exit(___);}
#if 0
#line 1025
{ 
#line 1026
int4 tmp; 
#line 1027
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char1(tmp.x); 
#line 1029
} 
#endif
#line 1031 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1032
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1036
::exit(___);}
#if 0
#line 1032
{ 
#line 1033
int4 tmp; 
#line 1034
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 1036
} 
#endif
#line 1038 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1039
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1043
::exit(___);}
#if 0
#line 1039
{ 
#line 1040
int4 tmp; 
#line 1041
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1043
} 
#endif
#line 1045 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1046
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1050
::exit(___);}
#if 0
#line 1046
{ 
#line 1047
uint4 tmp; 
#line 1048
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 1050
} 
#endif
#line 1052 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1053
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1057
::exit(___);}
#if 0
#line 1053
{ 
#line 1054
uint4 tmp; 
#line 1055
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar1(tmp.x); 
#line 1057
} 
#endif
#line 1059 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1060
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1064
::exit(___);}
#if 0
#line 1060
{ 
#line 1061
uint4 tmp; 
#line 1062
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 1064
} 
#endif
#line 1066 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1067
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1071
::exit(___);}
#if 0
#line 1067
{ 
#line 1068
uint4 tmp; 
#line 1069
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1071
} 
#endif
#line 1079 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1080
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1084
::exit(___);}
#if 0
#line 1080
{ 
#line 1081
int4 tmp; 
#line 1082
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((short)(tmp.x)); 
#line 1084
} 
#endif
#line 1086 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1087
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1091
::exit(___);}
#if 0
#line 1087
{ 
#line 1088
int4 tmp; 
#line 1089
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short1(tmp.x); 
#line 1091
} 
#endif
#line 1093 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1094
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1098
::exit(___);}
#if 0
#line 1094
{ 
#line 1095
int4 tmp; 
#line 1096
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 1098
} 
#endif
#line 1100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1101
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1105
::exit(___);}
#if 0
#line 1101
{ 
#line 1102
int4 tmp; 
#line 1103
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1105
} 
#endif
#line 1107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1108
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1112
::exit(___);}
#if 0
#line 1108
{ 
#line 1109
uint4 tmp; 
#line 1110
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 1112
} 
#endif
#line 1114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1115
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1119
::exit(___);}
#if 0
#line 1115
{ 
#line 1116
uint4 tmp; 
#line 1117
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort1(tmp.x); 
#line 1119
} 
#endif
#line 1121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1122
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1126
::exit(___);}
#if 0
#line 1122
{ 
#line 1123
uint4 tmp; 
#line 1124
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 1126
} 
#endif
#line 1128 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1129
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1133
::exit(___);}
#if 0
#line 1129
{ 
#line 1130
uint4 tmp; 
#line 1131
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1133
} 
#endif
#line 1141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(int *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1142
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1146
::exit(___);}
#if 0
#line 1142
{ 
#line 1143
int4 tmp; 
#line 1144
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 1146
} 
#endif
#line 1148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1153
::exit(___);}
#if 0
#line 1149
{ 
#line 1150
int4 tmp; 
#line 1151
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int1(tmp.x); 
#line 1153
} 
#endif
#line 1155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1156
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1160
::exit(___);}
#if 0
#line 1156
{ 
#line 1157
int4 tmp; 
#line 1158
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 1160
} 
#endif
#line 1162 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1163
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1167
::exit(___);}
#if 0
#line 1163
{ 
#line 1164
int4 tmp; 
#line 1165
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1167
} 
#endif
#line 1169 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1170
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1174
::exit(___);}
#if 0
#line 1170
{ 
#line 1171
uint4 tmp; 
#line 1172
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 1174
} 
#endif
#line 1176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1177
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1181
::exit(___);}
#if 0
#line 1177
{ 
#line 1178
uint4 tmp; 
#line 1179
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint1(tmp.x); 
#line 1181
} 
#endif
#line 1183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1184
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1188
::exit(___);}
#if 0
#line 1184
{ 
#line 1185
uint4 tmp; 
#line 1186
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 1188
} 
#endif
#line 1190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1191
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1195
::exit(___);}
#if 0
#line 1191
{ 
#line 1192
uint4 tmp; 
#line 1193
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1195
} 
#endif
#line 1205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(long *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1206
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1210
::exit(___);}
#if 0
#line 1206
{ 
#line 1207
int4 tmp; 
#line 1208
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((long)(tmp.x)); 
#line 1210
} 
#endif
#line 1212 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1213
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1217
::exit(___);}
#if 0
#line 1213
{ 
#line 1214
int4 tmp; 
#line 1215
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long1(tmp.x); 
#line 1217
} 
#endif
#line 1219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1220
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1224
::exit(___);}
#if 0
#line 1220
{ 
#line 1221
int4 tmp; 
#line 1222
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 1224
} 
#endif
#line 1226 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1227
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1231
::exit(___);}
#if 0
#line 1227
{ 
#line 1228
int4 tmp; 
#line 1229
__asm tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1231
} 
#endif
#line 1233 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1234
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1238
::exit(___);}
#if 0
#line 1234
{ 
#line 1235
uint4 tmp; 
#line 1236
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 1238
} 
#endif
#line 1240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1241
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1245
::exit(___);}
#if 0
#line 1241
{ 
#line 1242
uint4 tmp; 
#line 1243
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong1(tmp.x); 
#line 1245
} 
#endif
#line 1247 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1248
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1252
::exit(___);}
#if 0
#line 1248
{ 
#line 1249
uint4 tmp; 
#line 1250
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 1252
} 
#endif
#line 1254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1255
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1259
::exit(___);}
#if 0
#line 1255
{ 
#line 1256
uint4 tmp; 
#line 1257
__asm tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1259
} 
#endif
#line 1270 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(float *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1271
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1275
::exit(___);}
#if 0
#line 1271
{ 
#line 1272
float4 tmp; 
#line 1273
__asm tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 1275
} 
#endif
#line 1277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1278
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1282
::exit(___);}
#if 0
#line 1278
{ 
#line 1279
float4 tmp; 
#line 1280
__asm tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float1(tmp.x); 
#line 1282
} 
#endif
#line 1284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1285
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1289
::exit(___);}
#if 0
#line 1285
{ 
#line 1286
float4 tmp; 
#line 1287
__asm tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 1289
} 
#endif
#line 1291 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1292
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1296
::exit(___);}
#if 0
#line 1292
{ 
#line 1293
float4 tmp; 
#line 1294
__asm tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1296
} 
#endif
#line 1304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 1305
tex3D(::cudaTextureObject_t texObject, float x, float y, float z) 
#line 1306
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
#line 1310
::exit(___);}
#if 0
#line 1306
{ 
#line 1307
T ret; 
#line 1308
tex3D(&ret, texObject, x, y, z); 
#line 1309
return ret; 
#line 1310
} 
#endif
#line 1318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(char *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1319
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1328 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 1319 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 1324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 1325
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
#line 1327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 1328
} 
#endif
#line 1329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1330
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1334
::exit(___);}
#if 0
#line 1330
{ 
#line 1331
int4 tmp; 
#line 1332
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((signed char)(tmp.x)); 
#line 1334
} 
#endif
#line 1336 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1337
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1341
::exit(___);}
#if 0
#line 1337
{ 
#line 1338
int4 tmp; 
#line 1339
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_char1(tmp.x); 
#line 1341
} 
#endif
#line 1343 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1344
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1348
::exit(___);}
#if 0
#line 1344
{ 
#line 1345
int4 tmp; 
#line 1346
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 1348
} 
#endif
#line 1350 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1351
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1355
::exit(___);}
#if 0
#line 1351
{ 
#line 1352
int4 tmp; 
#line 1353
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1355
} 
#endif
#line 1357 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1358
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1362
::exit(___);}
#if 0
#line 1358
{ 
#line 1359
uint4 tmp; 
#line 1360
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 1362
} 
#endif
#line 1364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1365
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1369
::exit(___);}
#if 0
#line 1365
{ 
#line 1366
uint4 tmp; 
#line 1367
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uchar1(tmp.x); 
#line 1369
} 
#endif
#line 1371 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1372
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1376
::exit(___);}
#if 0
#line 1372
{ 
#line 1373
uint4 tmp; 
#line 1374
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 1376
} 
#endif
#line 1378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1379
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1383
::exit(___);}
#if 0
#line 1379
{ 
#line 1380
uint4 tmp; 
#line 1381
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1383
} 
#endif
#line 1391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(short *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1392
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1396
::exit(___);}
#if 0
#line 1392
{ 
#line 1393
int4 tmp; 
#line 1394
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((short)(tmp.x)); 
#line 1396
} 
#endif
#line 1398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1399
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1403
::exit(___);}
#if 0
#line 1399
{ 
#line 1400
int4 tmp; 
#line 1401
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_short1(tmp.x); 
#line 1403
} 
#endif
#line 1405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1406
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1410
::exit(___);}
#if 0
#line 1406
{ 
#line 1407
int4 tmp; 
#line 1408
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 1410
} 
#endif
#line 1412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1413
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1417
::exit(___);}
#if 0
#line 1413
{ 
#line 1414
int4 tmp; 
#line 1415
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1417
} 
#endif
#line 1419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1420
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1424
::exit(___);}
#if 0
#line 1420
{ 
#line 1421
uint4 tmp; 
#line 1422
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 1424
} 
#endif
#line 1426 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1427
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1431
::exit(___);}
#if 0
#line 1427
{ 
#line 1428
uint4 tmp; 
#line 1429
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ushort1(tmp.x); 
#line 1431
} 
#endif
#line 1433 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1434
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1438
::exit(___);}
#if 0
#line 1434
{ 
#line 1435
uint4 tmp; 
#line 1436
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 1438
} 
#endif
#line 1440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1441
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1445
::exit(___);}
#if 0
#line 1441
{ 
#line 1442
uint4 tmp; 
#line 1443
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1445
} 
#endif
#line 1453 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(int *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1458
::exit(___);}
#if 0
#line 1454
{ 
#line 1455
int4 tmp; 
#line 1456
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = (tmp.x); 
#line 1458
} 
#endif
#line 1460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1465
::exit(___);}
#if 0
#line 1461
{ 
#line 1462
int4 tmp; 
#line 1463
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_int1(tmp.x); 
#line 1465
} 
#endif
#line 1467 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1468
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1472
::exit(___);}
#if 0
#line 1468
{ 
#line 1469
int4 tmp; 
#line 1470
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 1472
} 
#endif
#line 1474 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1475
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1479
::exit(___);}
#if 0
#line 1475
{ 
#line 1476
int4 tmp; 
#line 1477
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1479
} 
#endif
#line 1481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1482
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1486
::exit(___);}
#if 0
#line 1482
{ 
#line 1483
uint4 tmp; 
#line 1484
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = (tmp.x); 
#line 1486
} 
#endif
#line 1488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1489
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1493
::exit(___);}
#if 0
#line 1489
{ 
#line 1490
uint4 tmp; 
#line 1491
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uint1(tmp.x); 
#line 1493
} 
#endif
#line 1495 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1496
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1500
::exit(___);}
#if 0
#line 1496
{ 
#line 1497
uint4 tmp; 
#line 1498
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 1500
} 
#endif
#line 1502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1503
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1507
::exit(___);}
#if 0
#line 1503
{ 
#line 1504
uint4 tmp; 
#line 1505
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1507
} 
#endif
#line 1517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(long *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1518
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1522
::exit(___);}
#if 0
#line 1518
{ 
#line 1519
int4 tmp; 
#line 1520
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((long)(tmp.x)); 
#line 1522
} 
#endif
#line 1524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(long1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1525
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1529
::exit(___);}
#if 0
#line 1525
{ 
#line 1526
int4 tmp; 
#line 1527
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_long1(tmp.x); 
#line 1529
} 
#endif
#line 1531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(long2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1536
::exit(___);}
#if 0
#line 1532
{ 
#line 1533
int4 tmp; 
#line 1534
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 1536
} 
#endif
#line 1538 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(long4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1539
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1543
::exit(___);}
#if 0
#line 1539
{ 
#line 1540
int4 tmp; 
#line 1541
__asm tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1543
} 
#endif
#line 1545 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1546
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1550
::exit(___);}
#if 0
#line 1546
{ 
#line 1547
uint4 tmp; 
#line 1548
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 1550
} 
#endif
#line 1552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1553
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1557
::exit(___);}
#if 0
#line 1553
{ 
#line 1554
uint4 tmp; 
#line 1555
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ulong1(tmp.x); 
#line 1557
} 
#endif
#line 1559 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1560
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1564
::exit(___);}
#if 0
#line 1560
{ 
#line 1561
uint4 tmp; 
#line 1562
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 1564
} 
#endif
#line 1566 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1567
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1571
::exit(___);}
#if 0
#line 1567
{ 
#line 1568
uint4 tmp; 
#line 1569
__asm tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1571
} 
#endif
#line 1582 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(float *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1583
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1587
::exit(___);}
#if 0
#line 1583
{ 
#line 1584
float4 tmp; 
#line 1585
__asm tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = (tmp.x); 
#line 1587
} 
#endif
#line 1589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1590
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1594
::exit(___);}
#if 0
#line 1590
{ 
#line 1591
float4 tmp; 
#line 1592
__asm tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_float1(tmp.x); 
#line 1594
} 
#endif
#line 1596 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1597
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1601
::exit(___);}
#if 0
#line 1597
{ 
#line 1598
float4 tmp; 
#line 1599
__asm tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 1601
} 
#endif
#line 1603 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1604
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1608
::exit(___);}
#if 0
#line 1604
{ 
#line 1605
float4 tmp; 
#line 1606
__asm tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1608
} 
#endif
#line 1616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 1617
tex1DLayered(::cudaTextureObject_t texObject, float x, int layer) 
#line 1618
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;
#line 1622
::exit(___);}
#if 0
#line 1618
{ 
#line 1619
T ret; 
#line 1620
tex1DLayered(&ret, texObject, x, layer); 
#line 1621
return ret; 
#line 1622
} 
#endif
#line 1630 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1631
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1640 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 1631 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 1636 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 1637
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
#line 1639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 1640
} 
#endif
#line 1641 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1642
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1646
::exit(___);}
#if 0
#line 1642
{ 
#line 1643
int4 tmp; 
#line 1644
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((signed char)(tmp.x)); 
#line 1646
} 
#endif
#line 1648 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1649
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1653
::exit(___);}
#if 0
#line 1649
{ 
#line 1650
int4 tmp; 
#line 1651
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char1(tmp.x); 
#line 1653
} 
#endif
#line 1655 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1656
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1660
::exit(___);}
#if 0
#line 1656
{ 
#line 1657
int4 tmp; 
#line 1658
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 1660
} 
#endif
#line 1662 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1663
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1667
::exit(___);}
#if 0
#line 1663
{ 
#line 1664
int4 tmp; 
#line 1665
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1667
} 
#endif
#line 1669 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1670
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1674
::exit(___);}
#if 0
#line 1670
{ 
#line 1671
uint4 tmp; 
#line 1672
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 1674
} 
#endif
#line 1676 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1677
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1681
::exit(___);}
#if 0
#line 1677
{ 
#line 1678
uint4 tmp; 
#line 1679
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar1(tmp.x); 
#line 1681
} 
#endif
#line 1683 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1684
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1688
::exit(___);}
#if 0
#line 1684
{ 
#line 1685
uint4 tmp; 
#line 1686
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 1688
} 
#endif
#line 1690 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1691
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1695
::exit(___);}
#if 0
#line 1691
{ 
#line 1692
uint4 tmp; 
#line 1693
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1695
} 
#endif
#line 1703 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1704
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1708
::exit(___);}
#if 0
#line 1704
{ 
#line 1705
int4 tmp; 
#line 1706
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((short)(tmp.x)); 
#line 1708
} 
#endif
#line 1710 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1711
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1715
::exit(___);}
#if 0
#line 1711
{ 
#line 1712
int4 tmp; 
#line 1713
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short1(tmp.x); 
#line 1715
} 
#endif
#line 1717 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1718
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1722
::exit(___);}
#if 0
#line 1718
{ 
#line 1719
int4 tmp; 
#line 1720
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 1722
} 
#endif
#line 1724 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1725
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1729
::exit(___);}
#if 0
#line 1725
{ 
#line 1726
int4 tmp; 
#line 1727
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1729
} 
#endif
#line 1731 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1732
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1736
::exit(___);}
#if 0
#line 1732
{ 
#line 1733
uint4 tmp; 
#line 1734
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 1736
} 
#endif
#line 1738 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1739
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1743
::exit(___);}
#if 0
#line 1739
{ 
#line 1740
uint4 tmp; 
#line 1741
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort1(tmp.x); 
#line 1743
} 
#endif
#line 1745 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1746
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1750
::exit(___);}
#if 0
#line 1746
{ 
#line 1747
uint4 tmp; 
#line 1748
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 1750
} 
#endif
#line 1752 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1753
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1757
::exit(___);}
#if 0
#line 1753
{ 
#line 1754
uint4 tmp; 
#line 1755
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1757
} 
#endif
#line 1765 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1766
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1770
::exit(___);}
#if 0
#line 1766
{ 
#line 1767
int4 tmp; 
#line 1768
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 1770
} 
#endif
#line 1772 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1773
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1777
::exit(___);}
#if 0
#line 1773
{ 
#line 1774
int4 tmp; 
#line 1775
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int1(tmp.x); 
#line 1777
} 
#endif
#line 1779 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1780
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1784
::exit(___);}
#if 0
#line 1780
{ 
#line 1781
int4 tmp; 
#line 1782
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 1784
} 
#endif
#line 1786 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1787
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1791
::exit(___);}
#if 0
#line 1787
{ 
#line 1788
int4 tmp; 
#line 1789
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1791
} 
#endif
#line 1793 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1794
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1798
::exit(___);}
#if 0
#line 1794
{ 
#line 1795
uint4 tmp; 
#line 1796
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 1798
} 
#endif
#line 1800 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1801
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1805
::exit(___);}
#if 0
#line 1801
{ 
#line 1802
uint4 tmp; 
#line 1803
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint1(tmp.x); 
#line 1805
} 
#endif
#line 1807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1808
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1812
::exit(___);}
#if 0
#line 1808
{ 
#line 1809
uint4 tmp; 
#line 1810
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 1812
} 
#endif
#line 1814 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1815
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1819
::exit(___);}
#if 0
#line 1815
{ 
#line 1816
uint4 tmp; 
#line 1817
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1819
} 
#endif
#line 1829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1830
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1834
::exit(___);}
#if 0
#line 1830
{ 
#line 1831
int4 tmp; 
#line 1832
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((long)(tmp.x)); 
#line 1834
} 
#endif
#line 1836 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1837
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1841
::exit(___);}
#if 0
#line 1837
{ 
#line 1838
int4 tmp; 
#line 1839
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long1(tmp.x); 
#line 1841
} 
#endif
#line 1843 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1844
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1848
::exit(___);}
#if 0
#line 1844
{ 
#line 1845
int4 tmp; 
#line 1846
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 1848
} 
#endif
#line 1850 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1851
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1855
::exit(___);}
#if 0
#line 1851
{ 
#line 1852
int4 tmp; 
#line 1853
__asm tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1855
} 
#endif
#line 1857 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1858
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1862
::exit(___);}
#if 0
#line 1858
{ 
#line 1859
uint4 tmp; 
#line 1860
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 1862
} 
#endif
#line 1864 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1865
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1869
::exit(___);}
#if 0
#line 1865
{ 
#line 1866
uint4 tmp; 
#line 1867
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong1(tmp.x); 
#line 1869
} 
#endif
#line 1871 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1872
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1876
::exit(___);}
#if 0
#line 1872
{ 
#line 1873
uint4 tmp; 
#line 1874
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 1876
} 
#endif
#line 1878 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1879
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1883
::exit(___);}
#if 0
#line 1879
{ 
#line 1880
uint4 tmp; 
#line 1881
__asm tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1883
} 
#endif
#line 1894 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1895
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1899
::exit(___);}
#if 0
#line 1895
{ 
#line 1896
float4 tmp; 
#line 1897
__asm tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 1899
} 
#endif
#line 1901 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1902
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1906
::exit(___);}
#if 0
#line 1902
{ 
#line 1903
float4 tmp; 
#line 1904
__asm tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float1(tmp.x); 
#line 1906
} 
#endif
#line 1908 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1909
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1913
::exit(___);}
#if 0
#line 1909
{ 
#line 1910
float4 tmp; 
#line 1911
__asm tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 1913
} 
#endif
#line 1915 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1916
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1920
::exit(___);}
#if 0
#line 1916
{ 
#line 1917
float4 tmp; 
#line 1918
__asm tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1920
} 
#endif
#line 1928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 1929
tex2DLayered(::cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1930
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;
#line 1934
::exit(___);}
#if 0
#line 1930
{ 
#line 1931
T ret; 
#line 1932
tex2DLayered(&ret, texObject, x, y, layer); 
#line 1933
return ret; 
#line 1934
} 
#endif
#line 1942 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1943
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1952 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 1943 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 1948 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 1949
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
#line 1951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 1952
} 
#endif
#line 1953 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1954
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1958
::exit(___);}
#if 0
#line 1954
{ 
#line 1955
int4 tmp; 
#line 1956
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((signed char)(tmp.x)); 
#line 1958
} 
#endif
#line 1960 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1961
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1965
::exit(___);}
#if 0
#line 1961
{ 
#line 1962
int4 tmp; 
#line 1963
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char1(tmp.x); 
#line 1965
} 
#endif
#line 1967 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1968
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1972
::exit(___);}
#if 0
#line 1968
{ 
#line 1969
int4 tmp; 
#line 1970
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 1972
} 
#endif
#line 1974 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1975
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1979
::exit(___);}
#if 0
#line 1975
{ 
#line 1976
int4 tmp; 
#line 1977
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1979
} 
#endif
#line 1981 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1982
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1986
::exit(___);}
#if 0
#line 1982
{ 
#line 1983
uint4 tmp; 
#line 1984
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 1986
} 
#endif
#line 1988 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1989
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1993
::exit(___);}
#if 0
#line 1989
{ 
#line 1990
uint4 tmp; 
#line 1991
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar1(tmp.x); 
#line 1993
} 
#endif
#line 1995 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1996
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2000
::exit(___);}
#if 0
#line 1996
{ 
#line 1997
uint4 tmp; 
#line 1998
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 2000
} 
#endif
#line 2002 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2003
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2007
::exit(___);}
#if 0
#line 2003
{ 
#line 2004
uint4 tmp; 
#line 2005
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2007
} 
#endif
#line 2015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2016
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2020
::exit(___);}
#if 0
#line 2016
{ 
#line 2017
int4 tmp; 
#line 2018
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((short)(tmp.x)); 
#line 2020
} 
#endif
#line 2022 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2023
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2027
::exit(___);}
#if 0
#line 2023
{ 
#line 2024
int4 tmp; 
#line 2025
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short1(tmp.x); 
#line 2027
} 
#endif
#line 2029 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2030
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2034
::exit(___);}
#if 0
#line 2030
{ 
#line 2031
int4 tmp; 
#line 2032
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 2034
} 
#endif
#line 2036 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2037
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2041
::exit(___);}
#if 0
#line 2037
{ 
#line 2038
int4 tmp; 
#line 2039
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2041
} 
#endif
#line 2043 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2044
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2048
::exit(___);}
#if 0
#line 2044
{ 
#line 2045
uint4 tmp; 
#line 2046
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 2048
} 
#endif
#line 2050 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2051
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2055
::exit(___);}
#if 0
#line 2051
{ 
#line 2052
uint4 tmp; 
#line 2053
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort1(tmp.x); 
#line 2055
} 
#endif
#line 2057 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2058
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2062
::exit(___);}
#if 0
#line 2058
{ 
#line 2059
uint4 tmp; 
#line 2060
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 2062
} 
#endif
#line 2064 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2065
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2069
::exit(___);}
#if 0
#line 2065
{ 
#line 2066
uint4 tmp; 
#line 2067
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2069
} 
#endif
#line 2077 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(int *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2078
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2082
::exit(___);}
#if 0
#line 2078
{ 
#line 2079
int4 tmp; 
#line 2080
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 2082
} 
#endif
#line 2084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2085
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2089
::exit(___);}
#if 0
#line 2085
{ 
#line 2086
int4 tmp; 
#line 2087
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int1(tmp.x); 
#line 2089
} 
#endif
#line 2091 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2092
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2096
::exit(___);}
#if 0
#line 2092
{ 
#line 2093
int4 tmp; 
#line 2094
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 2096
} 
#endif
#line 2098 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2099
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2103
::exit(___);}
#if 0
#line 2099
{ 
#line 2100
int4 tmp; 
#line 2101
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2103
} 
#endif
#line 2105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2106
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2110
::exit(___);}
#if 0
#line 2106
{ 
#line 2107
uint4 tmp; 
#line 2108
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 2110
} 
#endif
#line 2112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2113
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2117
::exit(___);}
#if 0
#line 2113
{ 
#line 2114
uint4 tmp; 
#line 2115
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint1(tmp.x); 
#line 2117
} 
#endif
#line 2119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2120
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2124
::exit(___);}
#if 0
#line 2120
{ 
#line 2121
uint4 tmp; 
#line 2122
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 2124
} 
#endif
#line 2126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2127
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2131
::exit(___);}
#if 0
#line 2127
{ 
#line 2128
uint4 tmp; 
#line 2129
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2131
} 
#endif
#line 2141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(long *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2142
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2146
::exit(___);}
#if 0
#line 2142
{ 
#line 2143
int4 tmp; 
#line 2144
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((long)(tmp.x)); 
#line 2146
} 
#endif
#line 2148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2153
::exit(___);}
#if 0
#line 2149
{ 
#line 2150
int4 tmp; 
#line 2151
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long1(tmp.x); 
#line 2153
} 
#endif
#line 2155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2156
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2160
::exit(___);}
#if 0
#line 2156
{ 
#line 2157
int4 tmp; 
#line 2158
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 2160
} 
#endif
#line 2162 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2163
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2167
::exit(___);}
#if 0
#line 2163
{ 
#line 2164
int4 tmp; 
#line 2165
__asm tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2167
} 
#endif
#line 2169 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2170
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2174
::exit(___);}
#if 0
#line 2170
{ 
#line 2171
uint4 tmp; 
#line 2172
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 2174
} 
#endif
#line 2176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2177
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2181
::exit(___);}
#if 0
#line 2177
{ 
#line 2178
uint4 tmp; 
#line 2179
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong1(tmp.x); 
#line 2181
} 
#endif
#line 2183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2184
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2188
::exit(___);}
#if 0
#line 2184
{ 
#line 2185
uint4 tmp; 
#line 2186
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 2188
} 
#endif
#line 2190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2191
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2195
::exit(___);}
#if 0
#line 2191
{ 
#line 2192
uint4 tmp; 
#line 2193
__asm tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2195
} 
#endif
#line 2206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(float *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2207
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2211
::exit(___);}
#if 0
#line 2207
{ 
#line 2208
float4 tmp; 
#line 2209
__asm tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = (tmp.x); 
#line 2211
} 
#endif
#line 2213 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2214
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2218
::exit(___);}
#if 0
#line 2214
{ 
#line 2215
float4 tmp; 
#line 2216
__asm tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float1(tmp.x); 
#line 2218
} 
#endif
#line 2220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2221
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2225
::exit(___);}
#if 0
#line 2221
{ 
#line 2222
float4 tmp; 
#line 2223
__asm tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 2225
} 
#endif
#line 2227 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2228
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2232
::exit(___);}
#if 0
#line 2228
{ 
#line 2229
float4 tmp; 
#line 2230
__asm tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2232
} 
#endif
#line 2240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 2241
texCubemap(::cudaTextureObject_t texObject, float x, float y, float z) 
#line 2242
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
#line 2246
::exit(___);}
#if 0
#line 2242
{ 
#line 2243
T ret; 
#line 2244
texCubemap(&ret, texObject, x, y, z); 
#line 2245
return ret; 
#line 2246
} 
#endif
#line 2254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2255
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2264 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 2255 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 2260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 2261
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
#line 2263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 2264
} 
#endif
#line 2265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2266
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2270
::exit(___);}
#if 0
#line 2266
{ 
#line 2267
int4 tmp; 
#line 2268
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = ((signed char)(tmp.x)); 
#line 2270
} 
#endif
#line 2272 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2273
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2277
::exit(___);}
#if 0
#line 2273
{ 
#line 2274
int4 tmp; 
#line 2275
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_char1(tmp.x); 
#line 2277
} 
#endif
#line 2279 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2280
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2284
::exit(___);}
#if 0
#line 2280
{ 
#line 2281
int4 tmp; 
#line 2282
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 2284
} 
#endif
#line 2286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2287
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2291
::exit(___);}
#if 0
#line 2287
{ 
#line 2288
int4 tmp; 
#line 2289
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2291
} 
#endif
#line 2293 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2294
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2298
::exit(___);}
#if 0
#line 2294
{ 
#line 2295
uint4 tmp; 
#line 2296
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = ((unsigned char)(tmp.x)); 
#line 2298
} 
#endif
#line 2300 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2301
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2305
::exit(___);}
#if 0
#line 2301
{ 
#line 2302
uint4 tmp; 
#line 2303
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_uchar1(tmp.x); 
#line 2305
} 
#endif
#line 2307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2308
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2312
::exit(___);}
#if 0
#line 2308
{ 
#line 2309
uint4 tmp; 
#line 2310
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 2312
} 
#endif
#line 2314 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2315
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2319
::exit(___);}
#if 0
#line 2315
{ 
#line 2316
uint4 tmp; 
#line 2317
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2319
} 
#endif
#line 2327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2328
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2332
::exit(___);}
#if 0
#line 2328
{ 
#line 2329
int4 tmp; 
#line 2330
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = ((short)(tmp.x)); 
#line 2332
} 
#endif
#line 2334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2335
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2339
::exit(___);}
#if 0
#line 2335
{ 
#line 2336
int4 tmp; 
#line 2337
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_short1(tmp.x); 
#line 2339
} 
#endif
#line 2341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2342
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2346
::exit(___);}
#if 0
#line 2342
{ 
#line 2343
int4 tmp; 
#line 2344
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 2346
} 
#endif
#line 2348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2349
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2353
::exit(___);}
#if 0
#line 2349
{ 
#line 2350
int4 tmp; 
#line 2351
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2353
} 
#endif
#line 2355 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2356
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2360
::exit(___);}
#if 0
#line 2356
{ 
#line 2357
uint4 tmp; 
#line 2358
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = ((unsigned short)(tmp.x)); 
#line 2360
} 
#endif
#line 2362 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2363
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2367
::exit(___);}
#if 0
#line 2363
{ 
#line 2364
uint4 tmp; 
#line 2365
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_ushort1(tmp.x); 
#line 2367
} 
#endif
#line 2369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2370
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2374
::exit(___);}
#if 0
#line 2370
{ 
#line 2371
uint4 tmp; 
#line 2372
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 2374
} 
#endif
#line 2376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2377
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2381
::exit(___);}
#if 0
#line 2377
{ 
#line 2378
uint4 tmp; 
#line 2379
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2381
} 
#endif
#line 2389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2390
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2394
::exit(___);}
#if 0
#line 2390
{ 
#line 2391
int4 tmp; 
#line 2392
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = (tmp.x); 
#line 2394
} 
#endif
#line 2396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2397
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2401
::exit(___);}
#if 0
#line 2397
{ 
#line 2398
int4 tmp; 
#line 2399
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_int1(tmp.x); 
#line 2401
} 
#endif
#line 2403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2404
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2408
::exit(___);}
#if 0
#line 2404
{ 
#line 2405
int4 tmp; 
#line 2406
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 2408
} 
#endif
#line 2410 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2411
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2415
::exit(___);}
#if 0
#line 2411
{ 
#line 2412
int4 tmp; 
#line 2413
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2415
} 
#endif
#line 2417 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2418
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2422
::exit(___);}
#if 0
#line 2418
{ 
#line 2419
uint4 tmp; 
#line 2420
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = (tmp.x); 
#line 2422
} 
#endif
#line 2424 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2425
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2429
::exit(___);}
#if 0
#line 2425
{ 
#line 2426
uint4 tmp; 
#line 2427
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_uint1(tmp.x); 
#line 2429
} 
#endif
#line 2431 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2432
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2436
::exit(___);}
#if 0
#line 2432
{ 
#line 2433
uint4 tmp; 
#line 2434
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 2436
} 
#endif
#line 2438 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2439
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2443
::exit(___);}
#if 0
#line 2439
{ 
#line 2440
uint4 tmp; 
#line 2441
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2443
} 
#endif
#line 2453 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2458
::exit(___);}
#if 0
#line 2454
{ 
#line 2455
int4 tmp; 
#line 2456
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = ((long)(tmp.x)); 
#line 2458
} 
#endif
#line 2460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2465
::exit(___);}
#if 0
#line 2461
{ 
#line 2462
int4 tmp; 
#line 2463
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_long1(tmp.x); 
#line 2465
} 
#endif
#line 2467 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2468
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2472
::exit(___);}
#if 0
#line 2468
{ 
#line 2469
int4 tmp; 
#line 2470
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 2472
} 
#endif
#line 2474 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2475
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2479
::exit(___);}
#if 0
#line 2475
{ 
#line 2476
int4 tmp; 
#line 2477
__asm tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2479
} 
#endif
#line 2481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2482
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2486
::exit(___);}
#if 0
#line 2482
{ 
#line 2483
uint4 tmp; 
#line 2484
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = ((unsigned long)(tmp.x)); 
#line 2486
} 
#endif
#line 2488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2489
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2493
::exit(___);}
#if 0
#line 2489
{ 
#line 2490
uint4 tmp; 
#line 2491
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_ulong1(tmp.x); 
#line 2493
} 
#endif
#line 2495 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2496
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2500
::exit(___);}
#if 0
#line 2496
{ 
#line 2497
uint4 tmp; 
#line 2498
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 2500
} 
#endif
#line 2502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2503
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2507
::exit(___);}
#if 0
#line 2503
{ 
#line 2504
uint4 tmp; 
#line 2505
__asm tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2507
} 
#endif
#line 2518 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2519
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2523
::exit(___);}
#if 0
#line 2519
{ 
#line 2520
float4 tmp; 
#line 2521
__asm tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = (tmp.x); 
#line 2523
} 
#endif
#line 2525 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2526
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2530
::exit(___);}
#if 0
#line 2526
{ 
#line 2527
float4 tmp; 
#line 2528
__asm tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_float1(tmp.x); 
#line 2530
} 
#endif
#line 2532 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2533
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2537
::exit(___);}
#if 0
#line 2533
{ 
#line 2534
float4 tmp; 
#line 2535
__asm tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 2537
} 
#endif
#line 2539 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2540
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2544
::exit(___);}
#if 0
#line 2540
{ 
#line 2541
float4 tmp; 
#line 2542
__asm tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2544
} 
#endif
#line 2552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 2553
texCubemapLayered(::cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2554
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2558
::exit(___);}
#if 0
#line 2554
{ 
#line 2555
T ret; 
#line 2556
texCubemapLayered(&ret, texObject, x, y, z, layer); 
#line 2557
return ret; 
#line 2558
} 
#endif
#line 2566 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2567
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2582
::exit(___);}
#if 0
#line 2567
{ 
#line 2568
int4 tmp; 
#line 2569
if (comp == 0) { 
#line 2570
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2572
if (comp == 1) { 
#line 2573
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2575
if (comp == 2) { 
#line 2576
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2578
if (comp == 3) { 
#line 2579
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2581
(*retVal) = ((char)(tmp.x)); 
#line 2582
} 
#endif
#line 2584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2585
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2600
::exit(___);}
#if 0
#line 2585
{ 
#line 2586
int4 tmp; 
#line 2587
if (comp == 0) { 
#line 2588
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2590
if (comp == 1) { 
#line 2591
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2593
if (comp == 2) { 
#line 2594
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2596
if (comp == 3) { 
#line 2597
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2599
(*retVal) = ((signed char)(tmp.x)); 
#line 2600
} 
#endif
#line 2602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2603
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2618
::exit(___);}
#if 0
#line 2603
{ 
#line 2604
int4 tmp; 
#line 2605
if (comp == 0) { 
#line 2606
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2608
if (comp == 1) { 
#line 2609
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2611
if (comp == 2) { 
#line 2612
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2614
if (comp == 3) { 
#line 2615
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2617
(*retVal) = make_char1(tmp.x); 
#line 2618
} 
#endif
#line 2620 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2621
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2636
::exit(___);}
#if 0
#line 2621
{ 
#line 2622
int4 tmp; 
#line 2623
if (comp == 0) { 
#line 2624
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2626
if (comp == 1) { 
#line 2627
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2629
if (comp == 2) { 
#line 2630
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2632
if (comp == 3) { 
#line 2633
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2635
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 2636
} 
#endif
#line 2638 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2639
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2654
::exit(___);}
#if 0
#line 2639
{ 
#line 2640
int4 tmp; 
#line 2641
if (comp == 0) { 
#line 2642
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2644
if (comp == 1) { 
#line 2645
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2647
if (comp == 2) { 
#line 2648
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2650
if (comp == 3) { 
#line 2651
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2653
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2654
} 
#endif
#line 2656 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2657
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2672
::exit(___);}
#if 0
#line 2657
{ 
#line 2658
uint4 tmp; 
#line 2659
if (comp == 0) { 
#line 2660
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2662
if (comp == 1) { 
#line 2663
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2665
if (comp == 2) { 
#line 2666
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2668
if (comp == 3) { 
#line 2669
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2671
(*retVal) = ((unsigned char)(tmp.x)); 
#line 2672
} 
#endif
#line 2674 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2675
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2690
::exit(___);}
#if 0
#line 2675
{ 
#line 2676
uint4 tmp; 
#line 2677
if (comp == 0) { 
#line 2678
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2680
if (comp == 1) { 
#line 2681
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2683
if (comp == 2) { 
#line 2684
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2686
if (comp == 3) { 
#line 2687
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2689
(*retVal) = make_uchar1(tmp.x); 
#line 2690
} 
#endif
#line 2692 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2693
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2708
::exit(___);}
#if 0
#line 2693
{ 
#line 2694
uint4 tmp; 
#line 2695
if (comp == 0) { 
#line 2696
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2698
if (comp == 1) { 
#line 2699
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2701
if (comp == 2) { 
#line 2702
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2704
if (comp == 3) { 
#line 2705
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2707
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 2708
} 
#endif
#line 2710 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2711
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2726
::exit(___);}
#if 0
#line 2711
{ 
#line 2712
uint4 tmp; 
#line 2713
if (comp == 0) { 
#line 2714
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2716
if (comp == 1) { 
#line 2717
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2719
if (comp == 2) { 
#line 2720
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2722
if (comp == 3) { 
#line 2723
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2725
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2726
} 
#endif
#line 2734 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(short *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2735
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2750
::exit(___);}
#if 0
#line 2735
{ 
#line 2736
int4 tmp; 
#line 2737
if (comp == 0) { 
#line 2738
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2740
if (comp == 1) { 
#line 2741
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2743
if (comp == 2) { 
#line 2744
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2746
if (comp == 3) { 
#line 2747
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2749
(*retVal) = ((short)(tmp.x)); 
#line 2750
} 
#endif
#line 2752 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2753
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2768
::exit(___);}
#if 0
#line 2753
{ 
#line 2754
int4 tmp; 
#line 2755
if (comp == 0) { 
#line 2756
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2758
if (comp == 1) { 
#line 2759
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2761
if (comp == 2) { 
#line 2762
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2764
if (comp == 3) { 
#line 2765
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2767
(*retVal) = make_short1(tmp.x); 
#line 2768
} 
#endif
#line 2770 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2771
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2786
::exit(___);}
#if 0
#line 2771
{ 
#line 2772
int4 tmp; 
#line 2773
if (comp == 0) { 
#line 2774
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2776
if (comp == 1) { 
#line 2777
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2779
if (comp == 2) { 
#line 2780
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2782
if (comp == 3) { 
#line 2783
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2785
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 2786
} 
#endif
#line 2788 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2789
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2804
::exit(___);}
#if 0
#line 2789
{ 
#line 2790
int4 tmp; 
#line 2791
if (comp == 0) { 
#line 2792
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2794
if (comp == 1) { 
#line 2795
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2797
if (comp == 2) { 
#line 2798
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2800
if (comp == 3) { 
#line 2801
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2803
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2804
} 
#endif
#line 2806 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2807
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2822
::exit(___);}
#if 0
#line 2807
{ 
#line 2808
uint4 tmp; 
#line 2809
if (comp == 0) { 
#line 2810
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2812
if (comp == 1) { 
#line 2813
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2815
if (comp == 2) { 
#line 2816
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2818
if (comp == 3) { 
#line 2819
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2821
(*retVal) = ((unsigned short)(tmp.x)); 
#line 2822
} 
#endif
#line 2824 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2825
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2840
::exit(___);}
#if 0
#line 2825
{ 
#line 2826
uint4 tmp; 
#line 2827
if (comp == 0) { 
#line 2828
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2830
if (comp == 1) { 
#line 2831
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2833
if (comp == 2) { 
#line 2834
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2836
if (comp == 3) { 
#line 2837
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2839
(*retVal) = make_ushort1(tmp.x); 
#line 2840
} 
#endif
#line 2842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2843
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2858
::exit(___);}
#if 0
#line 2843
{ 
#line 2844
uint4 tmp; 
#line 2845
if (comp == 0) { 
#line 2846
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2848
if (comp == 1) { 
#line 2849
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2851
if (comp == 2) { 
#line 2852
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2854
if (comp == 3) { 
#line 2855
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2857
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 2858
} 
#endif
#line 2860 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2861
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2876
::exit(___);}
#if 0
#line 2861
{ 
#line 2862
uint4 tmp; 
#line 2863
if (comp == 0) { 
#line 2864
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2866
if (comp == 1) { 
#line 2867
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2869
if (comp == 2) { 
#line 2870
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2872
if (comp == 3) { 
#line 2873
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2875
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2876
} 
#endif
#line 2884 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(int *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2885
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2900
::exit(___);}
#if 0
#line 2885
{ 
#line 2886
int4 tmp; 
#line 2887
if (comp == 0) { 
#line 2888
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2890
if (comp == 1) { 
#line 2891
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2893
if (comp == 2) { 
#line 2894
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2896
if (comp == 3) { 
#line 2897
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2899
(*retVal) = (tmp.x); 
#line 2900
} 
#endif
#line 2902 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2903
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2918
::exit(___);}
#if 0
#line 2903
{ 
#line 2904
int4 tmp; 
#line 2905
if (comp == 0) { 
#line 2906
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2908
if (comp == 1) { 
#line 2909
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2911
if (comp == 2) { 
#line 2912
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2914
if (comp == 3) { 
#line 2915
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2917
(*retVal) = make_int1(tmp.x); 
#line 2918
} 
#endif
#line 2920 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2921
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2936
::exit(___);}
#if 0
#line 2921
{ 
#line 2922
int4 tmp; 
#line 2923
if (comp == 0) { 
#line 2924
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2926
if (comp == 1) { 
#line 2927
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2929
if (comp == 2) { 
#line 2930
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2932
if (comp == 3) { 
#line 2933
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2935
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 2936
} 
#endif
#line 2938 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2939
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2954
::exit(___);}
#if 0
#line 2939
{ 
#line 2940
int4 tmp; 
#line 2941
if (comp == 0) { 
#line 2942
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2944
if (comp == 1) { 
#line 2945
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2947
if (comp == 2) { 
#line 2948
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2950
if (comp == 3) { 
#line 2951
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2953
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2954
} 
#endif
#line 2956 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2957
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2972
::exit(___);}
#if 0
#line 2957
{ 
#line 2958
uint4 tmp; 
#line 2959
if (comp == 0) { 
#line 2960
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2962
if (comp == 1) { 
#line 2963
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2965
if (comp == 2) { 
#line 2966
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2968
if (comp == 3) { 
#line 2969
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2971
(*retVal) = (tmp.x); 
#line 2972
} 
#endif
#line 2974 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2975
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2990
::exit(___);}
#if 0
#line 2975
{ 
#line 2976
uint4 tmp; 
#line 2977
if (comp == 0) { 
#line 2978
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2980
if (comp == 1) { 
#line 2981
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2983
if (comp == 2) { 
#line 2984
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2986
if (comp == 3) { 
#line 2987
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 2989
(*retVal) = make_uint1(tmp.x); 
#line 2990
} 
#endif
#line 2992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 2993
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3008
::exit(___);}
#if 0
#line 2993
{ 
#line 2994
uint4 tmp; 
#line 2995
if (comp == 0) { 
#line 2996
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2998
if (comp == 1) { 
#line 2999
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3001
if (comp == 2) { 
#line 3002
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3004
if (comp == 3) { 
#line 3005
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3007
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 3008
} 
#endif
#line 3010 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3011
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3026
::exit(___);}
#if 0
#line 3011
{ 
#line 3012
uint4 tmp; 
#line 3013
if (comp == 0) { 
#line 3014
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3016
if (comp == 1) { 
#line 3017
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3019
if (comp == 2) { 
#line 3020
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3022
if (comp == 3) { 
#line 3023
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3025
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3026
} 
#endif
#line 3034 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(long *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3035
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3050
::exit(___);}
#if 0
#line 3035
{ 
#line 3036
int4 tmp; 
#line 3037
if (comp == 0) { 
#line 3038
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3040
if (comp == 1) { 
#line 3041
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3043
if (comp == 2) { 
#line 3044
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3046
if (comp == 3) { 
#line 3047
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3049
(*retVal) = ((long)(tmp.x)); 
#line 3050
} 
#endif
#line 3052 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3053
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3068
::exit(___);}
#if 0
#line 3053
{ 
#line 3054
int4 tmp; 
#line 3055
if (comp == 0) { 
#line 3056
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3058
if (comp == 1) { 
#line 3059
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3061
if (comp == 2) { 
#line 3062
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3064
if (comp == 3) { 
#line 3065
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3067
(*retVal) = make_long1(tmp.x); 
#line 3068
} 
#endif
#line 3070 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3071
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3086
::exit(___);}
#if 0
#line 3071
{ 
#line 3072
int4 tmp; 
#line 3073
if (comp == 0) { 
#line 3074
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3076
if (comp == 1) { 
#line 3077
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3079
if (comp == 2) { 
#line 3080
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3082
if (comp == 3) { 
#line 3083
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3085
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 3086
} 
#endif
#line 3088 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3089
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3104
::exit(___);}
#if 0
#line 3089
{ 
#line 3090
int4 tmp; 
#line 3091
if (comp == 0) { 
#line 3092
__asm tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3094
if (comp == 1) { 
#line 3095
__asm tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3097
if (comp == 2) { 
#line 3098
__asm tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3100
if (comp == 3) { 
#line 3101
__asm tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3103
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3104
} 
#endif
#line 3106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3107
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3122
::exit(___);}
#if 0
#line 3107
{ 
#line 3108
uint4 tmp; 
#line 3109
if (comp == 0) { 
#line 3110
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3112
if (comp == 1) { 
#line 3113
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3115
if (comp == 2) { 
#line 3116
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3118
if (comp == 3) { 
#line 3119
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3121
(*retVal) = ((unsigned long)(tmp.x)); 
#line 3122
} 
#endif
#line 3124 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3125
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3140
::exit(___);}
#if 0
#line 3125
{ 
#line 3126
uint4 tmp; 
#line 3127
if (comp == 0) { 
#line 3128
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3130
if (comp == 1) { 
#line 3131
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3133
if (comp == 2) { 
#line 3134
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3136
if (comp == 3) { 
#line 3137
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3139
(*retVal) = make_ulong1(tmp.x); 
#line 3140
} 
#endif
#line 3142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3143
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3158
::exit(___);}
#if 0
#line 3143
{ 
#line 3144
uint4 tmp; 
#line 3145
if (comp == 0) { 
#line 3146
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3148
if (comp == 1) { 
#line 3149
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3151
if (comp == 2) { 
#line 3152
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3154
if (comp == 3) { 
#line 3155
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3157
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 3158
} 
#endif
#line 3160 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3161
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3176
::exit(___);}
#if 0
#line 3161
{ 
#line 3162
uint4 tmp; 
#line 3163
if (comp == 0) { 
#line 3164
__asm tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3166
if (comp == 1) { 
#line 3167
__asm tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3169
if (comp == 2) { 
#line 3170
__asm tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3172
if (comp == 3) { 
#line 3173
__asm tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3175
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3176
} 
#endif
#line 3184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(float *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3185
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3200
::exit(___);}
#if 0
#line 3185
{ 
#line 3186
float4 tmp; 
#line 3187
if (comp == 0) { 
#line 3188
__asm tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3190
if (comp == 1) { 
#line 3191
__asm tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3193
if (comp == 2) { 
#line 3194
__asm tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3196
if (comp == 3) { 
#line 3197
__asm tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3199
(*retVal) = (tmp.x); 
#line 3200
} 
#endif
#line 3202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3203
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3218
::exit(___);}
#if 0
#line 3203
{ 
#line 3204
float4 tmp; 
#line 3205
if (comp == 0) { 
#line 3206
__asm tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3208
if (comp == 1) { 
#line 3209
__asm tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3211
if (comp == 2) { 
#line 3212
__asm tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3214
if (comp == 3) { 
#line 3215
__asm tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3217
(*retVal) = make_float1(tmp.x); 
#line 3218
} 
#endif
#line 3220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3221
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3236
::exit(___);}
#if 0
#line 3221
{ 
#line 3222
float4 tmp; 
#line 3223
if (comp == 0) { 
#line 3224
__asm tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3226
if (comp == 1) { 
#line 3227
__asm tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3229
if (comp == 2) { 
#line 3230
__asm tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3232
if (comp == 3) { 
#line 3233
__asm tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3235
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 3236
} 
#endif
#line 3238 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
#line 3239
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3254
::exit(___);}
#if 0
#line 3239
{ 
#line 3240
float4 tmp; 
#line 3241
if (comp == 0) { 
#line 3242
__asm tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3244
if (comp == 1) { 
#line 3245
__asm tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3247
if (comp == 2) { 
#line 3248
__asm tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 3250
if (comp == 3) { 
#line 3251
__asm tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  }  
#line 3253
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3254
} 
#endif
#line 3262 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 3263
tex2Dgather(::cudaTextureObject_t to, float x, float y, int comp = 0) 
#line 3264
{int volatile ___ = 1;(void)to;(void)x;(void)y;(void)comp;
#line 3268
::exit(___);}
#if 0
#line 3264
{ 
#line 3265
T ret; 
#line 3266
tex2Dgather(&ret, to, x, y, comp); 
#line 3267
return ret; 
#line 3268
} 
#endif
#line 3276 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(char *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3277
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 3277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 3282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 3283
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
#line 3285 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 3286
} 
#endif
#line 3287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3288
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3292
::exit(___);}
#if 0
#line 3288
{ 
#line 3289
int4 tmp; 
#line 3290
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = ((signed char)(tmp.x)); 
#line 3292
} 
#endif
#line 3294 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3295
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3299
::exit(___);}
#if 0
#line 3295
{ 
#line 3296
int4 tmp; 
#line 3297
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_char1(tmp.x); 
#line 3299
} 
#endif
#line 3301 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3302
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3306
::exit(___);}
#if 0
#line 3302
{ 
#line 3303
int4 tmp; 
#line 3304
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 3306
} 
#endif
#line 3308 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3309
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3313
::exit(___);}
#if 0
#line 3309
{ 
#line 3310
int4 tmp; 
#line 3311
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3313
} 
#endif
#line 3315 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3316
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3320
::exit(___);}
#if 0
#line 3316
{ 
#line 3317
uint4 tmp; 
#line 3318
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 3320
} 
#endif
#line 3322 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3323
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3327
::exit(___);}
#if 0
#line 3323
{ 
#line 3324
uint4 tmp; 
#line 3325
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_uchar1(tmp.x); 
#line 3327
} 
#endif
#line 3329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3330
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3334
::exit(___);}
#if 0
#line 3330
{ 
#line 3331
uint4 tmp; 
#line 3332
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 3334
} 
#endif
#line 3336 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3337
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3341
::exit(___);}
#if 0
#line 3337
{ 
#line 3338
uint4 tmp; 
#line 3339
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3341
} 
#endif
#line 3349 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(short *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3350
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3354
::exit(___);}
#if 0
#line 3350
{ 
#line 3351
int4 tmp; 
#line 3352
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = ((short)(tmp.x)); 
#line 3354
} 
#endif
#line 3356 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3357
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3361
::exit(___);}
#if 0
#line 3357
{ 
#line 3358
int4 tmp; 
#line 3359
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_short1(tmp.x); 
#line 3361
} 
#endif
#line 3363 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3364
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3368
::exit(___);}
#if 0
#line 3364
{ 
#line 3365
int4 tmp; 
#line 3366
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 3368
} 
#endif
#line 3370 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3371
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3375
::exit(___);}
#if 0
#line 3371
{ 
#line 3372
int4 tmp; 
#line 3373
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3375
} 
#endif
#line 3377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3378
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3382
::exit(___);}
#if 0
#line 3378
{ 
#line 3379
uint4 tmp; 
#line 3380
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 3382
} 
#endif
#line 3384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3385
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3389
::exit(___);}
#if 0
#line 3385
{ 
#line 3386
uint4 tmp; 
#line 3387
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_ushort1(tmp.x); 
#line 3389
} 
#endif
#line 3391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3392
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3396
::exit(___);}
#if 0
#line 3392
{ 
#line 3393
uint4 tmp; 
#line 3394
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 3396
} 
#endif
#line 3398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3399
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3403
::exit(___);}
#if 0
#line 3399
{ 
#line 3400
uint4 tmp; 
#line 3401
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3403
} 
#endif
#line 3411 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(int *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3412
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3416
::exit(___);}
#if 0
#line 3412
{ 
#line 3413
int4 tmp; 
#line 3414
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = (tmp.x); 
#line 3416
} 
#endif
#line 3418 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3419
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3423
::exit(___);}
#if 0
#line 3419
{ 
#line 3420
int4 tmp; 
#line 3421
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_int1(tmp.x); 
#line 3423
} 
#endif
#line 3425 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3426
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3430
::exit(___);}
#if 0
#line 3426
{ 
#line 3427
int4 tmp; 
#line 3428
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 3430
} 
#endif
#line 3432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3433
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3437
::exit(___);}
#if 0
#line 3433
{ 
#line 3434
int4 tmp; 
#line 3435
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3437
} 
#endif
#line 3439 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3440
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3444
::exit(___);}
#if 0
#line 3440
{ 
#line 3441
uint4 tmp; 
#line 3442
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = (tmp.x); 
#line 3444
} 
#endif
#line 3446 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3447
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3451
::exit(___);}
#if 0
#line 3447
{ 
#line 3448
uint4 tmp; 
#line 3449
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_uint1(tmp.x); 
#line 3451
} 
#endif
#line 3453 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3458
::exit(___);}
#if 0
#line 3454
{ 
#line 3455
uint4 tmp; 
#line 3456
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 3458
} 
#endif
#line 3460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3465
::exit(___);}
#if 0
#line 3461
{ 
#line 3462
uint4 tmp; 
#line 3463
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3465
} 
#endif
#line 3475 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(long *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3476
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3480
::exit(___);}
#if 0
#line 3476
{ 
#line 3477
int4 tmp; 
#line 3478
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = ((long)(tmp.x)); 
#line 3480
} 
#endif
#line 3482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3483
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3487
::exit(___);}
#if 0
#line 3483
{ 
#line 3484
int4 tmp; 
#line 3485
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_long1(tmp.x); 
#line 3487
} 
#endif
#line 3489 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3490
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3494
::exit(___);}
#if 0
#line 3490
{ 
#line 3491
int4 tmp; 
#line 3492
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 3494
} 
#endif
#line 3496 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3497
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3501
::exit(___);}
#if 0
#line 3497
{ 
#line 3498
int4 tmp; 
#line 3499
__asm tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3501
} 
#endif
#line 3503 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3504
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3508
::exit(___);}
#if 0
#line 3504
{ 
#line 3505
uint4 tmp; 
#line 3506
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 3508
} 
#endif
#line 3510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3511
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3515
::exit(___);}
#if 0
#line 3511
{ 
#line 3512
uint4 tmp; 
#line 3513
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_ulong1(tmp.x); 
#line 3515
} 
#endif
#line 3517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3518
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3522
::exit(___);}
#if 0
#line 3518
{ 
#line 3519
uint4 tmp; 
#line 3520
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 3522
} 
#endif
#line 3524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3525
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3529
::exit(___);}
#if 0
#line 3525
{ 
#line 3526
uint4 tmp; 
#line 3527
__asm tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3529
} 
#endif
#line 3540 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(float *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3541
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3545
::exit(___);}
#if 0
#line 3541
{ 
#line 3542
float4 tmp; 
#line 3543
__asm tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = (tmp.x); 
#line 3545
} 
#endif
#line 3547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3548
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3552
::exit(___);}
#if 0
#line 3548
{ 
#line 3549
float4 tmp; 
#line 3550
__asm tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_float1(tmp.x); 
#line 3552
} 
#endif
#line 3554 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3555
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3559
::exit(___);}
#if 0
#line 3555
{ 
#line 3556
float4 tmp; 
#line 3557
__asm tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 3559
} 
#endif
#line 3561 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3562
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3566
::exit(___);}
#if 0
#line 3562
{ 
#line 3563
float4 tmp; 
#line 3564
__asm tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3566
} 
#endif
#line 3574 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 3575
tex1DLod(::cudaTextureObject_t texObject, float x, float level) 
#line 3576
{int volatile ___ = 1;(void)texObject;(void)x;(void)level;
#line 3580
::exit(___);}
#if 0
#line 3576
{ 
#line 3577
T ret; 
#line 3578
tex1DLod(&ret, texObject, x, level); 
#line 3579
return ret; 
#line 3580
} 
#endif
#line 3588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3589
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3598 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 3589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 3594 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 3595
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
#line 3597 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 3598
} 
#endif
#line 3599 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3600
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3604
::exit(___);}
#if 0
#line 3600
{ 
#line 3601
int4 tmp; 
#line 3602
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((signed char)(tmp.x)); 
#line 3604
} 
#endif
#line 3606 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3607
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3611
::exit(___);}
#if 0
#line 3607
{ 
#line 3608
int4 tmp; 
#line 3609
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_char1(tmp.x); 
#line 3611
} 
#endif
#line 3613 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3614
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3618
::exit(___);}
#if 0
#line 3614
{ 
#line 3615
int4 tmp; 
#line 3616
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 3618
} 
#endif
#line 3620 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3621
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3625
::exit(___);}
#if 0
#line 3621
{ 
#line 3622
int4 tmp; 
#line 3623
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3625
} 
#endif
#line 3627 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3628
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3632
::exit(___);}
#if 0
#line 3628
{ 
#line 3629
uint4 tmp; 
#line 3630
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 3632
} 
#endif
#line 3634 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3635
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3639
::exit(___);}
#if 0
#line 3635
{ 
#line 3636
uint4 tmp; 
#line 3637
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uchar1(tmp.x); 
#line 3639
} 
#endif
#line 3641 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3642
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3646
::exit(___);}
#if 0
#line 3642
{ 
#line 3643
uint4 tmp; 
#line 3644
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 3646
} 
#endif
#line 3648 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3649
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3653
::exit(___);}
#if 0
#line 3649
{ 
#line 3650
uint4 tmp; 
#line 3651
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3653
} 
#endif
#line 3661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3662
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3666
::exit(___);}
#if 0
#line 3662
{ 
#line 3663
int4 tmp; 
#line 3664
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((short)(tmp.x)); 
#line 3666
} 
#endif
#line 3668 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3669
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3673
::exit(___);}
#if 0
#line 3669
{ 
#line 3670
int4 tmp; 
#line 3671
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_short1(tmp.x); 
#line 3673
} 
#endif
#line 3675 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3676
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3680
::exit(___);}
#if 0
#line 3676
{ 
#line 3677
int4 tmp; 
#line 3678
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 3680
} 
#endif
#line 3682 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3683
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3687
::exit(___);}
#if 0
#line 3683
{ 
#line 3684
int4 tmp; 
#line 3685
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3687
} 
#endif
#line 3689 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3690
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3694
::exit(___);}
#if 0
#line 3690
{ 
#line 3691
uint4 tmp; 
#line 3692
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 3694
} 
#endif
#line 3696 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3697
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3701
::exit(___);}
#if 0
#line 3697
{ 
#line 3698
uint4 tmp; 
#line 3699
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ushort1(tmp.x); 
#line 3701
} 
#endif
#line 3703 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3704
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3708
::exit(___);}
#if 0
#line 3704
{ 
#line 3705
uint4 tmp; 
#line 3706
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 3708
} 
#endif
#line 3710 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3711
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3715
::exit(___);}
#if 0
#line 3711
{ 
#line 3712
uint4 tmp; 
#line 3713
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3715
} 
#endif
#line 3723 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3724
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3728
::exit(___);}
#if 0
#line 3724
{ 
#line 3725
int4 tmp; 
#line 3726
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = (tmp.x); 
#line 3728
} 
#endif
#line 3730 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3731
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3735
::exit(___);}
#if 0
#line 3731
{ 
#line 3732
int4 tmp; 
#line 3733
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_int1(tmp.x); 
#line 3735
} 
#endif
#line 3737 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3738
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3742
::exit(___);}
#if 0
#line 3738
{ 
#line 3739
int4 tmp; 
#line 3740
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 3742
} 
#endif
#line 3744 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3745
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3749
::exit(___);}
#if 0
#line 3745
{ 
#line 3746
int4 tmp; 
#line 3747
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3749
} 
#endif
#line 3751 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3752
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3756
::exit(___);}
#if 0
#line 3752
{ 
#line 3753
uint4 tmp; 
#line 3754
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = (tmp.x); 
#line 3756
} 
#endif
#line 3758 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3759
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3763
::exit(___);}
#if 0
#line 3759
{ 
#line 3760
uint4 tmp; 
#line 3761
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uint1(tmp.x); 
#line 3763
} 
#endif
#line 3765 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3766
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3770
::exit(___);}
#if 0
#line 3766
{ 
#line 3767
uint4 tmp; 
#line 3768
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 3770
} 
#endif
#line 3772 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3773
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3777
::exit(___);}
#if 0
#line 3773
{ 
#line 3774
uint4 tmp; 
#line 3775
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3777
} 
#endif
#line 3787 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3788
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3792
::exit(___);}
#if 0
#line 3788
{ 
#line 3789
int4 tmp; 
#line 3790
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((long)(tmp.x)); 
#line 3792
} 
#endif
#line 3794 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3795
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3799
::exit(___);}
#if 0
#line 3795
{ 
#line 3796
int4 tmp; 
#line 3797
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_long1(tmp.x); 
#line 3799
} 
#endif
#line 3801 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3802
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3806
::exit(___);}
#if 0
#line 3802
{ 
#line 3803
int4 tmp; 
#line 3804
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 3806
} 
#endif
#line 3808 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3809
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3813
::exit(___);}
#if 0
#line 3809
{ 
#line 3810
int4 tmp; 
#line 3811
__asm tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3813
} 
#endif
#line 3815 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3816
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3820
::exit(___);}
#if 0
#line 3816
{ 
#line 3817
uint4 tmp; 
#line 3818
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 3820
} 
#endif
#line 3822 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3823
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3827
::exit(___);}
#if 0
#line 3823
{ 
#line 3824
uint4 tmp; 
#line 3825
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ulong1(tmp.x); 
#line 3827
} 
#endif
#line 3829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3830
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3834
::exit(___);}
#if 0
#line 3830
{ 
#line 3831
uint4 tmp; 
#line 3832
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 3834
} 
#endif
#line 3836 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3837
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3841
::exit(___);}
#if 0
#line 3837
{ 
#line 3838
uint4 tmp; 
#line 3839
__asm tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3841
} 
#endif
#line 3852 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3853
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3857
::exit(___);}
#if 0
#line 3853
{ 
#line 3854
float4 tmp; 
#line 3855
__asm tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = (tmp.x); 
#line 3857
} 
#endif
#line 3859 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3860
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3864
::exit(___);}
#if 0
#line 3860
{ 
#line 3861
float4 tmp; 
#line 3862
__asm tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_float1(tmp.x); 
#line 3864
} 
#endif
#line 3866 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3867
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3871
::exit(___);}
#if 0
#line 3867
{ 
#line 3868
float4 tmp; 
#line 3869
__asm tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 3871
} 
#endif
#line 3873 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3874
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3878
::exit(___);}
#if 0
#line 3874
{ 
#line 3875
float4 tmp; 
#line 3876
__asm tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3878
} 
#endif
#line 3886 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 3887
tex2DLod(::cudaTextureObject_t texObject, float x, float y, float level) 
#line 3888
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;
#line 3892
::exit(___);}
#if 0
#line 3888
{ 
#line 3889
T ret; 
#line 3890
tex2DLod(&ret, texObject, x, y, level); 
#line 3891
return ret; 
#line 3892
} 
#endif
#line 3900 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3901
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3910 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 3901 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 3906 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 3907
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
#line 3909 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 3910
} 
#endif
#line 3911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3912
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3916
::exit(___);}
#if 0
#line 3912
{ 
#line 3913
int4 tmp; 
#line 3914
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((signed char)(tmp.x)); 
#line 3916
} 
#endif
#line 3918 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3919
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3923
::exit(___);}
#if 0
#line 3919
{ 
#line 3920
int4 tmp; 
#line 3921
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char1(tmp.x); 
#line 3923
} 
#endif
#line 3925 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3926
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3930
::exit(___);}
#if 0
#line 3926
{ 
#line 3927
int4 tmp; 
#line 3928
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 3930
} 
#endif
#line 3932 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3933
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3937
::exit(___);}
#if 0
#line 3933
{ 
#line 3934
int4 tmp; 
#line 3935
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3937
} 
#endif
#line 3939 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3940
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3944
::exit(___);}
#if 0
#line 3940
{ 
#line 3941
uint4 tmp; 
#line 3942
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 3944
} 
#endif
#line 3946 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3947
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3951
::exit(___);}
#if 0
#line 3947
{ 
#line 3948
uint4 tmp; 
#line 3949
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar1(tmp.x); 
#line 3951
} 
#endif
#line 3953 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3954
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3958
::exit(___);}
#if 0
#line 3954
{ 
#line 3955
uint4 tmp; 
#line 3956
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 3958
} 
#endif
#line 3960 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3961
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3965
::exit(___);}
#if 0
#line 3961
{ 
#line 3962
uint4 tmp; 
#line 3963
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3965
} 
#endif
#line 3973 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3974
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3978
::exit(___);}
#if 0
#line 3974
{ 
#line 3975
int4 tmp; 
#line 3976
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((short)(tmp.x)); 
#line 3978
} 
#endif
#line 3980 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3981
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3985
::exit(___);}
#if 0
#line 3981
{ 
#line 3982
int4 tmp; 
#line 3983
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short1(tmp.x); 
#line 3985
} 
#endif
#line 3987 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3988
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3992
::exit(___);}
#if 0
#line 3988
{ 
#line 3989
int4 tmp; 
#line 3990
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 3992
} 
#endif
#line 3994 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3995
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3999
::exit(___);}
#if 0
#line 3995
{ 
#line 3996
int4 tmp; 
#line 3997
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3999
} 
#endif
#line 4001 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4002
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4006
::exit(___);}
#if 0
#line 4002
{ 
#line 4003
uint4 tmp; 
#line 4004
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 4006
} 
#endif
#line 4008 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4009
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4013
::exit(___);}
#if 0
#line 4009
{ 
#line 4010
uint4 tmp; 
#line 4011
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort1(tmp.x); 
#line 4013
} 
#endif
#line 4015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4016
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4020
::exit(___);}
#if 0
#line 4016
{ 
#line 4017
uint4 tmp; 
#line 4018
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 4020
} 
#endif
#line 4022 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4023
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4027
::exit(___);}
#if 0
#line 4023
{ 
#line 4024
uint4 tmp; 
#line 4025
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4027
} 
#endif
#line 4035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4036
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4040
::exit(___);}
#if 0
#line 4036
{ 
#line 4037
int4 tmp; 
#line 4038
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4040
} 
#endif
#line 4042 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4043
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4047
::exit(___);}
#if 0
#line 4043
{ 
#line 4044
int4 tmp; 
#line 4045
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int1(tmp.x); 
#line 4047
} 
#endif
#line 4049 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4050
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4054
::exit(___);}
#if 0
#line 4050
{ 
#line 4051
int4 tmp; 
#line 4052
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 4054
} 
#endif
#line 4056 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4057
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4061
::exit(___);}
#if 0
#line 4057
{ 
#line 4058
int4 tmp; 
#line 4059
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4061
} 
#endif
#line 4063 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4064
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4068
::exit(___);}
#if 0
#line 4064
{ 
#line 4065
uint4 tmp; 
#line 4066
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4068
} 
#endif
#line 4070 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4071
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4075
::exit(___);}
#if 0
#line 4071
{ 
#line 4072
uint4 tmp; 
#line 4073
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint1(tmp.x); 
#line 4075
} 
#endif
#line 4077 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4078
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4082
::exit(___);}
#if 0
#line 4078
{ 
#line 4079
uint4 tmp; 
#line 4080
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 4082
} 
#endif
#line 4084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4085
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4089
::exit(___);}
#if 0
#line 4085
{ 
#line 4086
uint4 tmp; 
#line 4087
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4089
} 
#endif
#line 4099 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4100
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4104
::exit(___);}
#if 0
#line 4100
{ 
#line 4101
int4 tmp; 
#line 4102
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((long)(tmp.x)); 
#line 4104
} 
#endif
#line 4106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4107
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4111
::exit(___);}
#if 0
#line 4107
{ 
#line 4108
int4 tmp; 
#line 4109
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long1(tmp.x); 
#line 4111
} 
#endif
#line 4113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4114
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4118
::exit(___);}
#if 0
#line 4114
{ 
#line 4115
int4 tmp; 
#line 4116
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 4118
} 
#endif
#line 4120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4121
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4125
::exit(___);}
#if 0
#line 4121
{ 
#line 4122
int4 tmp; 
#line 4123
__asm tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4125
} 
#endif
#line 4127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4128
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4132
::exit(___);}
#if 0
#line 4128
{ 
#line 4129
uint4 tmp; 
#line 4130
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 4132
} 
#endif
#line 4134 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4135
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4139
::exit(___);}
#if 0
#line 4135
{ 
#line 4136
uint4 tmp; 
#line 4137
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong1(tmp.x); 
#line 4139
} 
#endif
#line 4141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4142
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4146
::exit(___);}
#if 0
#line 4142
{ 
#line 4143
uint4 tmp; 
#line 4144
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 4146
} 
#endif
#line 4148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4153
::exit(___);}
#if 0
#line 4149
{ 
#line 4150
uint4 tmp; 
#line 4151
__asm tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4153
} 
#endif
#line 4164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4165
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4169
::exit(___);}
#if 0
#line 4165
{ 
#line 4166
float4 tmp; 
#line 4167
__asm tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4169
} 
#endif
#line 4171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4172
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4176
::exit(___);}
#if 0
#line 4172
{ 
#line 4173
float4 tmp; 
#line 4174
__asm tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float1(tmp.x); 
#line 4176
} 
#endif
#line 4178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4179
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4183
::exit(___);}
#if 0
#line 4179
{ 
#line 4180
float4 tmp; 
#line 4181
__asm tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 4183
} 
#endif
#line 4185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4186
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4190
::exit(___);}
#if 0
#line 4186
{ 
#line 4187
float4 tmp; 
#line 4188
__asm tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4190
} 
#endif
#line 4198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 4199
tex3DLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4200
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4204
::exit(___);}
#if 0
#line 4200
{ 
#line 4201
T ret; 
#line 4202
tex3DLod(&ret, texObject, x, y, z, level); 
#line 4203
return ret; 
#line 4204
} 
#endif
#line 4212 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4213
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4222 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 4213 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 4218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 4219
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
#line 4221 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 4222
} 
#endif
#line 4223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4224
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4228
::exit(___);}
#if 0
#line 4224
{ 
#line 4225
int4 tmp; 
#line 4226
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((signed char)(tmp.x)); 
#line 4228
} 
#endif
#line 4230 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4231
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4235
::exit(___);}
#if 0
#line 4231
{ 
#line 4232
int4 tmp; 
#line 4233
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_char1(tmp.x); 
#line 4235
} 
#endif
#line 4237 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4238
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4242
::exit(___);}
#if 0
#line 4238
{ 
#line 4239
int4 tmp; 
#line 4240
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 4242
} 
#endif
#line 4244 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4245
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4249
::exit(___);}
#if 0
#line 4245
{ 
#line 4246
int4 tmp; 
#line 4247
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4249
} 
#endif
#line 4251 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4252
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4256
::exit(___);}
#if 0
#line 4252
{ 
#line 4253
uint4 tmp; 
#line 4254
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 4256
} 
#endif
#line 4258 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4259
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4263
::exit(___);}
#if 0
#line 4259
{ 
#line 4260
uint4 tmp; 
#line 4261
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uchar1(tmp.x); 
#line 4263
} 
#endif
#line 4265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4266
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4270
::exit(___);}
#if 0
#line 4266
{ 
#line 4267
uint4 tmp; 
#line 4268
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 4270
} 
#endif
#line 4272 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4273
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4277
::exit(___);}
#if 0
#line 4273
{ 
#line 4274
uint4 tmp; 
#line 4275
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4277
} 
#endif
#line 4285 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4286
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4290
::exit(___);}
#if 0
#line 4286
{ 
#line 4287
int4 tmp; 
#line 4288
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((short)(tmp.x)); 
#line 4290
} 
#endif
#line 4292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4293
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4297
::exit(___);}
#if 0
#line 4293
{ 
#line 4294
int4 tmp; 
#line 4295
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_short1(tmp.x); 
#line 4297
} 
#endif
#line 4299 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4300
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4304
::exit(___);}
#if 0
#line 4300
{ 
#line 4301
int4 tmp; 
#line 4302
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 4304
} 
#endif
#line 4306 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4307
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4311
::exit(___);}
#if 0
#line 4307
{ 
#line 4308
int4 tmp; 
#line 4309
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4311
} 
#endif
#line 4313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4314
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4318
::exit(___);}
#if 0
#line 4314
{ 
#line 4315
uint4 tmp; 
#line 4316
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 4318
} 
#endif
#line 4320 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4321
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4325
::exit(___);}
#if 0
#line 4321
{ 
#line 4322
uint4 tmp; 
#line 4323
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ushort1(tmp.x); 
#line 4325
} 
#endif
#line 4327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4328
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4332
::exit(___);}
#if 0
#line 4328
{ 
#line 4329
uint4 tmp; 
#line 4330
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 4332
} 
#endif
#line 4334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4335
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4339
::exit(___);}
#if 0
#line 4335
{ 
#line 4336
uint4 tmp; 
#line 4337
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4339
} 
#endif
#line 4347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4348
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4352
::exit(___);}
#if 0
#line 4348
{ 
#line 4349
int4 tmp; 
#line 4350
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = (tmp.x); 
#line 4352
} 
#endif
#line 4354 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4355
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4359
::exit(___);}
#if 0
#line 4355
{ 
#line 4356
int4 tmp; 
#line 4357
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_int1(tmp.x); 
#line 4359
} 
#endif
#line 4361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4362
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4366
::exit(___);}
#if 0
#line 4362
{ 
#line 4363
int4 tmp; 
#line 4364
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 4366
} 
#endif
#line 4368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4369
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4373
::exit(___);}
#if 0
#line 4369
{ 
#line 4370
int4 tmp; 
#line 4371
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4373
} 
#endif
#line 4375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4376
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4380
::exit(___);}
#if 0
#line 4376
{ 
#line 4377
uint4 tmp; 
#line 4378
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = (tmp.x); 
#line 4380
} 
#endif
#line 4382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4383
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4387
::exit(___);}
#if 0
#line 4383
{ 
#line 4384
uint4 tmp; 
#line 4385
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uint1(tmp.x); 
#line 4387
} 
#endif
#line 4389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4390
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4394
::exit(___);}
#if 0
#line 4390
{ 
#line 4391
uint4 tmp; 
#line 4392
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 4394
} 
#endif
#line 4396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4397
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4401
::exit(___);}
#if 0
#line 4397
{ 
#line 4398
uint4 tmp; 
#line 4399
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4401
} 
#endif
#line 4411 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4412
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4416
::exit(___);}
#if 0
#line 4412
{ 
#line 4413
int4 tmp; 
#line 4414
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((long)(tmp.x)); 
#line 4416
} 
#endif
#line 4418 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4419
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4423
::exit(___);}
#if 0
#line 4419
{ 
#line 4420
int4 tmp; 
#line 4421
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_long1(tmp.x); 
#line 4423
} 
#endif
#line 4425 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4426
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4430
::exit(___);}
#if 0
#line 4426
{ 
#line 4427
int4 tmp; 
#line 4428
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 4430
} 
#endif
#line 4432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4433
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4437
::exit(___);}
#if 0
#line 4433
{ 
#line 4434
int4 tmp; 
#line 4435
__asm tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4437
} 
#endif
#line 4439 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4440
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4444
::exit(___);}
#if 0
#line 4440
{ 
#line 4441
uint4 tmp; 
#line 4442
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 4444
} 
#endif
#line 4446 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4447
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4451
::exit(___);}
#if 0
#line 4447
{ 
#line 4448
uint4 tmp; 
#line 4449
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ulong1(tmp.x); 
#line 4451
} 
#endif
#line 4453 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4458
::exit(___);}
#if 0
#line 4454
{ 
#line 4455
uint4 tmp; 
#line 4456
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 4458
} 
#endif
#line 4460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4465
::exit(___);}
#if 0
#line 4461
{ 
#line 4462
uint4 tmp; 
#line 4463
__asm tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4465
} 
#endif
#line 4476 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4477
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4481
::exit(___);}
#if 0
#line 4477
{ 
#line 4478
float4 tmp; 
#line 4479
__asm tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = (tmp.x); 
#line 4481
} 
#endif
#line 4483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4484
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4488
::exit(___);}
#if 0
#line 4484
{ 
#line 4485
float4 tmp; 
#line 4486
__asm tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_float1(tmp.x); 
#line 4488
} 
#endif
#line 4490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4491
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4495
::exit(___);}
#if 0
#line 4491
{ 
#line 4492
float4 tmp; 
#line 4493
__asm tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 4495
} 
#endif
#line 4497 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4498
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4502
::exit(___);}
#if 0
#line 4498
{ 
#line 4499
float4 tmp; 
#line 4500
__asm tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4502
} 
#endif
#line 4510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 4511
tex1DLayeredLod(::cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4512
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)level;
#line 4516
::exit(___);}
#if 0
#line 4512
{ 
#line 4513
T ret; 
#line 4514
tex1DLayeredLod(&ret, texObject, x, layer, level); 
#line 4515
return ret; 
#line 4516
} 
#endif
#line 4524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4525
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4534 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 4525 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 4530 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 4531
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
#line 4533 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 4534
} 
#endif
#line 4535 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4536
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4540
::exit(___);}
#if 0
#line 4536
{ 
#line 4537
int4 tmp; 
#line 4538
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((signed char)(tmp.x)); 
#line 4540
} 
#endif
#line 4542 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4543
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4547
::exit(___);}
#if 0
#line 4543
{ 
#line 4544
int4 tmp; 
#line 4545
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char1(tmp.x); 
#line 4547
} 
#endif
#line 4549 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4550
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4554
::exit(___);}
#if 0
#line 4550
{ 
#line 4551
int4 tmp; 
#line 4552
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 4554
} 
#endif
#line 4556 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4557
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4561
::exit(___);}
#if 0
#line 4557
{ 
#line 4558
int4 tmp; 
#line 4559
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4561
} 
#endif
#line 4563 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4564
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4568
::exit(___);}
#if 0
#line 4564
{ 
#line 4565
uint4 tmp; 
#line 4566
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 4568
} 
#endif
#line 4570 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4571
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4575
::exit(___);}
#if 0
#line 4571
{ 
#line 4572
uint4 tmp; 
#line 4573
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar1(tmp.x); 
#line 4575
} 
#endif
#line 4577 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4578
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4582
::exit(___);}
#if 0
#line 4578
{ 
#line 4579
uint4 tmp; 
#line 4580
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 4582
} 
#endif
#line 4584 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4585
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4589
::exit(___);}
#if 0
#line 4585
{ 
#line 4586
uint4 tmp; 
#line 4587
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4589
} 
#endif
#line 4597 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4598
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4602
::exit(___);}
#if 0
#line 4598
{ 
#line 4599
int4 tmp; 
#line 4600
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((short)(tmp.x)); 
#line 4602
} 
#endif
#line 4604 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4605
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4609
::exit(___);}
#if 0
#line 4605
{ 
#line 4606
int4 tmp; 
#line 4607
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short1(tmp.x); 
#line 4609
} 
#endif
#line 4611 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4612
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4616
::exit(___);}
#if 0
#line 4612
{ 
#line 4613
int4 tmp; 
#line 4614
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 4616
} 
#endif
#line 4618 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4619
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4623
::exit(___);}
#if 0
#line 4619
{ 
#line 4620
int4 tmp; 
#line 4621
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4623
} 
#endif
#line 4625 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4626
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4630
::exit(___);}
#if 0
#line 4626
{ 
#line 4627
uint4 tmp; 
#line 4628
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 4630
} 
#endif
#line 4632 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4633
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4637
::exit(___);}
#if 0
#line 4633
{ 
#line 4634
uint4 tmp; 
#line 4635
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort1(tmp.x); 
#line 4637
} 
#endif
#line 4639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4640
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4644
::exit(___);}
#if 0
#line 4640
{ 
#line 4641
uint4 tmp; 
#line 4642
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 4644
} 
#endif
#line 4646 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4647
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4651
::exit(___);}
#if 0
#line 4647
{ 
#line 4648
uint4 tmp; 
#line 4649
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4651
} 
#endif
#line 4659 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4660
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4664
::exit(___);}
#if 0
#line 4660
{ 
#line 4661
int4 tmp; 
#line 4662
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4664
} 
#endif
#line 4666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4667
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4671
::exit(___);}
#if 0
#line 4667
{ 
#line 4668
int4 tmp; 
#line 4669
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int1(tmp.x); 
#line 4671
} 
#endif
#line 4673 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4674
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4678
::exit(___);}
#if 0
#line 4674
{ 
#line 4675
int4 tmp; 
#line 4676
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 4678
} 
#endif
#line 4680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4681
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4685
::exit(___);}
#if 0
#line 4681
{ 
#line 4682
int4 tmp; 
#line 4683
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4685
} 
#endif
#line 4687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4688
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4692
::exit(___);}
#if 0
#line 4688
{ 
#line 4689
uint4 tmp; 
#line 4690
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4692
} 
#endif
#line 4694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4695
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4699
::exit(___);}
#if 0
#line 4695
{ 
#line 4696
uint4 tmp; 
#line 4697
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint1(tmp.x); 
#line 4699
} 
#endif
#line 4701 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4702
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4706
::exit(___);}
#if 0
#line 4702
{ 
#line 4703
uint4 tmp; 
#line 4704
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 4706
} 
#endif
#line 4708 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4709
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4713
::exit(___);}
#if 0
#line 4709
{ 
#line 4710
uint4 tmp; 
#line 4711
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4713
} 
#endif
#line 4723 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4724
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4728
::exit(___);}
#if 0
#line 4724
{ 
#line 4725
int4 tmp; 
#line 4726
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((long)(tmp.x)); 
#line 4728
} 
#endif
#line 4730 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4731
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4735
::exit(___);}
#if 0
#line 4731
{ 
#line 4732
int4 tmp; 
#line 4733
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long1(tmp.x); 
#line 4735
} 
#endif
#line 4737 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4738
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4742
::exit(___);}
#if 0
#line 4738
{ 
#line 4739
int4 tmp; 
#line 4740
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 4742
} 
#endif
#line 4744 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4745
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4749
::exit(___);}
#if 0
#line 4745
{ 
#line 4746
int4 tmp; 
#line 4747
__asm tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4749
} 
#endif
#line 4751 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4752
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4756
::exit(___);}
#if 0
#line 4752
{ 
#line 4753
uint4 tmp; 
#line 4754
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 4756
} 
#endif
#line 4758 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4759
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4763
::exit(___);}
#if 0
#line 4759
{ 
#line 4760
uint4 tmp; 
#line 4761
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong1(tmp.x); 
#line 4763
} 
#endif
#line 4765 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4766
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4770
::exit(___);}
#if 0
#line 4766
{ 
#line 4767
uint4 tmp; 
#line 4768
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 4770
} 
#endif
#line 4772 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4773
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4777
::exit(___);}
#if 0
#line 4773
{ 
#line 4774
uint4 tmp; 
#line 4775
__asm tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4777
} 
#endif
#line 4788 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4789
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4793
::exit(___);}
#if 0
#line 4789
{ 
#line 4790
float4 tmp; 
#line 4791
__asm tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4793
} 
#endif
#line 4795 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4796
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4800
::exit(___);}
#if 0
#line 4796
{ 
#line 4797
float4 tmp; 
#line 4798
__asm tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float1(tmp.x); 
#line 4800
} 
#endif
#line 4802 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4803
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4807
::exit(___);}
#if 0
#line 4803
{ 
#line 4804
float4 tmp; 
#line 4805
__asm tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 4807
} 
#endif
#line 4809 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4810
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4814
::exit(___);}
#if 0
#line 4810
{ 
#line 4811
float4 tmp; 
#line 4812
__asm tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4814
} 
#endif
#line 4822 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 4823
tex2DLayeredLod(::cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4824
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4828
::exit(___);}
#if 0
#line 4824
{ 
#line 4825
T ret; 
#line 4826
tex2DLayeredLod(&ret, texObject, x, y, layer, level); 
#line 4827
return ret; 
#line 4828
} 
#endif
#line 4836 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4837
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4846 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 4837 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 4842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 4843
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
#line 4845 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 4846
} 
#endif
#line 4847 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4848
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4852
::exit(___);}
#if 0
#line 4848
{ 
#line 4849
int4 tmp; 
#line 4850
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((signed char)(tmp.x)); 
#line 4852
} 
#endif
#line 4854 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4855
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4859
::exit(___);}
#if 0
#line 4855
{ 
#line 4856
int4 tmp; 
#line 4857
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char1(tmp.x); 
#line 4859
} 
#endif
#line 4861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4862
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4866
::exit(___);}
#if 0
#line 4862
{ 
#line 4863
int4 tmp; 
#line 4864
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 4866
} 
#endif
#line 4868 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4869
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4873
::exit(___);}
#if 0
#line 4869
{ 
#line 4870
int4 tmp; 
#line 4871
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4873
} 
#endif
#line 4875 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4876
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4880
::exit(___);}
#if 0
#line 4876
{ 
#line 4877
uint4 tmp; 
#line 4878
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 4880
} 
#endif
#line 4882 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4883
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4887
::exit(___);}
#if 0
#line 4883
{ 
#line 4884
uint4 tmp; 
#line 4885
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar1(tmp.x); 
#line 4887
} 
#endif
#line 4889 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4890
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4894
::exit(___);}
#if 0
#line 4890
{ 
#line 4891
uint4 tmp; 
#line 4892
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 4894
} 
#endif
#line 4896 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4897
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4901
::exit(___);}
#if 0
#line 4897
{ 
#line 4898
uint4 tmp; 
#line 4899
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4901
} 
#endif
#line 4909 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4910
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4914
::exit(___);}
#if 0
#line 4910
{ 
#line 4911
int4 tmp; 
#line 4912
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((short)(tmp.x)); 
#line 4914
} 
#endif
#line 4916 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4917
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4921
::exit(___);}
#if 0
#line 4917
{ 
#line 4918
int4 tmp; 
#line 4919
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short1(tmp.x); 
#line 4921
} 
#endif
#line 4923 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4924
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4928
::exit(___);}
#if 0
#line 4924
{ 
#line 4925
int4 tmp; 
#line 4926
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 4928
} 
#endif
#line 4930 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4931
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4935
::exit(___);}
#if 0
#line 4931
{ 
#line 4932
int4 tmp; 
#line 4933
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4935
} 
#endif
#line 4937 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4938
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4942
::exit(___);}
#if 0
#line 4938
{ 
#line 4939
uint4 tmp; 
#line 4940
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 4942
} 
#endif
#line 4944 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4945
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4949
::exit(___);}
#if 0
#line 4945
{ 
#line 4946
uint4 tmp; 
#line 4947
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort1(tmp.x); 
#line 4949
} 
#endif
#line 4951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4952
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4956
::exit(___);}
#if 0
#line 4952
{ 
#line 4953
uint4 tmp; 
#line 4954
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 4956
} 
#endif
#line 4958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4959
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4963
::exit(___);}
#if 0
#line 4959
{ 
#line 4960
uint4 tmp; 
#line 4961
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4963
} 
#endif
#line 4971 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4972
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4976
::exit(___);}
#if 0
#line 4972
{ 
#line 4973
int4 tmp; 
#line 4974
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 4976
} 
#endif
#line 4978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4979
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4983
::exit(___);}
#if 0
#line 4979
{ 
#line 4980
int4 tmp; 
#line 4981
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int1(tmp.x); 
#line 4983
} 
#endif
#line 4985 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4986
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4990
::exit(___);}
#if 0
#line 4986
{ 
#line 4987
int4 tmp; 
#line 4988
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 4990
} 
#endif
#line 4992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4993
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4997
::exit(___);}
#if 0
#line 4993
{ 
#line 4994
int4 tmp; 
#line 4995
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4997
} 
#endif
#line 4999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5000
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5004
::exit(___);}
#if 0
#line 5000
{ 
#line 5001
uint4 tmp; 
#line 5002
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 5004
} 
#endif
#line 5006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5007
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5011
::exit(___);}
#if 0
#line 5007
{ 
#line 5008
uint4 tmp; 
#line 5009
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint1(tmp.x); 
#line 5011
} 
#endif
#line 5013 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5014
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5018
::exit(___);}
#if 0
#line 5014
{ 
#line 5015
uint4 tmp; 
#line 5016
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 5018
} 
#endif
#line 5020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5021
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5025
::exit(___);}
#if 0
#line 5021
{ 
#line 5022
uint4 tmp; 
#line 5023
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5025
} 
#endif
#line 5035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5036
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5040
::exit(___);}
#if 0
#line 5036
{ 
#line 5037
int4 tmp; 
#line 5038
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((long)(tmp.x)); 
#line 5040
} 
#endif
#line 5042 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5043
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5047
::exit(___);}
#if 0
#line 5043
{ 
#line 5044
int4 tmp; 
#line 5045
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long1(tmp.x); 
#line 5047
} 
#endif
#line 5049 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5050
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5054
::exit(___);}
#if 0
#line 5050
{ 
#line 5051
int4 tmp; 
#line 5052
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 5054
} 
#endif
#line 5056 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5057
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5061
::exit(___);}
#if 0
#line 5057
{ 
#line 5058
int4 tmp; 
#line 5059
__asm tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5061
} 
#endif
#line 5063 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5064
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5068
::exit(___);}
#if 0
#line 5064
{ 
#line 5065
uint4 tmp; 
#line 5066
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 5068
} 
#endif
#line 5070 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5071
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5075
::exit(___);}
#if 0
#line 5071
{ 
#line 5072
uint4 tmp; 
#line 5073
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong1(tmp.x); 
#line 5075
} 
#endif
#line 5077 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5078
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5082
::exit(___);}
#if 0
#line 5078
{ 
#line 5079
uint4 tmp; 
#line 5080
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 5082
} 
#endif
#line 5084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5085
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5089
::exit(___);}
#if 0
#line 5085
{ 
#line 5086
uint4 tmp; 
#line 5087
__asm tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5089
} 
#endif
#line 5100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5101
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5105
::exit(___);}
#if 0
#line 5101
{ 
#line 5102
float4 tmp; 
#line 5103
__asm tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = (tmp.x); 
#line 5105
} 
#endif
#line 5107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5108
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5112
::exit(___);}
#if 0
#line 5108
{ 
#line 5109
float4 tmp; 
#line 5110
__asm tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float1(tmp.x); 
#line 5112
} 
#endif
#line 5114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5115
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5119
::exit(___);}
#if 0
#line 5115
{ 
#line 5116
float4 tmp; 
#line 5117
__asm tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 5119
} 
#endif
#line 5121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5122
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5126
::exit(___);}
#if 0
#line 5122
{ 
#line 5123
float4 tmp; 
#line 5124
__asm tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5126
} 
#endif
#line 5134 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 5135
texCubemapLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 5136
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 5140
::exit(___);}
#if 0
#line 5136
{ 
#line 5137
T ret; 
#line 5138
texCubemapLod(&ret, texObject, x, y, z, level); 
#line 5139
return ret; 
#line 5140
} 
#endif
#line 5148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5158 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 5149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 5154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 5155
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
#line 5157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 5158
} 
#endif
#line 5159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5160
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5164
::exit(___);}
#if 0
#line 5160
{ 
#line 5161
int4 tmp; 
#line 5162
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = ((signed char)(tmp.x)); 
#line 5164
} 
#endif
#line 5166 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5167
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5171
::exit(___);}
#if 0
#line 5167
{ 
#line 5168
int4 tmp; 
#line 5169
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_char1(tmp.x); 
#line 5171
} 
#endif
#line 5173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5174
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5178
::exit(___);}
#if 0
#line 5174
{ 
#line 5175
int4 tmp; 
#line 5176
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 5178
} 
#endif
#line 5180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5181
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5185
::exit(___);}
#if 0
#line 5181
{ 
#line 5182
int4 tmp; 
#line 5183
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5185
} 
#endif
#line 5187 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5188
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5192
::exit(___);}
#if 0
#line 5188
{ 
#line 5189
uint4 tmp; 
#line 5190
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = ((unsigned char)(tmp.x)); 
#line 5192
} 
#endif
#line 5194 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5195
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5199
::exit(___);}
#if 0
#line 5195
{ 
#line 5196
uint4 tmp; 
#line 5197
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_uchar1(tmp.x); 
#line 5199
} 
#endif
#line 5201 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5202
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5206
::exit(___);}
#if 0
#line 5202
{ 
#line 5203
uint4 tmp; 
#line 5204
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 5206
} 
#endif
#line 5208 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5209
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5213
::exit(___);}
#if 0
#line 5209
{ 
#line 5210
uint4 tmp; 
#line 5211
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5213
} 
#endif
#line 5221 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5222
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5226
::exit(___);}
#if 0
#line 5222
{ 
#line 5223
int4 tmp; 
#line 5224
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = ((short)(tmp.x)); 
#line 5226
} 
#endif
#line 5228 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5229
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5233
::exit(___);}
#if 0
#line 5229
{ 
#line 5230
int4 tmp; 
#line 5231
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_short1(tmp.x); 
#line 5233
} 
#endif
#line 5235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5236
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5240
::exit(___);}
#if 0
#line 5236
{ 
#line 5237
int4 tmp; 
#line 5238
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 5240
} 
#endif
#line 5242 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5243
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5247
::exit(___);}
#if 0
#line 5243
{ 
#line 5244
int4 tmp; 
#line 5245
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5247
} 
#endif
#line 5249 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5250
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5254
::exit(___);}
#if 0
#line 5250
{ 
#line 5251
uint4 tmp; 
#line 5252
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = ((unsigned short)(tmp.x)); 
#line 5254
} 
#endif
#line 5256 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5257
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5261
::exit(___);}
#if 0
#line 5257
{ 
#line 5258
uint4 tmp; 
#line 5259
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_ushort1(tmp.x); 
#line 5261
} 
#endif
#line 5263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5264
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5268
::exit(___);}
#if 0
#line 5264
{ 
#line 5265
uint4 tmp; 
#line 5266
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 5268
} 
#endif
#line 5270 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5271
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5275
::exit(___);}
#if 0
#line 5271
{ 
#line 5272
uint4 tmp; 
#line 5273
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5275
} 
#endif
#line 5283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5284
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5288
::exit(___);}
#if 0
#line 5284
{ 
#line 5285
int4 tmp; 
#line 5286
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = (tmp.x); 
#line 5288
} 
#endif
#line 5290 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5291
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5295
::exit(___);}
#if 0
#line 5291
{ 
#line 5292
int4 tmp; 
#line 5293
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_int1(tmp.x); 
#line 5295
} 
#endif
#line 5297 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5298
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5302
::exit(___);}
#if 0
#line 5298
{ 
#line 5299
int4 tmp; 
#line 5300
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 5302
} 
#endif
#line 5304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5305
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5309
::exit(___);}
#if 0
#line 5305
{ 
#line 5306
int4 tmp; 
#line 5307
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5309
} 
#endif
#line 5311 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5312
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5316
::exit(___);}
#if 0
#line 5312
{ 
#line 5313
uint4 tmp; 
#line 5314
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = (tmp.x); 
#line 5316
} 
#endif
#line 5318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5319
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5323
::exit(___);}
#if 0
#line 5319
{ 
#line 5320
uint4 tmp; 
#line 5321
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_uint1(tmp.x); 
#line 5323
} 
#endif
#line 5325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5326
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5330
::exit(___);}
#if 0
#line 5326
{ 
#line 5327
uint4 tmp; 
#line 5328
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 5330
} 
#endif
#line 5332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5333
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5337
::exit(___);}
#if 0
#line 5333
{ 
#line 5334
uint4 tmp; 
#line 5335
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5337
} 
#endif
#line 5347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5348
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5352
::exit(___);}
#if 0
#line 5348
{ 
#line 5349
int4 tmp; 
#line 5350
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = ((long)(tmp.x)); 
#line 5352
} 
#endif
#line 5354 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5355
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5359
::exit(___);}
#if 0
#line 5355
{ 
#line 5356
int4 tmp; 
#line 5357
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_long1(tmp.x); 
#line 5359
} 
#endif
#line 5361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5362
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5366
::exit(___);}
#if 0
#line 5362
{ 
#line 5363
int4 tmp; 
#line 5364
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 5366
} 
#endif
#line 5368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5369
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5373
::exit(___);}
#if 0
#line 5369
{ 
#line 5370
int4 tmp; 
#line 5371
__asm tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5373
} 
#endif
#line 5375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5376
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5380
::exit(___);}
#if 0
#line 5376
{ 
#line 5377
uint4 tmp; 
#line 5378
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = ((unsigned long)(tmp.x)); 
#line 5380
} 
#endif
#line 5382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5383
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5387
::exit(___);}
#if 0
#line 5383
{ 
#line 5384
uint4 tmp; 
#line 5385
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_ulong1(tmp.x); 
#line 5387
} 
#endif
#line 5389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5390
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5394
::exit(___);}
#if 0
#line 5390
{ 
#line 5391
uint4 tmp; 
#line 5392
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 5394
} 
#endif
#line 5396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5397
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5401
::exit(___);}
#if 0
#line 5397
{ 
#line 5398
uint4 tmp; 
#line 5399
__asm tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5401
} 
#endif
#line 5412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5413
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5417
::exit(___);}
#if 0
#line 5413
{ 
#line 5414
float4 tmp; 
#line 5415
__asm tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = (tmp.x); 
#line 5417
} 
#endif
#line 5419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5420
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5424
::exit(___);}
#if 0
#line 5420
{ 
#line 5421
float4 tmp; 
#line 5422
__asm tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_float1(tmp.x); 
#line 5424
} 
#endif
#line 5426 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5427
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5431
::exit(___);}
#if 0
#line 5427
{ 
#line 5428
float4 tmp; 
#line 5429
__asm tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 5431
} 
#endif
#line 5433 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5434
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5438
::exit(___);}
#if 0
#line 5434
{ 
#line 5435
float4 tmp; 
#line 5436
__asm tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5438
} 
#endif
#line 5446 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 5447
texCubemapLayeredLod(::cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5448
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5452
::exit(___);}
#if 0
#line 5448
{ 
#line 5449
T ret; 
#line 5450
texCubemapLayeredLod(&ret, texObject, x, y, z, layer, level); 
#line 5451
return ret; 
#line 5452
} 
#endif
#line 5460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5470 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 5461 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 5466 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 5467
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
#line 5469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 5470
} 
#endif
#line 5471 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5472
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5476
::exit(___);}
#if 0
#line 5472
{ 
#line 5473
int4 tmp; 
#line 5474
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = ((signed char)(tmp.x)); 
#line 5476
} 
#endif
#line 5478 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5479
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5483
::exit(___);}
#if 0
#line 5479
{ 
#line 5480
int4 tmp; 
#line 5481
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_char1(tmp.x); 
#line 5483
} 
#endif
#line 5485 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5486
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5490
::exit(___);}
#if 0
#line 5486
{ 
#line 5487
int4 tmp; 
#line 5488
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 5490
} 
#endif
#line 5492 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5493
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5497
::exit(___);}
#if 0
#line 5493
{ 
#line 5494
int4 tmp; 
#line 5495
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5497
} 
#endif
#line 5499 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5500
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5504
::exit(___);}
#if 0
#line 5500
{ 
#line 5501
uint4 tmp; 
#line 5502
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = ((unsigned char)(tmp.x)); 
#line 5504
} 
#endif
#line 5506 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5507
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5511
::exit(___);}
#if 0
#line 5507
{ 
#line 5508
uint4 tmp; 
#line 5509
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_uchar1(tmp.x); 
#line 5511
} 
#endif
#line 5513 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5514
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5518
::exit(___);}
#if 0
#line 5514
{ 
#line 5515
uint4 tmp; 
#line 5516
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 5518
} 
#endif
#line 5520 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5521
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5525
::exit(___);}
#if 0
#line 5521
{ 
#line 5522
uint4 tmp; 
#line 5523
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5525
} 
#endif
#line 5533 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5534
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5538
::exit(___);}
#if 0
#line 5534
{ 
#line 5535
int4 tmp; 
#line 5536
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = ((short)(tmp.x)); 
#line 5538
} 
#endif
#line 5540 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5541
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5545
::exit(___);}
#if 0
#line 5541
{ 
#line 5542
int4 tmp; 
#line 5543
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_short1(tmp.x); 
#line 5545
} 
#endif
#line 5547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5548
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5552
::exit(___);}
#if 0
#line 5548
{ 
#line 5549
int4 tmp; 
#line 5550
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 5552
} 
#endif
#line 5554 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5555
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5559
::exit(___);}
#if 0
#line 5555
{ 
#line 5556
int4 tmp; 
#line 5557
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5559
} 
#endif
#line 5561 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5562
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5566
::exit(___);}
#if 0
#line 5562
{ 
#line 5563
uint4 tmp; 
#line 5564
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = ((unsigned short)(tmp.x)); 
#line 5566
} 
#endif
#line 5568 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5569
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5573
::exit(___);}
#if 0
#line 5569
{ 
#line 5570
uint4 tmp; 
#line 5571
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_ushort1(tmp.x); 
#line 5573
} 
#endif
#line 5575 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5576
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5580
::exit(___);}
#if 0
#line 5576
{ 
#line 5577
uint4 tmp; 
#line 5578
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 5580
} 
#endif
#line 5582 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5583
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5587
::exit(___);}
#if 0
#line 5583
{ 
#line 5584
uint4 tmp; 
#line 5585
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5587
} 
#endif
#line 5595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(int *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5596
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5600
::exit(___);}
#if 0
#line 5596
{ 
#line 5597
int4 tmp; 
#line 5598
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = (tmp.x); 
#line 5600
} 
#endif
#line 5602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5603
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5607
::exit(___);}
#if 0
#line 5603
{ 
#line 5604
int4 tmp; 
#line 5605
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_int1(tmp.x); 
#line 5607
} 
#endif
#line 5609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5610
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5614
::exit(___);}
#if 0
#line 5610
{ 
#line 5611
int4 tmp; 
#line 5612
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 5614
} 
#endif
#line 5616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5617
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5621
::exit(___);}
#if 0
#line 5617
{ 
#line 5618
int4 tmp; 
#line 5619
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5621
} 
#endif
#line 5623 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5624
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5628
::exit(___);}
#if 0
#line 5624
{ 
#line 5625
uint4 tmp; 
#line 5626
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = (tmp.x); 
#line 5628
} 
#endif
#line 5630 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5631
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5635
::exit(___);}
#if 0
#line 5631
{ 
#line 5632
uint4 tmp; 
#line 5633
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_uint1(tmp.x); 
#line 5635
} 
#endif
#line 5637 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5638
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5642
::exit(___);}
#if 0
#line 5638
{ 
#line 5639
uint4 tmp; 
#line 5640
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 5642
} 
#endif
#line 5644 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5645
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5649
::exit(___);}
#if 0
#line 5645
{ 
#line 5646
uint4 tmp; 
#line 5647
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5649
} 
#endif
#line 5659 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(long *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5660
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5664
::exit(___);}
#if 0
#line 5660
{ 
#line 5661
int4 tmp; 
#line 5662
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = ((long)(tmp.x)); 
#line 5664
} 
#endif
#line 5666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5667
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5671
::exit(___);}
#if 0
#line 5667
{ 
#line 5668
int4 tmp; 
#line 5669
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_long1(tmp.x); 
#line 5671
} 
#endif
#line 5673 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5674
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5678
::exit(___);}
#if 0
#line 5674
{ 
#line 5675
int4 tmp; 
#line 5676
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 5678
} 
#endif
#line 5680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5681
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5685
::exit(___);}
#if 0
#line 5681
{ 
#line 5682
int4 tmp; 
#line 5683
__asm tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5685
} 
#endif
#line 5687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5688
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5692
::exit(___);}
#if 0
#line 5688
{ 
#line 5689
uint4 tmp; 
#line 5690
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = ((unsigned long)(tmp.x)); 
#line 5692
} 
#endif
#line 5694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5695
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5699
::exit(___);}
#if 0
#line 5695
{ 
#line 5696
uint4 tmp; 
#line 5697
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_ulong1(tmp.x); 
#line 5699
} 
#endif
#line 5701 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5702
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5706
::exit(___);}
#if 0
#line 5702
{ 
#line 5703
uint4 tmp; 
#line 5704
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 5706
} 
#endif
#line 5708 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5709
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5713
::exit(___);}
#if 0
#line 5709
{ 
#line 5710
uint4 tmp; 
#line 5711
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5713
} 
#endif
#line 5724 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(float *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5725
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5729
::exit(___);}
#if 0
#line 5725
{ 
#line 5726
float4 tmp; 
#line 5727
__asm tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = (tmp.x); 
#line 5729
} 
#endif
#line 5731 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5732
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5736
::exit(___);}
#if 0
#line 5732
{ 
#line 5733
float4 tmp; 
#line 5734
__asm tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_float1(tmp.x); 
#line 5736
} 
#endif
#line 5738 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5739
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5743
::exit(___);}
#if 0
#line 5739
{ 
#line 5740
float4 tmp; 
#line 5741
__asm tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 5743
} 
#endif
#line 5745 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5746
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5750
::exit(___);}
#if 0
#line 5746
{ 
#line 5747
float4 tmp; 
#line 5748
__asm tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5750
} 
#endif
#line 5758 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 5759
tex1DGrad(::cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5760
{int volatile ___ = 1;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5764
::exit(___);}
#if 0
#line 5760
{ 
#line 5761
T ret; 
#line 5762
tex1DGrad(&ret, texObject, x, dPdx, dPdy); 
#line 5763
return ret; 
#line 5764
} 
#endif
#line 5772 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5773
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5782 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 5773 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 5778 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 5779
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
#line 5781 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 5782
} 
#endif
#line 5783 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5784
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5788
::exit(___);}
#if 0
#line 5784
{ 
#line 5785
int4 tmp; 
#line 5786
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = ((signed char)(tmp.x)); 
#line 5788
} 
#endif
#line 5790 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5791
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5795
::exit(___);}
#if 0
#line 5791
{ 
#line 5792
int4 tmp; 
#line 5793
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_char1(tmp.x); 
#line 5795
} 
#endif
#line 5797 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5798
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5802
::exit(___);}
#if 0
#line 5798
{ 
#line 5799
int4 tmp; 
#line 5800
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 5802
} 
#endif
#line 5804 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5805
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5809
::exit(___);}
#if 0
#line 5805
{ 
#line 5806
int4 tmp; 
#line 5807
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5809
} 
#endif
#line 5811 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5812
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5816
::exit(___);}
#if 0
#line 5812
{ 
#line 5813
uint4 tmp; 
#line 5814
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = ((unsigned char)(tmp.x)); 
#line 5816
} 
#endif
#line 5818 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5819
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5823
::exit(___);}
#if 0
#line 5819
{ 
#line 5820
uint4 tmp; 
#line 5821
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_uchar1(tmp.x); 
#line 5823
} 
#endif
#line 5825 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5826
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5830
::exit(___);}
#if 0
#line 5826
{ 
#line 5827
uint4 tmp; 
#line 5828
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 5830
} 
#endif
#line 5832 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5833
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5837
::exit(___);}
#if 0
#line 5833
{ 
#line 5834
uint4 tmp; 
#line 5835
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5837
} 
#endif
#line 5845 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5846
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5850
::exit(___);}
#if 0
#line 5846
{ 
#line 5847
int4 tmp; 
#line 5848
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = ((short)(tmp.x)); 
#line 5850
} 
#endif
#line 5852 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5853
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5857
::exit(___);}
#if 0
#line 5853
{ 
#line 5854
int4 tmp; 
#line 5855
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_short1(tmp.x); 
#line 5857
} 
#endif
#line 5859 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5860
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5864
::exit(___);}
#if 0
#line 5860
{ 
#line 5861
int4 tmp; 
#line 5862
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 5864
} 
#endif
#line 5866 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5867
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5871
::exit(___);}
#if 0
#line 5867
{ 
#line 5868
int4 tmp; 
#line 5869
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5871
} 
#endif
#line 5873 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5874
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5878
::exit(___);}
#if 0
#line 5874
{ 
#line 5875
uint4 tmp; 
#line 5876
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = ((unsigned short)(tmp.x)); 
#line 5878
} 
#endif
#line 5880 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5881
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5885
::exit(___);}
#if 0
#line 5881
{ 
#line 5882
uint4 tmp; 
#line 5883
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_ushort1(tmp.x); 
#line 5885
} 
#endif
#line 5887 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5888
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5892
::exit(___);}
#if 0
#line 5888
{ 
#line 5889
uint4 tmp; 
#line 5890
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 5892
} 
#endif
#line 5894 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5895
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5899
::exit(___);}
#if 0
#line 5895
{ 
#line 5896
uint4 tmp; 
#line 5897
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5899
} 
#endif
#line 5907 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5908
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5912
::exit(___);}
#if 0
#line 5908
{ 
#line 5909
int4 tmp; 
#line 5910
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = (tmp.x); 
#line 5912
} 
#endif
#line 5914 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5915
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5919
::exit(___);}
#if 0
#line 5915
{ 
#line 5916
int4 tmp; 
#line 5917
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_int1(tmp.x); 
#line 5919
} 
#endif
#line 5921 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5922
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5926
::exit(___);}
#if 0
#line 5922
{ 
#line 5923
int4 tmp; 
#line 5924
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 5926
} 
#endif
#line 5928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5929
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5933
::exit(___);}
#if 0
#line 5929
{ 
#line 5930
int4 tmp; 
#line 5931
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5933
} 
#endif
#line 5935 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5936
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5940
::exit(___);}
#if 0
#line 5936
{ 
#line 5937
uint4 tmp; 
#line 5938
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = (tmp.x); 
#line 5940
} 
#endif
#line 5942 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5943
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5947
::exit(___);}
#if 0
#line 5943
{ 
#line 5944
uint4 tmp; 
#line 5945
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_uint1(tmp.x); 
#line 5947
} 
#endif
#line 5949 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5950
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5954
::exit(___);}
#if 0
#line 5950
{ 
#line 5951
uint4 tmp; 
#line 5952
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 5954
} 
#endif
#line 5956 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5957
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5961
::exit(___);}
#if 0
#line 5957
{ 
#line 5958
uint4 tmp; 
#line 5959
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5961
} 
#endif
#line 5971 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5972
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5976
::exit(___);}
#if 0
#line 5972
{ 
#line 5973
int4 tmp; 
#line 5974
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = ((long)(tmp.x)); 
#line 5976
} 
#endif
#line 5978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5979
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5983
::exit(___);}
#if 0
#line 5979
{ 
#line 5980
int4 tmp; 
#line 5981
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_long1(tmp.x); 
#line 5983
} 
#endif
#line 5985 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5986
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5990
::exit(___);}
#if 0
#line 5986
{ 
#line 5987
int4 tmp; 
#line 5988
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 5990
} 
#endif
#line 5992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5993
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5997
::exit(___);}
#if 0
#line 5993
{ 
#line 5994
int4 tmp; 
#line 5995
__asm tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5997
} 
#endif
#line 5999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6000
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6004
::exit(___);}
#if 0
#line 6000
{ 
#line 6001
uint4 tmp; 
#line 6002
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = ((unsigned long)(tmp.x)); 
#line 6004
} 
#endif
#line 6006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6007
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6011
::exit(___);}
#if 0
#line 6007
{ 
#line 6008
uint4 tmp; 
#line 6009
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_ulong1(tmp.x); 
#line 6011
} 
#endif
#line 6013 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6014
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6018
::exit(___);}
#if 0
#line 6014
{ 
#line 6015
uint4 tmp; 
#line 6016
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 6018
} 
#endif
#line 6020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6021
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6025
::exit(___);}
#if 0
#line 6021
{ 
#line 6022
uint4 tmp; 
#line 6023
__asm tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6025
} 
#endif
#line 6036 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6037
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6041
::exit(___);}
#if 0
#line 6037
{ 
#line 6038
float4 tmp; 
#line 6039
__asm tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = (tmp.x); 
#line 6041
} 
#endif
#line 6043 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6044
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6048
::exit(___);}
#if 0
#line 6044
{ 
#line 6045
float4 tmp; 
#line 6046
__asm tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_float1(tmp.x); 
#line 6048
} 
#endif
#line 6050 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6051
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6055
::exit(___);}
#if 0
#line 6051
{ 
#line 6052
float4 tmp; 
#line 6053
__asm tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 6055
} 
#endif
#line 6057 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 6058
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6062
::exit(___);}
#if 0
#line 6058
{ 
#line 6059
float4 tmp; 
#line 6060
__asm tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6062
} 
#endif
#line 6070 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 6071
tex2DGrad(::cudaTextureObject_t texObject, float x, float y, ::float2 dPdx, ::float2 dPdy) 
#line 6072
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 6076
::exit(___);}
#if 0
#line 6072
{ 
#line 6073
T ret; 
#line 6074
tex2DGrad(&ret, texObject, x, y, dPdx, dPdy); 
#line 6075
return ret; 
#line 6076
} 
#endif
#line 6084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6085
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6094 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 6085 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 6090 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 6091
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
#line 6093 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 6094
} 
#endif
#line 6095 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6096
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6100
::exit(___);}
#if 0
#line 6096
{ 
#line 6097
int4 tmp; 
#line 6098
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = ((signed char)(tmp.x)); 
#line 6100
} 
#endif
#line 6102 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6103
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6107
::exit(___);}
#if 0
#line 6103
{ 
#line 6104
int4 tmp; 
#line 6105
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_char1(tmp.x); 
#line 6107
} 
#endif
#line 6109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6110
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6114
::exit(___);}
#if 0
#line 6110
{ 
#line 6111
int4 tmp; 
#line 6112
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 6114
} 
#endif
#line 6116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6117
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6121
::exit(___);}
#if 0
#line 6117
{ 
#line 6118
int4 tmp; 
#line 6119
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6121
} 
#endif
#line 6123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6124
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6128
::exit(___);}
#if 0
#line 6124
{ 
#line 6125
uint4 tmp; 
#line 6126
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = ((unsigned char)(tmp.x)); 
#line 6128
} 
#endif
#line 6130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6131
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6135
::exit(___);}
#if 0
#line 6131
{ 
#line 6132
uint4 tmp; 
#line 6133
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_uchar1(tmp.x); 
#line 6135
} 
#endif
#line 6137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6138
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6142
::exit(___);}
#if 0
#line 6138
{ 
#line 6139
uint4 tmp; 
#line 6140
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 6142
} 
#endif
#line 6144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6145
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6149
::exit(___);}
#if 0
#line 6145
{ 
#line 6146
uint4 tmp; 
#line 6147
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6149
} 
#endif
#line 6157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6158
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6162
::exit(___);}
#if 0
#line 6158
{ 
#line 6159
int4 tmp; 
#line 6160
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = ((short)(tmp.x)); 
#line 6162
} 
#endif
#line 6164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6165
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6169
::exit(___);}
#if 0
#line 6165
{ 
#line 6166
int4 tmp; 
#line 6167
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_short1(tmp.x); 
#line 6169
} 
#endif
#line 6171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6172
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6176
::exit(___);}
#if 0
#line 6172
{ 
#line 6173
int4 tmp; 
#line 6174
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 6176
} 
#endif
#line 6178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6179
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6183
::exit(___);}
#if 0
#line 6179
{ 
#line 6180
int4 tmp; 
#line 6181
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6183
} 
#endif
#line 6185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6186
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6190
::exit(___);}
#if 0
#line 6186
{ 
#line 6187
uint4 tmp; 
#line 6188
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = ((unsigned short)(tmp.x)); 
#line 6190
} 
#endif
#line 6192 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6193
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6197
::exit(___);}
#if 0
#line 6193
{ 
#line 6194
uint4 tmp; 
#line 6195
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_ushort1(tmp.x); 
#line 6197
} 
#endif
#line 6199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6200
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6204
::exit(___);}
#if 0
#line 6200
{ 
#line 6201
uint4 tmp; 
#line 6202
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 6204
} 
#endif
#line 6206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6207
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6211
::exit(___);}
#if 0
#line 6207
{ 
#line 6208
uint4 tmp; 
#line 6209
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6211
} 
#endif
#line 6219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6220
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6224
::exit(___);}
#if 0
#line 6220
{ 
#line 6221
int4 tmp; 
#line 6222
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = (tmp.x); 
#line 6224
} 
#endif
#line 6226 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6227
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6231
::exit(___);}
#if 0
#line 6227
{ 
#line 6228
int4 tmp; 
#line 6229
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_int1(tmp.x); 
#line 6231
} 
#endif
#line 6233 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6234
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6238
::exit(___);}
#if 0
#line 6234
{ 
#line 6235
int4 tmp; 
#line 6236
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 6238
} 
#endif
#line 6240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6241
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6245
::exit(___);}
#if 0
#line 6241
{ 
#line 6242
int4 tmp; 
#line 6243
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6245
} 
#endif
#line 6247 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6248
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6252
::exit(___);}
#if 0
#line 6248
{ 
#line 6249
uint4 tmp; 
#line 6250
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = (tmp.x); 
#line 6252
} 
#endif
#line 6254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6255
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6259
::exit(___);}
#if 0
#line 6255
{ 
#line 6256
uint4 tmp; 
#line 6257
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_uint1(tmp.x); 
#line 6259
} 
#endif
#line 6261 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6262
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6266
::exit(___);}
#if 0
#line 6262
{ 
#line 6263
uint4 tmp; 
#line 6264
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 6266
} 
#endif
#line 6268 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6269
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6273
::exit(___);}
#if 0
#line 6269
{ 
#line 6270
uint4 tmp; 
#line 6271
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6273
} 
#endif
#line 6283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6284
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6288
::exit(___);}
#if 0
#line 6284
{ 
#line 6285
int4 tmp; 
#line 6286
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = ((long)(tmp.x)); 
#line 6288
} 
#endif
#line 6290 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6291
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6295
::exit(___);}
#if 0
#line 6291
{ 
#line 6292
int4 tmp; 
#line 6293
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_long1(tmp.x); 
#line 6295
} 
#endif
#line 6297 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6298
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6302
::exit(___);}
#if 0
#line 6298
{ 
#line 6299
int4 tmp; 
#line 6300
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 6302
} 
#endif
#line 6304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6305
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6309
::exit(___);}
#if 0
#line 6305
{ 
#line 6306
int4 tmp; 
#line 6307
__asm tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6309
} 
#endif
#line 6311 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6312
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6316
::exit(___);}
#if 0
#line 6312
{ 
#line 6313
uint4 tmp; 
#line 6314
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = ((unsigned long)(tmp.x)); 
#line 6316
} 
#endif
#line 6318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6319
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6323
::exit(___);}
#if 0
#line 6319
{ 
#line 6320
uint4 tmp; 
#line 6321
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_ulong1(tmp.x); 
#line 6323
} 
#endif
#line 6325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6326
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6330
::exit(___);}
#if 0
#line 6326
{ 
#line 6327
uint4 tmp; 
#line 6328
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 6330
} 
#endif
#line 6332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6333
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6337
::exit(___);}
#if 0
#line 6333
{ 
#line 6334
uint4 tmp; 
#line 6335
__asm tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6337
} 
#endif
#line 6348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6349
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6353
::exit(___);}
#if 0
#line 6349
{ 
#line 6350
float4 tmp; 
#line 6351
__asm tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = (tmp.x); 
#line 6353
} 
#endif
#line 6355 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6356
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6360
::exit(___);}
#if 0
#line 6356
{ 
#line 6357
float4 tmp; 
#line 6358
__asm tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_float1(tmp.x); 
#line 6360
} 
#endif
#line 6362 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6363
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6367
::exit(___);}
#if 0
#line 6363
{ 
#line 6364
float4 tmp; 
#line 6365
__asm tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 6367
} 
#endif
#line 6369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6370
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6374
::exit(___);}
#if 0
#line 6370
{ 
#line 6371
float4 tmp; 
#line 6372
__asm tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6374
} 
#endif
#line 6382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 6383
tex3DGrad(::cudaTextureObject_t texObject, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) 
#line 6384
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6388
::exit(___);}
#if 0
#line 6384
{ 
#line 6385
T ret; 
#line 6386
tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy); 
#line 6387
return ret; 
#line 6388
} 
#endif
#line 6396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6397
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6406 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 6397 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 6402 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 6403
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
#line 6405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 6406
} 
#endif
#line 6407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6408
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6412
::exit(___);}
#if 0
#line 6408
{ 
#line 6409
int4 tmp; 
#line 6410
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = ((signed char)(tmp.x)); 
#line 6412
} 
#endif
#line 6414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6415
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6419
::exit(___);}
#if 0
#line 6415
{ 
#line 6416
int4 tmp; 
#line 6417
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_char1(tmp.x); 
#line 6419
} 
#endif
#line 6421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6422
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6426
::exit(___);}
#if 0
#line 6422
{ 
#line 6423
int4 tmp; 
#line 6424
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 6426
} 
#endif
#line 6428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6429
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6433
::exit(___);}
#if 0
#line 6429
{ 
#line 6430
int4 tmp; 
#line 6431
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6433
} 
#endif
#line 6435 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6436
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6440
::exit(___);}
#if 0
#line 6436
{ 
#line 6437
uint4 tmp; 
#line 6438
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = ((unsigned char)(tmp.x)); 
#line 6440
} 
#endif
#line 6442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6443
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6447
::exit(___);}
#if 0
#line 6443
{ 
#line 6444
uint4 tmp; 
#line 6445
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_uchar1(tmp.x); 
#line 6447
} 
#endif
#line 6449 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6450
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6454
::exit(___);}
#if 0
#line 6450
{ 
#line 6451
uint4 tmp; 
#line 6452
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 6454
} 
#endif
#line 6456 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6457
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6461
::exit(___);}
#if 0
#line 6457
{ 
#line 6458
uint4 tmp; 
#line 6459
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6461
} 
#endif
#line 6469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6470
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6474
::exit(___);}
#if 0
#line 6470
{ 
#line 6471
int4 tmp; 
#line 6472
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = ((short)(tmp.x)); 
#line 6474
} 
#endif
#line 6476 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6477
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6481
::exit(___);}
#if 0
#line 6477
{ 
#line 6478
int4 tmp; 
#line 6479
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_short1(tmp.x); 
#line 6481
} 
#endif
#line 6483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6484
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6488
::exit(___);}
#if 0
#line 6484
{ 
#line 6485
int4 tmp; 
#line 6486
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 6488
} 
#endif
#line 6490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6491
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6495
::exit(___);}
#if 0
#line 6491
{ 
#line 6492
int4 tmp; 
#line 6493
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6495
} 
#endif
#line 6497 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6498
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6502
::exit(___);}
#if 0
#line 6498
{ 
#line 6499
uint4 tmp; 
#line 6500
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = ((unsigned short)(tmp.x)); 
#line 6502
} 
#endif
#line 6504 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6505
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6509
::exit(___);}
#if 0
#line 6505
{ 
#line 6506
uint4 tmp; 
#line 6507
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_ushort1(tmp.x); 
#line 6509
} 
#endif
#line 6511 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6512
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6516
::exit(___);}
#if 0
#line 6512
{ 
#line 6513
uint4 tmp; 
#line 6514
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 6516
} 
#endif
#line 6518 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6519
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6523
::exit(___);}
#if 0
#line 6519
{ 
#line 6520
uint4 tmp; 
#line 6521
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6523
} 
#endif
#line 6531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6536
::exit(___);}
#if 0
#line 6532
{ 
#line 6533
int4 tmp; 
#line 6534
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = (tmp.x); 
#line 6536
} 
#endif
#line 6538 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6539
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6543
::exit(___);}
#if 0
#line 6539
{ 
#line 6540
int4 tmp; 
#line 6541
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_int1(tmp.x); 
#line 6543
} 
#endif
#line 6545 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6546
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6550
::exit(___);}
#if 0
#line 6546
{ 
#line 6547
int4 tmp; 
#line 6548
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 6550
} 
#endif
#line 6552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6553
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6557
::exit(___);}
#if 0
#line 6553
{ 
#line 6554
int4 tmp; 
#line 6555
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6557
} 
#endif
#line 6559 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6560
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6564
::exit(___);}
#if 0
#line 6560
{ 
#line 6561
uint4 tmp; 
#line 6562
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = (tmp.x); 
#line 6564
} 
#endif
#line 6566 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6567
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6571
::exit(___);}
#if 0
#line 6567
{ 
#line 6568
uint4 tmp; 
#line 6569
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_uint1(tmp.x); 
#line 6571
} 
#endif
#line 6573 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6574
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6578
::exit(___);}
#if 0
#line 6574
{ 
#line 6575
uint4 tmp; 
#line 6576
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 6578
} 
#endif
#line 6580 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6581
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6585
::exit(___);}
#if 0
#line 6581
{ 
#line 6582
uint4 tmp; 
#line 6583
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6585
} 
#endif
#line 6595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(long *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6596
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6600
::exit(___);}
#if 0
#line 6596
{ 
#line 6597
int4 tmp; 
#line 6598
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = ((long)(tmp.x)); 
#line 6600
} 
#endif
#line 6602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(long1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6603
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6607
::exit(___);}
#if 0
#line 6603
{ 
#line 6604
int4 tmp; 
#line 6605
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_long1(tmp.x); 
#line 6607
} 
#endif
#line 6609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(long2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6610
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6614
::exit(___);}
#if 0
#line 6610
{ 
#line 6611
int4 tmp; 
#line 6612
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 6614
} 
#endif
#line 6616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(long4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6617
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6621
::exit(___);}
#if 0
#line 6617
{ 
#line 6618
int4 tmp; 
#line 6619
__asm tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6621
} 
#endif
#line 6623 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6624
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6628
::exit(___);}
#if 0
#line 6624
{ 
#line 6625
uint4 tmp; 
#line 6626
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = ((unsigned long)(tmp.x)); 
#line 6628
} 
#endif
#line 6630 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6631
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6635
::exit(___);}
#if 0
#line 6631
{ 
#line 6632
uint4 tmp; 
#line 6633
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_ulong1(tmp.x); 
#line 6635
} 
#endif
#line 6637 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6638
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6642
::exit(___);}
#if 0
#line 6638
{ 
#line 6639
uint4 tmp; 
#line 6640
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 6642
} 
#endif
#line 6644 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6645
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6649
::exit(___);}
#if 0
#line 6645
{ 
#line 6646
uint4 tmp; 
#line 6647
__asm tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6649
} 
#endif
#line 6660 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6661
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6665
::exit(___);}
#if 0
#line 6661
{ 
#line 6662
float4 tmp; 
#line 6663
__asm tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = (tmp.x); 
#line 6665
} 
#endif
#line 6667 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6668
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6672
::exit(___);}
#if 0
#line 6668
{ 
#line 6669
float4 tmp; 
#line 6670
__asm tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_float1(tmp.x); 
#line 6672
} 
#endif
#line 6674 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6675
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6679
::exit(___);}
#if 0
#line 6675
{ 
#line 6676
float4 tmp; 
#line 6677
__asm tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 6679
} 
#endif
#line 6681 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6682
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6686
::exit(___);}
#if 0
#line 6682
{ 
#line 6683
float4 tmp; 
#line 6684
__asm tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6686
} 
#endif
#line 6694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 6695
tex1DLayeredGrad(::cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6696
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6700
::exit(___);}
#if 0
#line 6696
{ 
#line 6697
T ret; 
#line 6698
tex1DLayeredGrad(&ret, texObject, x, layer, dPdx, dPdy); 
#line 6699
return ret; 
#line 6700
} 
#endif
#line 6708 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6709
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6718 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
::exit(___);}
#if 0
#line 6709 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
{ 
#line 6714 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
int4 tmp; 
#line 6715
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
#line 6717 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
(*retVal) = ((char)(tmp.x)); 
#line 6718
} 
#endif
#line 6719 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6720
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6724
::exit(___);}
#if 0
#line 6720
{ 
#line 6721
int4 tmp; 
#line 6722
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = ((signed char)(tmp.x)); 
#line 6724
} 
#endif
#line 6726 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6727
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6731
::exit(___);}
#if 0
#line 6727
{ 
#line 6728
int4 tmp; 
#line 6729
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_char1(tmp.x); 
#line 6731
} 
#endif
#line 6733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6734
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6738
::exit(___);}
#if 0
#line 6734
{ 
#line 6735
int4 tmp; 
#line 6736
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 6738
} 
#endif
#line 6740 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6741
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6745
::exit(___);}
#if 0
#line 6741
{ 
#line 6742
int4 tmp; 
#line 6743
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6745
} 
#endif
#line 6747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6748
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6752
::exit(___);}
#if 0
#line 6748
{ 
#line 6749
uint4 tmp; 
#line 6750
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = ((unsigned char)(tmp.x)); 
#line 6752
} 
#endif
#line 6754 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6755
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6759
::exit(___);}
#if 0
#line 6755
{ 
#line 6756
uint4 tmp; 
#line 6757
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_uchar1(tmp.x); 
#line 6759
} 
#endif
#line 6761 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6762
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6766
::exit(___);}
#if 0
#line 6762
{ 
#line 6763
uint4 tmp; 
#line 6764
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 6766
} 
#endif
#line 6768 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6769
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6773
::exit(___);}
#if 0
#line 6769
{ 
#line 6770
uint4 tmp; 
#line 6771
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6773
} 
#endif
#line 6781 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6782
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6786
::exit(___);}
#if 0
#line 6782
{ 
#line 6783
int4 tmp; 
#line 6784
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = ((short)(tmp.x)); 
#line 6786
} 
#endif
#line 6788 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6789
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6793
::exit(___);}
#if 0
#line 6789
{ 
#line 6790
int4 tmp; 
#line 6791
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_short1(tmp.x); 
#line 6793
} 
#endif
#line 6795 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6796
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6800
::exit(___);}
#if 0
#line 6796
{ 
#line 6797
int4 tmp; 
#line 6798
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 6800
} 
#endif
#line 6802 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6803
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6807
::exit(___);}
#if 0
#line 6803
{ 
#line 6804
int4 tmp; 
#line 6805
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6807
} 
#endif
#line 6809 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6810
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6814
::exit(___);}
#if 0
#line 6810
{ 
#line 6811
uint4 tmp; 
#line 6812
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = ((unsigned short)(tmp.x)); 
#line 6814
} 
#endif
#line 6816 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6817
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6821
::exit(___);}
#if 0
#line 6817
{ 
#line 6818
uint4 tmp; 
#line 6819
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_ushort1(tmp.x); 
#line 6821
} 
#endif
#line 6823 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6824
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6828
::exit(___);}
#if 0
#line 6824
{ 
#line 6825
uint4 tmp; 
#line 6826
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 6828
} 
#endif
#line 6830 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6831
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6835
::exit(___);}
#if 0
#line 6831
{ 
#line 6832
uint4 tmp; 
#line 6833
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6835
} 
#endif
#line 6843 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6844
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6848
::exit(___);}
#if 0
#line 6844
{ 
#line 6845
int4 tmp; 
#line 6846
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = (tmp.x); 
#line 6848
} 
#endif
#line 6850 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6851
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6855
::exit(___);}
#if 0
#line 6851
{ 
#line 6852
int4 tmp; 
#line 6853
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_int1(tmp.x); 
#line 6855
} 
#endif
#line 6857 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6858
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6862
::exit(___);}
#if 0
#line 6858
{ 
#line 6859
int4 tmp; 
#line 6860
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 6862
} 
#endif
#line 6864 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6865
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6869
::exit(___);}
#if 0
#line 6865
{ 
#line 6866
int4 tmp; 
#line 6867
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6869
} 
#endif
#line 6871 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6872
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6876
::exit(___);}
#if 0
#line 6872
{ 
#line 6873
uint4 tmp; 
#line 6874
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = (tmp.x); 
#line 6876
} 
#endif
#line 6878 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6879
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6883
::exit(___);}
#if 0
#line 6879
{ 
#line 6880
uint4 tmp; 
#line 6881
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_uint1(tmp.x); 
#line 6883
} 
#endif
#line 6885 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6886
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6890
::exit(___);}
#if 0
#line 6886
{ 
#line 6887
uint4 tmp; 
#line 6888
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 6890
} 
#endif
#line 6892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6893
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6897
::exit(___);}
#if 0
#line 6893
{ 
#line 6894
uint4 tmp; 
#line 6895
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6897
} 
#endif
#line 6907 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6908
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6912
::exit(___);}
#if 0
#line 6908
{ 
#line 6909
int4 tmp; 
#line 6910
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = ((long)(tmp.x)); 
#line 6912
} 
#endif
#line 6914 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6915
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6919
::exit(___);}
#if 0
#line 6915
{ 
#line 6916
int4 tmp; 
#line 6917
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_long1(tmp.x); 
#line 6919
} 
#endif
#line 6921 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6922
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6926
::exit(___);}
#if 0
#line 6922
{ 
#line 6923
int4 tmp; 
#line 6924
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 6926
} 
#endif
#line 6928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6929
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6933
::exit(___);}
#if 0
#line 6929
{ 
#line 6930
int4 tmp; 
#line 6931
__asm tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6933
} 
#endif
#line 6935 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6936
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6940
::exit(___);}
#if 0
#line 6936
{ 
#line 6937
uint4 tmp; 
#line 6938
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = ((unsigned long)(tmp.x)); 
#line 6940
} 
#endif
#line 6942 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6943
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6947
::exit(___);}
#if 0
#line 6943
{ 
#line 6944
uint4 tmp; 
#line 6945
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_ulong1(tmp.x); 
#line 6947
} 
#endif
#line 6949 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6950
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6954
::exit(___);}
#if 0
#line 6950
{ 
#line 6951
uint4 tmp; 
#line 6952
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 6954
} 
#endif
#line 6956 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6957
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6961
::exit(___);}
#if 0
#line 6957
{ 
#line 6958
uint4 tmp; 
#line 6959
__asm tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6961
} 
#endif
#line 6972 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6973
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6977
::exit(___);}
#if 0
#line 6973
{ 
#line 6974
float4 tmp; 
#line 6975
__asm tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = (tmp.x); 
#line 6977
} 
#endif
#line 6979 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6980
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6984
::exit(___);}
#if 0
#line 6980
{ 
#line 6981
float4 tmp; 
#line 6982
__asm tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_float1(tmp.x); 
#line 6984
} 
#endif
#line 6986 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6987
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6991
::exit(___);}
#if 0
#line 6987
{ 
#line 6988
float4 tmp; 
#line 6989
__asm tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 6991
} 
#endif
#line 6993 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6994
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6998
::exit(___);}
#if 0
#line 6994
{ 
#line 6995
float4 tmp; 
#line 6996
__asm tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6998
} 
#endif
#line 7006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\texture_indirect_functions.h"
template< class T> static __forceinline T 
#line 7007
tex2DLayeredGrad(::cudaTextureObject_t texObject, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) 
#line 7008
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 7012
::exit(___);}
#if 0
#line 7008
{ 
#line 7009
T ret; 
#line 7010
tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy); 
#line 7011
return ret; 
#line 7012
} 
#endif
#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 71
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 83
::exit(___);}
#if 0
#line 71
{ 
#line 72
int tmp; 
#line 73
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 74
__asm suld.b.1d.b8.trap  {%0}, [%1, {%2}];
} else { 
#line 76
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 77
__asm suld.b.1d.b8.clamp {%0}, [%1, {%2}];
} else { 
#line 79
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 80
__asm suld.b.1d.b8.zero  {%0}, [%1, {%2}];
}  }  }  
#line 82
(*retVal) = ((char)tmp); 
#line 83
} 
#endif
#line 85 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 86
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 98
::exit(___);}
#if 0
#line 86
{ 
#line 87
int tmp; 
#line 88
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 89
__asm suld.b.1d.b8.trap  {%0}, [%1, {%2}];
} else { 
#line 91
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 92
__asm suld.b.1d.b8.clamp {%0}, [%1, {%2}];
} else { 
#line 94
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 95
__asm suld.b.1d.b8.zero  {%0}, [%1, {%2}];
}  }  }  
#line 97
(*retVal) = ((signed char)tmp); 
#line 98
} 
#endif
#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 101
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 113
::exit(___);}
#if 0
#line 101
{ 
#line 102
int1 tmp; 
#line 103
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 104
__asm suld.b.1d.b8.trap  {%0}, [%1, {%2}];
} else { 
#line 106
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 107
__asm suld.b.1d.b8.clamp {%0}, [%1, {%2}];
} else { 
#line 109
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 110
__asm suld.b.1d.b8.zero  {%0}, [%1, {%2}];
}  }  }  
#line 112
(*retVal) = make_char1(tmp.x); 
#line 113
} 
#endif
#line 115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 116
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 128
::exit(___);}
#if 0
#line 116
{ 
#line 117
unsigned tmp; 
#line 118
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 119
__asm suld.b.1d.b8.trap  {%0}, [%1, {%2}];
} else { 
#line 121
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 122
__asm suld.b.1d.b8.clamp {%0}, [%1, {%2}];
} else { 
#line 124
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 125
__asm suld.b.1d.b8.zero  {%0}, [%1, {%2}];
}  }  }  
#line 127
(*retVal) = ((unsigned char)tmp); 
#line 128
} 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 131
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 143
::exit(___);}
#if 0
#line 131
{ 
#line 132
uint1 tmp; 
#line 133
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 134
__asm suld.b.1d.b8.trap  {%0}, [%1, {%2}];
} else { 
#line 136
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 137
__asm suld.b.1d.b8.clamp {%0}, [%1, {%2}];
} else { 
#line 139
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 140
__asm suld.b.1d.b8.zero  {%0}, [%1, {%2}];
}  }  }  
#line 142
(*retVal) = make_uchar1(tmp.x); 
#line 143
} 
#endif
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 146
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 158
::exit(___);}
#if 0
#line 146
{ 
#line 147
short tmp; 
#line 148
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 149
__asm suld.b.1d.b16.trap  {%0}, [%1, {%2}];
} else { 
#line 151
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 152
__asm suld.b.1d.b16.clamp {%0}, [%1, {%2}];
} else { 
#line 154
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 155
__asm suld.b.1d.b16.zero  {%0}, [%1, {%2}];
}  }  }  
#line 157
(*retVal) = tmp; 
#line 158
} 
#endif
#line 160 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 161
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 173
::exit(___);}
#if 0
#line 161
{ 
#line 162
short1 tmp; 
#line 163
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 164
__asm suld.b.1d.b16.trap  {%0}, [%1, {%2}];
} else { 
#line 166
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 167
__asm suld.b.1d.b16.clamp {%0}, [%1, {%2}];
} else { 
#line 169
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 170
__asm suld.b.1d.b16.zero  {%0}, [%1, {%2}];
}  }  }  
#line 172
(*retVal) = make_short1(tmp.x); 
#line 173
} 
#endif
#line 175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 176
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 188
::exit(___);}
#if 0
#line 176
{ 
#line 177
unsigned short tmp; 
#line 178
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 179
__asm suld.b.1d.b16.trap  {%0}, [%1, {%2}];
} else { 
#line 181
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 182
__asm suld.b.1d.b16.clamp {%0}, [%1, {%2}];
} else { 
#line 184
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 185
__asm suld.b.1d.b16.zero  {%0}, [%1, {%2}];
}  }  }  
#line 187
(*retVal) = tmp; 
#line 188
} 
#endif
#line 190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 191
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 203
::exit(___);}
#if 0
#line 191
{ 
#line 192
ushort1 tmp; 
#line 193
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 194
__asm suld.b.1d.b16.trap  {%0}, [%1, {%2}];
} else { 
#line 196
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 197
__asm suld.b.1d.b16.clamp {%0}, [%1, {%2}];
} else { 
#line 199
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 200
__asm suld.b.1d.b16.zero  {%0}, [%1, {%2}];
}  }  }  
#line 202
(*retVal) = make_ushort1(tmp.x); 
#line 203
} 
#endif
#line 205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 206
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 218
::exit(___);}
#if 0
#line 206
{ 
#line 207
int tmp; 
#line 208
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 209
__asm suld.b.1d.b32.trap  {%0}, [%1, {%2}];
} else { 
#line 211
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 212
__asm suld.b.1d.b32.clamp {%0}, [%1, {%2}];
} else { 
#line 214
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 215
__asm suld.b.1d.b32.zero  {%0}, [%1, {%2}];
}  }  }  
#line 217
(*retVal) = tmp; 
#line 218
} 
#endif
#line 220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 221
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 233
::exit(___);}
#if 0
#line 221
{ 
#line 222
int1 tmp; 
#line 223
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 224
__asm suld.b.1d.b32.trap  {%0}, [%1, {%2}];
} else { 
#line 226
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 227
__asm suld.b.1d.b32.clamp {%0}, [%1, {%2}];
} else { 
#line 229
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 230
__asm suld.b.1d.b32.zero  {%0}, [%1, {%2}];
}  }  }  
#line 232
(*retVal) = make_int1(tmp.x); 
#line 233
} 
#endif
#line 235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 236
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 248
::exit(___);}
#if 0
#line 236
{ 
#line 237
unsigned tmp; 
#line 238
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 239
__asm suld.b.1d.b32.trap  {%0}, [%1, {%2}];
} else { 
#line 241
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 242
__asm suld.b.1d.b32.clamp {%0}, [%1, {%2}];
} else { 
#line 244
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 245
__asm suld.b.1d.b32.zero  {%0}, [%1, {%2}];
}  }  }  
#line 247
(*retVal) = tmp; 
#line 248
} 
#endif
#line 250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 251
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 263
::exit(___);}
#if 0
#line 251
{ 
#line 252
uint1 tmp; 
#line 253
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 254
__asm suld.b.1d.b32.trap  {%0}, [%1, {%2}];
} else { 
#line 256
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 257
__asm suld.b.1d.b32.clamp {%0}, [%1, {%2}];
} else { 
#line 259
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 260
__asm suld.b.1d.b32.zero  {%0}, [%1, {%2}];
}  }  }  
#line 262
(*retVal) = make_uint1(tmp.x); 
#line 263
} 
#endif
#line 265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 266
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 278
::exit(___);}
#if 0
#line 266
{ 
#line 267
__int64 tmp; 
#line 268
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 269
__asm suld.b.1d.b64.trap  {%0}, [%1, {%2}];
} else { 
#line 271
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 272
__asm suld.b.1d.b64.clamp {%0}, [%1, {%2}];
} else { 
#line 274
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 275
__asm suld.b.1d.b64.zero  {%0}, [%1, {%2}];
}  }  }  
#line 277
(*retVal) = tmp; 
#line 278
} 
#endif
#line 280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 281
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 293
::exit(___);}
#if 0
#line 281
{ 
#line 282
longlong1 tmp; 
#line 283
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 284
__asm suld.b.1d.b64.trap  {%0}, [%1, {%2}];
} else { 
#line 286
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 287
__asm suld.b.1d.b64.clamp {%0}, [%1, {%2}];
} else { 
#line 289
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 290
__asm suld.b.1d.b64.zero  {%0}, [%1, {%2}];
}  }  }  
#line 292
(*retVal) = make_longlong1(tmp.x); 
#line 293
} 
#endif
#line 295 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 296
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 308
::exit(___);}
#if 0
#line 296
{ 
#line 297
unsigned __int64 tmp; 
#line 298
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 299
__asm suld.b.1d.b64.trap  {%0}, [%1, {%2}];
} else { 
#line 301
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 302
__asm suld.b.1d.b64.clamp {%0}, [%1, {%2}];
} else { 
#line 304
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 305
__asm suld.b.1d.b64.zero  {%0}, [%1, {%2}];
}  }  }  
#line 307
(*retVal) = tmp; 
#line 308
} 
#endif
#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 311
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 323
::exit(___);}
#if 0
#line 311
{ 
#line 312
ulonglong1 tmp; 
#line 313
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 314
__asm suld.b.1d.b64.trap  {%0}, [%1, {%2}];
} else { 
#line 316
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 317
__asm suld.b.1d.b64.clamp {%0}, [%1, {%2}];
} else { 
#line 319
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 320
__asm suld.b.1d.b64.zero  {%0}, [%1, {%2}];
}  }  }  
#line 322
(*retVal) = make_ulonglong1(tmp.x); 
#line 323
} 
#endif
#line 325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 326
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 338
::exit(___);}
#if 0
#line 326
{ 
#line 327
float tmp; 
#line 328
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 329
__asm suld.b.1d.b32.trap  {%0}, [%1, {%2}];
} else { 
#line 331
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 332
__asm suld.b.1d.b32.clamp {%0}, [%1, {%2}];
} else { 
#line 334
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 335
__asm suld.b.1d.b32.zero  {%0}, [%1, {%2}];
}  }  }  
#line 337
(*retVal) = tmp; 
#line 338
} 
#endif
#line 340 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 341
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 353
::exit(___);}
#if 0
#line 341
{ 
#line 342
float1 tmp; 
#line 343
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 344
__asm suld.b.1d.b32.trap  {%0}, [%1, {%2}];
} else { 
#line 346
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 347
__asm suld.b.1d.b32.clamp {%0}, [%1, {%2}];
} else { 
#line 349
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 350
__asm suld.b.1d.b32.zero  {%0}, [%1, {%2}];
}  }  }  
#line 352
(*retVal) = make_float1(tmp.x); 
#line 353
} 
#endif
#line 361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 362
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 374
::exit(___);}
#if 0
#line 362
{ 
#line 363
int2 tmp; 
#line 364
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 365
__asm suld.b.1d.v2.b8.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 367
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 368
__asm suld.b.1d.v2.b8.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 370
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 371
__asm suld.b.1d.v2.b8.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 373
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 374
} 
#endif
#line 376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 377
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 389
::exit(___);}
#if 0
#line 377
{ 
#line 378
uint2 tmp; 
#line 379
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 380
__asm suld.b.1d.v2.b8.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 382
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 383
__asm suld.b.1d.v2.b8.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 385
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 386
__asm suld.b.1d.v2.b8.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 388
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 389
} 
#endif
#line 391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 392
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 404
::exit(___);}
#if 0
#line 392
{ 
#line 393
short2 tmp; 
#line 394
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 395
__asm suld.b.1d.v2.b16.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 397
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 398
__asm suld.b.1d.v2.b16.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 400
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 401
__asm suld.b.1d.v2.b16.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 403
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 404
} 
#endif
#line 406 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 407
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 419
::exit(___);}
#if 0
#line 407
{ 
#line 408
ushort2 tmp; 
#line 409
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 410
__asm suld.b.1d.v2.b16.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 412
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 413
__asm suld.b.1d.v2.b16.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 415
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 416
__asm suld.b.1d.v2.b16.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 418
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 419
} 
#endif
#line 421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 422
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 434
::exit(___);}
#if 0
#line 422
{ 
#line 423
int2 tmp; 
#line 424
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 425
__asm suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 427
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 428
__asm suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 430
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 431
__asm suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 433
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 434
} 
#endif
#line 436 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 437
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 449
::exit(___);}
#if 0
#line 437
{ 
#line 438
uint2 tmp; 
#line 439
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 440
__asm suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 442
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 443
__asm suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 445
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 446
__asm suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 448
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 449
} 
#endif
#line 451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 452
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 464
::exit(___);}
#if 0
#line 452
{ 
#line 453
longlong2 tmp; 
#line 454
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 455
__asm suld.b.1d.v2.b64.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 457
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 458
__asm suld.b.1d.v2.b64.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 460
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 461
__asm suld.b.1d.v2.b64.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 463
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 464
} 
#endif
#line 466 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 467
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 479
::exit(___);}
#if 0
#line 467
{ 
#line 468
ulonglong2 tmp; 
#line 469
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 470
__asm suld.b.1d.v2.b64.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 472
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 473
__asm suld.b.1d.v2.b64.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 475
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 476
__asm suld.b.1d.v2.b64.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 478
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 479
} 
#endif
#line 481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 482
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 494
::exit(___);}
#if 0
#line 482
{ 
#line 483
float2 tmp; 
#line 484
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 485
__asm suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];
} else { 
#line 487
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 488
__asm suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];
} else { 
#line 490
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 491
__asm suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];
}  }  }  
#line 493
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 494
} 
#endif
#line 502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 503
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 515
::exit(___);}
#if 0
#line 503
{ 
#line 504
int4 tmp; 
#line 505
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 506
__asm suld.b.1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 508
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 509
__asm suld.b.1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 511
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 512
__asm suld.b.1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 514
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 515
} 
#endif
#line 517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 518
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 530
::exit(___);}
#if 0
#line 518
{ 
#line 519
uint4 tmp; 
#line 520
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 521
__asm suld.b.1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 523
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 524
__asm suld.b.1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 526
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 527
__asm suld.b.1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 529
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 530
} 
#endif
#line 532 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 533
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 545
::exit(___);}
#if 0
#line 533
{ 
#line 534
short4 tmp; 
#line 535
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 536
__asm suld.b.1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 538
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 539
__asm suld.b.1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 541
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 542
__asm suld.b.1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 544
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 545
} 
#endif
#line 547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 548
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 560
::exit(___);}
#if 0
#line 548
{ 
#line 549
ushort4 tmp; 
#line 550
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 551
__asm suld.b.1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 553
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 554
__asm suld.b.1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 556
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 557
__asm suld.b.1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 559
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 560
} 
#endif
#line 562 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 563
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 575
::exit(___);}
#if 0
#line 563
{ 
#line 564
int4 tmp; 
#line 565
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 566
__asm suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 568
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 569
__asm suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 571
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 572
__asm suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 574
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 575
} 
#endif
#line 577 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 578
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 590
::exit(___);}
#if 0
#line 578
{ 
#line 579
uint4 tmp; 
#line 580
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 581
__asm suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 583
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 584
__asm suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 586
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 587
__asm suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 589
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 590
} 
#endif
#line 592 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 593
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 605
::exit(___);}
#if 0
#line 593
{ 
#line 594
float4 tmp; 
#line 595
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 596
__asm suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 598
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 599
__asm suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];
} else { 
#line 601
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 602
__asm suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];
}  }  }  
#line 604
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 605
} 
#endif
#line 613 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 614
surf1Dread(::cudaSurfaceObject_t surfObject, int x, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 615
{int volatile ___ = 1;(void)surfObject;(void)x;(void)boundaryMode;
#line 619
::exit(___);}
#if 0
#line 615
{ 
#line 616
T ret; 
#line 617
surf1Dread(&ret, surfObject, x, boundaryMode); 
#line 618
return ret; 
#line 619
} 
#endif
#line 627 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 628
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 640
::exit(___);}
#if 0
#line 628
{ 
#line 629
int tmp; 
#line 630
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 631
__asm suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 633
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 634
__asm suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 636
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 637
__asm suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 639
(*retVal) = ((char)tmp); 
#line 640
} 
#endif
#line 642 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 643
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 655
::exit(___);}
#if 0
#line 643
{ 
#line 644
int tmp; 
#line 645
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 646
__asm suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 648
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 649
__asm suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 651
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 652
__asm suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 654
(*retVal) = ((signed char)tmp); 
#line 655
} 
#endif
#line 657 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 658
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 670
::exit(___);}
#if 0
#line 658
{ 
#line 659
int1 tmp; 
#line 660
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 661
__asm suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 663
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 664
__asm suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 666
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 667
__asm suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 669
(*retVal) = make_char1(tmp.x); 
#line 670
} 
#endif
#line 672 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 673
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 685
::exit(___);}
#if 0
#line 673
{ 
#line 674
unsigned tmp; 
#line 675
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 676
__asm suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 678
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 679
__asm suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 681
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 682
__asm suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 684
(*retVal) = ((unsigned char)tmp); 
#line 685
} 
#endif
#line 687 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 688
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 700
::exit(___);}
#if 0
#line 688
{ 
#line 689
uint1 tmp; 
#line 690
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 691
__asm suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 693
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 694
__asm suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 696
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 697
__asm suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 699
(*retVal) = make_uchar1(tmp.x); 
#line 700
} 
#endif
#line 702 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 703
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 715
::exit(___);}
#if 0
#line 703
{ 
#line 704
short tmp; 
#line 705
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 706
__asm suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 708
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 709
__asm suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 711
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 712
__asm suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 714
(*retVal) = tmp; 
#line 715
} 
#endif
#line 717 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 718
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 730
::exit(___);}
#if 0
#line 718
{ 
#line 719
short1 tmp; 
#line 720
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 721
__asm suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 723
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 724
__asm suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 726
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 727
__asm suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 729
(*retVal) = make_short1(tmp.x); 
#line 730
} 
#endif
#line 732 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 733
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 745
::exit(___);}
#if 0
#line 733
{ 
#line 734
unsigned short tmp; 
#line 735
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 736
__asm suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 738
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 739
__asm suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 741
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 742
__asm suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 744
(*retVal) = tmp; 
#line 745
} 
#endif
#line 747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 748
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 760
::exit(___);}
#if 0
#line 748
{ 
#line 749
ushort1 tmp; 
#line 750
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 751
__asm suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 753
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 754
__asm suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 756
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 757
__asm suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 759
(*retVal) = make_ushort1(tmp.x); 
#line 760
} 
#endif
#line 762 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 763
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 775
::exit(___);}
#if 0
#line 763
{ 
#line 764
int tmp; 
#line 765
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 766
__asm suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 768
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 769
__asm suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 771
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 772
__asm suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 774
(*retVal) = tmp; 
#line 775
} 
#endif
#line 777 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 778
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 790
::exit(___);}
#if 0
#line 778
{ 
#line 779
int1 tmp; 
#line 780
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 781
__asm suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 783
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 784
__asm suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 786
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 787
__asm suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 789
(*retVal) = make_int1(tmp.x); 
#line 790
} 
#endif
#line 792 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 793
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 805
::exit(___);}
#if 0
#line 793
{ 
#line 794
unsigned tmp; 
#line 795
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 796
__asm suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 798
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 799
__asm suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 801
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 802
__asm suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 804
(*retVal) = tmp; 
#line 805
} 
#endif
#line 807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 808
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 820
::exit(___);}
#if 0
#line 808
{ 
#line 809
uint1 tmp; 
#line 810
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 811
__asm suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 813
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 814
__asm suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 816
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 817
__asm suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 819
(*retVal) = make_uint1(tmp.x); 
#line 820
} 
#endif
#line 822 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 823
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 835
::exit(___);}
#if 0
#line 823
{ 
#line 824
__int64 tmp; 
#line 825
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 826
__asm suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 828
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 829
__asm suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 831
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 832
__asm suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 834
(*retVal) = tmp; 
#line 835
} 
#endif
#line 837 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 838
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 850
::exit(___);}
#if 0
#line 838
{ 
#line 839
longlong1 tmp; 
#line 840
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 841
__asm suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 843
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 844
__asm suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 846
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 847
__asm suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 849
(*retVal) = make_longlong1(tmp.x); 
#line 850
} 
#endif
#line 852 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 853
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 865
::exit(___);}
#if 0
#line 853
{ 
#line 854
unsigned __int64 tmp; 
#line 855
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 856
__asm suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 858
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 859
__asm suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 861
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 862
__asm suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 864
(*retVal) = tmp; 
#line 865
} 
#endif
#line 867 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 868
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 880
::exit(___);}
#if 0
#line 868
{ 
#line 869
ulonglong1 tmp; 
#line 870
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 871
__asm suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 873
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 874
__asm suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 876
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 877
__asm suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 879
(*retVal) = make_ulonglong1(tmp.x); 
#line 880
} 
#endif
#line 882 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 883
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 895
::exit(___);}
#if 0
#line 883
{ 
#line 884
float tmp; 
#line 885
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 886
__asm suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 888
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 889
__asm suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 891
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 892
__asm suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 894
(*retVal) = tmp; 
#line 895
} 
#endif
#line 897 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 898
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 910
::exit(___);}
#if 0
#line 898
{ 
#line 899
float1 tmp; 
#line 900
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 901
__asm suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 903
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 904
__asm suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 906
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 907
__asm suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 909
(*retVal) = make_float1(tmp.x); 
#line 910
} 
#endif
#line 918 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 919
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 931
::exit(___);}
#if 0
#line 919
{ 
#line 920
int2 tmp; 
#line 921
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 922
__asm suld.b.2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 924
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 925
__asm suld.b.2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 927
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 928
__asm suld.b.2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 930
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 931
} 
#endif
#line 933 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 934
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 946
::exit(___);}
#if 0
#line 934
{ 
#line 935
uint2 tmp; 
#line 936
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 937
__asm suld.b.2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 939
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 940
__asm suld.b.2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 942
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 943
__asm suld.b.2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 945
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 946
} 
#endif
#line 948 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 949
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 961
::exit(___);}
#if 0
#line 949
{ 
#line 950
short2 tmp; 
#line 951
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 952
__asm suld.b.2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 954
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 955
__asm suld.b.2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 957
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 958
__asm suld.b.2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 960
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 961
} 
#endif
#line 963 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 964
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 976
::exit(___);}
#if 0
#line 964
{ 
#line 965
ushort2 tmp; 
#line 966
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 967
__asm suld.b.2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 969
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 970
__asm suld.b.2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 972
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 973
__asm suld.b.2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 975
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 976
} 
#endif
#line 978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 979
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 991
::exit(___);}
#if 0
#line 979
{ 
#line 980
int2 tmp; 
#line 981
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 982
__asm suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 984
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 985
__asm suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 987
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 988
__asm suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 990
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 991
} 
#endif
#line 993 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 994
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1006
::exit(___);}
#if 0
#line 994
{ 
#line 995
uint2 tmp; 
#line 996
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 997
__asm suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 999
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1000
__asm suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1002
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1003
__asm suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 1005
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 1006
} 
#endif
#line 1008 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1009
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1021
::exit(___);}
#if 0
#line 1009
{ 
#line 1010
longlong2 tmp; 
#line 1011
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1012
__asm suld.b.2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1014
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1015
__asm suld.b.2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1017
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1018
__asm suld.b.2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 1020
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 1021
} 
#endif
#line 1023 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1024
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1036
::exit(___);}
#if 0
#line 1024
{ 
#line 1025
ulonglong2 tmp; 
#line 1026
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1027
__asm suld.b.2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1029
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1030
__asm suld.b.2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1032
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1033
__asm suld.b.2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 1035
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 1036
} 
#endif
#line 1038 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1039
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1051
::exit(___);}
#if 0
#line 1039
{ 
#line 1040
float2 tmp; 
#line 1041
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1042
__asm suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1044
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1045
__asm suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 1047
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1048
__asm suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 1050
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 1051
} 
#endif
#line 1059 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1060
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1072
::exit(___);}
#if 0
#line 1060
{ 
#line 1061
int4 tmp; 
#line 1062
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1063
__asm suld.b.2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1065
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1066
__asm suld.b.2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1068
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1069
__asm suld.b.2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1071
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1072
} 
#endif
#line 1074 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1075
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1087
::exit(___);}
#if 0
#line 1075
{ 
#line 1076
uint4 tmp; 
#line 1077
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1078
__asm suld.b.2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1080
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1081
__asm suld.b.2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1083
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1084
__asm suld.b.2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1086
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1087
} 
#endif
#line 1089 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1090
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1102
::exit(___);}
#if 0
#line 1090
{ 
#line 1091
short4 tmp; 
#line 1092
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1093
__asm suld.b.2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1095
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1096
__asm suld.b.2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1098
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1099
__asm suld.b.2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1101
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1102
} 
#endif
#line 1104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1105
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1117
::exit(___);}
#if 0
#line 1105
{ 
#line 1106
ushort4 tmp; 
#line 1107
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1108
__asm suld.b.2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1110
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1111
__asm suld.b.2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1113
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1114
__asm suld.b.2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1116
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1117
} 
#endif
#line 1119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1120
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1132
::exit(___);}
#if 0
#line 1120
{ 
#line 1121
int4 tmp; 
#line 1122
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1123
__asm suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1125
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1126
__asm suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1128
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1129
__asm suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1131
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1132
} 
#endif
#line 1134 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1135
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1147
::exit(___);}
#if 0
#line 1135
{ 
#line 1136
uint4 tmp; 
#line 1137
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1138
__asm suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1140
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1141
__asm suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1143
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1144
__asm suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1146
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1147
} 
#endif
#line 1149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1150
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1162
::exit(___);}
#if 0
#line 1150
{ 
#line 1151
float4 tmp; 
#line 1152
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1153
__asm suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1155
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1156
__asm suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 1158
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1159
__asm suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 1161
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1162
} 
#endif
#line 1170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 1171
surf2Dread(::cudaSurfaceObject_t surfObject, int x, int y, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1172
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1176
::exit(___);}
#if 0
#line 1172
{ 
#line 1173
T ret; 
#line 1174
surf2Dread(&ret, surfObject, x, y, boundaryMode); 
#line 1175
return ret; 
#line 1176
} 
#endif
#line 1184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1185
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1197
::exit(___);}
#if 0
#line 1185
{ 
#line 1186
int tmp; 
#line 1187
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1188
__asm suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1190
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1191
__asm suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1193
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1194
__asm suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1196
(*retVal) = ((char)tmp); 
#line 1197
} 
#endif
#line 1199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1200
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1212
::exit(___);}
#if 0
#line 1200
{ 
#line 1201
int tmp; 
#line 1202
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1203
__asm suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1205
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1206
__asm suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1208
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1209
__asm suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1211
(*retVal) = ((signed char)tmp); 
#line 1212
} 
#endif
#line 1214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1215
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1227
::exit(___);}
#if 0
#line 1215
{ 
#line 1216
int1 tmp; 
#line 1217
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1218
__asm suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1220
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1221
__asm suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1223
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1224
__asm suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1226
(*retVal) = make_char1(tmp.x); 
#line 1227
} 
#endif
#line 1229 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1230
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1242
::exit(___);}
#if 0
#line 1230
{ 
#line 1231
unsigned tmp; 
#line 1232
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1233
__asm suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1235
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1236
__asm suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1238
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1239
__asm suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1241
(*retVal) = ((unsigned char)tmp); 
#line 1242
} 
#endif
#line 1244 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1245
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1257
::exit(___);}
#if 0
#line 1245
{ 
#line 1246
uint1 tmp; 
#line 1247
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1248
__asm suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1250
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1251
__asm suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1253
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1254
__asm suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1256
(*retVal) = make_uchar1(tmp.x); 
#line 1257
} 
#endif
#line 1259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1260
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1272
::exit(___);}
#if 0
#line 1260
{ 
#line 1261
short tmp; 
#line 1262
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1263
__asm suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1265
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1266
__asm suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1268
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1269
__asm suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1271
(*retVal) = tmp; 
#line 1272
} 
#endif
#line 1274 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1275
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1287
::exit(___);}
#if 0
#line 1275
{ 
#line 1276
short1 tmp; 
#line 1277
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1278
__asm suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1280
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1281
__asm suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1283
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1284
__asm suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1286
(*retVal) = make_short1(tmp.x); 
#line 1287
} 
#endif
#line 1289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1290
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1302
::exit(___);}
#if 0
#line 1290
{ 
#line 1291
unsigned short tmp; 
#line 1292
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1293
__asm suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1295
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1296
__asm suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1298
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1299
__asm suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1301
(*retVal) = tmp; 
#line 1302
} 
#endif
#line 1304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1305
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1317
::exit(___);}
#if 0
#line 1305
{ 
#line 1306
ushort1 tmp; 
#line 1307
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1308
__asm suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1310
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1311
__asm suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1313
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1314
__asm suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1316
(*retVal) = make_ushort1(tmp.x); 
#line 1317
} 
#endif
#line 1319 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1320
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1332
::exit(___);}
#if 0
#line 1320
{ 
#line 1321
int tmp; 
#line 1322
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1323
__asm suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1325
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1326
__asm suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1328
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1329
__asm suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1331
(*retVal) = tmp; 
#line 1332
} 
#endif
#line 1334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1335
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1347
::exit(___);}
#if 0
#line 1335
{ 
#line 1336
int1 tmp; 
#line 1337
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1338
__asm suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1340
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1341
__asm suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1343
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1344
__asm suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1346
(*retVal) = make_int1(tmp.x); 
#line 1347
} 
#endif
#line 1349 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1350
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1362
::exit(___);}
#if 0
#line 1350
{ 
#line 1351
unsigned tmp; 
#line 1352
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1353
__asm suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1355
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1356
__asm suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1358
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1359
__asm suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1361
(*retVal) = tmp; 
#line 1362
} 
#endif
#line 1364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1365
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1377
::exit(___);}
#if 0
#line 1365
{ 
#line 1366
uint1 tmp; 
#line 1367
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1368
__asm suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1370
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1371
__asm suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1373
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1374
__asm suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1376
(*retVal) = make_uint1(tmp.x); 
#line 1377
} 
#endif
#line 1379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1380
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1392
::exit(___);}
#if 0
#line 1380
{ 
#line 1381
__int64 tmp; 
#line 1382
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1383
__asm suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1385
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1386
__asm suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1388
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1389
__asm suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1391
(*retVal) = tmp; 
#line 1392
} 
#endif
#line 1394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1395
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1407
::exit(___);}
#if 0
#line 1395
{ 
#line 1396
longlong1 tmp; 
#line 1397
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1398
__asm suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1400
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1401
__asm suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1403
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1404
__asm suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1406
(*retVal) = make_longlong1(tmp.x); 
#line 1407
} 
#endif
#line 1409 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1410
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1422
::exit(___);}
#if 0
#line 1410
{ 
#line 1411
unsigned __int64 tmp; 
#line 1412
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1413
__asm suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1415
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1416
__asm suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1418
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1419
__asm suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1421
(*retVal) = tmp; 
#line 1422
} 
#endif
#line 1424 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1425
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1437
::exit(___);}
#if 0
#line 1425
{ 
#line 1426
ulonglong1 tmp; 
#line 1427
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1428
__asm suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1430
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1431
__asm suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1433
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1434
__asm suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1436
(*retVal) = make_ulonglong1(tmp.x); 
#line 1437
} 
#endif
#line 1439 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1440
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1452
::exit(___);}
#if 0
#line 1440
{ 
#line 1441
float tmp; 
#line 1442
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1443
__asm suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1445
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1446
__asm suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1448
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1449
__asm suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1451
(*retVal) = tmp; 
#line 1452
} 
#endif
#line 1454 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1455
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1467
::exit(___);}
#if 0
#line 1455
{ 
#line 1456
float1 tmp; 
#line 1457
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1458
__asm suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1460
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1461
__asm suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 1463
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1464
__asm suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 1466
(*retVal) = make_float1(tmp.x); 
#line 1467
} 
#endif
#line 1475 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1476
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1488
::exit(___);}
#if 0
#line 1476
{ 
#line 1477
int2 tmp; 
#line 1478
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1479
__asm suld.b.3d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1481
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1482
__asm suld.b.3d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1484
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1485
__asm suld.b.3d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1487
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 1488
} 
#endif
#line 1490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1491
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1503
::exit(___);}
#if 0
#line 1491
{ 
#line 1492
uint2 tmp; 
#line 1493
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1494
__asm suld.b.3d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1496
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1497
__asm suld.b.3d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1499
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1500
__asm suld.b.3d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1502
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 1503
} 
#endif
#line 1505 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1506
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1518
::exit(___);}
#if 0
#line 1506
{ 
#line 1507
short2 tmp; 
#line 1508
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1509
__asm suld.b.3d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1511
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1512
__asm suld.b.3d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1514
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1515
__asm suld.b.3d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1517
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 1518
} 
#endif
#line 1520 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1521
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1533
::exit(___);}
#if 0
#line 1521
{ 
#line 1522
ushort2 tmp; 
#line 1523
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1524
__asm suld.b.3d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1526
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1527
__asm suld.b.3d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1529
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1530
__asm suld.b.3d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1532
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 1533
} 
#endif
#line 1535 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1536
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1548
::exit(___);}
#if 0
#line 1536
{ 
#line 1537
int2 tmp; 
#line 1538
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1539
__asm suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1541
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1542
__asm suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1544
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1545
__asm suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1547
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 1548
} 
#endif
#line 1550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1551
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1563
::exit(___);}
#if 0
#line 1551
{ 
#line 1552
uint2 tmp; 
#line 1553
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1554
__asm suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1556
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1557
__asm suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1559
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1560
__asm suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1562
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 1563
} 
#endif
#line 1565 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1566
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1578
::exit(___);}
#if 0
#line 1566
{ 
#line 1567
longlong2 tmp; 
#line 1568
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1569
__asm suld.b.3d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1571
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1572
__asm suld.b.3d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1574
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1575
__asm suld.b.3d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1577
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 1578
} 
#endif
#line 1580 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1581
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1593
::exit(___);}
#if 0
#line 1581
{ 
#line 1582
ulonglong2 tmp; 
#line 1583
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1584
__asm suld.b.3d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1586
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1587
__asm suld.b.3d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1589
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1590
__asm suld.b.3d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1592
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 1593
} 
#endif
#line 1595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1596
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1608
::exit(___);}
#if 0
#line 1596
{ 
#line 1597
float2 tmp; 
#line 1598
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1599
__asm suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1601
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1602
__asm suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 1604
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1605
__asm suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 1607
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 1608
} 
#endif
#line 1616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1617
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1629
::exit(___);}
#if 0
#line 1617
{ 
#line 1618
int4 tmp; 
#line 1619
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1620
__asm suld.b.3d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1622
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1623
__asm suld.b.3d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1625
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1626
__asm suld.b.3d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1628
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1629
} 
#endif
#line 1631 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1632
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1644
::exit(___);}
#if 0
#line 1632
{ 
#line 1633
uint4 tmp; 
#line 1634
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1635
__asm suld.b.3d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1637
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1638
__asm suld.b.3d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1640
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1641
__asm suld.b.3d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1643
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1644
} 
#endif
#line 1646 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1647
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1659
::exit(___);}
#if 0
#line 1647
{ 
#line 1648
short4 tmp; 
#line 1649
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1650
__asm suld.b.3d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1652
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1653
__asm suld.b.3d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1655
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1656
__asm suld.b.3d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1658
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1659
} 
#endif
#line 1661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1662
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1674
::exit(___);}
#if 0
#line 1662
{ 
#line 1663
ushort4 tmp; 
#line 1664
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1665
__asm suld.b.3d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1667
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1668
__asm suld.b.3d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1670
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1671
__asm suld.b.3d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1673
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1674
} 
#endif
#line 1676 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1677
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1689
::exit(___);}
#if 0
#line 1677
{ 
#line 1678
int4 tmp; 
#line 1679
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1680
__asm suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1682
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1683
__asm suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1685
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1686
__asm suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1688
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1689
} 
#endif
#line 1691 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1692
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1704
::exit(___);}
#if 0
#line 1692
{ 
#line 1693
uint4 tmp; 
#line 1694
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1695
__asm suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1697
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1698
__asm suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1700
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1701
__asm suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1703
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1704
} 
#endif
#line 1706 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1707
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1719
::exit(___);}
#if 0
#line 1707
{ 
#line 1708
float4 tmp; 
#line 1709
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1710
__asm suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1712
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1713
__asm suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 1715
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1716
__asm suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 1718
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1719
} 
#endif
#line 1727 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 1728
surf3Dread(::cudaSurfaceObject_t surfObject, int x, int y, int z, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1729
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1733
::exit(___);}
#if 0
#line 1729
{ 
#line 1730
T ret; 
#line 1731
surf3Dread(&ret, surfObject, x, y, z, boundaryMode); 
#line 1732
return ret; 
#line 1733
} 
#endif
#line 1741 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1742
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1754
::exit(___);}
#if 0
#line 1742
{ 
#line 1743
int tmp; 
#line 1744
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1745
__asm suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1747
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1748
__asm suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1750
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1751
__asm suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1753
(*retVal) = ((char)tmp); 
#line 1754
} 
#endif
#line 1756 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1757
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1769
::exit(___);}
#if 0
#line 1757
{ 
#line 1758
int tmp; 
#line 1759
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1760
__asm suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1762
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1763
__asm suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1765
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1766
__asm suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1768
(*retVal) = ((signed char)tmp); 
#line 1769
} 
#endif
#line 1771 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1772
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1784
::exit(___);}
#if 0
#line 1772
{ 
#line 1773
int1 tmp; 
#line 1774
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1775
__asm suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1777
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1778
__asm suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1780
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1781
__asm suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1783
(*retVal) = make_char1(tmp.x); 
#line 1784
} 
#endif
#line 1786 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1787
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1799
::exit(___);}
#if 0
#line 1787
{ 
#line 1788
unsigned tmp; 
#line 1789
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1790
__asm suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1792
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1793
__asm suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1795
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1796
__asm suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1798
(*retVal) = ((unsigned char)tmp); 
#line 1799
} 
#endif
#line 1801 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1802
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1814
::exit(___);}
#if 0
#line 1802
{ 
#line 1803
uint1 tmp; 
#line 1804
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1805
__asm suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1807
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1808
__asm suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1810
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1811
__asm suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1813
(*retVal) = make_uchar1(tmp.x); 
#line 1814
} 
#endif
#line 1816 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1817
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1829
::exit(___);}
#if 0
#line 1817
{ 
#line 1818
short tmp; 
#line 1819
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1820
__asm suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1822
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1823
__asm suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1825
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1826
__asm suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1828
(*retVal) = tmp; 
#line 1829
} 
#endif
#line 1831 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1832
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1844
::exit(___);}
#if 0
#line 1832
{ 
#line 1833
short1 tmp; 
#line 1834
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1835
__asm suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1837
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1838
__asm suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1840
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1841
__asm suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1843
(*retVal) = make_short1(tmp.x); 
#line 1844
} 
#endif
#line 1846 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1847
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1859
::exit(___);}
#if 0
#line 1847
{ 
#line 1848
unsigned short tmp; 
#line 1849
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1850
__asm suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1852
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1853
__asm suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1855
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1856
__asm suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1858
(*retVal) = tmp; 
#line 1859
} 
#endif
#line 1861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1862
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1874
::exit(___);}
#if 0
#line 1862
{ 
#line 1863
ushort1 tmp; 
#line 1864
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1865
__asm suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1867
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1868
__asm suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1870
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1871
__asm suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1873
(*retVal) = make_ushort1(tmp.x); 
#line 1874
} 
#endif
#line 1876 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1877
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1889
::exit(___);}
#if 0
#line 1877
{ 
#line 1878
int tmp; 
#line 1879
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1880
__asm suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1882
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1883
__asm suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1885
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1886
__asm suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1888
(*retVal) = tmp; 
#line 1889
} 
#endif
#line 1891 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1892
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1904
::exit(___);}
#if 0
#line 1892
{ 
#line 1893
int1 tmp; 
#line 1894
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1895
__asm suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1897
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1898
__asm suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1900
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1901
__asm suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1903
(*retVal) = make_int1(tmp.x); 
#line 1904
} 
#endif
#line 1906 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1907
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1919
::exit(___);}
#if 0
#line 1907
{ 
#line 1908
unsigned tmp; 
#line 1909
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1910
__asm suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1912
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1913
__asm suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1915
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1916
__asm suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1918
(*retVal) = tmp; 
#line 1919
} 
#endif
#line 1921 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1922
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1934
::exit(___);}
#if 0
#line 1922
{ 
#line 1923
uint1 tmp; 
#line 1924
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1925
__asm suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1927
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1928
__asm suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1930
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1931
__asm suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1933
(*retVal) = make_uint1(tmp.x); 
#line 1934
} 
#endif
#line 1936 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1937
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1949
::exit(___);}
#if 0
#line 1937
{ 
#line 1938
__int64 tmp; 
#line 1939
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1940
__asm suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1942
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1943
__asm suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1945
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1946
__asm suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1948
(*retVal) = tmp; 
#line 1949
} 
#endif
#line 1951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1952
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1964
::exit(___);}
#if 0
#line 1952
{ 
#line 1953
longlong1 tmp; 
#line 1954
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1955
__asm suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1957
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1958
__asm suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1960
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1961
__asm suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1963
(*retVal) = make_longlong1(tmp.x); 
#line 1964
} 
#endif
#line 1966 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1967
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1979
::exit(___);}
#if 0
#line 1967
{ 
#line 1968
unsigned __int64 tmp; 
#line 1969
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1970
__asm suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1972
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1973
__asm suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1975
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1976
__asm suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1978
(*retVal) = tmp; 
#line 1979
} 
#endif
#line 1981 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1982
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1994
::exit(___);}
#if 0
#line 1982
{ 
#line 1983
ulonglong1 tmp; 
#line 1984
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1985
__asm suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 1987
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1988
__asm suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 1990
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1991
__asm suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 1993
(*retVal) = make_ulonglong1(tmp.x); 
#line 1994
} 
#endif
#line 1996 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1997
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2009
::exit(___);}
#if 0
#line 1997
{ 
#line 1998
float tmp; 
#line 1999
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2000
__asm suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 2002
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2003
__asm suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 2005
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2006
__asm suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 2008
(*retVal) = tmp; 
#line 2009
} 
#endif
#line 2011 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2012
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2024
::exit(___);}
#if 0
#line 2012
{ 
#line 2013
float1 tmp; 
#line 2014
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2015
__asm suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];
} else { 
#line 2017
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2018
__asm suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];
} else { 
#line 2020
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2021
__asm suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];
}  }  }  
#line 2023
(*retVal) = make_float1(tmp.x); 
#line 2024
} 
#endif
#line 2032 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2033
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2045
::exit(___);}
#if 0
#line 2033
{ 
#line 2034
int2 tmp; 
#line 2035
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2036
__asm suld.b.a1d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2038
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2039
__asm suld.b.a1d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2041
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2042
__asm suld.b.a1d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2044
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 2045
} 
#endif
#line 2047 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2048
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2060
::exit(___);}
#if 0
#line 2048
{ 
#line 2049
uint2 tmp; 
#line 2050
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2051
__asm suld.b.a1d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2053
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2054
__asm suld.b.a1d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2056
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2057
__asm suld.b.a1d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2059
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 2060
} 
#endif
#line 2062 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2063
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2075
::exit(___);}
#if 0
#line 2063
{ 
#line 2064
short2 tmp; 
#line 2065
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2066
__asm suld.b.a1d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2068
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2069
__asm suld.b.a1d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2071
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2072
__asm suld.b.a1d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2074
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 2075
} 
#endif
#line 2077 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2078
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2090
::exit(___);}
#if 0
#line 2078
{ 
#line 2079
ushort2 tmp; 
#line 2080
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2081
__asm suld.b.a1d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2083
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2084
__asm suld.b.a1d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2086
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2087
__asm suld.b.a1d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2089
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 2090
} 
#endif
#line 2092 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2093
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2105
::exit(___);}
#if 0
#line 2093
{ 
#line 2094
int2 tmp; 
#line 2095
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2096
__asm suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2098
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2099
__asm suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2101
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2102
__asm suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2104
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 2105
} 
#endif
#line 2107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2108
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2120
::exit(___);}
#if 0
#line 2108
{ 
#line 2109
uint2 tmp; 
#line 2110
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2111
__asm suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2113
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2114
__asm suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2116
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2117
__asm suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2119
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 2120
} 
#endif
#line 2122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2123
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2135
::exit(___);}
#if 0
#line 2123
{ 
#line 2124
longlong2 tmp; 
#line 2125
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2126
__asm suld.b.a1d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2128
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2129
__asm suld.b.a1d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2131
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2132
__asm suld.b.a1d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2134
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 2135
} 
#endif
#line 2137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2138
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2150
::exit(___);}
#if 0
#line 2138
{ 
#line 2139
ulonglong2 tmp; 
#line 2140
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2141
__asm suld.b.a1d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2143
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2144
__asm suld.b.a1d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2146
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2147
__asm suld.b.a1d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2149
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 2150
} 
#endif
#line 2152 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2153
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2165
::exit(___);}
#if 0
#line 2153
{ 
#line 2154
float2 tmp; 
#line 2155
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2156
__asm suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2158
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2159
__asm suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];
} else { 
#line 2161
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2162
__asm suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];
}  }  }  
#line 2164
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 2165
} 
#endif
#line 2173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2174
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2186
::exit(___);}
#if 0
#line 2174
{ 
#line 2175
int4 tmp; 
#line 2176
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2177
__asm suld.b.a1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2179
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2180
__asm suld.b.a1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2182
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2183
__asm suld.b.a1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2185
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2186
} 
#endif
#line 2188 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2189
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2201
::exit(___);}
#if 0
#line 2189
{ 
#line 2190
uint4 tmp; 
#line 2191
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2192
__asm suld.b.a1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2194
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2195
__asm suld.b.a1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2197
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2198
__asm suld.b.a1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2200
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2201
} 
#endif
#line 2203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2204
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2216
::exit(___);}
#if 0
#line 2204
{ 
#line 2205
short4 tmp; 
#line 2206
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2207
__asm suld.b.a1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2209
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2210
__asm suld.b.a1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2212
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2213
__asm suld.b.a1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2215
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2216
} 
#endif
#line 2218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2219
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2231
::exit(___);}
#if 0
#line 2219
{ 
#line 2220
ushort4 tmp; 
#line 2221
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2222
__asm suld.b.a1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2224
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2225
__asm suld.b.a1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2227
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2228
__asm suld.b.a1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2230
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2231
} 
#endif
#line 2233 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2234
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2246
::exit(___);}
#if 0
#line 2234
{ 
#line 2235
int4 tmp; 
#line 2236
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2237
__asm suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2239
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2240
__asm suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2242
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2243
__asm suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2245
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2246
} 
#endif
#line 2248 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2249
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2261
::exit(___);}
#if 0
#line 2249
{ 
#line 2250
uint4 tmp; 
#line 2251
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2252
__asm suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2254
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2255
__asm suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2257
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2258
__asm suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2260
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2261
} 
#endif
#line 2263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2264
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2276
::exit(___);}
#if 0
#line 2264
{ 
#line 2265
float4 tmp; 
#line 2266
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2267
__asm suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2269
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2270
__asm suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];
} else { 
#line 2272
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2273
__asm suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];
}  }  }  
#line 2275
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2276
} 
#endif
#line 2284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 2285
surf1DLayeredread(::cudaSurfaceObject_t surfObject, int x, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2286
{int volatile ___ = 1;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2290
::exit(___);}
#if 0
#line 2286
{ 
#line 2287
T ret; 
#line 2288
surf1DLayeredread(&ret, surfObject, x, layer, boundaryMode); 
#line 2289
return ret; 
#line 2290
} 
#endif
#line 2298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2299
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2311
::exit(___);}
#if 0
#line 2299
{ 
#line 2300
int tmp; 
#line 2301
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2302
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2304
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2305
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2307
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2308
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2310
(*retVal) = ((char)tmp); 
#line 2311
} 
#endif
#line 2313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2314
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2326
::exit(___);}
#if 0
#line 2314
{ 
#line 2315
int tmp; 
#line 2316
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2317
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2319
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2320
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2322
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2323
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2325
(*retVal) = ((signed char)tmp); 
#line 2326
} 
#endif
#line 2328 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2329
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2341
::exit(___);}
#if 0
#line 2329
{ 
#line 2330
int1 tmp; 
#line 2331
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2332
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2334
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2335
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2337
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2338
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2340
(*retVal) = make_char1(tmp.x); 
#line 2341
} 
#endif
#line 2343 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2344
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2356
::exit(___);}
#if 0
#line 2344
{ 
#line 2345
unsigned tmp; 
#line 2346
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2347
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2349
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2350
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2352
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2353
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2355
(*retVal) = ((unsigned char)tmp); 
#line 2356
} 
#endif
#line 2358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2359
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2371
::exit(___);}
#if 0
#line 2359
{ 
#line 2360
uint1 tmp; 
#line 2361
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2362
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2364
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2365
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2367
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2368
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2370
(*retVal) = make_uchar1(tmp.x); 
#line 2371
} 
#endif
#line 2373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2374
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2386
::exit(___);}
#if 0
#line 2374
{ 
#line 2375
short tmp; 
#line 2376
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2377
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2379
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2380
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2382
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2383
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2385
(*retVal) = tmp; 
#line 2386
} 
#endif
#line 2388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2389
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2401
::exit(___);}
#if 0
#line 2389
{ 
#line 2390
short1 tmp; 
#line 2391
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2392
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2394
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2395
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2397
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2398
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2400
(*retVal) = make_short1(tmp.x); 
#line 2401
} 
#endif
#line 2403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2404
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2416
::exit(___);}
#if 0
#line 2404
{ 
#line 2405
unsigned short tmp; 
#line 2406
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2407
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2409
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2410
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2412
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2413
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2415
(*retVal) = tmp; 
#line 2416
} 
#endif
#line 2418 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2419
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2431
::exit(___);}
#if 0
#line 2419
{ 
#line 2420
ushort1 tmp; 
#line 2421
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2422
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2424
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2425
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2427
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2428
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2430
(*retVal) = make_ushort1(tmp.x); 
#line 2431
} 
#endif
#line 2433 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2434
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2446
::exit(___);}
#if 0
#line 2434
{ 
#line 2435
int tmp; 
#line 2436
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2437
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2439
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2440
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2442
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2443
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2445
(*retVal) = tmp; 
#line 2446
} 
#endif
#line 2448 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2449
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2461
::exit(___);}
#if 0
#line 2449
{ 
#line 2450
int1 tmp; 
#line 2451
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2452
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2454
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2455
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2457
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2458
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2460
(*retVal) = make_int1(tmp.x); 
#line 2461
} 
#endif
#line 2463 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2464
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2476
::exit(___);}
#if 0
#line 2464
{ 
#line 2465
unsigned tmp; 
#line 2466
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2467
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2469
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2470
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2472
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2473
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2475
(*retVal) = tmp; 
#line 2476
} 
#endif
#line 2478 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2479
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2491
::exit(___);}
#if 0
#line 2479
{ 
#line 2480
uint1 tmp; 
#line 2481
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2482
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2484
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2485
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2487
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2488
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2490
(*retVal) = make_uint1(tmp.x); 
#line 2491
} 
#endif
#line 2493 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2494
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2506
::exit(___);}
#if 0
#line 2494
{ 
#line 2495
__int64 tmp; 
#line 2496
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2497
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2499
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2500
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2502
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2503
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2505
(*retVal) = tmp; 
#line 2506
} 
#endif
#line 2508 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2509
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2521
::exit(___);}
#if 0
#line 2509
{ 
#line 2510
longlong1 tmp; 
#line 2511
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2512
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2514
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2515
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2517
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2518
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2520
(*retVal) = make_longlong1(tmp.x); 
#line 2521
} 
#endif
#line 2523 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2524
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2536
::exit(___);}
#if 0
#line 2524
{ 
#line 2525
unsigned __int64 tmp; 
#line 2526
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2527
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2529
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2530
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2532
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2533
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2535
(*retVal) = tmp; 
#line 2536
} 
#endif
#line 2538 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2539
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2551
::exit(___);}
#if 0
#line 2539
{ 
#line 2540
ulonglong1 tmp; 
#line 2541
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2542
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2544
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2545
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2547
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2548
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2550
(*retVal) = make_ulonglong1(tmp.x); 
#line 2551
} 
#endif
#line 2553 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2554
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2566
::exit(___);}
#if 0
#line 2554
{ 
#line 2555
float tmp; 
#line 2556
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2557
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2559
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2560
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2562
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2563
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2565
(*retVal) = tmp; 
#line 2566
} 
#endif
#line 2568 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2569
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2581
::exit(___);}
#if 0
#line 2569
{ 
#line 2570
float1 tmp; 
#line 2571
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2572
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2574
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2575
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2577
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2578
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2580
(*retVal) = make_float1(tmp.x); 
#line 2581
} 
#endif
#line 2589 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2590
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2602
::exit(___);}
#if 0
#line 2590
{ 
#line 2591
int2 tmp; 
#line 2592
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2593
__asm suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2595
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2596
__asm suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2598
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2599
__asm suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2601
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 2602
} 
#endif
#line 2604 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2605
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2617
::exit(___);}
#if 0
#line 2605
{ 
#line 2606
uint2 tmp; 
#line 2607
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2608
__asm suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2610
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2611
__asm suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2613
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2614
__asm suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2616
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 2617
} 
#endif
#line 2619 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2620
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2632
::exit(___);}
#if 0
#line 2620
{ 
#line 2621
short2 tmp; 
#line 2622
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2623
__asm suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2625
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2626
__asm suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2628
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2629
__asm suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2631
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 2632
} 
#endif
#line 2634 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2635
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2647
::exit(___);}
#if 0
#line 2635
{ 
#line 2636
ushort2 tmp; 
#line 2637
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2638
__asm suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2640
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2641
__asm suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2643
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2644
__asm suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2646
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 2647
} 
#endif
#line 2649 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2650
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2662
::exit(___);}
#if 0
#line 2650
{ 
#line 2651
int2 tmp; 
#line 2652
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2653
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2655
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2656
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2658
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2659
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2661
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 2662
} 
#endif
#line 2664 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2665
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2677
::exit(___);}
#if 0
#line 2665
{ 
#line 2666
uint2 tmp; 
#line 2667
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2668
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2670
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2671
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2673
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2674
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2676
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 2677
} 
#endif
#line 2679 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2680
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2692
::exit(___);}
#if 0
#line 2680
{ 
#line 2681
longlong2 tmp; 
#line 2682
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2683
__asm suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2685
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2686
__asm suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2688
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2689
__asm suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2691
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 2692
} 
#endif
#line 2694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2695
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2707
::exit(___);}
#if 0
#line 2695
{ 
#line 2696
ulonglong2 tmp; 
#line 2697
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2698
__asm suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2700
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2701
__asm suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2703
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2704
__asm suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2706
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 2707
} 
#endif
#line 2709 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2710
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2722
::exit(___);}
#if 0
#line 2710
{ 
#line 2711
float2 tmp; 
#line 2712
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2713
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2715
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2716
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 2718
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2719
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 2721
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 2722
} 
#endif
#line 2730 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2731
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2743
::exit(___);}
#if 0
#line 2731
{ 
#line 2732
int4 tmp; 
#line 2733
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2734
__asm suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2736
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2737
__asm suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2739
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2740
__asm suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2742
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2743
} 
#endif
#line 2745 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2746
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2758
::exit(___);}
#if 0
#line 2746
{ 
#line 2747
uint4 tmp; 
#line 2748
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2749
__asm suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2751
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2752
__asm suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2754
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2755
__asm suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2757
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2758
} 
#endif
#line 2760 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2761
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2773
::exit(___);}
#if 0
#line 2761
{ 
#line 2762
short4 tmp; 
#line 2763
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2764
__asm suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2766
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2767
__asm suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2769
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2770
__asm suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2772
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2773
} 
#endif
#line 2775 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2776
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2788
::exit(___);}
#if 0
#line 2776
{ 
#line 2777
ushort4 tmp; 
#line 2778
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2779
__asm suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2781
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2782
__asm suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2784
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2785
__asm suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2787
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2788
} 
#endif
#line 2790 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2791
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2803
::exit(___);}
#if 0
#line 2791
{ 
#line 2792
int4 tmp; 
#line 2793
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2794
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2796
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2797
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2799
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2800
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2802
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2803
} 
#endif
#line 2805 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2806
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2818
::exit(___);}
#if 0
#line 2806
{ 
#line 2807
uint4 tmp; 
#line 2808
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2809
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2811
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2812
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2814
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2815
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2817
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2818
} 
#endif
#line 2820 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2821
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2833
::exit(___);}
#if 0
#line 2821
{ 
#line 2822
float4 tmp; 
#line 2823
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2824
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2826
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2827
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 2829
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2830
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 2832
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2833
} 
#endif
#line 2841 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 2842
surf2DLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2843
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2847
::exit(___);}
#if 0
#line 2843
{ 
#line 2844
T ret; 
#line 2845
surf2DLayeredread(&ret, surfObject, x, y, layer, boundaryMode); 
#line 2846
return ret; 
#line 2847
} 
#endif
#line 2855 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2856
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2868
::exit(___);}
#if 0
#line 2856
{ 
#line 2857
int tmp; 
#line 2858
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2859
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2861
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2862
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2864
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2865
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2867
(*retVal) = ((char)tmp); 
#line 2868
} 
#endif
#line 2870 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2871
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2883
::exit(___);}
#if 0
#line 2871
{ 
#line 2872
int tmp; 
#line 2873
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2874
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2876
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2877
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2879
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2880
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2882
(*retVal) = ((signed char)tmp); 
#line 2883
} 
#endif
#line 2885 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2886
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2898
::exit(___);}
#if 0
#line 2886
{ 
#line 2887
int1 tmp; 
#line 2888
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2889
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2891
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2892
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2894
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2895
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2897
(*retVal) = make_char1(tmp.x); 
#line 2898
} 
#endif
#line 2900 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2901
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2913
::exit(___);}
#if 0
#line 2901
{ 
#line 2902
unsigned tmp; 
#line 2903
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2904
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2906
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2907
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2909
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2910
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2912
(*retVal) = ((unsigned char)tmp); 
#line 2913
} 
#endif
#line 2915 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2916
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2928
::exit(___);}
#if 0
#line 2916
{ 
#line 2917
uint1 tmp; 
#line 2918
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2919
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2921
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2922
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2924
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2925
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2927
(*retVal) = make_uchar1(tmp.x); 
#line 2928
} 
#endif
#line 2930 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2931
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2943
::exit(___);}
#if 0
#line 2931
{ 
#line 2932
short tmp; 
#line 2933
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2934
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2936
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2937
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2939
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2940
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2942
(*retVal) = tmp; 
#line 2943
} 
#endif
#line 2945 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2946
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2958
::exit(___);}
#if 0
#line 2946
{ 
#line 2947
short1 tmp; 
#line 2948
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2949
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2951
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2952
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2954
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2955
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2957
(*retVal) = make_short1(tmp.x); 
#line 2958
} 
#endif
#line 2960 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2961
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2973
::exit(___);}
#if 0
#line 2961
{ 
#line 2962
unsigned short tmp; 
#line 2963
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2964
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2966
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2967
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2969
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2970
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2972
(*retVal) = tmp; 
#line 2973
} 
#endif
#line 2975 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2976
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2988
::exit(___);}
#if 0
#line 2976
{ 
#line 2977
ushort1 tmp; 
#line 2978
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2979
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2981
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2982
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2984
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2985
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 2987
(*retVal) = make_ushort1(tmp.x); 
#line 2988
} 
#endif
#line 2990 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 2991
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3003
::exit(___);}
#if 0
#line 2991
{ 
#line 2992
int tmp; 
#line 2993
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2994
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2996
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2997
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 2999
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3000
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3002
(*retVal) = tmp; 
#line 3003
} 
#endif
#line 3005 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3006
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3018
::exit(___);}
#if 0
#line 3006
{ 
#line 3007
int1 tmp; 
#line 3008
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3009
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3011
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3012
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3014
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3015
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3017
(*retVal) = make_int1(tmp.x); 
#line 3018
} 
#endif
#line 3020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3021
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3033
::exit(___);}
#if 0
#line 3021
{ 
#line 3022
unsigned tmp; 
#line 3023
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3024
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3026
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3027
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3029
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3030
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3032
(*retVal) = tmp; 
#line 3033
} 
#endif
#line 3035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3036
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3048
::exit(___);}
#if 0
#line 3036
{ 
#line 3037
uint1 tmp; 
#line 3038
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3039
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3041
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3042
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3044
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3045
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3047
(*retVal) = make_uint1(tmp.x); 
#line 3048
} 
#endif
#line 3050 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3051
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3063
::exit(___);}
#if 0
#line 3051
{ 
#line 3052
__int64 tmp; 
#line 3053
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3054
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3056
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3057
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3059
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3060
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3062
(*retVal) = tmp; 
#line 3063
} 
#endif
#line 3065 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3066
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3078
::exit(___);}
#if 0
#line 3066
{ 
#line 3067
longlong1 tmp; 
#line 3068
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3069
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3071
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3072
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3074
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3075
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3077
(*retVal) = make_longlong1(tmp.x); 
#line 3078
} 
#endif
#line 3080 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3081
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3093
::exit(___);}
#if 0
#line 3081
{ 
#line 3082
unsigned __int64 tmp; 
#line 3083
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3084
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3086
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3087
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3089
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3090
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3092
(*retVal) = tmp; 
#line 3093
} 
#endif
#line 3095 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3096
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3108
::exit(___);}
#if 0
#line 3096
{ 
#line 3097
ulonglong1 tmp; 
#line 3098
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3099
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3101
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3102
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3104
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3105
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3107
(*retVal) = make_ulonglong1(tmp.x); 
#line 3108
} 
#endif
#line 3110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3111
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3123
::exit(___);}
#if 0
#line 3111
{ 
#line 3112
float tmp; 
#line 3113
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3114
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3116
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3117
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3119
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3120
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3122
(*retVal) = tmp; 
#line 3123
} 
#endif
#line 3125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3126
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3138
::exit(___);}
#if 0
#line 3126
{ 
#line 3127
float1 tmp; 
#line 3128
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3129
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3131
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3132
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3134
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3135
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3137
(*retVal) = make_float1(tmp.x); 
#line 3138
} 
#endif
#line 3146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3147
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3159
::exit(___);}
#if 0
#line 3147
{ 
#line 3148
int2 tmp; 
#line 3149
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3150
__asm suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3152
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3153
__asm suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3155
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3156
__asm suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3158
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 3159
} 
#endif
#line 3161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3162
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3174
::exit(___);}
#if 0
#line 3162
{ 
#line 3163
uint2 tmp; 
#line 3164
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3165
__asm suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3167
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3168
__asm suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3170
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3171
__asm suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3173
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 3174
} 
#endif
#line 3176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3177
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3189
::exit(___);}
#if 0
#line 3177
{ 
#line 3178
short2 tmp; 
#line 3179
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3180
__asm suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3182
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3183
__asm suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3185
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3186
__asm suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3188
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 3189
} 
#endif
#line 3191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3192
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3204
::exit(___);}
#if 0
#line 3192
{ 
#line 3193
ushort2 tmp; 
#line 3194
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3195
__asm suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3197
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3198
__asm suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3200
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3201
__asm suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3203
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 3204
} 
#endif
#line 3206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3207
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3219
::exit(___);}
#if 0
#line 3207
{ 
#line 3208
int2 tmp; 
#line 3209
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3210
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3212
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3213
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3215
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3216
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3218
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 3219
} 
#endif
#line 3221 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3222
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3234
::exit(___);}
#if 0
#line 3222
{ 
#line 3223
uint2 tmp; 
#line 3224
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3225
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3227
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3228
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3230
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3231
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3233
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 3234
} 
#endif
#line 3236 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3237
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3249
::exit(___);}
#if 0
#line 3237
{ 
#line 3238
longlong2 tmp; 
#line 3239
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3240
__asm suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3242
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3243
__asm suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3245
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3246
__asm suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3248
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 3249
} 
#endif
#line 3251 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3252
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3264
::exit(___);}
#if 0
#line 3252
{ 
#line 3253
ulonglong2 tmp; 
#line 3254
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3255
__asm suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3257
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3258
__asm suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3260
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3261
__asm suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3263
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 3264
} 
#endif
#line 3266 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3267
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3279
::exit(___);}
#if 0
#line 3267
{ 
#line 3268
float2 tmp; 
#line 3269
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3270
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3272
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3273
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3275
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3276
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3278
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 3279
} 
#endif
#line 3287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3288
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3300
::exit(___);}
#if 0
#line 3288
{ 
#line 3289
int4 tmp; 
#line 3290
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3291
__asm suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3293
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3294
__asm suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3296
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3297
__asm suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3299
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3300
} 
#endif
#line 3302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3303
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3315
::exit(___);}
#if 0
#line 3303
{ 
#line 3304
uint4 tmp; 
#line 3305
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3306
__asm suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3308
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3309
__asm suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3311
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3312
__asm suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3314
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3315
} 
#endif
#line 3317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3318
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3330
::exit(___);}
#if 0
#line 3318
{ 
#line 3319
short4 tmp; 
#line 3320
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3321
__asm suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3323
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3324
__asm suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3326
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3327
__asm suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3329
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3330
} 
#endif
#line 3332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3333
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3345
::exit(___);}
#if 0
#line 3333
{ 
#line 3334
ushort4 tmp; 
#line 3335
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3336
__asm suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3338
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3339
__asm suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3341
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3342
__asm suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3344
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3345
} 
#endif
#line 3347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3348
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3360
::exit(___);}
#if 0
#line 3348
{ 
#line 3349
int4 tmp; 
#line 3350
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3351
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3353
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3354
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3356
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3357
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3359
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3360
} 
#endif
#line 3362 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3363
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3375
::exit(___);}
#if 0
#line 3363
{ 
#line 3364
uint4 tmp; 
#line 3365
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3366
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3368
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3369
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3371
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3372
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3374
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3375
} 
#endif
#line 3377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3378
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3390
::exit(___);}
#if 0
#line 3378
{ 
#line 3379
float4 tmp; 
#line 3380
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3381
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3383
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3384
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3386
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3387
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3389
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3390
} 
#endif
#line 3398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 3399
surfCubemapread(::cudaSurfaceObject_t surfObject, int x, int y, int face, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3400
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3404
::exit(___);}
#if 0
#line 3400
{ 
#line 3401
T ret; 
#line 3402
surfCubemapread(&ret, surfObject, face, x, y, boundaryMode); 
#line 3403
return ret; 
#line 3404
} 
#endif
#line 3412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3413
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3425
::exit(___);}
#if 0
#line 3413
{ 
#line 3414
int tmp; 
#line 3415
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3416
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3418
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3419
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3421
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3422
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3424
(*retVal) = ((char)tmp); 
#line 3425
} 
#endif
#line 3427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3428
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3440
::exit(___);}
#if 0
#line 3428
{ 
#line 3429
int tmp; 
#line 3430
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3431
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3433
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3434
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3436
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3437
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3439
(*retVal) = ((signed char)tmp); 
#line 3440
} 
#endif
#line 3442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3443
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3455
::exit(___);}
#if 0
#line 3443
{ 
#line 3444
int1 tmp; 
#line 3445
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3446
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3448
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3449
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3451
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3452
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3454
(*retVal) = make_char1(tmp.x); 
#line 3455
} 
#endif
#line 3457 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3458
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3470
::exit(___);}
#if 0
#line 3458
{ 
#line 3459
unsigned tmp; 
#line 3460
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3461
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3463
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3464
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3466
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3467
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3469
(*retVal) = ((unsigned char)tmp); 
#line 3470
} 
#endif
#line 3472 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3473
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3485
::exit(___);}
#if 0
#line 3473
{ 
#line 3474
uint1 tmp; 
#line 3475
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3476
__asm suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3478
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3479
__asm suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3481
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3482
__asm suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3484
(*retVal) = make_uchar1(tmp.x); 
#line 3485
} 
#endif
#line 3487 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3488
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3500
::exit(___);}
#if 0
#line 3488
{ 
#line 3489
short tmp; 
#line 3490
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3491
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3493
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3494
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3496
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3497
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3499
(*retVal) = tmp; 
#line 3500
} 
#endif
#line 3502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3503
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3515
::exit(___);}
#if 0
#line 3503
{ 
#line 3504
short1 tmp; 
#line 3505
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3506
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3508
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3509
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3511
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3512
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3514
(*retVal) = make_short1(tmp.x); 
#line 3515
} 
#endif
#line 3517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3518
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3530
::exit(___);}
#if 0
#line 3518
{ 
#line 3519
unsigned short tmp; 
#line 3520
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3521
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3523
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3524
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3526
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3527
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3529
(*retVal) = tmp; 
#line 3530
} 
#endif
#line 3532 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3533
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3545
::exit(___);}
#if 0
#line 3533
{ 
#line 3534
ushort1 tmp; 
#line 3535
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3536
__asm suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3538
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3539
__asm suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3541
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3542
__asm suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3544
(*retVal) = make_ushort1(tmp.x); 
#line 3545
} 
#endif
#line 3547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3548
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3560
::exit(___);}
#if 0
#line 3548
{ 
#line 3549
int tmp; 
#line 3550
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3551
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3553
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3554
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3556
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3557
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3559
(*retVal) = tmp; 
#line 3560
} 
#endif
#line 3562 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3563
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3575
::exit(___);}
#if 0
#line 3563
{ 
#line 3564
int1 tmp; 
#line 3565
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3566
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3568
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3569
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3571
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3572
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3574
(*retVal) = make_int1(tmp.x); 
#line 3575
} 
#endif
#line 3577 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3578
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3590
::exit(___);}
#if 0
#line 3578
{ 
#line 3579
unsigned tmp; 
#line 3580
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3581
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3583
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3584
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3586
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3587
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3589
(*retVal) = tmp; 
#line 3590
} 
#endif
#line 3592 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3593
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3605
::exit(___);}
#if 0
#line 3593
{ 
#line 3594
uint1 tmp; 
#line 3595
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3596
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3598
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3599
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3601
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3602
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3604
(*retVal) = make_uint1(tmp.x); 
#line 3605
} 
#endif
#line 3607 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3608
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3620
::exit(___);}
#if 0
#line 3608
{ 
#line 3609
__int64 tmp; 
#line 3610
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3611
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3613
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3614
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3616
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3617
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3619
(*retVal) = tmp; 
#line 3620
} 
#endif
#line 3622 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3623
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3635
::exit(___);}
#if 0
#line 3623
{ 
#line 3624
longlong1 tmp; 
#line 3625
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3626
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3628
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3629
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3631
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3632
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3634
(*retVal) = make_longlong1(tmp.x); 
#line 3635
} 
#endif
#line 3637 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3638
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3650
::exit(___);}
#if 0
#line 3638
{ 
#line 3639
unsigned __int64 tmp; 
#line 3640
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3641
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3643
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3644
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3646
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3647
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3649
(*retVal) = tmp; 
#line 3650
} 
#endif
#line 3652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3653
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3665
::exit(___);}
#if 0
#line 3653
{ 
#line 3654
ulonglong1 tmp; 
#line 3655
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3656
__asm suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3658
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3659
__asm suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3661
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3662
__asm suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3664
(*retVal) = make_ulonglong1(tmp.x); 
#line 3665
} 
#endif
#line 3667 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3668
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3680
::exit(___);}
#if 0
#line 3668
{ 
#line 3669
float tmp; 
#line 3670
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3671
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3673
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3674
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3676
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3677
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3679
(*retVal) = tmp; 
#line 3680
} 
#endif
#line 3682 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3683
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3695
::exit(___);}
#if 0
#line 3683
{ 
#line 3684
float1 tmp; 
#line 3685
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3686
__asm suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3688
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3689
__asm suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];
} else { 
#line 3691
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3692
__asm suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];
}  }  }  
#line 3694
(*retVal) = make_float1(tmp.x); 
#line 3695
} 
#endif
#line 3703 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3704
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3716
::exit(___);}
#if 0
#line 3704
{ 
#line 3705
int2 tmp; 
#line 3706
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3707
__asm suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3709
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3710
__asm suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3712
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3713
__asm suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3715
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 3716
} 
#endif
#line 3718 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3719
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3731
::exit(___);}
#if 0
#line 3719
{ 
#line 3720
uint2 tmp; 
#line 3721
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3722
__asm suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3724
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3725
__asm suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3727
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3728
__asm suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3730
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 3731
} 
#endif
#line 3733 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3734
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3746
::exit(___);}
#if 0
#line 3734
{ 
#line 3735
short2 tmp; 
#line 3736
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3737
__asm suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3739
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3740
__asm suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3742
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3743
__asm suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3745
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 3746
} 
#endif
#line 3748 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3749
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3761
::exit(___);}
#if 0
#line 3749
{ 
#line 3750
ushort2 tmp; 
#line 3751
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3752
__asm suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3754
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3755
__asm suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3757
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3758
__asm suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3760
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 3761
} 
#endif
#line 3763 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3764
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3776
::exit(___);}
#if 0
#line 3764
{ 
#line 3765
int2 tmp; 
#line 3766
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3767
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3769
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3770
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3772
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3773
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3775
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 3776
} 
#endif
#line 3778 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3779
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3791
::exit(___);}
#if 0
#line 3779
{ 
#line 3780
uint2 tmp; 
#line 3781
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3782
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3784
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3785
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3787
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3788
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3790
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 3791
} 
#endif
#line 3793 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3794
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3806
::exit(___);}
#if 0
#line 3794
{ 
#line 3795
longlong2 tmp; 
#line 3796
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3797
__asm suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3799
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3800
__asm suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3802
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3803
__asm suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3805
(*retVal) = make_longlong2(tmp.x, tmp.y); 
#line 3806
} 
#endif
#line 3808 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3809
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3821
::exit(___);}
#if 0
#line 3809
{ 
#line 3810
ulonglong2 tmp; 
#line 3811
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3812
__asm suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3814
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3815
__asm suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3817
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3818
__asm suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3820
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
#line 3821
} 
#endif
#line 3823 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3824
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3836
::exit(___);}
#if 0
#line 3824
{ 
#line 3825
float2 tmp; 
#line 3826
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3827
__asm suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3829
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3830
__asm suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];
} else { 
#line 3832
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3833
__asm suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];
}  }  }  
#line 3835
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 3836
} 
#endif
#line 3844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3845
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3857
::exit(___);}
#if 0
#line 3845
{ 
#line 3846
int4 tmp; 
#line 3847
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3848
__asm suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3850
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3851
__asm suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3853
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3854
__asm suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3856
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3857
} 
#endif
#line 3859 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3860
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3872
::exit(___);}
#if 0
#line 3860
{ 
#line 3861
uint4 tmp; 
#line 3862
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3863
__asm suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3865
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3866
__asm suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3868
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3869
__asm suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3871
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3872
} 
#endif
#line 3874 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3875
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3887
::exit(___);}
#if 0
#line 3875
{ 
#line 3876
short4 tmp; 
#line 3877
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3878
__asm suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3880
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3881
__asm suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3883
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3884
__asm suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3886
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3887
} 
#endif
#line 3889 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3890
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3902
::exit(___);}
#if 0
#line 3890
{ 
#line 3891
ushort4 tmp; 
#line 3892
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3893
__asm suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3895
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3896
__asm suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3898
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3899
__asm suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3901
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3902
} 
#endif
#line 3904 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3905
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3917
::exit(___);}
#if 0
#line 3905
{ 
#line 3906
int4 tmp; 
#line 3907
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3908
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3910
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3911
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3913
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3914
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3916
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3917
} 
#endif
#line 3919 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3920
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3932
::exit(___);}
#if 0
#line 3920
{ 
#line 3921
uint4 tmp; 
#line 3922
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3923
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3925
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3926
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3928
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3929
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3931
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3932
} 
#endif
#line 3934 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3935
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3947
::exit(___);}
#if 0
#line 3935
{ 
#line 3936
float4 tmp; 
#line 3937
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3938
__asm suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3940
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3941
__asm suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
} else { 
#line 3943
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3944
__asm suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];
}  }  }  
#line 3946
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3947
} 
#endif
#line 3955 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
template< class T> static __forceinline T 
#line 3956
surfCubemapLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3957
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 3961
::exit(___);}
#if 0
#line 3957
{ 
#line 3958
T ret; 
#line 3959
surfCubemapLayeredread(&ret, surfObject, x, y, z, layerface, boundaryMode); 
#line 3960
return ret; 
#line 3961
} 
#endif
#line 3969 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3970
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 3980
::exit(___);}
#if 0
#line 3970
{ 
#line 3971
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3972
__asm sust.b.1d.b8.trap  [%0, {%1}], {%2};
} else { 
#line 3974
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3975
__asm sust.b.1d.b8.clamp [%0, {%1}], {%2};
} else { 
#line 3977
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3978
__asm sust.b.1d.b8.zero  [%0, {%1}], {%2};
}  }  }  
#line 3980
} 
#endif
#line 3982 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3983
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 3993
::exit(___);}
#if 0
#line 3983
{ 
#line 3984
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3985
__asm sust.b.1d.b8.trap  [%0, {%1}], {%2};
} else { 
#line 3987
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3988
__asm sust.b.1d.b8.clamp [%0, {%1}], {%2};
} else { 
#line 3990
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3991
__asm sust.b.1d.b8.zero  [%0, {%1}], {%2};
}  }  }  
#line 3993
} 
#endif
#line 3995 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 3996
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4006
::exit(___);}
#if 0
#line 3996
{ 
#line 3997
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3998
__asm sust.b.1d.b8.trap  [%0, {%1}], {%2};
} else { 
#line 4000
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4001
__asm sust.b.1d.b8.clamp [%0, {%1}], {%2};
} else { 
#line 4003
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4004
__asm sust.b.1d.b8.zero  [%0, {%1}], {%2};
}  }  }  
#line 4006
} 
#endif
#line 4008 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4009
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4019
::exit(___);}
#if 0
#line 4009
{ 
#line 4010
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4011
__asm sust.b.1d.b8.trap  [%0, {%1}], {%2};
} else { 
#line 4013
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4014
__asm sust.b.1d.b8.clamp [%0, {%1}], {%2};
} else { 
#line 4016
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4017
__asm sust.b.1d.b8.zero  [%0, {%1}], {%2};
}  }  }  
#line 4019
} 
#endif
#line 4021 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4022
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4032
::exit(___);}
#if 0
#line 4022
{ 
#line 4023
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4024
__asm sust.b.1d.b8.trap  [%0, {%1}], {%2};
} else { 
#line 4026
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4027
__asm sust.b.1d.b8.clamp [%0, {%1}], {%2};
} else { 
#line 4029
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4030
__asm sust.b.1d.b8.zero  [%0, {%1}], {%2};
}  }  }  
#line 4032
} 
#endif
#line 4034 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4035
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4045
::exit(___);}
#if 0
#line 4035
{ 
#line 4036
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4037
__asm sust.b.1d.b16.trap  [%0, {%1}], {%2};
} else { 
#line 4039
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4040
__asm sust.b.1d.b16.clamp [%0, {%1}], {%2};
} else { 
#line 4042
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4043
__asm sust.b.1d.b16.zero  [%0, {%1}], {%2};
}  }  }  
#line 4045
} 
#endif
#line 4047 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4048
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4058
::exit(___);}
#if 0
#line 4048
{ 
#line 4049
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4050
__asm sust.b.1d.b16.trap  [%0, {%1}], {%2};
} else { 
#line 4052
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4053
__asm sust.b.1d.b16.clamp [%0, {%1}], {%2};
} else { 
#line 4055
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4056
__asm sust.b.1d.b16.zero  [%0, {%1}], {%2};
}  }  }  
#line 4058
} 
#endif
#line 4060 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4061
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4071
::exit(___);}
#if 0
#line 4061
{ 
#line 4062
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4063
__asm sust.b.1d.b16.trap  [%0, {%1}], {%2};
} else { 
#line 4065
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4066
__asm sust.b.1d.b16.clamp [%0, {%1}], {%2};
} else { 
#line 4068
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4069
__asm sust.b.1d.b16.zero  [%0, {%1}], {%2};
}  }  }  
#line 4071
} 
#endif
#line 4073 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4074
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4084
::exit(___);}
#if 0
#line 4074
{ 
#line 4075
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4076
__asm sust.b.1d.b16.trap  [%0, {%1}], {%2};
} else { 
#line 4078
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4079
__asm sust.b.1d.b16.clamp [%0, {%1}], {%2};
} else { 
#line 4081
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4082
__asm sust.b.1d.b16.zero  [%0, {%1}], {%2};
}  }  }  
#line 4084
} 
#endif
#line 4086 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(int data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4087
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4097
::exit(___);}
#if 0
#line 4087
{ 
#line 4088
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4089
__asm sust.b.1d.b32.trap  [%0, {%1}], {%2};
} else { 
#line 4091
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4092
__asm sust.b.1d.b32.clamp [%0, {%1}], {%2};
} else { 
#line 4094
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4095
__asm sust.b.1d.b32.zero  [%0, {%1}], {%2};
}  }  }  
#line 4097
} 
#endif
#line 4099 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4100
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4110
::exit(___);}
#if 0
#line 4100
{ 
#line 4101
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4102
__asm sust.b.1d.b32.trap  [%0, {%1}], {%2};
} else { 
#line 4104
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4105
__asm sust.b.1d.b32.clamp [%0, {%1}], {%2};
} else { 
#line 4107
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4108
__asm sust.b.1d.b32.zero  [%0, {%1}], {%2};
}  }  }  
#line 4110
} 
#endif
#line 4112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4113
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4123
::exit(___);}
#if 0
#line 4113
{ 
#line 4114
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4115
__asm sust.b.1d.b32.trap  [%0, {%1}], {%2};
} else { 
#line 4117
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4118
__asm sust.b.1d.b32.clamp [%0, {%1}], {%2};
} else { 
#line 4120
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4121
__asm sust.b.1d.b32.zero  [%0, {%1}], {%2};
}  }  }  
#line 4123
} 
#endif
#line 4125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4126
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4136
::exit(___);}
#if 0
#line 4126
{ 
#line 4127
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4128
__asm sust.b.1d.b32.trap  [%0, {%1}], {%2};
} else { 
#line 4130
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4131
__asm sust.b.1d.b32.clamp [%0, {%1}], {%2};
} else { 
#line 4133
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4134
__asm sust.b.1d.b32.zero  [%0, {%1}], {%2};
}  }  }  
#line 4136
} 
#endif
#line 4138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4139
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4149
::exit(___);}
#if 0
#line 4139
{ 
#line 4140
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4141
__asm sust.b.1d.b64.trap  [%0, {%1}], {%2};
} else { 
#line 4143
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4144
__asm sust.b.1d.b64.clamp [%0, {%1}], {%2};
} else { 
#line 4146
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4147
__asm sust.b.1d.b64.zero  [%0, {%1}], {%2};
}  }  }  
#line 4149
} 
#endif
#line 4151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4152
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4162
::exit(___);}
#if 0
#line 4152
{ 
#line 4153
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4154
__asm sust.b.1d.b64.trap  [%0, {%1}], {%2};
} else { 
#line 4156
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4157
__asm sust.b.1d.b64.clamp [%0, {%1}], {%2};
} else { 
#line 4159
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4160
__asm sust.b.1d.b64.zero  [%0, {%1}], {%2};
}  }  }  
#line 4162
} 
#endif
#line 4164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4165
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4175
::exit(___);}
#if 0
#line 4165
{ 
#line 4166
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4167
__asm sust.b.1d.b64.trap  [%0, {%1}], {%2};
} else { 
#line 4169
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4170
__asm sust.b.1d.b64.clamp [%0, {%1}], {%2};
} else { 
#line 4172
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4173
__asm sust.b.1d.b64.zero  [%0, {%1}], {%2};
}  }  }  
#line 4175
} 
#endif
#line 4177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4178
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4188
::exit(___);}
#if 0
#line 4178
{ 
#line 4179
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4180
__asm sust.b.1d.b64.trap  [%0, {%1}], {%2};
} else { 
#line 4182
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4183
__asm sust.b.1d.b64.clamp [%0, {%1}], {%2};
} else { 
#line 4185
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4186
__asm sust.b.1d.b64.zero  [%0, {%1}], {%2};
}  }  }  
#line 4188
} 
#endif
#line 4190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(float data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4191
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4201
::exit(___);}
#if 0
#line 4191
{ 
#line 4192
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4193
__asm sust.b.1d.b32.trap  [%0, {%1}], {%2};
} else { 
#line 4195
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4196
__asm sust.b.1d.b32.clamp [%0, {%1}], {%2};
} else { 
#line 4198
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4199
__asm sust.b.1d.b32.zero  [%0, {%1}], {%2};
}  }  }  
#line 4201
} 
#endif
#line 4203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4204
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4214
::exit(___);}
#if 0
#line 4204
{ 
#line 4205
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4206
__asm sust.b.1d.b32.trap  [%0, {%1}], {%2};
} else { 
#line 4208
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4209
__asm sust.b.1d.b32.clamp [%0, {%1}], {%2};
} else { 
#line 4211
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4212
__asm sust.b.1d.b32.zero  [%0, {%1}], {%2};
}  }  }  
#line 4214
} 
#endif
#line 4222 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4223
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4233
::exit(___);}
#if 0
#line 4223
{ 
#line 4224
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4225
__asm sust.b.1d.v2.b8.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4227
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4228
__asm sust.b.1d.v2.b8.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4230
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4231
__asm sust.b.1d.v2.b8.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4233
} 
#endif
#line 4235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4236
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4246
::exit(___);}
#if 0
#line 4236
{ 
#line 4237
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4238
__asm sust.b.1d.v2.b8.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4240
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4241
__asm sust.b.1d.v2.b8.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4243
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4244
__asm sust.b.1d.v2.b8.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4246
} 
#endif
#line 4248 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4249
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4259
::exit(___);}
#if 0
#line 4249
{ 
#line 4250
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4251
__asm sust.b.1d.v2.b16.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4253
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4254
__asm sust.b.1d.v2.b16.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4256
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4257
__asm sust.b.1d.v2.b16.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4259
} 
#endif
#line 4261 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4262
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4272
::exit(___);}
#if 0
#line 4262
{ 
#line 4263
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4264
__asm sust.b.1d.v2.b16.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4266
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4267
__asm sust.b.1d.v2.b16.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4269
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4270
__asm sust.b.1d.v2.b16.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4272
} 
#endif
#line 4274 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4275
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4285
::exit(___);}
#if 0
#line 4275
{ 
#line 4276
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4277
__asm sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4279
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4280
__asm sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4282
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4283
__asm sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4285
} 
#endif
#line 4287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4288
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4298
::exit(___);}
#if 0
#line 4288
{ 
#line 4289
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4290
__asm sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4292
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4293
__asm sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4295
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4296
__asm sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4298
} 
#endif
#line 4300 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4301
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4311
::exit(___);}
#if 0
#line 4301
{ 
#line 4302
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4303
__asm sust.b.1d.v2.b64.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4305
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4306
__asm sust.b.1d.v2.b64.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4308
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4309
__asm sust.b.1d.v2.b64.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4311
} 
#endif
#line 4313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4314
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4324
::exit(___);}
#if 0
#line 4314
{ 
#line 4315
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4316
__asm sust.b.1d.v2.b64.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4318
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4319
__asm sust.b.1d.v2.b64.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4321
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4322
__asm sust.b.1d.v2.b64.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4324
} 
#endif
#line 4326 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4327
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4337
::exit(___);}
#if 0
#line 4327
{ 
#line 4328
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4329
__asm sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};
} else { 
#line 4331
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4332
__asm sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};
} else { 
#line 4334
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4335
__asm sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};
}  }  }  
#line 4337
} 
#endif
#line 4345 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4346
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4356
::exit(___);}
#if 0
#line 4346
{ 
#line 4347
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4348
__asm sust.b.1d.v4.b8.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4350
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4351
__asm sust.b.1d.v4.b8.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4353
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4354
__asm sust.b.1d.v4.b8.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4356
} 
#endif
#line 4358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4359
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4369
::exit(___);}
#if 0
#line 4359
{ 
#line 4360
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4361
__asm sust.b.1d.v4.b8.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4363
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4364
__asm sust.b.1d.v4.b8.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4366
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4367
__asm sust.b.1d.v4.b8.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4369
} 
#endif
#line 4371 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4372
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4382
::exit(___);}
#if 0
#line 4372
{ 
#line 4373
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4374
__asm sust.b.1d.v4.b16.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4376
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4377
__asm sust.b.1d.v4.b16.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4379
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4380
__asm sust.b.1d.v4.b16.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4382
} 
#endif
#line 4384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4385
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4395
::exit(___);}
#if 0
#line 4385
{ 
#line 4386
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4387
__asm sust.b.1d.v4.b16.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4389
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4390
__asm sust.b.1d.v4.b16.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4392
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4393
__asm sust.b.1d.v4.b16.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4395
} 
#endif
#line 4397 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4398
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4408
::exit(___);}
#if 0
#line 4398
{ 
#line 4399
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4400
__asm sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4402
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4403
__asm sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4405
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4406
__asm sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4408
} 
#endif
#line 4410 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4411
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4421
::exit(___);}
#if 0
#line 4411
{ 
#line 4412
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4413
__asm sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4415
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4416
__asm sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4418
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4419
__asm sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4421
} 
#endif
#line 4423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4424
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4434
::exit(___);}
#if 0
#line 4424
{ 
#line 4425
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4426
__asm sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4428
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4429
__asm sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};
} else { 
#line 4431
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4432
__asm sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};
}  }  }  
#line 4434
} 
#endif
#line 4442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4443
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4453
::exit(___);}
#if 0
#line 4443
{ 
#line 4444
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4445
__asm sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4447
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4448
__asm sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4450
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4451
__asm sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4453
} 
#endif
#line 4455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4456
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4466
::exit(___);}
#if 0
#line 4456
{ 
#line 4457
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4458
__asm sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4460
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4461
__asm sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4463
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4464
__asm sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4466
} 
#endif
#line 4468 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4469
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4479
::exit(___);}
#if 0
#line 4469
{ 
#line 4470
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4471
__asm sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4473
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4474
__asm sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4476
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4477
__asm sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4479
} 
#endif
#line 4481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4482
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4492
::exit(___);}
#if 0
#line 4482
{ 
#line 4483
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4484
__asm sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4486
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4487
__asm sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4489
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4490
__asm sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4492
} 
#endif
#line 4494 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4495
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4505
::exit(___);}
#if 0
#line 4495
{ 
#line 4496
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4497
__asm sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4499
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4500
__asm sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4502
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4503
__asm sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4505
} 
#endif
#line 4507 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4508
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4518
::exit(___);}
#if 0
#line 4508
{ 
#line 4509
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4510
__asm sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4512
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4513
__asm sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4515
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4516
__asm sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4518
} 
#endif
#line 4520 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4521
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4531
::exit(___);}
#if 0
#line 4521
{ 
#line 4522
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4523
__asm sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4525
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4526
__asm sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4528
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4529
__asm sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4531
} 
#endif
#line 4533 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4534
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4544
::exit(___);}
#if 0
#line 4534
{ 
#line 4535
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4536
__asm sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4538
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4539
__asm sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4541
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4542
__asm sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4544
} 
#endif
#line 4546 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4547
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4557
::exit(___);}
#if 0
#line 4547
{ 
#line 4548
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4549
__asm sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4551
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4552
__asm sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4554
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4555
__asm sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4557
} 
#endif
#line 4559 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4560
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4570
::exit(___);}
#if 0
#line 4560
{ 
#line 4561
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4562
__asm sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4564
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4565
__asm sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4567
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4568
__asm sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4570
} 
#endif
#line 4572 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4573
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4583
::exit(___);}
#if 0
#line 4573
{ 
#line 4574
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4575
__asm sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4577
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4578
__asm sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4580
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4581
__asm sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4583
} 
#endif
#line 4585 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4586
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4596
::exit(___);}
#if 0
#line 4586
{ 
#line 4587
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4588
__asm sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4590
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4591
__asm sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4593
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4594
__asm sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4596
} 
#endif
#line 4598 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4599
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4609
::exit(___);}
#if 0
#line 4599
{ 
#line 4600
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4601
__asm sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4603
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4604
__asm sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4606
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4607
__asm sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4609
} 
#endif
#line 4611 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4612
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4622
::exit(___);}
#if 0
#line 4612
{ 
#line 4613
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4614
__asm sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4616
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4617
__asm sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4619
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4620
__asm sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4622
} 
#endif
#line 4624 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4625
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4635
::exit(___);}
#if 0
#line 4625
{ 
#line 4626
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4627
__asm sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4629
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4630
__asm sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4632
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4633
__asm sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4635
} 
#endif
#line 4637 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4638
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4648
::exit(___);}
#if 0
#line 4638
{ 
#line 4639
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4640
__asm sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4642
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4643
__asm sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4645
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4646
__asm sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4648
} 
#endif
#line 4650 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4651
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4661
::exit(___);}
#if 0
#line 4651
{ 
#line 4652
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4653
__asm sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4655
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4656
__asm sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4658
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4659
__asm sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4661
} 
#endif
#line 4663 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4664
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4674
::exit(___);}
#if 0
#line 4664
{ 
#line 4665
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4666
__asm sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4668
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4669
__asm sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4671
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4672
__asm sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4674
} 
#endif
#line 4676 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4677
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4687
::exit(___);}
#if 0
#line 4677
{ 
#line 4678
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4679
__asm sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 4681
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4682
__asm sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 4684
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4685
__asm sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 4687
} 
#endif
#line 4695 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4696
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4706
::exit(___);}
#if 0
#line 4696
{ 
#line 4697
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4698
__asm sust.b.2d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4700
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4701
__asm sust.b.2d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4703
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4704
__asm sust.b.2d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4706
} 
#endif
#line 4708 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4709
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4719
::exit(___);}
#if 0
#line 4709
{ 
#line 4710
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4711
__asm sust.b.2d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4713
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4714
__asm sust.b.2d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4716
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4717
__asm sust.b.2d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4719
} 
#endif
#line 4721 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4722
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4732
::exit(___);}
#if 0
#line 4722
{ 
#line 4723
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4724
__asm sust.b.2d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4726
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4727
__asm sust.b.2d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4729
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4730
__asm sust.b.2d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4732
} 
#endif
#line 4734 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4735
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4745
::exit(___);}
#if 0
#line 4735
{ 
#line 4736
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4737
__asm sust.b.2d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4739
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4740
__asm sust.b.2d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4742
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4743
__asm sust.b.2d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4745
} 
#endif
#line 4747 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4748
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4758
::exit(___);}
#if 0
#line 4748
{ 
#line 4749
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4750
__asm sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4752
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4753
__asm sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4755
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4756
__asm sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4758
} 
#endif
#line 4760 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4761
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4771
::exit(___);}
#if 0
#line 4761
{ 
#line 4762
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4763
__asm sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4765
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4766
__asm sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4768
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4769
__asm sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4771
} 
#endif
#line 4773 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4774
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4784
::exit(___);}
#if 0
#line 4774
{ 
#line 4775
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4776
__asm sust.b.2d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4778
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4779
__asm sust.b.2d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4781
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4782
__asm sust.b.2d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4784
} 
#endif
#line 4786 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4787
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4797
::exit(___);}
#if 0
#line 4787
{ 
#line 4788
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4789
__asm sust.b.2d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4791
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4792
__asm sust.b.2d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4794
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4795
__asm sust.b.2d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4797
} 
#endif
#line 4799 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4800
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4810
::exit(___);}
#if 0
#line 4800
{ 
#line 4801
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4802
__asm sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 4804
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4805
__asm sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 4807
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4808
__asm sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 4810
} 
#endif
#line 4818 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4819
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4829
::exit(___);}
#if 0
#line 4819
{ 
#line 4820
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4821
__asm sust.b.2d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4823
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4824
__asm sust.b.2d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4826
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4827
__asm sust.b.2d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4829
} 
#endif
#line 4831 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4832
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4842
::exit(___);}
#if 0
#line 4832
{ 
#line 4833
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4834
__asm sust.b.2d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4836
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4837
__asm sust.b.2d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4839
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4840
__asm sust.b.2d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4842
} 
#endif
#line 4844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4845
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4855
::exit(___);}
#if 0
#line 4845
{ 
#line 4846
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4847
__asm sust.b.2d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4849
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4850
__asm sust.b.2d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4852
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4853
__asm sust.b.2d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4855
} 
#endif
#line 4857 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4858
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4868
::exit(___);}
#if 0
#line 4858
{ 
#line 4859
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4860
__asm sust.b.2d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4862
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4863
__asm sust.b.2d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4865
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4866
__asm sust.b.2d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4868
} 
#endif
#line 4870 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4871
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4881
::exit(___);}
#if 0
#line 4871
{ 
#line 4872
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4873
__asm sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4875
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4876
__asm sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4878
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4879
__asm sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4881
} 
#endif
#line 4883 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4884
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4894
::exit(___);}
#if 0
#line 4884
{ 
#line 4885
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4886
__asm sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4888
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4889
__asm sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4891
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4892
__asm sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4894
} 
#endif
#line 4896 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4897
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4907
::exit(___);}
#if 0
#line 4897
{ 
#line 4898
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4899
__asm sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4901
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4902
__asm sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 4904
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4905
__asm sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 4907
} 
#endif
#line 4915 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4916
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4926
::exit(___);}
#if 0
#line 4916
{ 
#line 4917
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4918
__asm sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4920
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4921
__asm sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4923
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4924
__asm sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 4926
} 
#endif
#line 4928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4929
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4939
::exit(___);}
#if 0
#line 4929
{ 
#line 4930
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4931
__asm sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4933
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4934
__asm sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4936
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4937
__asm sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 4939
} 
#endif
#line 4941 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4942
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4952
::exit(___);}
#if 0
#line 4942
{ 
#line 4943
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4944
__asm sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4946
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4947
__asm sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4949
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4950
__asm sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 4952
} 
#endif
#line 4954 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4955
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4965
::exit(___);}
#if 0
#line 4955
{ 
#line 4956
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4957
__asm sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4959
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4960
__asm sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4962
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4963
__asm sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 4965
} 
#endif
#line 4967 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4968
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4978
::exit(___);}
#if 0
#line 4968
{ 
#line 4969
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4970
__asm sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4972
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4973
__asm sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4975
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4976
__asm sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 4978
} 
#endif
#line 4980 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4981
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4991
::exit(___);}
#if 0
#line 4981
{ 
#line 4982
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4983
__asm sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4985
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4986
__asm sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4988
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4989
__asm sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 4991
} 
#endif
#line 4993 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 4994
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5004
::exit(___);}
#if 0
#line 4994
{ 
#line 4995
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4996
__asm sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 4998
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4999
__asm sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5001
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5002
__asm sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5004
} 
#endif
#line 5006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5007
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5017
::exit(___);}
#if 0
#line 5007
{ 
#line 5008
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5009
__asm sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5011
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5012
__asm sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5014
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5015
__asm sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5017
} 
#endif
#line 5019 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5020
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5030
::exit(___);}
#if 0
#line 5020
{ 
#line 5021
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5022
__asm sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5024
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5025
__asm sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5027
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5028
__asm sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5030
} 
#endif
#line 5032 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5033
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5043
::exit(___);}
#if 0
#line 5033
{ 
#line 5034
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5035
__asm sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5037
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5038
__asm sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5040
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5041
__asm sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5043
} 
#endif
#line 5045 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5046
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5056
::exit(___);}
#if 0
#line 5046
{ 
#line 5047
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5048
__asm sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5050
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5051
__asm sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5053
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5054
__asm sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5056
} 
#endif
#line 5058 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5059
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5069
::exit(___);}
#if 0
#line 5059
{ 
#line 5060
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5061
__asm sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5063
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5064
__asm sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5066
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5067
__asm sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5069
} 
#endif
#line 5071 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5072
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5082
::exit(___);}
#if 0
#line 5072
{ 
#line 5073
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5074
__asm sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5076
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5077
__asm sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5079
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5080
__asm sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5082
} 
#endif
#line 5084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5085
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5095
::exit(___);}
#if 0
#line 5085
{ 
#line 5086
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5087
__asm sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5089
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5090
__asm sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5092
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5093
__asm sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5095
} 
#endif
#line 5097 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5098
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5108
::exit(___);}
#if 0
#line 5098
{ 
#line 5099
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5100
__asm sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5102
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5103
__asm sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5105
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5106
__asm sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5108
} 
#endif
#line 5110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5111
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5121
::exit(___);}
#if 0
#line 5111
{ 
#line 5112
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5113
__asm sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5115
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5116
__asm sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5118
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5119
__asm sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5121
} 
#endif
#line 5123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5124
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5134
::exit(___);}
#if 0
#line 5124
{ 
#line 5125
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5126
__asm sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5128
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5129
__asm sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5131
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5132
__asm sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5134
} 
#endif
#line 5136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5137
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5147
::exit(___);}
#if 0
#line 5137
{ 
#line 5138
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5139
__asm sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5141
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5142
__asm sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5144
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5145
__asm sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5147
} 
#endif
#line 5149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5150
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5160
::exit(___);}
#if 0
#line 5150
{ 
#line 5151
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5152
__asm sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5154
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5155
__asm sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5157
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5158
__asm sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5160
} 
#endif
#line 5168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5169
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5179
::exit(___);}
#if 0
#line 5169
{ 
#line 5170
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5171
__asm sust.b.3d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5173
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5174
__asm sust.b.3d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5176
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5177
__asm sust.b.3d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5179
} 
#endif
#line 5181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5182
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5192
::exit(___);}
#if 0
#line 5182
{ 
#line 5183
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5184
__asm sust.b.3d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5186
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5187
__asm sust.b.3d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5189
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5190
__asm sust.b.3d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5192
} 
#endif
#line 5194 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5195
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5205
::exit(___);}
#if 0
#line 5195
{ 
#line 5196
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5197
__asm sust.b.3d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5199
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5200
__asm sust.b.3d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5202
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5203
__asm sust.b.3d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5205
} 
#endif
#line 5207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5208
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5218
::exit(___);}
#if 0
#line 5208
{ 
#line 5209
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5210
__asm sust.b.3d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5212
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5213
__asm sust.b.3d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5215
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5216
__asm sust.b.3d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5218
} 
#endif
#line 5220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5221
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5231
::exit(___);}
#if 0
#line 5221
{ 
#line 5222
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5223
__asm sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5225
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5226
__asm sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5228
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5229
__asm sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5231
} 
#endif
#line 5233 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5234
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5244
::exit(___);}
#if 0
#line 5234
{ 
#line 5235
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5236
__asm sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5238
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5239
__asm sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5241
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5242
__asm sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5244
} 
#endif
#line 5246 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5247
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5257
::exit(___);}
#if 0
#line 5247
{ 
#line 5248
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5249
__asm sust.b.3d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5251
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5252
__asm sust.b.3d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5254
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5255
__asm sust.b.3d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5257
} 
#endif
#line 5259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5260
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5270
::exit(___);}
#if 0
#line 5260
{ 
#line 5261
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5262
__asm sust.b.3d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5264
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5265
__asm sust.b.3d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5267
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5268
__asm sust.b.3d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5270
} 
#endif
#line 5272 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5273
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5283
::exit(___);}
#if 0
#line 5273
{ 
#line 5274
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5275
__asm sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5277
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5278
__asm sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 5280
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5281
__asm sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 5283
} 
#endif
#line 5291 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5292
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5302
::exit(___);}
#if 0
#line 5292
{ 
#line 5293
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5294
__asm sust.b.3d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5296
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5297
__asm sust.b.3d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5299
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5300
__asm sust.b.3d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5302
} 
#endif
#line 5304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5305
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5315
::exit(___);}
#if 0
#line 5305
{ 
#line 5306
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5307
__asm sust.b.3d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5309
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5310
__asm sust.b.3d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5312
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5313
__asm sust.b.3d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5315
} 
#endif
#line 5317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5318
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5328
::exit(___);}
#if 0
#line 5318
{ 
#line 5319
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5320
__asm sust.b.3d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5322
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5323
__asm sust.b.3d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5325
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5326
__asm sust.b.3d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5328
} 
#endif
#line 5330 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5331
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5341
::exit(___);}
#if 0
#line 5331
{ 
#line 5332
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5333
__asm sust.b.3d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5335
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5336
__asm sust.b.3d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5338
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5339
__asm sust.b.3d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5341
} 
#endif
#line 5343 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5344
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5354
::exit(___);}
#if 0
#line 5344
{ 
#line 5345
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5346
__asm sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5348
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5349
__asm sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5351
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5352
__asm sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5354
} 
#endif
#line 5356 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5357
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5367
::exit(___);}
#if 0
#line 5357
{ 
#line 5358
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5359
__asm sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5361
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5362
__asm sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5364
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5365
__asm sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5367
} 
#endif
#line 5369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5370
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5380
::exit(___);}
#if 0
#line 5370
{ 
#line 5371
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5372
__asm sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5374
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5375
__asm sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 5377
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5378
__asm sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 5380
} 
#endif
#line 5388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5389
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5399
::exit(___);}
#if 0
#line 5389
{ 
#line 5390
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5391
__asm sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5393
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5394
__asm sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5396
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5397
__asm sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5399
} 
#endif
#line 5401 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5402
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5412
::exit(___);}
#if 0
#line 5402
{ 
#line 5403
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5404
__asm sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5406
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5407
__asm sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5409
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5410
__asm sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5412
} 
#endif
#line 5414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5415
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5425
::exit(___);}
#if 0
#line 5415
{ 
#line 5416
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5417
__asm sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5419
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5420
__asm sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5422
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5423
__asm sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5425
} 
#endif
#line 5427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5428
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5438
::exit(___);}
#if 0
#line 5428
{ 
#line 5429
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5430
__asm sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5432
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5433
__asm sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5435
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5436
__asm sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5438
} 
#endif
#line 5440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5441
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5451
::exit(___);}
#if 0
#line 5441
{ 
#line 5442
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5443
__asm sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5445
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5446
__asm sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5448
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5449
__asm sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5451
} 
#endif
#line 5453 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5454
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5464
::exit(___);}
#if 0
#line 5454
{ 
#line 5455
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5456
__asm sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5458
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5459
__asm sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5461
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5462
__asm sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5464
} 
#endif
#line 5466 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5467
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5477
::exit(___);}
#if 0
#line 5467
{ 
#line 5468
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5469
__asm sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5471
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5472
__asm sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5474
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5475
__asm sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5477
} 
#endif
#line 5479 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5480
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5490
::exit(___);}
#if 0
#line 5480
{ 
#line 5481
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5482
__asm sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5484
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5485
__asm sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5487
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5488
__asm sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5490
} 
#endif
#line 5492 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5493
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5503
::exit(___);}
#if 0
#line 5493
{ 
#line 5494
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5495
__asm sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5497
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5498
__asm sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5500
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5501
__asm sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5503
} 
#endif
#line 5505 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5506
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5516
::exit(___);}
#if 0
#line 5506
{ 
#line 5507
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5508
__asm sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5510
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5511
__asm sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5513
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5514
__asm sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5516
} 
#endif
#line 5518 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5519
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5529
::exit(___);}
#if 0
#line 5519
{ 
#line 5520
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5521
__asm sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5523
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5524
__asm sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5526
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5527
__asm sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5529
} 
#endif
#line 5531 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5532
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5542
::exit(___);}
#if 0
#line 5532
{ 
#line 5533
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5534
__asm sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5536
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5537
__asm sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5539
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5540
__asm sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5542
} 
#endif
#line 5544 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5545
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5555
::exit(___);}
#if 0
#line 5545
{ 
#line 5546
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5547
__asm sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5549
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5550
__asm sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5552
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5553
__asm sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5555
} 
#endif
#line 5557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5558
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5568
::exit(___);}
#if 0
#line 5558
{ 
#line 5559
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5560
__asm sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5562
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5563
__asm sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5565
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5566
__asm sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5568
} 
#endif
#line 5570 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5571
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5581
::exit(___);}
#if 0
#line 5571
{ 
#line 5572
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5573
__asm sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5575
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5576
__asm sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5578
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5579
__asm sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5581
} 
#endif
#line 5583 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5584
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5594
::exit(___);}
#if 0
#line 5584
{ 
#line 5585
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5586
__asm sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5588
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5589
__asm sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5591
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5592
__asm sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5594
} 
#endif
#line 5596 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5597
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5607
::exit(___);}
#if 0
#line 5597
{ 
#line 5598
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5599
__asm sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5601
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5602
__asm sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5604
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5605
__asm sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5607
} 
#endif
#line 5609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5610
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5620
::exit(___);}
#if 0
#line 5610
{ 
#line 5611
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5612
__asm sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5614
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5615
__asm sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5617
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5618
__asm sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5620
} 
#endif
#line 5622 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5623
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5633
::exit(___);}
#if 0
#line 5623
{ 
#line 5624
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5625
__asm sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};
} else { 
#line 5627
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5628
__asm sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};
} else { 
#line 5630
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5631
__asm sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};
}  }  }  
#line 5633
} 
#endif
#line 5641 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5642
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5652
::exit(___);}
#if 0
#line 5642
{ 
#line 5643
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5644
__asm sust.b.a1d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5646
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5647
__asm sust.b.a1d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5649
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5650
__asm sust.b.a1d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5652
} 
#endif
#line 5654 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5655
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5665
::exit(___);}
#if 0
#line 5655
{ 
#line 5656
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5657
__asm sust.b.a1d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5659
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5660
__asm sust.b.a1d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5662
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5663
__asm sust.b.a1d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5665
} 
#endif
#line 5667 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5668
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5678
::exit(___);}
#if 0
#line 5668
{ 
#line 5669
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5670
__asm sust.b.a1d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5672
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5673
__asm sust.b.a1d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5675
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5676
__asm sust.b.a1d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5678
} 
#endif
#line 5680 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5681
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5691
::exit(___);}
#if 0
#line 5681
{ 
#line 5682
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5683
__asm sust.b.a1d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5685
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5686
__asm sust.b.a1d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5688
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5689
__asm sust.b.a1d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5691
} 
#endif
#line 5693 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5694
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5704
::exit(___);}
#if 0
#line 5694
{ 
#line 5695
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5696
__asm sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5698
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5699
__asm sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5701
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5702
__asm sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5704
} 
#endif
#line 5706 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5707
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5717
::exit(___);}
#if 0
#line 5707
{ 
#line 5708
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5709
__asm sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5711
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5712
__asm sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5714
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5715
__asm sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5717
} 
#endif
#line 5719 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5720
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5730
::exit(___);}
#if 0
#line 5720
{ 
#line 5721
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5722
__asm sust.b.a1d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5724
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5725
__asm sust.b.a1d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5727
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5728
__asm sust.b.a1d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5730
} 
#endif
#line 5732 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5733
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5743
::exit(___);}
#if 0
#line 5733
{ 
#line 5734
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5735
__asm sust.b.a1d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5737
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5738
__asm sust.b.a1d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5740
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5741
__asm sust.b.a1d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5743
} 
#endif
#line 5745 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5746
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5756
::exit(___);}
#if 0
#line 5746
{ 
#line 5747
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5748
__asm sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};
} else { 
#line 5750
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5751
__asm sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};
} else { 
#line 5753
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5754
__asm sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};
}  }  }  
#line 5756
} 
#endif
#line 5764 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5765
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5775
::exit(___);}
#if 0
#line 5765
{ 
#line 5766
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5767
__asm sust.b.a1d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5769
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5770
__asm sust.b.a1d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5772
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5773
__asm sust.b.a1d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5775
} 
#endif
#line 5777 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5778
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5788
::exit(___);}
#if 0
#line 5778
{ 
#line 5779
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5780
__asm sust.b.a1d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5782
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5783
__asm sust.b.a1d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5785
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5786
__asm sust.b.a1d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5788
} 
#endif
#line 5790 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5791
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5801
::exit(___);}
#if 0
#line 5791
{ 
#line 5792
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5793
__asm sust.b.a1d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5795
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5796
__asm sust.b.a1d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5798
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5799
__asm sust.b.a1d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5801
} 
#endif
#line 5803 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5804
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5814
::exit(___);}
#if 0
#line 5804
{ 
#line 5805
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5806
__asm sust.b.a1d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5808
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5809
__asm sust.b.a1d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5811
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5812
__asm sust.b.a1d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5814
} 
#endif
#line 5816 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5817
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5827
::exit(___);}
#if 0
#line 5817
{ 
#line 5818
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5819
__asm sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5821
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5822
__asm sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5824
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5825
__asm sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5827
} 
#endif
#line 5829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5830
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5840
::exit(___);}
#if 0
#line 5830
{ 
#line 5831
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5832
__asm sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5834
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5835
__asm sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5837
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5838
__asm sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5840
} 
#endif
#line 5842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5843
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5853
::exit(___);}
#if 0
#line 5843
{ 
#line 5844
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5845
__asm sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5847
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5848
__asm sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};
} else { 
#line 5850
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5851
__asm sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};
}  }  }  
#line 5853
} 
#endif
#line 5861 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5862
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5872
::exit(___);}
#if 0
#line 5862
{ 
#line 5863
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5864
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5866
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5867
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5869
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5870
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5872
} 
#endif
#line 5874 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5875
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5885
::exit(___);}
#if 0
#line 5875
{ 
#line 5876
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5877
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5879
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5880
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5882
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5883
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5885
} 
#endif
#line 5887 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5888
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5898
::exit(___);}
#if 0
#line 5888
{ 
#line 5889
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5890
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5892
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5893
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5895
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5896
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5898
} 
#endif
#line 5900 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5901
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5911
::exit(___);}
#if 0
#line 5901
{ 
#line 5902
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5903
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5905
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5906
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5908
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5909
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5911
} 
#endif
#line 5913 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5914
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5924
::exit(___);}
#if 0
#line 5914
{ 
#line 5915
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5916
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5918
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5919
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5921
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5922
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5924
} 
#endif
#line 5926 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5927
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5937
::exit(___);}
#if 0
#line 5927
{ 
#line 5928
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5929
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5931
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5932
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5934
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5935
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5937
} 
#endif
#line 5939 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5940
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5950
::exit(___);}
#if 0
#line 5940
{ 
#line 5941
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5942
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5944
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5945
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5947
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5948
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5950
} 
#endif
#line 5952 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5953
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5963
::exit(___);}
#if 0
#line 5953
{ 
#line 5954
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5955
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5957
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5958
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5960
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5961
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5963
} 
#endif
#line 5965 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5966
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5976
::exit(___);}
#if 0
#line 5966
{ 
#line 5967
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5968
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5970
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5971
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5973
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5974
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5976
} 
#endif
#line 5978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5979
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5989
::exit(___);}
#if 0
#line 5979
{ 
#line 5980
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5981
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5983
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5984
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5986
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5987
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 5989
} 
#endif
#line 5991 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 5992
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6002
::exit(___);}
#if 0
#line 5992
{ 
#line 5993
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5994
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5996
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5997
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 5999
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6000
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6002
} 
#endif
#line 6004 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6005
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6015
::exit(___);}
#if 0
#line 6005
{ 
#line 6006
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6007
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6009
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6010
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6012
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6013
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6015
} 
#endif
#line 6017 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6018
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6028
::exit(___);}
#if 0
#line 6018
{ 
#line 6019
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6020
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6022
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6023
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6025
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6026
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6028
} 
#endif
#line 6030 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6031
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6041
::exit(___);}
#if 0
#line 6031
{ 
#line 6032
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6033
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6035
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6036
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6038
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6039
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6041
} 
#endif
#line 6043 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6044
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6054
::exit(___);}
#if 0
#line 6044
{ 
#line 6045
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6046
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6048
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6049
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6051
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6052
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6054
} 
#endif
#line 6056 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6057
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6067
::exit(___);}
#if 0
#line 6057
{ 
#line 6058
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6059
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6061
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6062
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6064
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6065
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6067
} 
#endif
#line 6069 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6070
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6080
::exit(___);}
#if 0
#line 6070
{ 
#line 6071
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6072
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6074
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6075
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6077
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6078
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6080
} 
#endif
#line 6082 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6083
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6093
::exit(___);}
#if 0
#line 6083
{ 
#line 6084
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6085
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6087
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6088
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6090
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6091
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6093
} 
#endif
#line 6095 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6096
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6106
::exit(___);}
#if 0
#line 6096
{ 
#line 6097
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6098
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6100
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6101
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6103
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6104
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6106
} 
#endif
#line 6114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6115
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6125
::exit(___);}
#if 0
#line 6115
{ 
#line 6116
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6117
__asm sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6119
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6120
__asm sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6122
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6123
__asm sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6125
} 
#endif
#line 6127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6128
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6138
::exit(___);}
#if 0
#line 6128
{ 
#line 6129
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6130
__asm sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6132
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6133
__asm sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6135
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6136
__asm sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6138
} 
#endif
#line 6140 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6141
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6151
::exit(___);}
#if 0
#line 6141
{ 
#line 6142
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6143
__asm sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6145
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6146
__asm sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6148
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6149
__asm sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6151
} 
#endif
#line 6153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6154
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6164
::exit(___);}
#if 0
#line 6154
{ 
#line 6155
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6156
__asm sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6158
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6159
__asm sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6161
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6162
__asm sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6164
} 
#endif
#line 6166 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6167
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6177
::exit(___);}
#if 0
#line 6167
{ 
#line 6168
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6169
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6171
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6172
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6174
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6175
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6177
} 
#endif
#line 6179 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6180
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6190
::exit(___);}
#if 0
#line 6180
{ 
#line 6181
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6182
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6184
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6185
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6187
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6188
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6190
} 
#endif
#line 6192 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6193
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6203
::exit(___);}
#if 0
#line 6193
{ 
#line 6194
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6195
__asm sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6197
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6198
__asm sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6200
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6201
__asm sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6203
} 
#endif
#line 6205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6206
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6216
::exit(___);}
#if 0
#line 6206
{ 
#line 6207
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6208
__asm sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6210
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6211
__asm sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6213
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6214
__asm sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6216
} 
#endif
#line 6218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6219
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6229
::exit(___);}
#if 0
#line 6219
{ 
#line 6220
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6221
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6223
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6224
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6226
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6227
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6229
} 
#endif
#line 6237 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6238
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6248
::exit(___);}
#if 0
#line 6238
{ 
#line 6239
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6240
__asm sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6242
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6243
__asm sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6245
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6246
__asm sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6248
} 
#endif
#line 6250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6251
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6261
::exit(___);}
#if 0
#line 6251
{ 
#line 6252
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6253
__asm sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6255
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6256
__asm sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6258
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6259
__asm sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6261
} 
#endif
#line 6263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6264
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6274
::exit(___);}
#if 0
#line 6264
{ 
#line 6265
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6266
__asm sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6268
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6269
__asm sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6271
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6272
__asm sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6274
} 
#endif
#line 6276 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6277
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6287
::exit(___);}
#if 0
#line 6277
{ 
#line 6278
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6279
__asm sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6281
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6282
__asm sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6284
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6285
__asm sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6287
} 
#endif
#line 6289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6290
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6300
::exit(___);}
#if 0
#line 6290
{ 
#line 6291
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6292
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6294
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6295
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6297
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6298
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6300
} 
#endif
#line 6302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6303
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6313
::exit(___);}
#if 0
#line 6303
{ 
#line 6304
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6305
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6307
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6308
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6310
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6311
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6313
} 
#endif
#line 6315 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6316
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6326
::exit(___);}
#if 0
#line 6316
{ 
#line 6317
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6318
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6320
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6321
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6323
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6324
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6326
} 
#endif
#line 6334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6335
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6345
::exit(___);}
#if 0
#line 6335
{ 
#line 6336
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6337
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6339
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6340
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6342
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6343
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6345
} 
#endif
#line 6347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6348
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6358
::exit(___);}
#if 0
#line 6348
{ 
#line 6349
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6350
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6352
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6353
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6355
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6356
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6358
} 
#endif
#line 6360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6361
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6371
::exit(___);}
#if 0
#line 6361
{ 
#line 6362
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6363
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6365
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6366
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6368
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6369
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6371
} 
#endif
#line 6373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6374
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6384
::exit(___);}
#if 0
#line 6374
{ 
#line 6375
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6376
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6378
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6379
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6381
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6382
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6384
} 
#endif
#line 6386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6387
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6397
::exit(___);}
#if 0
#line 6387
{ 
#line 6388
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6389
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6391
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6392
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6394
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6395
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6397
} 
#endif
#line 6399 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6400
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6410
::exit(___);}
#if 0
#line 6400
{ 
#line 6401
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6402
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6404
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6405
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6407
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6408
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6410
} 
#endif
#line 6412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6413
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6423
::exit(___);}
#if 0
#line 6413
{ 
#line 6414
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6415
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6417
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6418
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6420
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6421
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6423
} 
#endif
#line 6425 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6426
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6436
::exit(___);}
#if 0
#line 6426
{ 
#line 6427
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6428
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6430
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6431
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6433
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6434
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6436
} 
#endif
#line 6438 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6439
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6449
::exit(___);}
#if 0
#line 6439
{ 
#line 6440
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6441
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6443
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6444
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6446
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6447
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6449
} 
#endif
#line 6451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6452
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6462
::exit(___);}
#if 0
#line 6452
{ 
#line 6453
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6454
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6456
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6457
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6459
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6460
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6462
} 
#endif
#line 6464 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6465
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6475
::exit(___);}
#if 0
#line 6465
{ 
#line 6466
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6467
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6469
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6470
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6472
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6473
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6475
} 
#endif
#line 6477 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6478
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6488
::exit(___);}
#if 0
#line 6478
{ 
#line 6479
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6480
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6482
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6483
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6485
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6486
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6488
} 
#endif
#line 6490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6491
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6501
::exit(___);}
#if 0
#line 6491
{ 
#line 6492
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6493
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6495
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6496
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6498
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6499
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6501
} 
#endif
#line 6503 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6504
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6514
::exit(___);}
#if 0
#line 6504
{ 
#line 6505
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6506
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6508
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6509
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6511
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6512
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6514
} 
#endif
#line 6516 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6517
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6527
::exit(___);}
#if 0
#line 6517
{ 
#line 6518
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6519
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6521
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6522
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6524
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6525
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6527
} 
#endif
#line 6529 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6530
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6540
::exit(___);}
#if 0
#line 6530
{ 
#line 6531
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6532
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6534
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6535
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6537
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6538
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6540
} 
#endif
#line 6542 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6543
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6553
::exit(___);}
#if 0
#line 6543
{ 
#line 6544
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6545
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6547
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6548
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6550
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6551
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6553
} 
#endif
#line 6555 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6556
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6566
::exit(___);}
#if 0
#line 6556
{ 
#line 6557
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6558
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6560
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6561
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6563
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6564
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6566
} 
#endif
#line 6568 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6569
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6579
::exit(___);}
#if 0
#line 6569
{ 
#line 6570
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6571
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6573
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6574
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6576
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6577
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6579
} 
#endif
#line 6587 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6588
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6598
::exit(___);}
#if 0
#line 6588
{ 
#line 6589
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6590
__asm sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6592
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6593
__asm sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6595
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6596
__asm sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6598
} 
#endif
#line 6600 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6601
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6611
::exit(___);}
#if 0
#line 6601
{ 
#line 6602
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6603
__asm sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6605
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6606
__asm sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6608
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6609
__asm sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6611
} 
#endif
#line 6613 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6614
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6624
::exit(___);}
#if 0
#line 6614
{ 
#line 6615
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6616
__asm sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6618
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6619
__asm sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6621
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6622
__asm sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6624
} 
#endif
#line 6626 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6627
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6637
::exit(___);}
#if 0
#line 6627
{ 
#line 6628
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6629
__asm sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6631
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6632
__asm sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6634
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6635
__asm sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6637
} 
#endif
#line 6639 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6640
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6650
::exit(___);}
#if 0
#line 6640
{ 
#line 6641
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6642
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6644
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6645
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6647
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6648
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6650
} 
#endif
#line 6652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6653
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6663
::exit(___);}
#if 0
#line 6653
{ 
#line 6654
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6655
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6657
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6658
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6660
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6661
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6663
} 
#endif
#line 6665 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6666
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6676
::exit(___);}
#if 0
#line 6666
{ 
#line 6667
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6668
__asm sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6670
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6671
__asm sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6673
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6674
__asm sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6676
} 
#endif
#line 6678 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6679
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6689
::exit(___);}
#if 0
#line 6679
{ 
#line 6680
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6681
__asm sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6683
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6684
__asm sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6686
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6687
__asm sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6689
} 
#endif
#line 6691 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6692
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6702
::exit(___);}
#if 0
#line 6692
{ 
#line 6693
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6694
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6696
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6697
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 6699
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6700
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 6702
} 
#endif
#line 6710 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6711
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6721
::exit(___);}
#if 0
#line 6711
{ 
#line 6712
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6713
__asm sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6715
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6716
__asm sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6718
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6719
__asm sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6721
} 
#endif
#line 6723 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6724
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6734
::exit(___);}
#if 0
#line 6724
{ 
#line 6725
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6726
__asm sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6728
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6729
__asm sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6731
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6732
__asm sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6734
} 
#endif
#line 6736 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6737
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6747
::exit(___);}
#if 0
#line 6737
{ 
#line 6738
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6739
__asm sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6741
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6742
__asm sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6744
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6745
__asm sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6747
} 
#endif
#line 6749 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6750
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6760
::exit(___);}
#if 0
#line 6750
{ 
#line 6751
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6752
__asm sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6754
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6755
__asm sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6757
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6758
__asm sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6760
} 
#endif
#line 6762 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6763
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6773
::exit(___);}
#if 0
#line 6763
{ 
#line 6764
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6765
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6767
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6768
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6770
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6771
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6773
} 
#endif
#line 6775 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6776
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6786
::exit(___);}
#if 0
#line 6776
{ 
#line 6777
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6778
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6780
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6781
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6783
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6784
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6786
} 
#endif
#line 6788 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6789
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6799
::exit(___);}
#if 0
#line 6789
{ 
#line 6790
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6791
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6793
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6794
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 6796
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6797
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 6799
} 
#endif
#line 6807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6808
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6818
::exit(___);}
#if 0
#line 6808
{ 
#line 6809
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6810
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6812
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6813
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6815
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6816
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6818
} 
#endif
#line 6820 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6821
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6831
::exit(___);}
#if 0
#line 6821
{ 
#line 6822
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6823
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6825
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6826
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6828
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6829
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6831
} 
#endif
#line 6833 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6834
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6844
::exit(___);}
#if 0
#line 6834
{ 
#line 6835
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6836
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6838
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6839
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6841
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6842
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6844
} 
#endif
#line 6846 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6847
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6857
::exit(___);}
#if 0
#line 6847
{ 
#line 6848
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6849
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6851
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6852
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6854
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6855
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6857
} 
#endif
#line 6859 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6860
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6870
::exit(___);}
#if 0
#line 6860
{ 
#line 6861
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6862
__asm sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6864
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6865
__asm sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6867
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6868
__asm sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6870
} 
#endif
#line 6872 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6873
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6883
::exit(___);}
#if 0
#line 6873
{ 
#line 6874
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6875
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6877
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6878
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6880
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6881
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6883
} 
#endif
#line 6885 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6886
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6896
::exit(___);}
#if 0
#line 6886
{ 
#line 6887
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6888
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6890
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6891
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6893
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6894
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6896
} 
#endif
#line 6898 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6899
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6909
::exit(___);}
#if 0
#line 6899
{ 
#line 6900
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6901
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6903
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6904
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6906
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6907
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6909
} 
#endif
#line 6911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6912
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6922
::exit(___);}
#if 0
#line 6912
{ 
#line 6913
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6914
__asm sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6916
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6917
__asm sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6919
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6920
__asm sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6922
} 
#endif
#line 6924 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6925
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6935
::exit(___);}
#if 0
#line 6925
{ 
#line 6926
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6927
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6929
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6930
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6932
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6933
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6935
} 
#endif
#line 6937 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6938
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6948
::exit(___);}
#if 0
#line 6938
{ 
#line 6939
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6940
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6942
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6943
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6945
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6946
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6948
} 
#endif
#line 6950 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6951
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6961
::exit(___);}
#if 0
#line 6951
{ 
#line 6952
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6953
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6955
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6956
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6958
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6959
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6961
} 
#endif
#line 6963 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6964
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6974
::exit(___);}
#if 0
#line 6964
{ 
#line 6965
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6966
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6968
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6969
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6971
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6972
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6974
} 
#endif
#line 6976 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6977
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 6987
::exit(___);}
#if 0
#line 6977
{ 
#line 6978
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6979
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6981
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6982
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6984
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6985
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 6987
} 
#endif
#line 6989 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 6990
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7000
::exit(___);}
#if 0
#line 6990
{ 
#line 6991
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6992
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6994
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6995
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 6997
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6998
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 7000
} 
#endif
#line 7002 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7003
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7013
::exit(___);}
#if 0
#line 7003
{ 
#line 7004
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7005
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7007
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7008
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7010
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7011
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 7013
} 
#endif
#line 7015 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7016
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7026
::exit(___);}
#if 0
#line 7016
{ 
#line 7017
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7018
__asm sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7020
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7021
__asm sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7023
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7024
__asm sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 7026
} 
#endif
#line 7028 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7029
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7039
::exit(___);}
#if 0
#line 7029
{ 
#line 7030
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7031
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7033
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7034
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7036
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7037
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 7039
} 
#endif
#line 7041 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7042
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7052
::exit(___);}
#if 0
#line 7042
{ 
#line 7043
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7044
__asm sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7046
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7047
__asm sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};
} else { 
#line 7049
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7050
__asm sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};
}  }  }  
#line 7052
} 
#endif
#line 7060 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7061
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7071
::exit(___);}
#if 0
#line 7061
{ 
#line 7062
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7063
__asm sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7065
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7066
__asm sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7068
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7069
__asm sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7071
} 
#endif
#line 7073 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7074
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7084
::exit(___);}
#if 0
#line 7074
{ 
#line 7075
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7076
__asm sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7078
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7079
__asm sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7081
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7082
__asm sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7084
} 
#endif
#line 7086 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7087
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7097
::exit(___);}
#if 0
#line 7087
{ 
#line 7088
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7089
__asm sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7091
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7092
__asm sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7094
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7095
__asm sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7097
} 
#endif
#line 7099 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7100
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7110
::exit(___);}
#if 0
#line 7100
{ 
#line 7101
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7102
__asm sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7104
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7105
__asm sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7107
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7108
__asm sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7110
} 
#endif
#line 7112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7113
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7123
::exit(___);}
#if 0
#line 7113
{ 
#line 7114
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7115
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7117
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7118
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7120
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7121
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7123
} 
#endif
#line 7125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7126
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7136
::exit(___);}
#if 0
#line 7126
{ 
#line 7127
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7128
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7130
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7131
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7133
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7134
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7136
} 
#endif
#line 7138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7139
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7149
::exit(___);}
#if 0
#line 7139
{ 
#line 7140
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7141
__asm sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7143
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7144
__asm sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7146
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7147
__asm sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7149
} 
#endif
#line 7151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7152
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7162
::exit(___);}
#if 0
#line 7152
{ 
#line 7153
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7154
__asm sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7156
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7157
__asm sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7159
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7160
__asm sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7162
} 
#endif
#line 7164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7165
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7175
::exit(___);}
#if 0
#line 7165
{ 
#line 7166
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7167
__asm sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7169
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7170
__asm sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};
} else { 
#line 7172
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7173
__asm sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};
}  }  }  
#line 7175
} 
#endif
#line 7183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7184
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7194
::exit(___);}
#if 0
#line 7184
{ 
#line 7185
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7186
__asm sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7188
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7189
__asm sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7191
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7192
__asm sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7194
} 
#endif
#line 7196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7197
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7207
::exit(___);}
#if 0
#line 7197
{ 
#line 7198
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7199
__asm sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7201
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7202
__asm sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7204
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7205
__asm sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7207
} 
#endif
#line 7209 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7210
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7220
::exit(___);}
#if 0
#line 7210
{ 
#line 7211
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7212
__asm sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7214
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7215
__asm sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7217
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7218
__asm sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7220
} 
#endif
#line 7222 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7223
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7233
::exit(___);}
#if 0
#line 7223
{ 
#line 7224
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7225
__asm sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7227
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7228
__asm sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7230
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7231
__asm sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7233
} 
#endif
#line 7235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7236
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7246
::exit(___);}
#if 0
#line 7236
{ 
#line 7237
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7238
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7240
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7241
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7243
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7244
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7246
} 
#endif
#line 7248 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7249
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7259
::exit(___);}
#if 0
#line 7249
{ 
#line 7250
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7251
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7253
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7254
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7256
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7257
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7259
} 
#endif
#line 7261 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 7262
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
#line 7272
::exit(___);}
#if 0
#line 7262
{ 
#line 7263
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7264
__asm sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7266
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7267
__asm sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
} else { 
#line 7269
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7270
__asm sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};
}  }  }  
#line 7272
} 
#endif
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\device_launch_parameters.h"
extern "C" const uint3 threadIdx; 
#line 67
extern "C" const uint3 blockIdx; 
#line 68
extern "C" const dim3 blockDim; 
#line 69
extern "C" const dim3 gridDim; 
#line 70
extern "C" const int warpSize; 
#line 118 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v6.0\\include\\cuda_device_runtime_api.h"
namespace _GLOBAL__N__26_pCT_Reconstruction_cpp1_ii_ped { }; using namespace _GLOBAL__N__26_pCT_Reconstruction_cpp1_ii_ped; namespace _GLOBAL__N__26_pCT_Reconstruction_cpp1_ii_ped { 
#line 123 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda_runtime.h"
template< class T> __inline ::cudaError_t 
#line 124
cudaSetupArgument(T 
#line 125
arg, ::size_t 
#line 126
offset) 
#line 128
{ 
#line 129
return ::cudaSetupArgument((const void *)(&arg), sizeof(T), offset); 
#line 130
} 
#line 162
static __inline cudaError_t cudaEventCreate(cudaEvent_t *
#line 163
event, unsigned 
#line 164
flags) 
#line 166
{ 
#line 167
return ::cudaEventCreateWithFlags(event, flags); 
#line 168
} 
#line 225
__inline cudaError_t cudaMallocHost(void **
#line 226
ptr, size_t 
#line 227
size, unsigned 
#line 228
flags) 
#line 230
{ 
#line 231
return ::cudaHostAlloc(ptr, size, flags); 
#line 232
} 
#line 234
template< class T> __inline ::cudaError_t 
#line 235
cudaHostAlloc(T **
#line 236
ptr, ::size_t 
#line 237
size, unsigned 
#line 238
flags) 
#line 240
{ 
#line 241
return ::cudaHostAlloc((void **)((void *)ptr), size, flags); 
#line 242
} 
#line 244
template< class T> __inline ::cudaError_t 
#line 245
cudaHostGetDevicePointer(T **
#line 246
pDevice, void *
#line 247
pHost, unsigned 
#line 248
flags) 
#line 250
{ 
#line 251
return ::cudaHostGetDevicePointer((void **)((void *)pDevice), pHost, flags); 
#line 252
} 
#line 323
template< class T> __inline ::cudaError_t 
#line 324
cudaMallocManaged(T **
#line 325
devPtr, ::size_t 
#line 326
size, unsigned 
#line 327
flags = 1) 
#line 329
{ 
#line 330
return ::cudaMallocManaged((void **)((void *)devPtr), size, flags); 
#line 331
} 
#line 399
template< class T> __inline ::cudaError_t 
#line 400
cudaStreamAttachMemAsync(::cudaStream_t 
#line 401
stream, T *
#line 402
devPtr, ::size_t 
#line 403
length = 0, unsigned 
#line 404
flags = 4) 
#line 406
{ 
#line 407
return ::cudaStreamAttachMemAsync(stream, (void *)devPtr, length, flags); 
#line 408
} 
#line 410
template< class T> __inline ::cudaError_t 
#line 411
cudaMalloc(T **
#line 412
devPtr, ::size_t 
#line 413
size) 
#line 415
{ 
#line 416
return ::cudaMalloc((void **)((void *)devPtr), size); 
#line 417
} 
#line 419
template< class T> __inline ::cudaError_t 
#line 420
cudaMallocHost(T **
#line 421
ptr, ::size_t 
#line 422
size, unsigned 
#line 423
flags = 0) 
#line 425
{ 
#line 426
return cudaMallocHost((void **)((void *)ptr), size, flags); 
#line 427
} 
#line 429
template< class T> __inline ::cudaError_t 
#line 430
cudaMallocPitch(T **
#line 431
devPtr, ::size_t *
#line 432
pitch, ::size_t 
#line 433
width, ::size_t 
#line 434
height) 
#line 436
{ 
#line 437
return ::cudaMallocPitch((void **)((void *)devPtr), pitch, width, height); 
#line 438
} 
#line 475
template< class T> __inline ::cudaError_t 
#line 476
cudaMemcpyToSymbol(const T &
#line 477
symbol, const void *
#line 478
src, ::size_t 
#line 479
count, ::size_t 
#line 480
offset = 0, ::cudaMemcpyKind 
#line 481
kind = cudaMemcpyHostToDevice) 
#line 483
{ 
#line 484
return ::cudaMemcpyToSymbol((const void *)(&symbol), src, count, offset, kind); 
#line 485
} 
#line 527
template< class T> __inline ::cudaError_t 
#line 528
cudaMemcpyToSymbolAsync(const T &
#line 529
symbol, const void *
#line 530
src, ::size_t 
#line 531
count, ::size_t 
#line 532
offset = 0, ::cudaMemcpyKind 
#line 533
kind = cudaMemcpyHostToDevice, ::cudaStream_t 
#line 534
stream = 0) 
#line 536
{ 
#line 537
return ::cudaMemcpyToSymbolAsync((const void *)(&symbol), src, count, offset, kind, stream); 
#line 538
} 
#line 573
template< class T> __inline ::cudaError_t 
#line 574
cudaMemcpyFromSymbol(void *
#line 575
dst, const T &
#line 576
symbol, ::size_t 
#line 577
count, ::size_t 
#line 578
offset = 0, ::cudaMemcpyKind 
#line 579
kind = cudaMemcpyDeviceToHost) 
#line 581
{ 
#line 582
return ::cudaMemcpyFromSymbol(dst, (const void *)(&symbol), count, offset, kind); 
#line 583
} 
#line 625
template< class T> __inline ::cudaError_t 
#line 626
cudaMemcpyFromSymbolAsync(void *
#line 627
dst, const T &
#line 628
symbol, ::size_t 
#line 629
count, ::size_t 
#line 630
offset = 0, ::cudaMemcpyKind 
#line 631
kind = cudaMemcpyDeviceToHost, ::cudaStream_t 
#line 632
stream = 0) 
#line 634
{ 
#line 635
return ::cudaMemcpyFromSymbolAsync(dst, (const void *)(&symbol), count, offset, kind, stream); 
#line 636
} 
#line 658
template< class T> __inline ::cudaError_t 
#line 659
cudaGetSymbolAddress(void **
#line 660
devPtr, const T &
#line 661
symbol) 
#line 663
{ 
#line 664
return ::cudaGetSymbolAddress(devPtr, (const void *)(&symbol)); 
#line 665
} 
#line 687
template< class T> __inline ::cudaError_t 
#line 688
cudaGetSymbolSize(::size_t *
#line 689
size, const T &
#line 690
symbol) 
#line 692
{ 
#line 693
return ::cudaGetSymbolSize(size, (const void *)(&symbol)); 
#line 694
} 
#line 730
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 731
cudaBindTexture(::size_t *
#line 732
offset, const texture< T, dim, readMode>  &
#line 733
tex, const void *
#line 734
devPtr, const ::cudaChannelFormatDesc &
#line 735
desc, ::size_t 
#line 736
size = 4294967295U) 
#line 738
{ 
#line 739
return ::cudaBindTexture(offset, &tex, devPtr, &desc, size); 
#line 740
} 
#line 775
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 776
cudaBindTexture(::size_t *
#line 777
offset, const texture< T, dim, readMode>  &
#line 778
tex, const void *
#line 779
devPtr, ::size_t 
#line 780
size = 4294967295U) 
#line 782
{ 
#line 783
return cudaBindTexture(offset, tex, devPtr, (tex.channelDesc), size); 
#line 784
} 
#line 831
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 832
cudaBindTexture2D(::size_t *
#line 833
offset, const texture< T, dim, readMode>  &
#line 834
tex, const void *
#line 835
devPtr, const ::cudaChannelFormatDesc &
#line 836
desc, ::size_t 
#line 837
width, ::size_t 
#line 838
height, ::size_t 
#line 839
pitch) 
#line 841
{ 
#line 842
return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch); 
#line 843
} 
#line 889
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 890
cudaBindTexture2D(::size_t *
#line 891
offset, const texture< T, dim, readMode>  &
#line 892
tex, const void *
#line 893
devPtr, ::size_t 
#line 894
width, ::size_t 
#line 895
height, ::size_t 
#line 896
pitch) 
#line 898
{ 
#line 899
return ::cudaBindTexture2D(offset, &tex, devPtr, &(tex.channelDesc), width, height, pitch); 
#line 900
} 
#line 931
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 932
cudaBindTextureToArray(const texture< T, dim, readMode>  &
#line 933
tex, ::cudaArray_const_t 
#line 934
array, const ::cudaChannelFormatDesc &
#line 935
desc) 
#line 937
{ 
#line 938
return ::cudaBindTextureToArray(&tex, array, &desc); 
#line 939
} 
#line 969
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 970
cudaBindTextureToArray(const texture< T, dim, readMode>  &
#line 971
tex, ::cudaArray_const_t 
#line 972
array) 
#line 974
{ 
#line 975
::cudaChannelFormatDesc desc; 
#line 976
::cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
#line 978
return (err == (cudaSuccess)) ? cudaBindTextureToArray(tex, array, desc) : err; 
#line 979
} 
#line 1010
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 1011
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
#line 1012
tex, ::cudaMipmappedArray_const_t 
#line 1013
mipmappedArray, const ::cudaChannelFormatDesc &
#line 1014
desc) 
#line 1016
{ 
#line 1017
return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc); 
#line 1018
} 
#line 1048
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 1049
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
#line 1050
tex, ::cudaMipmappedArray_const_t 
#line 1051
mipmappedArray) 
#line 1053
{ 
#line 1054
::cudaChannelFormatDesc desc; 
#line 1055
::cudaArray_t levelArray; 
#line 1056
::cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0); 
#line 1058
if (err != (cudaSuccess)) { 
#line 1059
return err; 
#line 1060
}  
#line 1061
err = ::cudaGetChannelDesc(&desc, levelArray); 
#line 1063
return (err == (cudaSuccess)) ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err; 
#line 1064
} 
#line 1087
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 1088
cudaUnbindTexture(const texture< T, dim, readMode>  &
#line 1089
tex) 
#line 1091
{ 
#line 1092
return ::cudaUnbindTexture(&tex); 
#line 1093
} 
#line 1121
template< class T, int dim, cudaTextureReadMode readMode> __inline ::cudaError_t 
#line 1122
cudaGetTextureAlignmentOffset(::size_t *
#line 1123
offset, const texture< T, dim, readMode>  &
#line 1124
tex) 
#line 1126
{ 
#line 1127
return ::cudaGetTextureAlignmentOffset(offset, &tex); 
#line 1128
} 
#line 1174
template< class T> __inline ::cudaError_t 
#line 1175
cudaFuncSetCacheConfig(T *
#line 1176
func, ::cudaFuncCache 
#line 1177
cacheConfig) 
#line 1179
{ 
#line 1180
return ::cudaFuncSetCacheConfig((const void *)func, cacheConfig); 
#line 1181
} 
#line 1183
template< class T> __inline ::cudaError_t 
#line 1184
cudaFuncSetSharedMemConfig(T *
#line 1185
func, ::cudaSharedMemConfig 
#line 1186
config) 
#line 1188
{ 
#line 1189
return ::cudaFuncSetSharedMemConfig((const void *)func, config); 
#line 1190
} 
#line 1226
template< class T> __inline ::cudaError_t 
#line 1227
cudaLaunch(T *
#line 1228
func) 
#line 1230
{ 
#line 1231
return ::cudaLaunch((const void *)func); 
#line 1232
} 
#line 1264
template< class T> __inline ::cudaError_t 
#line 1265
cudaFuncGetAttributes(::cudaFuncAttributes *
#line 1266
attr, T *
#line 1267
entry) 
#line 1269
{ 
#line 1270
return ::cudaFuncGetAttributes(attr, (const void *)entry); 
#line 1271
} 
#line 1293
template< class T, int dim> __inline ::cudaError_t 
#line 1294
cudaBindSurfaceToArray(const surface< T, dim>  &
#line 1295
surf, ::cudaArray_const_t 
#line 1296
array, const ::cudaChannelFormatDesc &
#line 1297
desc) 
#line 1299
{ 
#line 1300
return ::cudaBindSurfaceToArray(&surf, array, &desc); 
#line 1301
} 
#line 1322
template< class T, int dim> __inline ::cudaError_t 
#line 1323
cudaBindSurfaceToArray(const surface< T, dim>  &
#line 1324
surf, ::cudaArray_const_t 
#line 1325
array) 
#line 1327
{ 
#line 1328
::cudaChannelFormatDesc desc; 
#line 1329
::cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
#line 1331
return (err == (cudaSuccess)) ? cudaBindSurfaceToArray(surf, array, desc) : err; 
#line 1332
} 
#line 1338 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda_runtime.h"
}
#line 161 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { typedef unsigned __int64 CUdeviceptr; }
#line 168 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { typedef int CUdevice; }
#line 169
extern "C" { typedef struct CUctx_st *CUcontext; }
#line 170
extern "C" { typedef struct CUmod_st *CUmodule; }
#line 171
extern "C" { typedef struct CUfunc_st *CUfunction; }
#line 172
extern "C" { typedef struct CUarray_st *CUarray; }
#line 173
extern "C" { typedef struct CUmipmappedArray_st *CUmipmappedArray; }
#line 174
extern "C" { typedef struct CUtexref_st *CUtexref; }
#line 175
extern "C" { typedef struct CUsurfref_st *CUsurfref; }
#line 176
extern "C" { typedef CUevent_st *CUevent; }
#line 177
extern "C" { typedef CUstream_st *CUstream; }
#line 178
extern "C" { typedef struct CUgraphicsResource_st *CUgraphicsResource; }
#line 179
extern "C" { typedef unsigned __int64 CUtexObject; }
#line 180
extern "C" { typedef unsigned __int64 CUsurfObject; }
#line 184
extern "C" { typedef 
#line 182
struct CUuuid_st { 
#line 183
char bytes[16]; 
#line 184
} CUuuid; }
#line 199
extern "C" { typedef 
#line 197
struct CUipcEventHandle_st { 
#line 198
char reserved[64]; 
#line 199
} CUipcEventHandle; }
#line 206
extern "C" { typedef 
#line 204
struct CUipcMemHandle_st { 
#line 205
char reserved[64]; 
#line 206
} CUipcMemHandle; }
#line 213
extern "C" { typedef 
#line 211
enum CUipcMem_flags_enum { 
#line 212
CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 1
#line 213
} CUipcMem_flags; }
#line 224 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { typedef 
#line 220
enum CUmemAttach_flags_enum { 
#line 221
CU_MEM_ATTACH_GLOBAL = 1, 
#line 222
CU_MEM_ATTACH_HOST, 
#line 223
CU_MEM_ATTACH_SINGLE = 4
#line 224
} CUmemAttach_flags; }
#line 241
extern "C" { typedef 
#line 229
enum CUctx_flags_enum { 
#line 230
CU_CTX_SCHED_AUTO, 
#line 231
CU_CTX_SCHED_SPIN, 
#line 232
CU_CTX_SCHED_YIELD, 
#line 233
CU_CTX_SCHED_BLOCKING_SYNC = 4, 
#line 234
CU_CTX_BLOCKING_SYNC = 4, 
#line 237
CU_CTX_SCHED_MASK = 7, 
#line 238
CU_CTX_MAP_HOST, 
#line 239
CU_CTX_LMEM_RESIZE_TO_MAX = 16, 
#line 240
CU_CTX_FLAGS_MASK = 31
#line 241
} CUctx_flags; }
#line 249
extern "C" { typedef 
#line 246
enum CUstream_flags_enum { 
#line 247
CU_STREAM_DEFAULT, 
#line 248
CU_STREAM_NON_BLOCKING
#line 249
} CUstream_flags; }
#line 259
extern "C" { typedef 
#line 254
enum CUevent_flags_enum { 
#line 255
CU_EVENT_DEFAULT, 
#line 256
CU_EVENT_BLOCKING_SYNC, 
#line 257
CU_EVENT_DISABLE_TIMING, 
#line 258
CU_EVENT_INTERPROCESS = 4
#line 259
} CUevent_flags; }
#line 273
extern "C" { typedef 
#line 264
enum CUarray_format_enum { 
#line 265
CU_AD_FORMAT_UNSIGNED_INT8 = 1, 
#line 266
CU_AD_FORMAT_UNSIGNED_INT16, 
#line 267
CU_AD_FORMAT_UNSIGNED_INT32, 
#line 268
CU_AD_FORMAT_SIGNED_INT8 = 8, 
#line 269
CU_AD_FORMAT_SIGNED_INT16, 
#line 270
CU_AD_FORMAT_SIGNED_INT32, 
#line 271
CU_AD_FORMAT_HALF = 16, 
#line 272
CU_AD_FORMAT_FLOAT = 32
#line 273
} CUarray_format; }
#line 283
extern "C" { typedef 
#line 278
enum CUaddress_mode_enum { 
#line 279
CU_TR_ADDRESS_MODE_WRAP, 
#line 280
CU_TR_ADDRESS_MODE_CLAMP, 
#line 281
CU_TR_ADDRESS_MODE_MIRROR, 
#line 282
CU_TR_ADDRESS_MODE_BORDER
#line 283
} CUaddress_mode; }
#line 291
extern "C" { typedef 
#line 288
enum CUfilter_mode_enum { 
#line 289
CU_TR_FILTER_MODE_POINT, 
#line 290
CU_TR_FILTER_MODE_LINEAR
#line 291
} CUfilter_mode; }
#line 388
extern "C" { typedef 
#line 296
enum CUdevice_attribute_enum { 
#line 297
CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1, 
#line 298
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X, 
#line 299
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y, 
#line 300
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z, 
#line 301
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X, 
#line 302
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y, 
#line 303
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z, 
#line 304
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK, 
#line 305
CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = 8, 
#line 306
CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY, 
#line 307
CU_DEVICE_ATTRIBUTE_WARP_SIZE, 
#line 308
CU_DEVICE_ATTRIBUTE_MAX_PITCH, 
#line 309
CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK, 
#line 310
CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = 12, 
#line 311
CU_DEVICE_ATTRIBUTE_CLOCK_RATE, 
#line 312
CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT, 
#line 313
CU_DEVICE_ATTRIBUTE_GPU_OVERLAP, 
#line 314
CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, 
#line 315
CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT, 
#line 316
CU_DEVICE_ATTRIBUTE_INTEGRATED, 
#line 317
CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY, 
#line 318
CU_DEVICE_ATTRIBUTE_COMPUTE_MODE, 
#line 319
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH, 
#line 320
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH, 
#line 321
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT, 
#line 322
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH, 
#line 323
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT, 
#line 324
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH, 
#line 325
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH, 
#line 326
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT, 
#line 327
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS, 
#line 328
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = 27, 
#line 329
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT, 
#line 330
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES, 
#line 331
CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT, 
#line 332
CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS, 
#line 333
CU_DEVICE_ATTRIBUTE_ECC_ENABLED, 
#line 334
CU_DEVICE_ATTRIBUTE_PCI_BUS_ID, 
#line 335
CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID, 
#line 336
CU_DEVICE_ATTRIBUTE_TCC_DRIVER, 
#line 337
CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE, 
#line 338
CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH, 
#line 339
CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE, 
#line 340
CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR, 
#line 341
CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT, 
#line 342
CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING, 
#line 343
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH, 
#line 344
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS, 
#line 345
CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER, 
#line 346
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH, 
#line 347
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT, 
#line 348
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE, 
#line 349
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE, 
#line 350
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE, 
#line 351
CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID, 
#line 352
CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT, 
#line 353
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH, 
#line 354
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH, 
#line 355
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS, 
#line 356
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH, 
#line 357
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH, 
#line 358
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT, 
#line 359
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH, 
#line 360
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT, 
#line 361
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH, 
#line 362
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH, 
#line 363
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS, 
#line 364
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH, 
#line 365
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT, 
#line 366
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS, 
#line 367
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH, 
#line 368
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH, 
#line 369
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS, 
#line 370
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH, 
#line 371
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH, 
#line 372
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT, 
#line 373
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH, 
#line 374
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH, 
#line 375
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT, 
#line 376
CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR, 
#line 377
CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR, 
#line 378
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH, 
#line 379
CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED, 
#line 380
CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED, 
#line 381
CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED, 
#line 382
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR, 
#line 383
CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR, 
#line 384
CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY, 
#line 385
CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD, 
#line 386
CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID, 
#line 387
CU_DEVICE_ATTRIBUTE_MAX
#line 388
} CUdevice_attribute; }
#line 404
extern "C" { typedef 
#line 393
struct CUdevprop_st { 
#line 394
int maxThreadsPerBlock; 
#line 395
int maxThreadsDim[3]; 
#line 396
int maxGridSize[3]; 
#line 397
int sharedMemPerBlock; 
#line 398
int totalConstantMemory; 
#line 399
int SIMDWidth; 
#line 400
int memPitch; 
#line 401
int regsPerBlock; 
#line 402
int clockRate; 
#line 403
int textureAlign; 
#line 404
} CUdevprop; }
#line 418
extern "C" { typedef 
#line 409
enum CUpointer_attribute_enum { 
#line 410
CU_POINTER_ATTRIBUTE_CONTEXT = 1, 
#line 411
CU_POINTER_ATTRIBUTE_MEMORY_TYPE, 
#line 412
CU_POINTER_ATTRIBUTE_DEVICE_POINTER, 
#line 413
CU_POINTER_ATTRIBUTE_HOST_POINTER, 
#line 414
CU_POINTER_ATTRIBUTE_P2P_TOKENS, 
#line 415
CU_POINTER_ATTRIBUTE_SYNC_MEMOPS, 
#line 416
CU_POINTER_ATTRIBUTE_BUFFER_ID, 
#line 417
CU_POINTER_ATTRIBUTE_IS_MANAGED
#line 418
} CUpointer_attribute; }
#line 479
extern "C" { typedef 
#line 423
enum CUfunction_attribute_enum { 
#line 429
CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK, 
#line 436
CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES, 
#line 442
CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES, 
#line 447
CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES, 
#line 452
CU_FUNC_ATTRIBUTE_NUM_REGS, 
#line 461
CU_FUNC_ATTRIBUTE_PTX_VERSION, 
#line 470
CU_FUNC_ATTRIBUTE_BINARY_VERSION, 
#line 476
CU_FUNC_ATTRIBUTE_CACHE_MODE_CA, 
#line 478
CU_FUNC_ATTRIBUTE_MAX
#line 479
} CUfunction_attribute; }
#line 489
extern "C" { typedef 
#line 484
enum CUfunc_cache_enum { 
#line 485
CU_FUNC_CACHE_PREFER_NONE, 
#line 486
CU_FUNC_CACHE_PREFER_SHARED, 
#line 487
CU_FUNC_CACHE_PREFER_L1, 
#line 488
CU_FUNC_CACHE_PREFER_EQUAL
#line 489
} CUfunc_cache; }
#line 498
extern "C" { typedef 
#line 494
enum CUsharedconfig_enum { 
#line 495
CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE, 
#line 496
CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE, 
#line 497
CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE
#line 498
} CUsharedconfig; }
#line 508
extern "C" { typedef 
#line 503
enum CUmemorytype_enum { 
#line 504
CU_MEMORYTYPE_HOST = 1, 
#line 505
CU_MEMORYTYPE_DEVICE, 
#line 506
CU_MEMORYTYPE_ARRAY, 
#line 507
CU_MEMORYTYPE_UNIFIED
#line 508
} CUmemorytype; }
#line 518
extern "C" { typedef 
#line 513
enum CUcomputemode_enum { 
#line 514
CU_COMPUTEMODE_DEFAULT, 
#line 515
CU_COMPUTEMODE_EXCLUSIVE, 
#line 516
CU_COMPUTEMODE_PROHIBITED, 
#line 517
CU_COMPUTEMODE_EXCLUSIVE_PROCESS
#line 518
} CUcomputemode; }
#line 655
extern "C" { typedef 
#line 523
enum CUjit_option_enum { 
#line 530
CU_JIT_MAX_REGISTERS, 
#line 545
CU_JIT_THREADS_PER_BLOCK, 
#line 553
CU_JIT_WALL_TIME, 
#line 562
CU_JIT_INFO_LOG_BUFFER, 
#line 571
CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES, 
#line 580
CU_JIT_ERROR_LOG_BUFFER, 
#line 589
CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES, 
#line 597
CU_JIT_OPTIMIZATION_LEVEL, 
#line 605
CU_JIT_TARGET_FROM_CUCONTEXT, 
#line 613
CU_JIT_TARGET, 
#line 621
CU_JIT_FALLBACK_STRATEGY, 
#line 629
CU_JIT_GENERATE_DEBUG_INFO, 
#line 636
CU_JIT_LOG_VERBOSE, 
#line 643
CU_JIT_GENERATE_LINE_INFO, 
#line 651
CU_JIT_CACHE_MODE, 
#line 653
CU_JIT_NUM_OPTIONS
#line 655
} CUjit_option; }
#line 672
extern "C" { typedef 
#line 660
enum CUjit_target_enum { 
#line 662
CU_TARGET_COMPUTE_10 = 10, 
#line 663
CU_TARGET_COMPUTE_11, 
#line 664
CU_TARGET_COMPUTE_12, 
#line 665
CU_TARGET_COMPUTE_13, 
#line 666
CU_TARGET_COMPUTE_20 = 20, 
#line 667
CU_TARGET_COMPUTE_21, 
#line 668
CU_TARGET_COMPUTE_30 = 30, 
#line 669
CU_TARGET_COMPUTE_32 = 32, 
#line 670
CU_TARGET_COMPUTE_35 = 35, 
#line 671
CU_TARGET_COMPUTE_50 = 50
#line 672
} CUjit_target; }
#line 683
extern "C" { typedef 
#line 677
enum CUjit_fallback_enum { 
#line 679
CU_PREFER_PTX, 
#line 681
CU_PREFER_BINARY
#line 683
} CUjit_fallback; }
#line 693
extern "C" { typedef 
#line 688
enum CUjit_cacheMode_enum { 
#line 690
CU_JIT_CACHE_OPTION_NONE, 
#line 691
CU_JIT_CACHE_OPTION_CG, 
#line 692
CU_JIT_CACHE_OPTION_CA
#line 693
} CUjit_cacheMode; }
#line 731
extern "C" { typedef 
#line 698
enum CUjitInputType_enum { 
#line 704
CU_JIT_INPUT_CUBIN, 
#line 710
CU_JIT_INPUT_PTX, 
#line 716
CU_JIT_INPUT_FATBINARY, 
#line 722
CU_JIT_INPUT_OBJECT, 
#line 728
CU_JIT_INPUT_LIBRARY, 
#line 730
CU_JIT_NUM_INPUT_TYPES
#line 731
} CUjitInputType; }
#line 734
extern "C" { typedef struct CUlinkState_st *CUlinkState; }
#line 746 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { typedef 
#line 740
enum CUgraphicsRegisterFlags_enum { 
#line 741
CU_GRAPHICS_REGISTER_FLAGS_NONE, 
#line 742
CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY, 
#line 743
CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD, 
#line 744
CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 4, 
#line 745
CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 8
#line 746
} CUgraphicsRegisterFlags; }
#line 755
extern "C" { typedef 
#line 751
enum CUgraphicsMapResourceFlags_enum { 
#line 752
CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE, 
#line 753
CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY, 
#line 754
CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD
#line 755
} CUgraphicsMapResourceFlags; }
#line 767
extern "C" { typedef 
#line 760
enum CUarray_cubemap_face_enum { 
#line 761
CU_CUBEMAP_FACE_POSITIVE_X, 
#line 762
CU_CUBEMAP_FACE_NEGATIVE_X, 
#line 763
CU_CUBEMAP_FACE_POSITIVE_Y, 
#line 764
CU_CUBEMAP_FACE_NEGATIVE_Y, 
#line 765
CU_CUBEMAP_FACE_POSITIVE_Z, 
#line 766
CU_CUBEMAP_FACE_NEGATIVE_Z
#line 767
} CUarray_cubemap_face; }
#line 779
extern "C" { typedef 
#line 772
enum CUlimit_enum { 
#line 773
CU_LIMIT_STACK_SIZE, 
#line 774
CU_LIMIT_PRINTF_FIFO_SIZE, 
#line 775
CU_LIMIT_MALLOC_HEAP_SIZE, 
#line 776
CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH, 
#line 777
CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT, 
#line 778
CU_LIMIT_MAX
#line 779
} CUlimit; }
#line 789
extern "C" { typedef 
#line 784
enum CUresourcetype_enum { 
#line 785
CU_RESOURCE_TYPE_ARRAY, 
#line 786
CU_RESOURCE_TYPE_MIPMAPPED_ARRAY, 
#line 787
CU_RESOURCE_TYPE_LINEAR, 
#line 788
CU_RESOURCE_TYPE_PITCH2D
#line 789
} CUresourcetype; }
#line 1180
extern "C" { typedef 
#line 794
enum cudaError_enum { 
#line 800
CUDA_SUCCESS, 
#line 806
CUDA_ERROR_INVALID_VALUE, 
#line 812
CUDA_ERROR_OUT_OF_MEMORY, 
#line 818
CUDA_ERROR_NOT_INITIALIZED, 
#line 823
CUDA_ERROR_DEINITIALIZED, 
#line 830
CUDA_ERROR_PROFILER_DISABLED, 
#line 838
CUDA_ERROR_PROFILER_NOT_INITIALIZED, 
#line 845
CUDA_ERROR_PROFILER_ALREADY_STARTED, 
#line 852
CUDA_ERROR_PROFILER_ALREADY_STOPPED, 
#line 858
CUDA_ERROR_NO_DEVICE = 100, 
#line 864
CUDA_ERROR_INVALID_DEVICE, 
#line 871
CUDA_ERROR_INVALID_IMAGE = 200, 
#line 881
CUDA_ERROR_INVALID_CONTEXT, 
#line 890
CUDA_ERROR_CONTEXT_ALREADY_CURRENT, 
#line 895
CUDA_ERROR_MAP_FAILED = 205, 
#line 900
CUDA_ERROR_UNMAP_FAILED, 
#line 906
CUDA_ERROR_ARRAY_IS_MAPPED, 
#line 911
CUDA_ERROR_ALREADY_MAPPED, 
#line 919
CUDA_ERROR_NO_BINARY_FOR_GPU, 
#line 924
CUDA_ERROR_ALREADY_ACQUIRED, 
#line 929
CUDA_ERROR_NOT_MAPPED, 
#line 935
CUDA_ERROR_NOT_MAPPED_AS_ARRAY, 
#line 941
CUDA_ERROR_NOT_MAPPED_AS_POINTER, 
#line 947
CUDA_ERROR_ECC_UNCORRECTABLE, 
#line 953
CUDA_ERROR_UNSUPPORTED_LIMIT, 
#line 960
CUDA_ERROR_CONTEXT_ALREADY_IN_USE, 
#line 966
CUDA_ERROR_PEER_ACCESS_UNSUPPORTED, 
#line 971
CUDA_ERROR_INVALID_PTX, 
#line 976
CUDA_ERROR_INVALID_SOURCE = 300, 
#line 981
CUDA_ERROR_FILE_NOT_FOUND, 
#line 986
CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND, 
#line 991
CUDA_ERROR_SHARED_OBJECT_INIT_FAILED, 
#line 996
CUDA_ERROR_OPERATING_SYSTEM, 
#line 1002
CUDA_ERROR_INVALID_HANDLE = 400, 
#line 1008
CUDA_ERROR_NOT_FOUND = 500, 
#line 1016
CUDA_ERROR_NOT_READY = 600, 
#line 1025
CUDA_ERROR_ILLEGAL_ADDRESS = 700, 
#line 1036
CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES, 
#line 1047
CUDA_ERROR_LAUNCH_TIMEOUT, 
#line 1053
CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING, 
#line 1060
CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED, 
#line 1067
CUDA_ERROR_PEER_ACCESS_NOT_ENABLED, 
#line 1073
CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = 708, 
#line 1080
CUDA_ERROR_CONTEXT_IS_DESTROYED, 
#line 1088
CUDA_ERROR_ASSERT, 
#line 1095
CUDA_ERROR_TOO_MANY_PEERS, 
#line 1101
CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED, 
#line 1107
CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED, 
#line 1116
CUDA_ERROR_HARDWARE_STACK_ERROR, 
#line 1124
CUDA_ERROR_ILLEGAL_INSTRUCTION, 
#line 1133
CUDA_ERROR_MISALIGNED_ADDRESS, 
#line 1144
CUDA_ERROR_INVALID_ADDRESS_SPACE, 
#line 1152
CUDA_ERROR_INVALID_PC, 
#line 1162
CUDA_ERROR_LAUNCH_FAILED, 
#line 1168
CUDA_ERROR_NOT_PERMITTED = 800, 
#line 1174
CUDA_ERROR_NOT_SUPPORTED, 
#line 1179
CUDA_ERROR_UNKNOWN = 999
#line 1180
} CUresult; }
#line 1194 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { typedef void (__stdcall *CUstreamCallback)(CUstream , CUresult , void * ); }
#line 1256
extern "C" { typedef 
#line 1235
struct CUDA_MEMCPY2D_st { 
#line 1236
size_t srcXInBytes; 
#line 1237
size_t srcY; 
#line 1239
CUmemorytype srcMemoryType; 
#line 1240
const void *srcHost; 
#line 1241
CUdeviceptr srcDevice; 
#line 1242
CUarray srcArray; 
#line 1243
size_t srcPitch; 
#line 1245
size_t dstXInBytes; 
#line 1246
size_t dstY; 
#line 1248
CUmemorytype dstMemoryType; 
#line 1249
void *dstHost; 
#line 1250
CUdeviceptr dstDevice; 
#line 1251
CUarray dstArray; 
#line 1252
size_t dstPitch; 
#line 1254
size_t WidthInBytes; 
#line 1255
size_t Height; 
#line 1256
} CUDA_MEMCPY2D; }
#line 1289
extern "C" { typedef 
#line 1261
struct CUDA_MEMCPY3D_st { 
#line 1262
size_t srcXInBytes; 
#line 1263
size_t srcY; 
#line 1264
size_t srcZ; 
#line 1265
size_t srcLOD; 
#line 1266
CUmemorytype srcMemoryType; 
#line 1267
const void *srcHost; 
#line 1268
CUdeviceptr srcDevice; 
#line 1269
CUarray srcArray; 
#line 1270
void *reserved0; 
#line 1271
size_t srcPitch; 
#line 1272
size_t srcHeight; 
#line 1274
size_t dstXInBytes; 
#line 1275
size_t dstY; 
#line 1276
size_t dstZ; 
#line 1277
size_t dstLOD; 
#line 1278
CUmemorytype dstMemoryType; 
#line 1279
void *dstHost; 
#line 1280
CUdeviceptr dstDevice; 
#line 1281
CUarray dstArray; 
#line 1282
void *reserved1; 
#line 1283
size_t dstPitch; 
#line 1284
size_t dstHeight; 
#line 1286
size_t WidthInBytes; 
#line 1287
size_t Height; 
#line 1288
size_t Depth; 
#line 1289
} CUDA_MEMCPY3D; }
#line 1322
extern "C" { typedef 
#line 1294
struct CUDA_MEMCPY3D_PEER_st { 
#line 1295
size_t srcXInBytes; 
#line 1296
size_t srcY; 
#line 1297
size_t srcZ; 
#line 1298
size_t srcLOD; 
#line 1299
CUmemorytype srcMemoryType; 
#line 1300
const void *srcHost; 
#line 1301
CUdeviceptr srcDevice; 
#line 1302
CUarray srcArray; 
#line 1303
CUcontext srcContext; 
#line 1304
size_t srcPitch; 
#line 1305
size_t srcHeight; 
#line 1307
size_t dstXInBytes; 
#line 1308
size_t dstY; 
#line 1309
size_t dstZ; 
#line 1310
size_t dstLOD; 
#line 1311
CUmemorytype dstMemoryType; 
#line 1312
void *dstHost; 
#line 1313
CUdeviceptr dstDevice; 
#line 1314
CUarray dstArray; 
#line 1315
CUcontext dstContext; 
#line 1316
size_t dstPitch; 
#line 1317
size_t dstHeight; 
#line 1319
size_t WidthInBytes; 
#line 1320
size_t Height; 
#line 1321
size_t Depth; 
#line 1322
} CUDA_MEMCPY3D_PEER; }
#line 1334
extern "C" { typedef 
#line 1327
struct CUDA_ARRAY_DESCRIPTOR_st { 
#line 1329
size_t Width; 
#line 1330
size_t Height; 
#line 1332
CUarray_format Format; 
#line 1333
unsigned NumChannels; 
#line 1334
} CUDA_ARRAY_DESCRIPTOR; }
#line 1348
extern "C" { typedef 
#line 1339
struct CUDA_ARRAY3D_DESCRIPTOR_st { 
#line 1341
size_t Width; 
#line 1342
size_t Height; 
#line 1343
size_t Depth; 
#line 1345
CUarray_format Format; 
#line 1346
unsigned NumChannels; 
#line 1347
unsigned Flags; 
#line 1348
} CUDA_ARRAY3D_DESCRIPTOR; }
#line 1388 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { typedef 
#line 1357
struct CUDA_RESOURCE_DESC_st { 
#line 1359
CUresourcetype resType; 
#line 1361
union { 
#line 1362
struct { 
#line 1363
CUarray hArray; 
#line 1364
} array; 
#line 1365
struct { 
#line 1366
CUmipmappedArray hMipmappedArray; 
#line 1367
} mipmap; 
#line 1368
struct { 
#line 1369
CUdeviceptr devPtr; 
#line 1370
CUarray_format format; 
#line 1371
unsigned numChannels; 
#line 1372
size_t sizeInBytes; 
#line 1373
} linear; 
#line 1374
struct { 
#line 1375
CUdeviceptr devPtr; 
#line 1376
CUarray_format format; 
#line 1377
unsigned numChannels; 
#line 1378
size_t width; 
#line 1379
size_t height; 
#line 1380
size_t pitchInBytes; 
#line 1381
} pitch2D; 
#line 1382
struct { 
#line 1383
int reserved[32]; 
#line 1384
} reserved; 
#line 1385
} res; 
#line 1387
unsigned flags; 
#line 1388
} CUDA_RESOURCE_DESC; }
#line 1403
extern "C" { typedef 
#line 1393
struct CUDA_TEXTURE_DESC_st { 
#line 1394
CUaddress_mode addressMode[3]; 
#line 1395
CUfilter_mode filterMode; 
#line 1396
unsigned flags; 
#line 1397
unsigned maxAnisotropy; 
#line 1398
CUfilter_mode mipmapFilterMode; 
#line 1399
float mipmapLevelBias; 
#line 1400
float minMipmapLevelClamp; 
#line 1401
float maxMipmapLevelClamp; 
#line 1402
int reserved[16]; 
#line 1403
} CUDA_TEXTURE_DESC; }
#line 1445
extern "C" { typedef 
#line 1408
enum CUresourceViewFormat_enum { 
#line 1410
CU_RES_VIEW_FORMAT_NONE, 
#line 1411
CU_RES_VIEW_FORMAT_UINT_1X8, 
#line 1412
CU_RES_VIEW_FORMAT_UINT_2X8, 
#line 1413
CU_RES_VIEW_FORMAT_UINT_4X8, 
#line 1414
CU_RES_VIEW_FORMAT_SINT_1X8, 
#line 1415
CU_RES_VIEW_FORMAT_SINT_2X8, 
#line 1416
CU_RES_VIEW_FORMAT_SINT_4X8, 
#line 1417
CU_RES_VIEW_FORMAT_UINT_1X16, 
#line 1418
CU_RES_VIEW_FORMAT_UINT_2X16, 
#line 1419
CU_RES_VIEW_FORMAT_UINT_4X16, 
#line 1420
CU_RES_VIEW_FORMAT_SINT_1X16, 
#line 1421
CU_RES_VIEW_FORMAT_SINT_2X16, 
#line 1422
CU_RES_VIEW_FORMAT_SINT_4X16, 
#line 1423
CU_RES_VIEW_FORMAT_UINT_1X32, 
#line 1424
CU_RES_VIEW_FORMAT_UINT_2X32, 
#line 1425
CU_RES_VIEW_FORMAT_UINT_4X32, 
#line 1426
CU_RES_VIEW_FORMAT_SINT_1X32, 
#line 1427
CU_RES_VIEW_FORMAT_SINT_2X32, 
#line 1428
CU_RES_VIEW_FORMAT_SINT_4X32, 
#line 1429
CU_RES_VIEW_FORMAT_FLOAT_1X16, 
#line 1430
CU_RES_VIEW_FORMAT_FLOAT_2X16, 
#line 1431
CU_RES_VIEW_FORMAT_FLOAT_4X16, 
#line 1432
CU_RES_VIEW_FORMAT_FLOAT_1X32, 
#line 1433
CU_RES_VIEW_FORMAT_FLOAT_2X32, 
#line 1434
CU_RES_VIEW_FORMAT_FLOAT_4X32, 
#line 1435
CU_RES_VIEW_FORMAT_UNSIGNED_BC1, 
#line 1436
CU_RES_VIEW_FORMAT_UNSIGNED_BC2, 
#line 1437
CU_RES_VIEW_FORMAT_UNSIGNED_BC3, 
#line 1438
CU_RES_VIEW_FORMAT_UNSIGNED_BC4, 
#line 1439
CU_RES_VIEW_FORMAT_SIGNED_BC4, 
#line 1440
CU_RES_VIEW_FORMAT_UNSIGNED_BC5, 
#line 1441
CU_RES_VIEW_FORMAT_SIGNED_BC5, 
#line 1442
CU_RES_VIEW_FORMAT_UNSIGNED_BC6H, 
#line 1443
CU_RES_VIEW_FORMAT_SIGNED_BC6H, 
#line 1444
CU_RES_VIEW_FORMAT_UNSIGNED_BC7
#line 1445
} CUresourceViewFormat; }
#line 1461
extern "C" { typedef 
#line 1450
struct CUDA_RESOURCE_VIEW_DESC_st { 
#line 1452
CUresourceViewFormat format; 
#line 1453
size_t width; 
#line 1454
size_t height; 
#line 1455
size_t depth; 
#line 1456
unsigned firstMipmapLevel; 
#line 1457
unsigned lastMipmapLevel; 
#line 1458
unsigned firstLayer; 
#line 1459
unsigned lastLayer; 
#line 1460
unsigned reserved[16]; 
#line 1461
} CUDA_RESOURCE_VIEW_DESC; }
#line 1469
extern "C" { typedef 
#line 1466
struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st { 
#line 1467
unsigned __int64 p2pToken; 
#line 1468
unsigned vaSpaceToken; 
#line 1469
} CUDA_POINTER_ATTRIBUTE_P2P_TOKENS; }
#line 1606 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuGetErrorString(CUresult , const char ** ); } 
#line 1625
extern "C" { CUresult __stdcall cuGetErrorName(CUresult , const char ** ); } 
#line 1657
extern "C" { CUresult __stdcall cuInit(unsigned ); } 
#line 1687
extern "C" { CUresult __stdcall cuDriverGetVersion(int * ); } 
#line 1727
extern "C" { CUresult __stdcall cuDeviceGet(CUdevice * , int ); } 
#line 1752
extern "C" { CUresult __stdcall cuDeviceGetCount(int * ); } 
#line 1780
extern "C" { CUresult __stdcall cuDeviceGetName(char * , int , CUdevice ); } 
#line 1807
extern "C" { CUresult __stdcall cuDeviceTotalMem_v2(size_t * , CUdevice ); } 
#line 1993 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuDeviceGetAttribute(int * , CUdevice_attribute , CUdevice ); } 
#line 2070
extern "C" { CUresult __stdcall cuDeviceGetProperties(CUdevprop * , CUdevice ); } 
#line 2103
extern "C" { CUresult __stdcall cuDeviceComputeCapability(int * , int * , CUdevice ); } 
#line 2205
extern "C" { CUresult __stdcall cuCtxCreate_v2(CUcontext * , unsigned , CUdevice ); } 
#line 2244 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuCtxDestroy_v2(CUcontext ); } 
#line 2279 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuCtxPushCurrent_v2(CUcontext ); } 
#line 2312
extern "C" { CUresult __stdcall cuCtxPopCurrent_v2(CUcontext * ); } 
#line 2338
extern "C" { CUresult __stdcall cuCtxSetCurrent(CUcontext ); } 
#line 2357
extern "C" { CUresult __stdcall cuCtxGetCurrent(CUcontext * ); } 
#line 2386 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuCtxGetDevice(CUdevice * ); } 
#line 2414
extern "C" { CUresult __stdcall cuCtxSynchronize(); } 
#line 2508
extern "C" { CUresult __stdcall cuCtxSetLimit(CUlimit , size_t ); } 
#line 2546
extern "C" { CUresult __stdcall cuCtxGetLimit(size_t * , CUlimit ); } 
#line 2588
extern "C" { CUresult __stdcall cuCtxGetCacheConfig(CUfunc_cache * ); } 
#line 2637
extern "C" { CUresult __stdcall cuCtxSetCacheConfig(CUfunc_cache ); } 
#line 2678
extern "C" { CUresult __stdcall cuCtxGetSharedMemConfig(CUsharedconfig * ); } 
#line 2729
extern "C" { CUresult __stdcall cuCtxSetSharedMemConfig(CUsharedconfig ); } 
#line 2766 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuCtxGetApiVersion(CUcontext , unsigned * ); } 
#line 2804
extern "C" { CUresult __stdcall cuCtxGetStreamPriorityRange(int * , int * ); } 
#line 2858
extern "C" { CUresult __stdcall cuCtxAttach(CUcontext * , unsigned ); } 
#line 2893
extern "C" { CUresult __stdcall cuCtxDetach(CUcontext ); } 
#line 2947
extern "C" { CUresult __stdcall cuModuleLoad(CUmodule * , const char * ); } 
#line 2983
extern "C" { CUresult __stdcall cuModuleLoadData(CUmodule * , const void * ); } 
#line 3025
extern "C" { CUresult __stdcall cuModuleLoadDataEx(CUmodule * , const void * , unsigned , CUjit_option * , void ** ); } 
#line 3066
extern "C" { CUresult __stdcall cuModuleLoadFatBinary(CUmodule * , const void * ); } 
#line 3091
extern "C" { CUresult __stdcall cuModuleUnload(CUmodule ); } 
#line 3121
extern "C" { CUresult __stdcall cuModuleGetFunction(CUfunction * , CUmodule , const char * ); } 
#line 3155
extern "C" { CUresult __stdcall cuModuleGetGlobal_v2(CUdeviceptr * , size_t * , CUmodule , const char * ); } 
#line 3189 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuModuleGetTexRef(CUtexref * , CUmodule , const char * ); } 
#line 3220
extern "C" { CUresult __stdcall cuModuleGetSurfRef(CUsurfref * , CUmodule , const char * ); } 
#line 3262
extern "C" { CUresult __stdcall cuLinkCreate(unsigned , CUjit_option * , void ** , CUlinkState * ); } 
#line 3299
extern "C" { CUresult __stdcall cuLinkAddData(CUlinkState , CUjitInputType , void * , size_t , const char * , unsigned , CUjit_option * , void ** ); } 
#line 3338
extern "C" { CUresult __stdcall cuLinkAddFile(CUlinkState , CUjitInputType , const char * , unsigned , CUjit_option * , void ** ); } 
#line 3365
extern "C" { CUresult __stdcall cuLinkComplete(CUlinkState , void ** , size_t * ); } 
#line 3379
extern "C" { CUresult __stdcall cuLinkDestroy(CUlinkState ); } 
#line 3427 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuMemGetInfo_v2(size_t * , size_t * ); } 
#line 3460
extern "C" { CUresult __stdcall cuMemAlloc_v2(CUdeviceptr * , size_t ); } 
#line 3521
extern "C" { CUresult __stdcall cuMemAllocPitch_v2(CUdeviceptr * , size_t * , size_t , size_t , unsigned ); } 
#line 3550
extern "C" { CUresult __stdcall cuMemFree_v2(CUdeviceptr ); } 
#line 3583
extern "C" { CUresult __stdcall cuMemGetAddressRange_v2(CUdeviceptr * , size_t * , CUdeviceptr ); } 
#line 3629
extern "C" { CUresult __stdcall cuMemAllocHost_v2(void ** , size_t ); } 
#line 3659 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuMemFreeHost(void * ); } 
#line 3741
extern "C" { CUresult __stdcall cuMemHostAlloc(void ** , size_t , unsigned ); } 
#line 3779
extern "C" { CUresult __stdcall cuMemHostGetDevicePointer_v2(CUdeviceptr * , void * , unsigned ); } 
#line 3804 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuMemHostGetFlags(unsigned * , void * ); } 
#line 3886
extern "C" { CUresult __stdcall cuMemAllocManaged(CUdeviceptr * , size_t , unsigned ); } 
#line 3915 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuDeviceGetByPCIBusId(CUdevice * , const char * ); } 
#line 3943
extern "C" { CUresult __stdcall cuDeviceGetPCIBusId(char * , int , CUdevice ); } 
#line 3985
extern "C" { CUresult __stdcall cuIpcGetEventHandle(CUipcEventHandle * , CUevent ); } 
#line 4022
extern "C" { CUresult __stdcall cuIpcOpenEventHandle(CUevent * , CUipcEventHandle ); } 
#line 4059
extern "C" { CUresult __stdcall cuIpcGetMemHandle(CUipcMemHandle * , CUdeviceptr ); } 
#line 4110
extern "C" { CUresult __stdcall cuIpcOpenMemHandle(CUdeviceptr * , CUipcMemHandle , unsigned ); } 
#line 4141
extern "C" { CUresult __stdcall cuIpcCloseMemHandle(CUdeviceptr ); } 
#line 4204 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuMemHostRegister(void * , size_t , unsigned ); } 
#line 4228
extern "C" { CUresult __stdcall cuMemHostUnregister(void * ); } 
#line 4264
extern "C" { CUresult __stdcall cuMemcpy(CUdeviceptr , CUdeviceptr , size_t ); } 
#line 4297
extern "C" { CUresult __stdcall cuMemcpyPeer(CUdeviceptr , CUcontext , CUdeviceptr , CUcontext , size_t ); } 
#line 4333 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuMemcpyHtoD_v2(CUdeviceptr , const void * , size_t ); } 
#line 4366
extern "C" { CUresult __stdcall cuMemcpyDtoH_v2(void * , CUdeviceptr , size_t ); } 
#line 4399
extern "C" { CUresult __stdcall cuMemcpyDtoD_v2(CUdeviceptr , CUdeviceptr , size_t ); } 
#line 4433
extern "C" { CUresult __stdcall cuMemcpyDtoA_v2(CUarray , size_t , CUdeviceptr , size_t ); } 
#line 4469
extern "C" { CUresult __stdcall cuMemcpyAtoD_v2(CUdeviceptr , CUarray , size_t , size_t ); } 
#line 4503
extern "C" { CUresult __stdcall cuMemcpyHtoA_v2(CUarray , size_t , const void * , size_t ); } 
#line 4537
extern "C" { CUresult __stdcall cuMemcpyAtoH_v2(void * , CUarray , size_t , size_t ); } 
#line 4575
extern "C" { CUresult __stdcall cuMemcpyAtoA_v2(CUarray , size_t , CUarray , size_t , size_t ); } 
#line 4735
extern "C" { CUresult __stdcall cuMemcpy2D_v2(const CUDA_MEMCPY2D * ); } 
#line 4893
extern "C" { CUresult __stdcall cuMemcpy2DUnaligned_v2(const CUDA_MEMCPY2D * ); } 
#line 5060
extern "C" { CUresult __stdcall cuMemcpy3D_v2(const CUDA_MEMCPY3D * ); } 
#line 5091 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuMemcpy3DPeer(const CUDA_MEMCPY3D_PEER * ); } 
#line 5132
extern "C" { CUresult __stdcall cuMemcpyAsync(CUdeviceptr , CUdeviceptr , size_t , CUstream ); } 
#line 5163
extern "C" { CUresult __stdcall cuMemcpyPeerAsync(CUdeviceptr , CUcontext , CUdeviceptr , CUcontext , size_t , CUstream ); } 
#line 5206 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuMemcpyHtoDAsync_v2(CUdeviceptr , const void * , size_t , CUstream ); } 
#line 5247
extern "C" { CUresult __stdcall cuMemcpyDtoHAsync_v2(void * , CUdeviceptr , size_t , CUstream ); } 
#line 5285
extern "C" { CUresult __stdcall cuMemcpyDtoDAsync_v2(CUdeviceptr , CUdeviceptr , size_t , CUstream ); } 
#line 5328
extern "C" { CUresult __stdcall cuMemcpyHtoAAsync_v2(CUarray , size_t , const void * , size_t , CUstream ); } 
#line 5371
extern "C" { CUresult __stdcall cuMemcpyAtoHAsync_v2(void * , CUarray , size_t , size_t , CUstream ); } 
#line 5543
extern "C" { CUresult __stdcall cuMemcpy2DAsync_v2(const CUDA_MEMCPY2D * , CUstream ); } 
#line 5719
extern "C" { CUresult __stdcall cuMemcpy3DAsync_v2(const CUDA_MEMCPY3D * , CUstream ); } 
#line 5745 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuMemcpy3DPeerAsync(const CUDA_MEMCPY3D_PEER * , CUstream ); } 
#line 5783 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuMemsetD8_v2(CUdeviceptr , unsigned char , size_t ); } 
#line 5819
extern "C" { CUresult __stdcall cuMemsetD16_v2(CUdeviceptr , unsigned short , size_t ); } 
#line 5855
extern "C" { CUresult __stdcall cuMemsetD32_v2(CUdeviceptr , unsigned , size_t ); } 
#line 5896
extern "C" { CUresult __stdcall cuMemsetD2D8_v2(CUdeviceptr , size_t , unsigned char , size_t , size_t ); } 
#line 5938
extern "C" { CUresult __stdcall cuMemsetD2D16_v2(CUdeviceptr , size_t , unsigned short , size_t , size_t ); } 
#line 5980
extern "C" { CUresult __stdcall cuMemsetD2D32_v2(CUdeviceptr , size_t , unsigned , size_t , size_t ); } 
#line 6018
extern "C" { CUresult __stdcall cuMemsetD8Async(CUdeviceptr , unsigned char , size_t , CUstream ); } 
#line 6056
extern "C" { CUresult __stdcall cuMemsetD16Async(CUdeviceptr , unsigned short , size_t , CUstream ); } 
#line 6093
extern "C" { CUresult __stdcall cuMemsetD32Async(CUdeviceptr , unsigned , size_t , CUstream ); } 
#line 6136
extern "C" { CUresult __stdcall cuMemsetD2D8Async(CUdeviceptr , size_t , unsigned char , size_t , size_t , CUstream ); } 
#line 6180
extern "C" { CUresult __stdcall cuMemsetD2D16Async(CUdeviceptr , size_t , unsigned short , size_t , size_t , CUstream ); } 
#line 6224
extern "C" { CUresult __stdcall cuMemsetD2D32Async(CUdeviceptr , size_t , unsigned , size_t , size_t , CUstream ); } 
#line 6327
extern "C" { CUresult __stdcall cuArrayCreate_v2(CUarray * , const CUDA_ARRAY_DESCRIPTOR * ); } 
#line 6360
extern "C" { CUresult __stdcall cuArrayGetDescriptor_v2(CUDA_ARRAY_DESCRIPTOR * , CUarray ); } 
#line 6391 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuArrayDestroy(CUarray ); } 
#line 6571
extern "C" { CUresult __stdcall cuArray3DCreate_v2(CUarray * , const CUDA_ARRAY3D_DESCRIPTOR * ); } 
#line 6607
extern "C" { CUresult __stdcall cuArray3DGetDescriptor_v2(CUDA_ARRAY3D_DESCRIPTOR * , CUarray ); } 
#line 6734 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuMipmappedArrayCreate(CUmipmappedArray * , const CUDA_ARRAY3D_DESCRIPTOR * , unsigned ); } 
#line 6760
extern "C" { CUresult __stdcall cuMipmappedArrayGetLevel(CUarray * , CUmipmappedArray , unsigned ); } 
#line 6780
extern "C" { CUresult __stdcall cuMipmappedArrayDestroy(CUmipmappedArray ); } 
#line 7026 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuPointerGetAttribute(void * , CUpointer_attribute , CUdeviceptr ); } 
#line 7069 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuPointerSetAttribute(const void * , CUpointer_attribute , CUdeviceptr ); } 
#line 7117 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuStreamCreate(CUstream * , unsigned ); } 
#line 7165
extern "C" { CUresult __stdcall cuStreamCreateWithPriority(CUstream * , unsigned , int ); } 
#line 7195
extern "C" { CUresult __stdcall cuStreamGetPriority(CUstream , int * ); } 
#line 7222
extern "C" { CUresult __stdcall cuStreamGetFlags(CUstream , unsigned * ); } 
#line 7263
extern "C" { CUresult __stdcall cuStreamWaitEvent(CUstream , CUevent , unsigned ); } 
#line 7334
extern "C" { CUresult __stdcall cuStreamAddCallback(CUstream , CUstreamCallback , void * , unsigned ); } 
#line 7410
extern "C" { CUresult __stdcall cuStreamAttachMemAsync(CUstream , CUdeviceptr , size_t , unsigned ); } 
#line 7441 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuStreamQuery(CUstream ); } 
#line 7468
extern "C" { CUresult __stdcall cuStreamSynchronize(CUstream ); } 
#line 7497
extern "C" { CUresult __stdcall cuStreamDestroy_v2(CUstream ); } 
#line 7552 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuEventCreate(CUevent * , unsigned ); } 
#line 7588
extern "C" { CUresult __stdcall cuEventRecord(CUevent , CUstream ); } 
#line 7622
extern "C" { CUresult __stdcall cuEventQuery(CUevent ); } 
#line 7656
extern "C" { CUresult __stdcall cuEventSynchronize(CUevent ); } 
#line 7685
extern "C" { CUresult __stdcall cuEventDestroy_v2(CUevent ); } 
#line 7729 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuEventElapsedTime(float * , CUevent , CUevent ); } 
#line 7796
extern "C" { CUresult __stdcall cuFuncGetAttribute(int * , CUfunction_attribute , CUfunction ); } 
#line 7839
extern "C" { CUresult __stdcall cuFuncSetCacheConfig(CUfunction , CUfunc_cache ); } 
#line 7891
extern "C" { CUresult __stdcall cuFuncSetSharedMemConfig(CUfunction , CUsharedconfig ); } 
#line 8008 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuLaunchKernel(CUfunction , unsigned , unsigned , unsigned , unsigned , unsigned , unsigned , unsigned , CUstream , void ** , void ** ); } 
#line 8069 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuFuncSetBlockShape(CUfunction , int , int , int ); } 
#line 8103
extern "C" { CUresult __stdcall cuFuncSetSharedSize(CUfunction , unsigned ); } 
#line 8135
extern "C" { CUresult __stdcall cuParamSetSize(CUfunction , unsigned ); } 
#line 8168
extern "C" { CUresult __stdcall cuParamSeti(CUfunction , int , unsigned ); } 
#line 8201
extern "C" { CUresult __stdcall cuParamSetf(CUfunction , int , float ); } 
#line 8236
extern "C" { CUresult __stdcall cuParamSetv(CUfunction , int , void * , unsigned ); } 
#line 8273
extern "C" { CUresult __stdcall cuLaunch(CUfunction ); } 
#line 8312
extern "C" { CUresult __stdcall cuLaunchGrid(CUfunction , int , int ); } 
#line 8362
extern "C" { CUresult __stdcall cuLaunchGridAsync(CUfunction , int , int , CUstream ); } 
#line 8387
extern "C" { CUresult __stdcall cuParamSetTexRef(CUfunction , int , CUtexref ); } 
#line 8429
extern "C" { CUresult __stdcall cuTexRefSetArray(CUtexref , CUarray , unsigned ); } 
#line 8456
extern "C" { CUresult __stdcall cuTexRefSetMipmappedArray(CUtexref , CUmipmappedArray , unsigned ); } 
#line 8500
extern "C" { CUresult __stdcall cuTexRefSetAddress_v2(size_t * , CUtexref , CUdeviceptr , size_t ); } 
#line 8552
extern "C" { CUresult __stdcall cuTexRefSetAddress2D_v3(CUtexref , const CUDA_ARRAY_DESCRIPTOR * , CUdeviceptr , size_t ); } 
#line 8581 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuTexRefSetFormat(CUtexref , CUarray_format , int ); } 
#line 8621
extern "C" { CUresult __stdcall cuTexRefSetAddressMode(CUtexref , int , CUaddress_mode ); } 
#line 8654
extern "C" { CUresult __stdcall cuTexRefSetFilterMode(CUtexref , CUfilter_mode ); } 
#line 8687
extern "C" { CUresult __stdcall cuTexRefSetMipmapFilterMode(CUtexref , CUfilter_mode ); } 
#line 8713
extern "C" { CUresult __stdcall cuTexRefSetMipmapLevelBias(CUtexref , float ); } 
#line 8741
extern "C" { CUresult __stdcall cuTexRefSetMipmapLevelClamp(CUtexref , float , float ); } 
#line 8767
extern "C" { CUresult __stdcall cuTexRefSetMaxAnisotropy(CUtexref , unsigned ); } 
#line 8802
extern "C" { CUresult __stdcall cuTexRefSetFlags(CUtexref , unsigned ); } 
#line 8828
extern "C" { CUresult __stdcall cuTexRefGetAddress_v2(CUdeviceptr * , CUtexref ); } 
#line 8854 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuTexRefGetArray(CUarray * , CUtexref ); } 
#line 8879
extern "C" { CUresult __stdcall cuTexRefGetMipmappedArray(CUmipmappedArray * , CUtexref ); } 
#line 8905
extern "C" { CUresult __stdcall cuTexRefGetAddressMode(CUaddress_mode * , CUtexref , int ); } 
#line 8929
extern "C" { CUresult __stdcall cuTexRefGetFilterMode(CUfilter_mode * , CUtexref ); } 
#line 8955
extern "C" { CUresult __stdcall cuTexRefGetFormat(CUarray_format * , int * , CUtexref ); } 
#line 8979
extern "C" { CUresult __stdcall cuTexRefGetMipmapFilterMode(CUfilter_mode * , CUtexref ); } 
#line 9003
extern "C" { CUresult __stdcall cuTexRefGetMipmapLevelBias(float * , CUtexref ); } 
#line 9028
extern "C" { CUresult __stdcall cuTexRefGetMipmapLevelClamp(float * , float * , CUtexref ); } 
#line 9052
extern "C" { CUresult __stdcall cuTexRefGetMaxAnisotropy(int * , CUtexref ); } 
#line 9075
extern "C" { CUresult __stdcall cuTexRefGetFlags(unsigned * , CUtexref ); } 
#line 9114
extern "C" { CUresult __stdcall cuTexRefCreate(CUtexref * ); } 
#line 9134
extern "C" { CUresult __stdcall cuTexRefDestroy(CUtexref ); } 
#line 9173
extern "C" { CUresult __stdcall cuSurfRefSetArray(CUsurfref , CUarray , unsigned ); } 
#line 9194
extern "C" { CUresult __stdcall cuSurfRefGetArray(CUarray * , CUsurfref ); } 
#line 9414
extern "C" { CUresult __stdcall cuTexObjectCreate(CUtexObject * , const CUDA_RESOURCE_DESC * , const CUDA_TEXTURE_DESC * , const CUDA_RESOURCE_VIEW_DESC * ); } 
#line 9432
extern "C" { CUresult __stdcall cuTexObjectDestroy(CUtexObject ); } 
#line 9451
extern "C" { CUresult __stdcall cuTexObjectGetResourceDesc(CUDA_RESOURCE_DESC * , CUtexObject ); } 
#line 9470
extern "C" { CUresult __stdcall cuTexObjectGetTextureDesc(CUDA_TEXTURE_DESC * , CUtexObject ); } 
#line 9490
extern "C" { CUresult __stdcall cuTexObjectGetResourceViewDesc(CUDA_RESOURCE_VIEW_DESC * , CUtexObject ); } 
#line 9529
extern "C" { CUresult __stdcall cuSurfObjectCreate(CUsurfObject * , const CUDA_RESOURCE_DESC * ); } 
#line 9547
extern "C" { CUresult __stdcall cuSurfObjectDestroy(CUsurfObject ); } 
#line 9566
extern "C" { CUresult __stdcall cuSurfObjectGetResourceDesc(CUDA_RESOURCE_DESC * , CUsurfObject ); } 
#line 9608 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuDeviceCanAccessPeer(int * , CUdevice , CUdevice ); } 
#line 9655
extern "C" { CUresult __stdcall cuCtxEnablePeerAccess(CUcontext , unsigned ); } 
#line 9680
extern "C" { CUresult __stdcall cuCtxDisablePeerAccess(CUcontext ); } 
#line 9724 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuGraphicsUnregisterResource(CUgraphicsResource ); } 
#line 9762
extern "C" { CUresult __stdcall cuGraphicsSubResourceGetMappedArray(CUarray * , CUgraphicsResource , unsigned , unsigned ); } 
#line 9793
extern "C" { CUresult __stdcall cuGraphicsResourceGetMappedMipmappedArray(CUmipmappedArray * , CUgraphicsResource ); } 
#line 9829 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuGraphicsResourceGetMappedPointer_v2(CUdeviceptr * , size_t * , CUgraphicsResource ); } 
#line 9870 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v6.0\\include\\cuda.h"
extern "C" { CUresult __stdcall cuGraphicsResourceSetMapFlags(CUgraphicsResource , unsigned ); } 
#line 9909
extern "C" { CUresult __stdcall cuGraphicsMapResources(unsigned , CUgraphicsResource * , CUstream ); } 
#line 9945
extern "C" { CUresult __stdcall cuGraphicsUnmapResources(unsigned , CUgraphicsResource * , CUstream ); } 
#line 9949
extern "C" { CUresult __stdcall cuGetExportTable(const void ** , const CUuuid * ); } 
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cstddef"
namespace std { 
#line 18
using ::ptrdiff_t;
#line 19
}
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"
#pragma warning(push,3)
#line 16
#pragma pack ( push, 8 )
#line 19
namespace std { 
#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"
template< bool _Test, class 
#line 79
_Ty1, class 
#line 80
_Ty2> 
#line 81
class _If { 
#line 84
public: typedef _Ty2 _Type; 
#line 85
}; 
#line 87
template< class _Ty1, class 
#line 88
_Ty2> 
#line 89
class _If< true, _Ty1, _Ty2>  { 
#line 92
public: typedef _Ty1 _Type; 
#line 93
}; 
#line 98
namespace tr1 { 
#line 99
typedef char (&_No)[1]; 
#line 100
typedef char (&_Yes)[2]; 
#line 101
}
#line 108 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"
struct _Bool_struct { 
#line 110
int _Member; 
#line 111
}; 
#line 125
typedef int _Bool_struct::*_Bool_type; 
#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"
template< class _Arg, class 
#line 133
_Result> 
#line 134
struct unary_function { 
#line 136
typedef _Arg argument_type; 
#line 137
typedef _Result result_type; 
#line 138
}; 
#line 141
template< class _Arg1, class 
#line 142
_Arg2, class 
#line 143
_Result> 
#line 144
struct binary_function { 
#line 146
typedef _Arg1 first_argument_type; 
#line 147
typedef _Arg2 second_argument_type; 
#line 148
typedef _Result result_type; 
#line 149
}; 
#line 150
}
#line 153
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
#pragma warning(push,3)
#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstddef"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
#pragma pack ( push, 8 )
#line 21
namespace std { 
#line 34
}
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"
#pragma pack ( push, 8 )
#line 31
typedef void (__cdecl *terminate_function)(void); 
#line 32
typedef void (__cdecl *terminate_handler)(void); 
#line 33
typedef void (__cdecl *unexpected_function)(void); 
#line 34
typedef void (__cdecl *unexpected_handler)(void); 
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"
struct _EXCEPTION_POINTERS; 
#line 51
typedef void (__cdecl *_se_translator_function)(unsigned, _EXCEPTION_POINTERS *); 
#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"
__declspec(dllimport) __declspec(noreturn) void __cdecl terminate(); 
#line 55
__declspec(dllimport) void __cdecl unexpected(); 
#line 57
__declspec(dllimport) int __cdecl _is_exception_typeof(const class type_info & , _EXCEPTION_POINTERS * ); 
#line 61
__declspec(dllimport) terminate_function __cdecl set_terminate(terminate_function ); 
#line 62
extern "C" __declspec(dllimport) terminate_function __cdecl _get_terminate(); 
#line 63
__declspec(dllimport) unexpected_function __cdecl set_unexpected(unexpected_function ); 
#line 64
extern "C" __declspec(dllimport) unexpected_function __cdecl _get_unexpected(); 
#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"
__declspec(dllimport) _se_translator_function __cdecl _set_se_translator(_se_translator_function ); 
#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\eh.h"
__declspec(dllimport) bool __cdecl __uncaught_exception(); 
#line 81
#pragma pack ( pop )
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
#pragma pack ( push, 8 )
#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
extern "C" { typedef 
#line 58
struct _heapinfo { 
#line 59
int *_pentry; 
#line 60
size_t _size; 
#line 61
int _useflag; 
#line 62
} _HEAPINFO; }
#line 142 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
extern "C" { __declspec(dllimport) int __cdecl _resetstkoflw(); } 
#line 146
extern "C" { __declspec(dllimport) unsigned long __cdecl _set_malloc_crt_max_wait(unsigned long ); } 
#line 157 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
extern "C" { __declspec(dllimport) void *__cdecl _expand(void * , size_t ); } 
#line 158
extern "C" { __declspec(dllimport) size_t __cdecl _msize(void * ); } 
#line 165 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
extern "C" { void *__cdecl _alloca(size_t ); } 
#line 166
extern "C" { __declspec(dllimport) int __cdecl _heapadd(void * , size_t ); } 
#line 167
extern "C" { __declspec(dllimport) int __cdecl _heapchk(); } 
#line 168
extern "C" { __declspec(dllimport) int __cdecl _heapmin(); } 
#line 169
extern "C" { __declspec(dllimport) int __cdecl _heapset(unsigned ); } 
#line 170
extern "C" { __declspec(dllimport) int __cdecl _heapwalk(_HEAPINFO * ); } 
#line 171
extern "C" { __declspec(dllimport) size_t __cdecl _heapused(size_t * , size_t * ); } 
#line 173
extern "C" { __declspec(dllimport) intptr_t __cdecl _get_heap_handle(); } 
#line 187 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
extern "C" { typedef char __static_assert_t[sizeof(unsigned) <= (16)]; }
#line 190
#pragma warning(push)
#pragma warning(disable:6540)
extern "C" { __inline void *_MarkAllocaS(void *_Ptr, unsigned _Marker) 
#line 193
{ 
#line 194
if (_Ptr) 
#line 195
{ 
#line 196
(*((unsigned *)_Ptr)) = _Marker; 
#line 197
_Ptr = (((char *)_Ptr) + 16); 
#line 198
}  
#line 199
return _Ptr; 
#line 200
} } 
#pragma warning(pop)
#line 227 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
extern "C" { __declspec(noalias) __inline void __cdecl _freea(void *_Memory) 
#line 228
{ 
#line 229
unsigned _Marker; 
#line 230
if (_Memory) 
#line 231
{ 
#line 232
_Memory = (((char *)_Memory) - 16); 
#line 233
_Marker = (*((unsigned *)_Memory)); 
#line 234
if (_Marker == (56797)) 
#line 235
{ 
#line 236
free(_Memory); 
#line 237
}  
#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
}  
#line 245
} } 
#line 280 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\malloc.h"
#pragma pack ( pop )
#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
namespace std { 
#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
class __declspec(dllimport) exception { 
#line 96
public: exception(); 
#line 97
explicit exception(const char *const &); 
#line 98
exception(const char *const &, int); 
#line 99
exception(const exception &); 
#line 100
exception &operator=(const exception &); 
#line 101
virtual ~exception(); 
#line 102
virtual const char *what() const; 
#line 105
private: void _Copy_str(const char *); 
#line 106
void _Tidy(); 
#line 108
const char *_Mywhat; 
#line 109
bool _Mydofree; 
#line 110
}; 
#line 192
using ::set_terminate;using ::terminate_handler;using ::terminate;using ::set_unexpected;using ::unexpected_handler;using ::unexpected;
#line 194
typedef void (__cdecl *_Prhand)(const exception &); 
#line 196
__declspec(dllimport) bool __cdecl uncaught_exception(); 
#line 198
}
#line 310 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
namespace std { 
#line 316 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
class bad_exception : public exception { 
#line 319
public: bad_exception(const char *_Message = "bad exception") throw() : exception(_Message) 
#line 322
{ 
#line 323
} 
#line 325
virtual ~bad_exception() throw() 
#line 326
{ 
#line 327
} 
#line 337 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
}; 
#line 340
class bad_alloc : public exception { 
#line 343
public: bad_alloc(const char *_Message) throw() : exception(_Message) 
#line 345
{ 
#line 346
} 
#line 348
bad_alloc() throw() : exception("bad allocation", 1) 
#line 350
{ 
#line 351
} 
#line 353
virtual ~bad_alloc() throw() 
#line 354
{ 
#line 355
} 
#line 365 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
}; 
#line 369
class bad_array_new_length : public bad_alloc { 
#line 374
public: bad_array_new_length() throw() : bad_alloc("bad array new length") 
#line 376
{ 
#line 377
} 
#line 378
}; 
#line 382 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
}
#line 394 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
__declspec(dllimport) void __cdecl __ExceptionPtrCreate(void *); 
#line 395
__declspec(dllimport) void __cdecl __ExceptionPtrDestroy(void *); 
#line 396
__declspec(dllimport) void __cdecl __ExceptionPtrCopy(void *, const void *); 
#line 397
__declspec(dllimport) void __cdecl __ExceptionPtrAssign(void *, const void *); 
#line 398
__declspec(dllimport) bool __cdecl __ExceptionPtrCompare(const void *, const void *); 
#line 400
__declspec(dllimport) void __cdecl __ExceptionPtrCurrentException(void *); 
#line 401
__declspec(dllimport) void __cdecl __ExceptionPtrRethrow(const void *); 
#line 402
__declspec(dllimport) void __cdecl __ExceptionPtrCopyException(void *, const void *, const void *); 
#line 404
namespace std { 
#line 407
typedef nullptr_t _Null_type; 
#line 412 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
class _Exception_ptr { 
#line 415
public: _Exception_ptr() 
#line 416
{ 
#line 417
__ExceptionPtrCreate(this); 
#line 418
} 
#line 419
_Exception_ptr(_Null_type) 
#line 420
{ 
#line 421
__ExceptionPtrCreate(this); 
#line 422
} 
#line 423
~_Exception_ptr() 
#line 424
{ 
#line 425
__ExceptionPtrDestroy(this); 
#line 426
} 
#line 427
_Exception_ptr(const _Exception_ptr &_Rhs) 
#line 428
{ 
#line 429
__ExceptionPtrCopy(this, const_cast< _Exception_ptr *>((&_Rhs))); 
#line 430
} 
#line 431
_Exception_ptr &operator=(const _Exception_ptr &_Rhs) 
#line 432
{ 
#line 433
__ExceptionPtrAssign(this, const_cast< _Exception_ptr *>((&_Rhs))); 
#line 434
return *this; 
#line 435
} 
#line 436
_Exception_ptr &operator=(_Null_type) 
#line 437
{ 
#line 438
_Exception_ptr _Ptr; 
#line 439
__ExceptionPtrAssign(this, &_Ptr); 
#line 440
return *this; 
#line 441
} 
#line 443
void _RethrowException() const 
#line 444
{ 
#line 445
__ExceptionPtrRethrow(const_cast< _Exception_ptr *>(this)); 
#line 446
} 
#line 448
static _Exception_ptr _Current_exception() 
#line 449
{ 
#line 450
_Exception_ptr _Retval; 
#line 451
__ExceptionPtrCurrentException(&_Retval); 
#line 452
return _Retval; 
#line 453
} 
#line 454
static _Exception_ptr _Copy_exception(void *_Except, const void *_Ptr) 
#line 455
{ 
#line 456
_Exception_ptr _Retval = 0; 
#line 457
if (!_Ptr) 
#line 458
{ 
#line 460
return _Retval; 
#line 461
}  
#line 462
__ExceptionPtrCopyException(&_Retval, _Except, _Ptr); 
#line 463
return _Retval; 
#line 464
} 
#line 466
private: void *_Data1; 
#line 467
void *_Data2; 
#line 468
}; 
#line 470
inline bool operator==(const _Exception_ptr &_Lhs, const _Exception_ptr &_Rhs) 
#line 471
{ 
#line 472
return __ExceptionPtrCompare(const_cast< _Exception_ptr *>((&_Lhs)), const_cast< _Exception_ptr *>((&_Rhs))); 
#line 473
} 
#line 475
inline bool operator==(_Null_type, const _Exception_ptr &_Rhs) 
#line 476
{ 
#line 477
_Exception_ptr _Ptr; 
#line 478
return __ExceptionPtrCompare(&_Ptr, const_cast< _Exception_ptr *>((&_Rhs))); 
#line 479
} 
#line 481
inline bool operator==(const _Exception_ptr &_Lhs, _Null_type) 
#line 482
{ 
#line 483
return operator==(0, _Lhs); 
#line 484
} 
#line 486
typedef _Exception_ptr exception_ptr; 
#line 488
inline exception_ptr current_exception() 
#line 489
{ 
#line 490
return _Exception_ptr::_Current_exception(); 
#line 491
} 
#line 493
inline void rethrow_exception(exception_ptr _P) 
#line 494
{ 
#line 495
_P._RethrowException(); 
#line 496
} 
#line 498
template< class _E> void *__GetExceptionInfo(_E); 
#line 500
template < class _E > exception_ptr copy_exception ( _E _Except )
 {
 return _Exception_ptr :: _Copy_exception ( & _Except, __GetExceptionInfo ( _Except ) );
 }
#line 505
}
#line 513
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"
#pragma warning(push,3)
#line 514 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\exception"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"
#pragma pack ( push, 8 )
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"
namespace std { 
#line 31
typedef void (__cdecl *new_handler)(void); 
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"
struct nothrow_t { 
#line 38
}; 
#line 40
extern const nothrow_t nothrow; 
#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"
__declspec(dllimport) new_handler __cdecl set_new_handler(new_handler) throw(); 
#line 46
}
#line 49
void __cdecl operator delete(void *) throw(); 
#pragma warning (suppress: 4985)
void *__cdecl operator new(size_t ); 
#line 55
inline void *__cdecl operator new(size_t, void *_Where) throw() 
#line 56
{ 
#line 57
return _Where; 
#line 58
} 
#line 60
inline void __cdecl operator delete(void *, void *) throw() 
#line 61
{ 
#line 62
} 
#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"
inline void *__cdecl operator new[](size_t, void *_Where) throw() 
#line 68
{ 
#line 69
return _Where; 
#line 70
} 
#line 72
inline void __cdecl operator delete[](void *, void *) throw() 
#line 73
{ 
#line 74
} 
#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"
void __cdecl operator delete[](void *) throw(); 
#line 79
void *__cdecl operator new[](size_t ); 
#line 84
void *__cdecl operator new(size_t , const std::nothrow_t &) throw(); 
#line 87
void *__cdecl operator new[](size_t , const std::nothrow_t &) throw(); 
#line 90
void __cdecl operator delete(void *, const std::nothrow_t &) throw(); 
#line 93
void __cdecl operator delete[](void *, const std::nothrow_t &) throw(); 
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"
using std::new_handler;
#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\new"
#pragma warning(pop)
#pragma pack ( pop )
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
#pragma pack ( push, 8 )
#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { struct _iobuf { 
#line 57
char *_ptr; 
#line 58
int _cnt; 
#line 59
char *_base; 
#line 60
int _flag; 
#line 61
int _file; 
#line 62
int _charbuf; 
#line 63
int _bufsiz; 
#line 64
char *_tmpfname; 
#line 65
}; }
#line 66
extern "C" { typedef _iobuf FILE; }
#line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) FILE *__cdecl __iob_func(); } 
#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { typedef __int64 fpos_t; }
#line 186 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _filbuf(FILE * ); } 
#line 187
extern "C" { __declspec(dllimport) int __cdecl _flsbuf(int , FILE * ); } 
#line 192
extern "C" { __declspec(dllimport) FILE *__cdecl _fsopen(const char * , const char * , int ); } 
#line 195 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) void __cdecl clearerr(FILE * ); } 
#line 197
extern "C" { __declspec(dllimport) errno_t __cdecl clearerr_s(FILE * ); } 
#line 199 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fclose(FILE * ); } 
#line 200
extern "C" { __declspec(dllimport) int __cdecl _fcloseall(); } 
#line 205
extern "C" { __declspec(dllimport) FILE *__cdecl _fdopen(int , const char * ); } 
#line 208 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl feof(FILE * ); } 
#line 209
extern "C" { __declspec(dllimport) int __cdecl ferror(FILE * ); } 
#line 210
extern "C" { __declspec(dllimport) int __cdecl fflush(FILE * ); } 
#line 211
extern "C" { __declspec(dllimport) int __cdecl fgetc(FILE * ); } 
#line 212
extern "C" { __declspec(dllimport) int __cdecl _fgetchar(); } 
#line 213
extern "C" { __declspec(dllimport) int __cdecl fgetpos(FILE * , fpos_t * ); } 
#line 214
extern "C" { __declspec(dllimport) char *__cdecl fgets(char * , int , FILE * ); } 
#line 219
extern "C" { __declspec(dllimport) int __cdecl _fileno(FILE * ); } 
#line 227 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) char *__cdecl _tempnam(const char * , const char * ); } 
#line 233 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _flushall(); } 
#line 234
extern "C" { __declspec(dllimport) FILE *__cdecl fopen(const char * , const char * ); } 
#line 236
extern "C" { __declspec(dllimport) errno_t __cdecl fopen_s(FILE ** , const char * , const char * ); } 
#line 238 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fprintf(FILE * , const char * , ...); } 
#line 240
extern "C" { __declspec(dllimport) int __cdecl fprintf_s(FILE * , const char * , ...); } 
#line 242 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fputc(int , FILE * ); } 
#line 243
extern "C" { __declspec(dllimport) int __cdecl _fputchar(int ); } 
#line 244
extern "C" { __declspec(dllimport) int __cdecl fputs(const char * , FILE * ); } 
#line 245
extern "C" { __declspec(dllimport) size_t __cdecl fread(void * , size_t , size_t , FILE * ); } 
#line 247
extern "C" { __declspec(dllimport) size_t __cdecl fread_s(void * , size_t , size_t , size_t , FILE * ); } 
#line 249 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) FILE *__cdecl freopen(const char * , const char * , FILE * ); } 
#line 251
extern "C" { __declspec(dllimport) errno_t __cdecl freopen_s(FILE ** , const char * , const char * , FILE * ); } 
#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fscanf(FILE * , const char * , ...); } 
#line 254
extern "C" { __declspec(dllimport) int __cdecl _fscanf_l(FILE * , const char * , _locale_t , ...); } 
#pragma warning(push)
#pragma warning(disable:6530)
#line 258
extern "C" { __declspec(dllimport) int __cdecl fscanf_s(FILE * , const char * , ...); } 
#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _fscanf_s_l(FILE * , const char * , _locale_t , ...); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) int __cdecl fsetpos(FILE * , const fpos_t * ); } 
#line 263
extern "C" { __declspec(dllimport) int __cdecl fseek(FILE * , long , int ); } 
#line 264
extern "C" { __declspec(dllimport) long __cdecl ftell(FILE * ); } 
#line 266
extern "C" { __declspec(dllimport) int __cdecl _fseeki64(FILE * , __int64 , int ); } 
#line 267
extern "C" { __declspec(dllimport) __int64 __cdecl _ftelli64(FILE * ); } 
#line 269
extern "C" { __declspec(dllimport) size_t __cdecl fwrite(const void * , size_t , size_t , FILE * ); } 
#line 270
extern "C" { __declspec(dllimport) int __cdecl getc(FILE * ); } 
#line 271
extern "C" { __declspec(dllimport) int __cdecl getchar(); } 
#line 272
extern "C" { __declspec(dllimport) int __cdecl _getmaxstdio(); } 
#line 274
extern "C" { __declspec(dllimport) char *__cdecl gets_s(char * , rsize_t ); } 
#line 276 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
template < size_t _Size > inline char * __cdecl gets_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return gets_s ( _Buffer, _Size ); }
#line 277
extern "C" { __declspec(dllimport) char *__cdecl gets(char * ); } 
#line 278
extern "C" { int __cdecl _getw(FILE * ); } 
#line 283
extern "C" { __declspec(dllimport) int __cdecl _pclose(FILE * ); } 
#line 284
extern "C" { __declspec(dllimport) FILE *__cdecl _popen(const char * , const char * ); } 
#line 285
extern "C" { __declspec(dllimport) int __cdecl printf(const char * , ...); } 
#line 287
extern "C" { __declspec(dllimport) int __cdecl printf_s(const char * , ...); } 
#line 289 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl putc(int , FILE * ); } 
#line 290
extern "C" { __declspec(dllimport) int __cdecl putchar(int ); } 
#line 291
extern "C" { __declspec(dllimport) int __cdecl puts(const char * ); } 
#line 292
extern "C" { __declspec(dllimport) int __cdecl _putw(int , FILE * ); } 
#line 295
extern "C" { __declspec(dllimport) int __cdecl remove(const char * ); } 
#line 296
extern "C" { __declspec(dllimport) int __cdecl rename(const char * , const char * ); } 
#line 297
extern "C" { __declspec(dllimport) int __cdecl _unlink(const char * ); } 
#line 299
extern "C" { __declspec(dllimport) int __cdecl unlink(const char * ); } 
#line 302 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) void __cdecl rewind(FILE * ); } 
#line 303
extern "C" { __declspec(dllimport) int __cdecl _rmtmp(); } 
#line 304
extern "C" { __declspec(dllimport) int __cdecl scanf(const char * , ...); } 
#line 305
extern "C" { __declspec(dllimport) int __cdecl _scanf_l(const char * , _locale_t , ...); } 
#pragma warning(push)
#pragma warning(disable:6530)
#line 309
extern "C" { __declspec(dllimport) int __cdecl scanf_s(const char * , ...); } 
#line 311 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _scanf_s_l(const char * , _locale_t , ...); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) void __cdecl setbuf(FILE * , char * ); } 
#line 314
extern "C" { __declspec(dllimport) int __cdecl _setmaxstdio(int ); } 
#line 315
extern "C" { __declspec(dllimport) unsigned __cdecl _set_output_format(unsigned ); } 
#line 316
extern "C" { __declspec(dllimport) unsigned __cdecl _get_output_format(); } 
#line 317
extern "C" { __declspec(dllimport) int __cdecl setvbuf(FILE * , char * , int , size_t ); } 
#line 318
extern "C" { __declspec(dllimport) int __cdecl _snprintf_s(char * , size_t , size_t , const char * , ...); } 
#line 319
__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl _snprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, ... ) throw ( ) { va_list _ArgList; ( __va_start ( & _ArgList, _Format ) ); return _vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _ArgList ); }__pragma( warning(pop)) 
#line 321
extern "C" { __declspec(dllimport) int __cdecl sprintf_s(char * , size_t , const char * , ...); } 
#line 323 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl sprintf_s ( char ( & _Dest ) [ _Size ], const char * _Format, ... ) throw ( ) { va_list _ArgList; ( __va_start ( & _ArgList, _Format ) ); return vsprintf_s ( _Dest, _Size, _Format, _ArgList ); }__pragma( warning(pop)) 
#line 324
extern "C" { __declspec(dllimport) int __cdecl _scprintf(const char * , ...); } 
#line 325
extern "C" { __declspec(dllimport) int __cdecl sscanf(const char * , const char * , ...); } 
#line 326
extern "C" { __declspec(dllimport) int __cdecl _sscanf_l(const char * , const char * , _locale_t , ...); } 
#pragma warning(push)
#pragma warning(disable:6530)
#line 330
extern "C" { __declspec(dllimport) int __cdecl sscanf_s(const char * , const char * , ...); } 
#line 332 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _sscanf_s_l(const char * , const char * , _locale_t , ...); } 
#line 333
extern "C" { __declspec(dllimport) int __cdecl _snscanf(const char * , size_t , const char * , ...); } 
#line 334
extern "C" { __declspec(dllimport) int __cdecl _snscanf_l(const char * , size_t , const char * , _locale_t , ...); } 
#line 335
extern "C" { __declspec(dllimport) int __cdecl _snscanf_s(const char * , size_t , const char * , ...); } 
#line 336
extern "C" { __declspec(dllimport) int __cdecl _snscanf_s_l(const char * , size_t , const char * , _locale_t , ...); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) FILE *__cdecl tmpfile(); } 
#line 340
extern "C" { __declspec(dllimport) errno_t __cdecl tmpfile_s(FILE ** ); } 
#line 341
extern "C" { __declspec(dllimport) errno_t __cdecl tmpnam_s(char * , rsize_t ); } 
#line 343 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
template < size_t _Size > inline errno_t __cdecl tmpnam_s ( char ( & _Buf ) [ _Size ] ) throw ( ) { return tmpnam_s ( _Buf, _Size ); }
#line 344
extern "C" { __declspec(dllimport) char *__cdecl tmpnam(char * ); } 
#line 345
extern "C" { __declspec(dllimport) int __cdecl ungetc(int , FILE * ); } 
#line 346
extern "C" { __declspec(dllimport) int __cdecl vfprintf(FILE * , const char * , va_list ); } 
#line 348
extern "C" { __declspec(dllimport) int __cdecl vfprintf_s(FILE * , const char * , va_list ); } 
#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl vprintf(const char * , va_list ); } 
#line 352
extern "C" { __declspec(dllimport) int __cdecl vprintf_s(const char * , va_list ); } 
#line 354 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl vsnprintf(char * , size_t , const char * , va_list ); } 
#line 356
extern "C" { __declspec(dllimport) int __cdecl vsnprintf_s(char * , size_t , size_t , const char * , va_list ); } 
#line 357
template < size_t _Size > inline int __cdecl vsnprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, va_list _Args ) throw ( ) { return vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _Args ); }
#line 359 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_s(char * , size_t , size_t , const char * , va_list ); } 
#line 360
template < size_t _Size > inline int __cdecl _vsnprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, va_list _Args ) throw ( ) { return _vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _Args ); }
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { __declspec(dllimport) int __cdecl _snprintf(char * , size_t , const char * , ...); } extern "C" { __declspec(dllimport) int __cdecl _vsnprintf(char * , size_t , const char * , va_list ); } 
#pragma warning(pop)
#line 366
extern "C" { __declspec(dllimport) int __cdecl vsprintf_s(char * , size_t , const char * , va_list ); } 
#line 367
template < size_t _Size > inline int __cdecl vsprintf_s ( char ( & _Dest ) [ _Size ], const char * _Format, va_list _Args ) throw ( ) { return vsprintf_s ( _Dest, _Size, _Format, _Args ); }
#line 369 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { __declspec(dllimport) int __cdecl sprintf(char * , const char * , ...); } extern "C" { __declspec(dllimport) int __cdecl vsprintf(char * , const char * , va_list ); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) int __cdecl _vscprintf(const char * , va_list ); } 
#line 374
extern "C" { __declspec(dllimport) int __cdecl _snprintf_c(char * , size_t , const char * , ...); } 
#line 375
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_c(char * , size_t , const char * , va_list ); } 
#line 377
extern "C" { __declspec(dllimport) int __cdecl _fprintf_p(FILE * , const char * , ...); } 
#line 378
extern "C" { __declspec(dllimport) int __cdecl _printf_p(const char * , ...); } 
#line 379
extern "C" { __declspec(dllimport) int __cdecl _sprintf_p(char * , size_t , const char * , ...); } 
#line 380
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_p(FILE * , const char * , va_list ); } 
#line 381
extern "C" { __declspec(dllimport) int __cdecl _vprintf_p(const char * , va_list ); } 
#line 382
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_p(char * , size_t , const char * , va_list ); } 
#line 383
extern "C" { __declspec(dllimport) int __cdecl _scprintf_p(const char * , ...); } 
#line 384
extern "C" { __declspec(dllimport) int __cdecl _vscprintf_p(const char * , va_list ); } 
#line 385
extern "C" { __declspec(dllimport) int __cdecl _set_printf_count_output(int ); } 
#line 386
extern "C" { __declspec(dllimport) int __cdecl _get_printf_count_output(); } 
#line 388
extern "C" { __declspec(dllimport) int __cdecl _printf_l(const char * , _locale_t , ...); } 
#line 389
extern "C" { __declspec(dllimport) int __cdecl _printf_p_l(const char * , _locale_t , ...); } 
#line 390
extern "C" { __declspec(dllimport) int __cdecl _printf_s_l(const char * , _locale_t , ...); } 
#line 391
extern "C" { __declspec(dllimport) int __cdecl _vprintf_l(const char * , _locale_t , va_list ); } 
#line 392
extern "C" { __declspec(dllimport) int __cdecl _vprintf_p_l(const char * , _locale_t , va_list ); } 
#line 393
extern "C" { __declspec(dllimport) int __cdecl _vprintf_s_l(const char * , _locale_t , va_list ); } 
#line 395
extern "C" { __declspec(dllimport) int __cdecl _fprintf_l(FILE * , const char * , _locale_t , ...); } 
#line 396
extern "C" { __declspec(dllimport) int __cdecl _fprintf_p_l(FILE * , const char * , _locale_t , ...); } 
#line 397
extern "C" { __declspec(dllimport) int __cdecl _fprintf_s_l(FILE * , const char * , _locale_t , ...); } 
#line 398
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_l(FILE * , const char * , _locale_t , va_list ); } 
#line 399
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_p_l(FILE * , const char * , _locale_t , va_list ); } 
#line 400
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_s_l(FILE * , const char * , _locale_t , va_list ); } 
#line 402
extern "C" { __declspec(dllimport) int __cdecl _sprintf_l(char * , const char * , _locale_t , ...); } 
#line 403
extern "C" { __declspec(dllimport) int __cdecl _sprintf_p_l(char * , size_t , const char * , _locale_t , ...); } 
#line 404
extern "C" { __declspec(dllimport) int __cdecl _sprintf_s_l(char * , size_t , const char * , _locale_t , ...); } 
#line 405
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_l(char * , const char * , _locale_t, va_list ); } 
#line 406
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_p_l(char * , size_t , const char * , _locale_t , va_list ); } 
#line 407
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_s_l(char * , size_t , const char * , _locale_t , va_list ); } 
#line 409
extern "C" { __declspec(dllimport) int __cdecl _scprintf_l(const char * , _locale_t , ...); } 
#line 410
extern "C" { __declspec(dllimport) int __cdecl _scprintf_p_l(const char * , _locale_t , ...); } 
#line 411
extern "C" { __declspec(dllimport) int __cdecl _vscprintf_l(const char * , _locale_t , va_list ); } 
#line 412
extern "C" { __declspec(dllimport) int __cdecl _vscprintf_p_l(const char * , _locale_t , va_list ); } 
#line 414
extern "C" { __declspec(dllimport) int __cdecl _snprintf_l(char * , size_t , const char * , _locale_t , ...); } 
#line 415
extern "C" { __declspec(dllimport) int __cdecl _snprintf_c_l(char * , size_t , const char * , _locale_t , ...); } 
#line 416
extern "C" { __declspec(dllimport) int __cdecl _snprintf_s_l(char * , size_t , size_t , const char * , _locale_t , ...); } 
#line 417
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_l(char * , size_t , const char * , _locale_t , va_list ); } 
#line 418
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_c_l(char * , size_t , const char *, _locale_t , va_list ); } 
#line 419
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_s_l(char * , size_t , size_t , const char * , _locale_t , va_list ); } 
#line 432 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) FILE *__cdecl _wfsopen(const __wchar_t * , const __wchar_t * , int ); } 
#line 435 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) wint_t __cdecl fgetwc(FILE * ); } 
#line 436
extern "C" { __declspec(dllimport) wint_t __cdecl _fgetwchar(); } 
#line 437
extern "C" { __declspec(dllimport) wint_t __cdecl fputwc(__wchar_t , FILE * ); } 
#line 438
extern "C" { __declspec(dllimport) wint_t __cdecl _fputwchar(__wchar_t ); } 
#line 439
extern "C" { __declspec(dllimport) wint_t __cdecl getwc(FILE * ); } 
#line 440
extern "C" { __declspec(dllimport) inline wint_t __cdecl getwchar(); } 
#line 441
extern "C" { __declspec(dllimport) wint_t __cdecl putwc(__wchar_t , FILE * ); } 
#line 442
extern "C" { __declspec(dllimport) inline wint_t __cdecl putwchar(__wchar_t ); } 
#line 443
extern "C" { __declspec(dllimport) wint_t __cdecl ungetwc(wint_t , FILE * ); } 
#line 445
extern "C" { __declspec(dllimport) __wchar_t *__cdecl fgetws(__wchar_t * , int , FILE * ); } 
#line 446
extern "C" { __declspec(dllimport) int __cdecl fputws(const __wchar_t * , FILE * ); } 
#line 447
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _getws_s(__wchar_t * , size_t ); } 
#line 448
template < size_t _Size > inline wchar_t * __cdecl _getws_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _getws_s ( _String, _Size ); }
#line 449
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _getws(__wchar_t * ); } 
#line 450
extern "C" { __declspec(dllimport) int __cdecl _putws(const __wchar_t * ); } 
#line 452
extern "C" { __declspec(dllimport) int __cdecl fwprintf(FILE * , const __wchar_t * , ...); } 
#line 454
extern "C" { __declspec(dllimport) int __cdecl fwprintf_s(FILE * , const __wchar_t * , ...); } 
#line 456 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl wprintf(const __wchar_t * , ...); } 
#line 458
extern "C" { __declspec(dllimport) int __cdecl wprintf_s(const __wchar_t * , ...); } 
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _scwprintf(const __wchar_t * , ...); } 
#line 461
extern "C" { __declspec(dllimport) int __cdecl vfwprintf(FILE * , const __wchar_t * , va_list ); } 
#line 463
extern "C" { __declspec(dllimport) int __cdecl vfwprintf_s(FILE * , const __wchar_t * , va_list ); } 
#line 465 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl vwprintf(const __wchar_t * , va_list ); } 
#line 467
extern "C" { __declspec(dllimport) int __cdecl vwprintf_s(const __wchar_t * , va_list ); } 
#line 471 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl swprintf_s(__wchar_t * , size_t , const __wchar_t * , ...); } 
#line 473 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl swprintf_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Format, ... ) throw ( ) { va_list _ArgList; ( __va_start ( & _ArgList, _Format ) ); return vswprintf_s ( _Dest, _Size, _Format, _ArgList ); }__pragma( warning(pop)) 
#line 475
extern "C" { __declspec(dllimport) int __cdecl vswprintf_s(__wchar_t * , size_t , const __wchar_t * , va_list ); } 
#line 477 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
template < size_t _Size > inline int __cdecl vswprintf_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Format, va_list _Args ) throw ( ) { return vswprintf_s ( _Dest, _Size, _Format, _Args ); }
#line 479
extern "C" { __declspec(dllimport) int __cdecl _swprintf_c(__wchar_t * , size_t , const __wchar_t * , ...); } 
#line 480
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_c(__wchar_t * , size_t , const __wchar_t * , va_list ); } 
#line 482
extern "C" { __declspec(dllimport) int __cdecl _snwprintf_s(__wchar_t * , size_t , size_t , const __wchar_t * , ...); } 
#line 483
__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl _snwprintf_s ( wchar_t ( & _Dest ) [ _Size ], size_t _Count, const wchar_t * _Format, ... ) throw ( ) { va_list _ArgList; ( __va_start ( & _ArgList, _Format ) ); return _vsnwprintf_s ( _Dest, _Size, _Count, _Format, _ArgList ); }__pragma( warning(pop)) 
#line 484
extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf_s(__wchar_t * , size_t , size_t , const __wchar_t * , va_list ); } 
#line 485
template < size_t _Size > inline int __cdecl _vsnwprintf_s ( wchar_t ( & _Dest ) [ _Size ], size_t _Count, const wchar_t * _Format, va_list _Args ) throw ( ) { return _vsnwprintf_s ( _Dest, _Size, _Count, _Format, _Args ); }
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { __declspec(dllimport) int __cdecl _snwprintf(__wchar_t * , size_t , const __wchar_t * , ...); } extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf(__wchar_t * , size_t , const __wchar_t * , va_list ); } 
#pragma warning(pop)
#line 491
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_p(FILE * , const __wchar_t * , ...); } 
#line 492
extern "C" { __declspec(dllimport) int __cdecl _wprintf_p(const __wchar_t * , ...); } 
#line 493
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_p(FILE * , const __wchar_t * , va_list ); } 
#line 494
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_p(const __wchar_t * , va_list ); } 
#line 495
extern "C" { __declspec(dllimport) int __cdecl _swprintf_p(__wchar_t * , size_t , const __wchar_t * , ...); } 
#line 496
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_p(__wchar_t * , size_t , const __wchar_t * , va_list ); } 
#line 497
extern "C" { __declspec(dllimport) int __cdecl _scwprintf_p(const __wchar_t * , ...); } 
#line 498
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf_p(const __wchar_t * , va_list ); } 
#line 500
extern "C" { __declspec(dllimport) int __cdecl _wprintf_l(const __wchar_t * , _locale_t , ...); } 
#line 501
extern "C" { __declspec(dllimport) int __cdecl _wprintf_p_l(const __wchar_t * , _locale_t , ...); } 
#line 502
extern "C" { __declspec(dllimport) int __cdecl _wprintf_s_l(const __wchar_t * , _locale_t , ...); } 
#line 503
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_l(const __wchar_t * , _locale_t , va_list ); } 
#line 504
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_p_l(const __wchar_t * , _locale_t , va_list ); } 
#line 505
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_s_l(const __wchar_t * , _locale_t , va_list ); } 
#line 507
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_l(FILE * , const __wchar_t * , _locale_t , ...); } 
#line 508
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_p_l(FILE * , const __wchar_t * , _locale_t , ...); } 
#line 509
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_s_l(FILE * , const __wchar_t * , _locale_t , ...); } 
#line 510
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_l(FILE * , const __wchar_t * , _locale_t , va_list ); } 
#line 511
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_p_l(FILE * , const __wchar_t * , _locale_t , va_list ); } 
#line 512
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_s_l(FILE * , const __wchar_t * , _locale_t , va_list ); } 
#line 514
extern "C" { __declspec(dllimport) int __cdecl _swprintf_c_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , ...); } 
#line 515
extern "C" { __declspec(dllimport) int __cdecl _swprintf_p_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , ...); } 
#line 516
extern "C" { __declspec(dllimport) int __cdecl _swprintf_s_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , ...); } 
#line 517
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_c_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , va_list ); } 
#line 518
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_p_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , va_list ); } 
#line 519
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_s_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , va_list ); } 
#line 521
extern "C" { __declspec(dllimport) int __cdecl _scwprintf_l(const __wchar_t * , _locale_t , ...); } 
#line 522
extern "C" { __declspec(dllimport) int __cdecl _scwprintf_p_l(const __wchar_t * , _locale_t , ...); } 
#line 523
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf_p_l(const __wchar_t * , _locale_t , va_list ); } 
#line 525
extern "C" { __declspec(dllimport) int __cdecl _snwprintf_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , ...); } 
#line 526
extern "C" { __declspec(dllimport) int __cdecl _snwprintf_s_l(__wchar_t * , size_t , size_t , const __wchar_t * , _locale_t , ...); } 
#line 527
extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf_l(__wchar_t * , size_t , const __wchar_t * , _locale_t , va_list ); } 
#line 528
extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf_s_l(__wchar_t * , size_t , size_t , const __wchar_t * , _locale_t , va_list ); } 
#line 542 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
#pragma warning(push)
#pragma warning(disable:4141 4996 4793)
extern "C" { __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _swprintf(__wchar_t * , const __wchar_t * , ...); } extern "C" { __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _vswprintf(__wchar_t * , const __wchar_t * , va_list ); } 
#line 545
extern "C" { __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __swprintf_l(__wchar_t * , const __wchar_t * , _locale_t , ...); } extern "C" { __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __vswprintf_l(__wchar_t * , const __wchar_t * , _locale_t , va_list ); } 
#pragma warning(pop)
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\swprintf.inl"
#pragma warning( push )
#pragma warning( disable : 4793 4412 )
extern "C" { static __inline int swprintf(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, ...) 
#line 37
{ 
#line 38
va_list _Arglist; 
#line 39
int _Ret; 
#line 40
__va_start(&_Arglist, _Format); 
#line 41
_Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist); 
#line 42
_Arglist = ((va_list)0); 
#line 43
return _Ret; 
#line 44
} } 
#pragma warning( pop )
#line 47
#pragma warning( push )
#pragma warning( disable : 4412 )
extern "C" { static __inline int __cdecl vswprintf(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, va_list _Ap) 
#line 50
{ 
#line 51
return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap); 
#line 52
} } 
#pragma warning( pop )
#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\swprintf.inl"
#pragma warning( push )
#pragma warning( disable : 4793 4412 )
extern "C" { static __inline int _swprintf_l(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, _locale_t _Plocinfo, ...) 
#line 61
{ 
#line 62
va_list _Arglist; 
#line 63
int _Ret; 
#line 64
__va_start(&_Arglist, _Plocinfo); 
#line 65
_Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist); 
#line 66
_Arglist = ((va_list)0); 
#line 67
return _Ret; 
#line 68
} } 
#pragma warning( pop )
#line 71
#pragma warning( push )
#pragma warning( disable : 4412 )
extern "C" { static __inline int __cdecl _vswprintf_l(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, _locale_t _Plocinfo, va_list _Ap) 
#line 74
{ 
#line 75
return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap); 
#line 76
} } 
#pragma warning( pop )
#line 80
#pragma warning( push )
#pragma warning( disable : 4996 )
#line 83
#pragma warning( push )
#pragma warning( disable : 4793 4141 )
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __inline int swprintf(__wchar_t *_String, const __wchar_t *_Format, ...) 
#line 86
{ 
#line 87
va_list _Arglist; 
#line 88
__va_start(&_Arglist, _Format); 
#line 89
int _Ret = _vswprintf(_String, _Format, _Arglist); 
#line 90
_Arglist = ((va_list)0); 
#line 91
return _Ret; 
#line 92
} 
#pragma warning( pop )
#line 95
#pragma warning( push )
#pragma warning( disable : 4141 )
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __inline int __cdecl vswprintf(__wchar_t *_String, const __wchar_t *_Format, va_list _Ap) 
#line 98
{ 
#line 99
return _vswprintf(_String, _Format, _Ap); 
#line 100
} 
#pragma warning( pop )
#line 103
#pragma warning( push )
#pragma warning( disable : 4793 4141 )
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __inline int _swprintf_l(__wchar_t *_String, const __wchar_t *_Format, _locale_t _Plocinfo, ...) 
#line 106
{ 
#line 107
va_list _Arglist; 
#line 108
__va_start(&_Arglist, _Plocinfo); 
#line 109
int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist); 
#line 110
_Arglist = ((va_list)0); 
#line 111
return _Ret; 
#line 112
} 
#pragma warning( pop )
#line 115
#pragma warning( push )
#pragma warning( disable : 4141 )
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __inline int __cdecl _vswprintf_l(__wchar_t *_String, const __wchar_t *_Format, _locale_t _Plocinfo, va_list _Ap) 
#line 118
{ 
#line 119
return __vswprintf_l(_String, _Format, _Plocinfo, _Ap); 
#line 120
} 
#pragma warning( pop )
#line 123
#pragma warning( pop )
#line 566 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wtempnam(const __wchar_t * , const __wchar_t * ); } 
#line 572 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf(const __wchar_t * , va_list ); } 
#line 573
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf_l(const __wchar_t * , _locale_t , va_list ); } 
#line 574
extern "C" { __declspec(dllimport) int __cdecl fwscanf(FILE * , const __wchar_t * , ...); } 
#line 575
extern "C" { __declspec(dllimport) int __cdecl _fwscanf_l(FILE * , const __wchar_t * , _locale_t , ...); } 
#pragma warning(push)
#pragma warning(disable:6530)
#line 579
extern "C" { __declspec(dllimport) int __cdecl fwscanf_s(FILE * , const __wchar_t * , ...); } 
#line 581 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _fwscanf_s_l(FILE * , const __wchar_t * , _locale_t , ...); } 
#line 582
extern "C" { __declspec(dllimport) int __cdecl swscanf(const __wchar_t * , const __wchar_t * , ...); } 
#line 583
extern "C" { __declspec(dllimport) int __cdecl _swscanf_l(const __wchar_t * , const __wchar_t * , _locale_t , ...); } 
#line 585
extern "C" { __declspec(dllimport) int __cdecl swscanf_s(const __wchar_t * , const __wchar_t * , ...); } 
#line 587 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _swscanf_s_l(const __wchar_t * , const __wchar_t * , _locale_t , ...); } 
#line 588
extern "C" { __declspec(dllimport) int __cdecl _snwscanf(const __wchar_t * , size_t , const __wchar_t * , ...); } 
#line 589
extern "C" { __declspec(dllimport) int __cdecl _snwscanf_l(const __wchar_t * , size_t , const __wchar_t * , _locale_t , ...); } 
#line 590
extern "C" { __declspec(dllimport) int __cdecl _snwscanf_s(const __wchar_t * , size_t , const __wchar_t * , ...); } 
#line 591
extern "C" { __declspec(dllimport) int __cdecl _snwscanf_s_l(const __wchar_t * , size_t , const __wchar_t * , _locale_t , ...); } 
#line 592
extern "C" { __declspec(dllimport) int __cdecl wscanf(const __wchar_t * , ...); } 
#line 593
extern "C" { __declspec(dllimport) int __cdecl _wscanf_l(const __wchar_t * , _locale_t , ...); } 
#line 595
extern "C" { __declspec(dllimport) int __cdecl wscanf_s(const __wchar_t * , ...); } 
#line 597 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _wscanf_s_l(const __wchar_t * , _locale_t , ...); } 
#pragma warning(pop)
#line 600
extern "C" { __declspec(dllimport) FILE *__cdecl _wfdopen(int , const __wchar_t * ); } 
#line 601
extern "C" { __declspec(dllimport) FILE *__cdecl _wfopen(const __wchar_t * , const __wchar_t * ); } 
#line 602
extern "C" { __declspec(dllimport) errno_t __cdecl _wfopen_s(FILE ** , const __wchar_t * , const __wchar_t * ); } 
#line 603
extern "C" { __declspec(dllimport) FILE *__cdecl _wfreopen(const __wchar_t * , const __wchar_t * , FILE * ); } 
#line 604
extern "C" { __declspec(dllimport) errno_t __cdecl _wfreopen_s(FILE ** , const __wchar_t * , const __wchar_t * , FILE * ); } 
#line 610
extern "C" { __declspec(dllimport) FILE *__cdecl _wpopen(const __wchar_t * , const __wchar_t * ); } 
#line 611
extern "C" { __declspec(dllimport) int __cdecl _wremove(const __wchar_t * ); } 
#line 612
extern "C" { __declspec(dllimport) errno_t __cdecl _wtmpnam_s(__wchar_t * , size_t ); } 
#line 613
template < size_t _Size > inline errno_t __cdecl _wtmpnam_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wtmpnam_s ( _Buffer, _Size ); }
#line 614
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wtmpnam(__wchar_t * ); } 
#line 616
extern "C" { __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(FILE * ); } 
#line 617
extern "C" { __declspec(dllimport) wint_t __cdecl _fputwc_nolock(__wchar_t , FILE * ); } 
#line 618
extern "C" { __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(wint_t , FILE * ); } 
#line 626 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { inline wint_t __cdecl getwchar() 
#line 627
{ return fgetwc(&(__iob_func()[0])); } } 
#line 628
extern "C" { inline wint_t __cdecl putwchar(__wchar_t _C) 
#line 629
{ return fputwc(_C, &(__iob_func()[1])); } } 
#line 675 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) void __cdecl _lock_file(FILE * ); } 
#line 676
extern "C" { __declspec(dllimport) void __cdecl _unlock_file(FILE * ); } 
#line 678
extern "C" { __declspec(dllimport) int __cdecl _fclose_nolock(FILE * ); } 
#line 679
extern "C" { __declspec(dllimport) int __cdecl _fflush_nolock(FILE * ); } 
#line 680
extern "C" { __declspec(dllimport) size_t __cdecl _fread_nolock(void * , size_t , size_t , FILE * ); } 
#line 681
extern "C" { __declspec(dllimport) size_t __cdecl _fread_nolock_s(void * , size_t , size_t , size_t , FILE * ); } 
#line 682
extern "C" { __declspec(dllimport) int __cdecl _fseek_nolock(FILE * , long , int ); } 
#line 683
extern "C" { __declspec(dllimport) long __cdecl _ftell_nolock(FILE * ); } 
#line 684
extern "C" { __declspec(dllimport) int __cdecl _fseeki64_nolock(FILE * , __int64 , int ); } 
#line 685
extern "C" { __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(FILE * ); } 
#line 686
extern "C" { __declspec(dllimport) size_t __cdecl _fwrite_nolock(const void * , size_t , size_t , FILE * ); } 
#line 687
extern "C" { __declspec(dllimport) int __cdecl _ungetc_nolock(int , FILE * ); } 
#line 714 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) char *__cdecl tempnam(const char * , const char * ); } 
#line 720 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fcloseall(); } 
#line 721
extern "C" { __declspec(dllimport) FILE *__cdecl fdopen(int , const char * ); } 
#line 722
extern "C" { __declspec(dllimport) int __cdecl fgetchar(); } 
#line 723
extern "C" { __declspec(dllimport) int __cdecl fileno(FILE * ); } 
#line 724
extern "C" { __declspec(dllimport) int __cdecl flushall(); } 
#line 725
extern "C" { __declspec(dllimport) int __cdecl fputchar(int ); } 
#line 726
extern "C" { __declspec(dllimport) int __cdecl getw(FILE * ); } 
#line 727
extern "C" { __declspec(dllimport) int __cdecl putw(int , FILE * ); } 
#line 728
extern "C" { __declspec(dllimport) int __cdecl rmtmp(); } 
#line 736 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdio.h"
#pragma pack ( pop )
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cstdio"
typedef FILE _iobuf; 
#line 37
namespace std { 
#line 38
using ::_iobuf;
#line 40
using ::fpos_t;using ::FILE;
#line 41
using ::clearerr;using ::fclose;using ::feof;
#line 42
using ::ferror;using ::fflush;using ::fgetc;
#line 43
using ::fgetpos;using ::fgets;using ::fopen;
#line 44
using ::fprintf;using ::fputc;using ::fputs;
#line 45
using ::fread;using ::freopen;using ::fscanf;
#line 46
using ::fseek;using ::fsetpos;using ::ftell;
#line 47
using ::fwrite;using ::getc;using ::getchar;
#line 48
using ::gets;using ::perror;
#line 49
using ::putc;using ::putchar;
#line 50
using ::printf;using ::puts;using ::remove;
#line 51
using ::rename;using ::rewind;using ::scanf;
#line 52
using ::setbuf;using ::setvbuf;using ::sprintf;
#line 53
using ::sscanf;using ::tmpfile;using ::tmpnam;
#line 54
using ::ungetc;using ::vfprintf;using ::vprintf;
#line 55
using ::vsprintf;
#line 56
}
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cstring"
namespace std { 
#line 18
using ::memchr;using ::memcmp;
#line 20
using ::memcpy;using ::memmove;using ::memset;
#line 21
using ::strcat;using ::strchr;using ::strcmp;
#line 22
using ::strcoll;using ::strcpy;using ::strcspn;
#line 23
using ::strerror;using ::strlen;using ::strncat;
#line 24
using ::strncmp;using ::strncpy;using ::strpbrk;
#line 25
using ::strrchr;using ::strspn;using ::strstr;
#line 26
using ::strtok;using ::strxfrm;
#line 27
}
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
#pragma pack ( push, 8 )
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { typedef unsigned long _fsize_t; }
#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { struct _wfinddata32_t { 
#line 90
unsigned attrib; 
#line 91
__time32_t time_create; 
#line 92
__time32_t time_access; 
#line 93
__time32_t time_write; 
#line 94
_fsize_t size; 
#line 95
__wchar_t name[260]; 
#line 96
}; }
#line 98
extern "C" { struct _wfinddata32i64_t { 
#line 99
unsigned attrib; 
#line 100
__time32_t time_create; 
#line 101
__time32_t time_access; 
#line 102
__time32_t time_write; 
#line 103
__int64 size; 
#line 104
__wchar_t name[260]; 
#line 105
}; }
#line 107
extern "C" { struct _wfinddata64i32_t { 
#line 108
unsigned attrib; 
#line 109
__time64_t time_create; 
#line 110
__time64_t time_access; 
#line 111
__time64_t time_write; 
#line 112
_fsize_t size; 
#line 113
__wchar_t name[260]; 
#line 114
}; }
#line 116
extern "C" { struct _wfinddata64_t { 
#line 117
unsigned attrib; 
#line 118
__time64_t time_create; 
#line 119
__time64_t time_access; 
#line 120
__time64_t time_write; 
#line 121
__int64 size; 
#line 122
__wchar_t name[260]; 
#line 123
}; }
#line 182 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { __declspec(dllimport) const unsigned short *__cdecl __pctype_func(); } 
#line 184
extern "C" __declspec(dllimport) const unsigned short *_pctype; 
#line 195 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" __declspec(dllimport) const unsigned short _wctype[]; 
#line 198 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { __declspec(dllimport) const wctype_t *__cdecl __pwctype_func(); } 
#line 200
extern "C" __declspec(dllimport) const wctype_t *_pwctype; 
#line 230 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { __declspec(dllimport) int __cdecl iswalpha(wint_t ); } 
#line 231
extern "C" { __declspec(dllimport) int __cdecl _iswalpha_l(wint_t , _locale_t ); } 
#line 232
extern "C" { __declspec(dllimport) int __cdecl iswupper(wint_t ); } 
#line 233
extern "C" { __declspec(dllimport) int __cdecl _iswupper_l(wint_t , _locale_t ); } 
#line 234
extern "C" { __declspec(dllimport) int __cdecl iswlower(wint_t ); } 
#line 235
extern "C" { __declspec(dllimport) int __cdecl _iswlower_l(wint_t , _locale_t ); } 
#line 236
extern "C" { __declspec(dllimport) int __cdecl iswdigit(wint_t ); } 
#line 237
extern "C" { __declspec(dllimport) int __cdecl _iswdigit_l(wint_t , _locale_t ); } 
#line 238
extern "C" { __declspec(dllimport) int __cdecl iswxdigit(wint_t ); } 
#line 239
extern "C" { __declspec(dllimport) int __cdecl _iswxdigit_l(wint_t , _locale_t ); } 
#line 240
extern "C" { __declspec(dllimport) int __cdecl iswspace(wint_t ); } 
#line 241
extern "C" { __declspec(dllimport) int __cdecl _iswspace_l(wint_t , _locale_t ); } 
#line 242
extern "C" { __declspec(dllimport) int __cdecl iswpunct(wint_t ); } 
#line 243
extern "C" { __declspec(dllimport) int __cdecl _iswpunct_l(wint_t , _locale_t ); } 
#line 244
extern "C" { __declspec(dllimport) int __cdecl iswalnum(wint_t ); } 
#line 245
extern "C" { __declspec(dllimport) int __cdecl _iswalnum_l(wint_t , _locale_t ); } 
#line 246
extern "C" { __declspec(dllimport) int __cdecl iswprint(wint_t ); } 
#line 247
extern "C" { __declspec(dllimport) int __cdecl _iswprint_l(wint_t , _locale_t ); } 
#line 248
extern "C" { __declspec(dllimport) int __cdecl iswgraph(wint_t ); } 
#line 249
extern "C" { __declspec(dllimport) int __cdecl _iswgraph_l(wint_t , _locale_t ); } 
#line 250
extern "C" { __declspec(dllimport) int __cdecl iswcntrl(wint_t ); } 
#line 251
extern "C" { __declspec(dllimport) int __cdecl _iswcntrl_l(wint_t , _locale_t ); } 
#line 252
extern "C" { __declspec(dllimport) int __cdecl iswascii(wint_t ); } 
#line 253
extern "C" { __declspec(dllimport) int __cdecl isleadbyte(int ); } 
#line 254
extern "C" { __declspec(dllimport) int __cdecl _isleadbyte_l(int , _locale_t ); } 
#line 256
extern "C" { __declspec(dllimport) wint_t __cdecl towupper(wint_t ); } 
#line 257
extern "C" { __declspec(dllimport) wint_t __cdecl _towupper_l(wint_t , _locale_t ); } 
#line 258
extern "C" { __declspec(dllimport) wint_t __cdecl towlower(wint_t ); } 
#line 259
extern "C" { __declspec(dllimport) wint_t __cdecl _towlower_l(wint_t , _locale_t ); } 
#line 260
extern "C" { __declspec(dllimport) int __cdecl iswctype(wint_t , wctype_t ); } 
#line 261
extern "C" { __declspec(dllimport) int __cdecl _iswctype_l(wint_t , wctype_t , _locale_t ); } 
#line 263
extern "C" { __declspec(dllimport) int __cdecl __iswcsymf(wint_t ); } 
#line 264
extern "C" { __declspec(dllimport) int __cdecl _iswcsymf_l(wint_t , _locale_t ); } 
#line 265
extern "C" { __declspec(dllimport) int __cdecl __iswcsym(wint_t ); } 
#line 266
extern "C" { __declspec(dllimport) int __cdecl _iswcsym_l(wint_t , _locale_t ); } 
#line 268
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using iswctype instea" "d. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(wint_t , wctype_t ); } 
#line 286 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wgetcwd(__wchar_t * , int ); } 
#line 287
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wgetdcwd(int , __wchar_t * , int ); } 
#line 288
extern "C" { __wchar_t *__cdecl _wgetdcwd_nolock(int , __wchar_t * , int ); } 
#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { __declspec(dllimport) int __cdecl _wchdir(const __wchar_t * ); } 
#line 297
extern "C" { __declspec(dllimport) int __cdecl _wmkdir(const __wchar_t * ); } 
#line 298
extern "C" { __declspec(dllimport) int __cdecl _wrmdir(const __wchar_t * ); } 
#line 305 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { __declspec(dllimport) int __cdecl _waccess(const __wchar_t * , int ); } 
#line 306
extern "C" { __declspec(dllimport) errno_t __cdecl _waccess_s(const __wchar_t * , int ); } 
#line 307
extern "C" { __declspec(dllimport) int __cdecl _wchmod(const __wchar_t * , int ); } 
#line 308
extern "C" { __declspec(dllimport) int __cdecl _wcreat(const __wchar_t * , int ); } 
#line 309
extern "C" { __declspec(dllimport) intptr_t __cdecl _wfindfirst32(const __wchar_t * , _wfinddata32_t * ); } 
#line 310
extern "C" { __declspec(dllimport) int __cdecl _wfindnext32(intptr_t , _wfinddata32_t * ); } 
#line 311
extern "C" { __declspec(dllimport) int __cdecl _wunlink(const __wchar_t * ); } 
#line 312
extern "C" { __declspec(dllimport) int __cdecl _wrename(const __wchar_t * , const __wchar_t * ); } 
#line 313
extern "C" { __declspec(dllimport) errno_t __cdecl _wmktemp_s(__wchar_t * , size_t ); } 
#line 314
template < size_t _Size > inline errno_t __cdecl _wmktemp_s ( wchar_t ( & _TemplateName ) [ _Size ] ) throw ( ) { return _wmktemp_s ( _TemplateName, _Size ); }
#line 315
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wmktemp(__wchar_t * ); } 
#line 317
extern "C" { __declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(const __wchar_t * , _wfinddata32i64_t * ); } 
#line 318
extern "C" { __declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(const __wchar_t * , _wfinddata64i32_t * ); } 
#line 319
extern "C" { __declspec(dllimport) intptr_t __cdecl _wfindfirst64(const __wchar_t * , _wfinddata64_t * ); } 
#line 320
extern "C" { __declspec(dllimport) int __cdecl _wfindnext32i64(intptr_t , _wfinddata32i64_t * ); } 
#line 321
extern "C" { __declspec(dllimport) int __cdecl _wfindnext64i32(intptr_t , _wfinddata64i32_t * ); } 
#line 322
extern "C" { __declspec(dllimport) int __cdecl _wfindnext64(intptr_t , _wfinddata64_t * ); } 
#line 324
extern "C" { __declspec(dllimport) errno_t __cdecl _wsopen_s(int * , const __wchar_t * , int , int , int ); } 
#line 328
extern "C" { __declspec(dllimport) int __cdecl _wopen(const __wchar_t * , int , ...); } 
#line 329
extern "C" { __declspec(dllimport) int __cdecl _wsopen(const __wchar_t * , int , int , ...); } 
#line 346 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wsetlocale(int , const __wchar_t * ); } 
#line 355 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecl(const __wchar_t * , const __wchar_t * , ...); } 
#line 356
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecle(const __wchar_t * , const __wchar_t * , ...); } 
#line 357
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexeclp(const __wchar_t * , const __wchar_t * , ...); } 
#line 358
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexeclpe(const __wchar_t * , const __wchar_t * , ...); } 
#line 359
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecv(const __wchar_t * , const __wchar_t *const * ); } 
#line 360
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecve(const __wchar_t * , const __wchar_t *const * , const __wchar_t *const * ); } 
#line 362
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecvp(const __wchar_t * , const __wchar_t *const * ); } 
#line 363
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecvpe(const __wchar_t * , const __wchar_t *const * , const __wchar_t *const * ); } 
#line 365
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnl(int , const __wchar_t * , const __wchar_t * , ...); } 
#line 366
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnle(int , const __wchar_t * , const __wchar_t * , ...); } 
#line 367
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnlp(int , const __wchar_t * , const __wchar_t * , ...); } 
#line 368
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnlpe(int , const __wchar_t * , const __wchar_t * , ...); } 
#line 369
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnv(int , const __wchar_t * , const __wchar_t *const * ); } 
#line 370
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnve(int , const __wchar_t * , const __wchar_t *const * , const __wchar_t *const * ); } 
#line 372
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnvp(int , const __wchar_t * , const __wchar_t *const * ); } 
#line 373
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnvpe(int , const __wchar_t * , const __wchar_t *const * , const __wchar_t *const * ); } 
#line 453 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { typedef unsigned short _ino_t; }
#line 456
extern "C" { typedef unsigned short ino_t; }
#line 462 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { typedef unsigned _dev_t; }
#line 465
extern "C" { typedef unsigned dev_t; }
#line 471 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { typedef long _off_t; }
#line 474
extern "C" { typedef long off_t; }
#line 481 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { struct _stat32 { 
#line 482
_dev_t st_dev; 
#line 483
_ino_t st_ino; 
#line 484
unsigned short st_mode; 
#line 485
short st_nlink; 
#line 486
short st_uid; 
#line 487
short st_gid; 
#line 488
_dev_t st_rdev; 
#line 489
_off_t st_size; 
#line 490
__time32_t st_atime; 
#line 491
__time32_t st_mtime; 
#line 492
__time32_t st_ctime; 
#line 493
}; }
#line 497
extern "C" { struct stat { 
#line 498
_dev_t st_dev; 
#line 499
_ino_t st_ino; 
#line 500
unsigned short st_mode; 
#line 501
short st_nlink; 
#line 502
short st_uid; 
#line 503
short st_gid; 
#line 504
_dev_t st_rdev; 
#line 505
_off_t st_size; 
#line 506
time_t st_atime; 
#line 507
time_t st_mtime; 
#line 508
time_t st_ctime; 
#line 509
}; }
#line 513 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { struct _stat32i64 { 
#line 514
_dev_t st_dev; 
#line 515
_ino_t st_ino; 
#line 516
unsigned short st_mode; 
#line 517
short st_nlink; 
#line 518
short st_uid; 
#line 519
short st_gid; 
#line 520
_dev_t st_rdev; 
#line 521
__int64 st_size; 
#line 522
__time32_t st_atime; 
#line 523
__time32_t st_mtime; 
#line 524
__time32_t st_ctime; 
#line 525
}; }
#line 527
extern "C" { struct _stat64i32 { 
#line 528
_dev_t st_dev; 
#line 529
_ino_t st_ino; 
#line 530
unsigned short st_mode; 
#line 531
short st_nlink; 
#line 532
short st_uid; 
#line 533
short st_gid; 
#line 534
_dev_t st_rdev; 
#line 535
_off_t st_size; 
#line 536
__time64_t st_atime; 
#line 537
__time64_t st_mtime; 
#line 538
__time64_t st_ctime; 
#line 539
}; }
#line 541
extern "C" { struct _stat64 { 
#line 542
_dev_t st_dev; 
#line 543
_ino_t st_ino; 
#line 544
unsigned short st_mode; 
#line 545
short st_nlink; 
#line 546
short st_uid; 
#line 547
short st_gid; 
#line 548
_dev_t st_rdev; 
#line 549
__int64 st_size; 
#line 550
__time64_t st_atime; 
#line 551
__time64_t st_mtime; 
#line 552
__time64_t st_ctime; 
#line 553
}; }
#line 587 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { __declspec(dllimport) int __cdecl _wstat32(const __wchar_t * , _stat32 * ); } 
#line 589
extern "C" { __declspec(dllimport) int __cdecl _wstat32i64(const __wchar_t * , _stat32i64 * ); } 
#line 590
extern "C" { __declspec(dllimport) int __cdecl _wstat64i32(const __wchar_t * , _stat64i32 * ); } 
#line 591
extern "C" { __declspec(dllimport) int __cdecl _wstat64(const __wchar_t * , _stat64 * ); } 
#line 607 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _cgetws_s(__wchar_t * , size_t , size_t * ); } 
#line 608
template < size_t _Size > inline errno_t __cdecl _cgetws_s ( wchar_t ( & _Buffer ) [ _Size ], size_t * _SizeRead ) throw ( ) { return _cgetws_s ( _Buffer, _Size, _SizeRead ); }
#line 609
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _cgetws(__wchar_t * ); } 
#line 610
extern "C" { __declspec(dllimport) wint_t __cdecl _getwch(); } 
#line 611
extern "C" { __declspec(dllimport) wint_t __cdecl _getwche(); } 
#line 612
extern "C" { __declspec(dllimport) wint_t __cdecl _putwch(__wchar_t ); } 
#line 613
extern "C" { __declspec(dllimport) wint_t __cdecl _ungetwch(wint_t ); } 
#line 614
extern "C" { __declspec(dllimport) int __cdecl _cputws(const __wchar_t * ); } 
#line 615
extern "C" { __declspec(dllimport) int __cdecl _cwprintf(const __wchar_t * , ...); } 
#line 616
extern "C" { __declspec(dllimport) int __cdecl _cwprintf_s(const __wchar_t * , ...); } 
#line 617
extern "C" { __declspec(dllimport) int __cdecl _cwscanf(const __wchar_t * , ...); } 
#line 618
extern "C" { __declspec(dllimport) int __cdecl _cwscanf_l(const __wchar_t * , _locale_t , ...); } 
#line 619
extern "C" { __declspec(dllimport) int __cdecl _cwscanf_s(const __wchar_t * , ...); } 
#line 620
extern "C" { __declspec(dllimport) int __cdecl _cwscanf_s_l(const __wchar_t * , _locale_t , ...); } 
#line 621
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf(const __wchar_t * , va_list ); } 
#line 622
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_s(const __wchar_t * , va_list ); } 
#line 624
extern "C" { __declspec(dllimport) int __cdecl _cwprintf_p(const __wchar_t * , ...); } 
#line 625
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_p(const __wchar_t * , va_list ); } 
#line 627
extern "C" { __declspec(dllimport) int __cdecl _cwprintf_l(const __wchar_t * , _locale_t , ...); } 
#line 628
extern "C" { __declspec(dllimport) int __cdecl _cwprintf_s_l(const __wchar_t * , _locale_t , ...); } 
#line 629
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_l(const __wchar_t * , _locale_t , va_list ); } 
#line 630
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_s_l(const __wchar_t * , _locale_t , va_list ); } 
#line 631
extern "C" { __declspec(dllimport) int __cdecl _cwprintf_p_l(const __wchar_t * , _locale_t , ...); } 
#line 632
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_p_l(const __wchar_t * , _locale_t , va_list ); } 
#line 634
extern "C" { wint_t __cdecl _putwch_nolock(__wchar_t ); } 
#line 635
extern "C" { wint_t __cdecl _getwch_nolock(); } 
#line 636
extern "C" { wint_t __cdecl _getwche_nolock(); } 
#line 637
extern "C" { wint_t __cdecl _ungetwch_nolock(wint_t ); } 
#line 1159 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { typedef int mbstate_t; }
#line 1160
extern "C" { typedef __wchar_t _Wint_t; }
#line 1162
extern "C" { __declspec(dllimport) wint_t __cdecl btowc(int); } 
#line 1163
extern "C" { __declspec(dllimport) size_t __cdecl mbrlen(const char * , size_t , mbstate_t * ); } 
#line 1165
extern "C" { __declspec(dllimport) size_t __cdecl mbrtowc(__wchar_t * , const char * , size_t , mbstate_t * ); } 
#line 1167
extern "C" { __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(size_t * , __wchar_t * , size_t , const char ** , size_t , mbstate_t * ); } 
#line 1168
template < size_t _Size > inline errno_t __cdecl mbsrtowcs_s ( size_t * _Retval, wchar_t ( & _Dest ) [ _Size ], const char * * _PSource, size_t _Count, mbstate_t * _State ) throw ( ) { return mbsrtowcs_s ( _Retval, _Dest, _Size, _PSource, _Count, _State ); }
#line 1169
extern "C" { __declspec(dllimport) size_t __cdecl mbsrtowcs(__wchar_t * , const char ** , size_t , mbstate_t * ); } 
#line 1171
extern "C" { __declspec(dllimport) errno_t __cdecl wcrtomb_s(size_t * , char * , size_t , __wchar_t , mbstate_t * ); } 
#line 1173
template < size_t _Size > inline errno_t __cdecl wcrtomb_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], wchar_t _Source, mbstate_t * _State ) throw ( ) { return wcrtomb_s ( _Retval, _Dest, _Size, _Source, _State ); }
#line 1174
extern "C" { __declspec(dllimport) size_t __cdecl wcrtomb(char * , __wchar_t , mbstate_t * ); } 
#line 1175
extern "C" { __declspec(dllimport) errno_t __cdecl wcsrtombs_s(size_t * , char * , size_t , const __wchar_t ** , size_t , mbstate_t * ); } 
#line 1177
template < size_t _Size > inline errno_t __cdecl wcsrtombs_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], const wchar_t * * _PSrc, size_t _Count, mbstate_t * _State ) throw ( ) { return wcsrtombs_s ( _Retval, _Dest, _Size, _PSrc, _Count, _State ); }
#line 1178
extern "C" { __declspec(dllimport) size_t __cdecl wcsrtombs(char * , const __wchar_t ** , size_t , mbstate_t * ); } 
#line 1179
extern "C" { __declspec(dllimport) int __cdecl wctob(wint_t ); } 
#line 1187 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { __declspec(dllimport) void *__cdecl memmove(void * , const void * , size_t ); } 
#line 1189 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { void *__cdecl memcpy(void * , const void * , size_t ); } 
#line 1191
extern "C" { __declspec(dllimport) errno_t __cdecl memcpy_s(void * , rsize_t , const void * , rsize_t ); } 
#line 1192
extern "C" { __declspec(dllimport) errno_t __cdecl memmove_s(void * , rsize_t , const void * , rsize_t ); } 
#line 1194 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { __inline int __cdecl fwide(FILE *_F, int _M) 
#line 1195
{ (void)_F; return _M; } } 
#line 1196
extern "C" { __inline int __cdecl mbsinit(const mbstate_t *_P) 
#line 1197
{ return (_P == (0)) || ((*_P) == 0); } } 
#line 1198
extern "C" { __inline const __wchar_t *__cdecl wmemchr(const __wchar_t *_S, __wchar_t _C, size_t _N) 
#line 1199
{ for (; (0) < _N; (++_S), (--_N)) { 
#line 1200
if ((*_S) == _C) { 
#line 1201
return _S; }  }  
#line 1202
return 0; } } 
#line 1203
extern "C" { __inline int __cdecl wmemcmp(const __wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
#line 1204
{ for (; (0) < _N; ((++_S1), (++_S2)), (--_N)) { 
#line 1205
if ((*_S1) != (*_S2)) { 
#line 1206
return ((*_S1) < (*_S2)) ? (-1) : (+1); }  }  
#line 1207
return 0; } } 
#line 1209
extern "C" { __inline __wchar_t *__cdecl wmemcpy(__wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
#line 1210
{ 
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
return (__wchar_t *)memcpy(_S1, _S2, _N * sizeof(__wchar_t)); 
#pragma warning( pop )
} } 
#line 1217
extern "C" { __inline __wchar_t *__cdecl wmemmove(__wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
#line 1218
{ 
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
#pragma warning( disable : 6387)
#line 1223
return (__wchar_t *)memmove(_S1, _S2, _N * sizeof(__wchar_t)); 
#pragma warning( pop )
} } 
#line 1228
extern "C" { errno_t __cdecl wmemcpy_s(__wchar_t * , rsize_t , const __wchar_t * , rsize_t ); } 
#line 1229
extern "C" { errno_t __cdecl wmemmove_s(__wchar_t * , rsize_t , const __wchar_t * , rsize_t ); } 
#line 1232 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
extern "C" { __inline __wchar_t *__cdecl wmemset(__wchar_t *_S, __wchar_t _C, size_t _N) 
#line 1233
{ 
#line 1234
__wchar_t *_Su = _S; 
#line 1235
for (; (0) < _N; (++_Su), (--_N)) 
#line 1236
{ 
#line 1237
(*_Su) = _C; 
#line 1238
}  
#line 1239
return _S; 
#line 1240
} } 
#line 1244
inline __wchar_t *__cdecl wmemchr(__wchar_t *_S, __wchar_t _C, size_t _N) 
#line 1245
{ return (__wchar_t *)wmemchr((const __wchar_t *)_S, _C, _N); } 
#line 1254 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wchar.h"
#pragma pack ( pop )
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cwchar"
typedef mbstate_t _Mbstatet; 
#line 19
namespace std { 
#line 20
using ::_Mbstatet;
#line 22
using ::mbstate_t;
#line 23
using ::tm;using ::wint_t;
#line 25
using ::btowc;using ::fgetwc;using ::fgetws;using ::fputwc;
#line 26
using ::fputws;using ::fwide;using ::fwprintf;
#line 27
using ::fwscanf;using ::getwc;using ::getwchar;
#line 28
using ::mbrlen;using ::mbrtowc;using ::mbsrtowcs;
#line 29
using ::mbsinit;using ::putwc;using ::putwchar;
#line 30
using ::swprintf;using ::swscanf;using ::ungetwc;
#line 31
using ::vfwprintf;using ::vswprintf;using ::vwprintf;
#line 32
using ::wcrtomb;using ::wprintf;using ::wscanf;
#line 33
using ::wcsrtombs;using ::wcstol;using ::wcscat;
#line 34
using ::wcschr;using ::wcscmp;using ::wcscoll;
#line 35
using ::wcscpy;using ::wcscspn;using ::wcslen;
#line 36
using ::wcsncat;using ::wcsncmp;using ::wcsncpy;
#line 37
using ::wcspbrk;using ::wcsrchr;using ::wcsspn;
#line 39
using ::wcstod;using ::wcstoul;using ::wcsstr;
#line 41
using ::wcstok;using ::wcsxfrm;using ::wctob;
#line 42
using ::wmemchr;using ::wmemcmp;using ::wmemcpy;
#line 43
using ::wmemmove;using ::wmemset;using ::wcsftime;
#line 44
}
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdbg.h"
#pragma pack ( push, 8 )
#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdbg.h"
extern "C" { typedef void *_HFILE; }
#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdbg.h"
extern "C" { typedef int (__cdecl *_CRT_REPORT_HOOK)(int, char *, int *); }
#line 69
extern "C" { typedef int (__cdecl *_CRT_REPORT_HOOKW)(int, __wchar_t *, int *); }
#line 100 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdbg.h"
extern "C" { typedef int (__cdecl *_CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int); }
#line 161 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdbg.h"
extern "C" { typedef void (__cdecl *_CRT_DUMP_CLIENT)(void *, size_t); }
#line 169 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdbg.h"
struct _CrtMemBlockHeader; 
#line 177
extern "C" { typedef 
#line 170
struct _CrtMemState { 
#line 172
_CrtMemBlockHeader *pBlockHeader; 
#line 173
size_t lCounts[5]; 
#line 174
size_t lSizes[5]; 
#line 175
size_t lHighWaterCount; 
#line 176
size_t lTotalCount; 
#line 177
} _CrtMemState; }
#line 1040 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdbg.h"
#pragma warning(suppress: 4985)
void *__cdecl operator new[](size_t ); 
#line 1044
void *__cdecl operator new(size_t , int, const char *, int); 
#line 1051
#pragma warning(suppress: 4985)
void *__cdecl operator new[](size_t , int, const char *, int); 
#line 1059
void __cdecl operator delete[](void *); 
#line 1061
inline void __cdecl operator delete(void *_P, int, const char *, int) 
#line 1062
{ ::operator delete(_P); } 
#line 1063
inline void __cdecl operator delete[](void *_P, int, const char *, int) 
#line 1064
{ ::operator delete[](_P); } 
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iosfwd"
#pragma warning(push,3)
#line 1130 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\crtdbg.h"
#pragma pack ( pop )
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iosfwd"
#pragma pack ( push, 8 )
#line 16
namespace std { 
#line 19
typedef _Longlong streamoff; 
#line 20
typedef _Longlong streamsize; 
#line 28
__declspec(dllimport) extern const streamoff _BADOFF; 
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iosfwd"
template < class _Statetype >
 class fpos
 {
 typedef fpos < _Statetype > _Myt;

public :
  fpos ( streamoff _Off = 0 )
  : _Myoff ( _Off ), _Fpos ( 0 ), _Mystate ( _Stz )
  {
  }

  fpos ( _Statetype _State, fpos_t _Fileposition )
  : _Myoff ( 0 ), _Fpos ( _Fileposition ), _Mystate ( _State )
  {
  }

 _Statetype state ( ) const
  {
  return ( _Mystate );
  }

 void state ( _Statetype _State )
  {
  _Mystate = _State;
  }

 fpos_t seekpos ( ) const
  {
  return ( _Fpos );
  }

  operator streamoff ( ) const
  {
  return ( ( streamoff ) ( _Myoff + ( ( long ) ( _Fpos ) ) ) );
  }

 streamoff operator - ( const _Myt & _Right ) const
  {
  return ( ( streamoff ) * this - ( streamoff ) _Right );
  }

 _Myt & operator += ( streamoff _Off )
  {
  _Myoff += _Off;
  return ( * this );
  }

 _Myt & operator -= ( streamoff _Off )
  {
  _Myoff -= _Off;
  return ( * this );
  }

 _Myt operator + ( streamoff _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt operator - ( streamoff _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 bool operator == ( const _Myt & _Right ) const
  {
  return ( ( streamoff ) * this == ( streamoff ) _Right );
  }

 bool operator == ( streamoff _Right ) const
  {
  return ( ( streamoff ) * this == _Right );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

private :
  static const _Statetype _Stz;
 streamoff _Myoff;
 fpos_t _Fpos;
 _Statetype _Mystate;
 };
#line 120
template< class _Statetype> const _Statetype 
#line 121
fpos< _Statetype> ::_Stz = (_Statetype()); 
#line 128
typedef fpos< int>  streampos; 
#line 130
typedef streampos wstreampos; 
#line 133
template < class _Elem,
 class _Int_type >
 struct _Char_traits
 {
 typedef _Elem char_type;
 typedef _Int_type int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare (
     const _Elem * _First1,
     const _Elem * _First2, size_t _Count )
  {
  for (; 0 < _Count; -- _Count, ++ _First1, ++ _First2 )
   if ( ! eq ( * _First1, * _First2 ) )
    return ( lt ( * _First1, * _First2 ) ? - 1 : + 1 );
  return ( 0 );
  }

 static size_t __cdecl length ( const _Elem * _First )
  {
  size_t _Count;
  for ( _Count = 0; ! eq ( * _First, _Elem ( ) ); ++ _First )
   ++ _Count;
  return ( _Count );
  }

 static _Elem * __cdecl copy (
    _Elem * _First1,
     const _Elem * _First2, size_t _Count )
  {
  _Elem * _Next = _First1;
  for (; 0 < _Count; -- _Count, ++ _Next, ++ _First2 )
   assign ( * _Next, * _First2 );
  return ( _First1 );
  }

 static _Elem * __cdecl _Copy_s (
    _Elem * _First1, size_t _Dest_size,
     const _Elem * _First2, size_t _Count )
  {
  { if ( ! ( _Dest_size >= _Count ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); return ( 0 ); } };
  return ( copy ( _First1, _First2, _Count ) );
  }

 static const _Elem * __cdecl find (
     const _Elem * _First,
  size_t _Count, const _Elem & _Ch )
  {
  for (; 0 < _Count; -- _Count, ++ _First )
   if ( eq ( * _First, _Ch ) )
    return ( _First );
  return ( 0 );
  }

 static _Elem * __cdecl move (
    _Elem * _First1,
     const _Elem * _First2, size_t _Count )
  {
  _Elem * _Next = _First1;
  if ( _First2 < _Next && _Next < _First2 + _Count )
   for ( _Next += _Count, _First2 += _Count; 0 < _Count; -- _Count )
    assign ( * -- _Next, * -- _First2 );
  else
   for (; 0 < _Count; -- _Count, ++ _Next, ++ _First2 )
    assign ( * _Next, * _First2 );
  return ( _First1 );
  }

 static _Elem * __cdecl assign (
    _Elem * _First,
  size_t _Count, _Elem _Ch )
  {
  _Elem * _Next = _First;
  for (; 0 < _Count; -- _Count, ++ _Next )
   assign ( * _Next, _Ch );
  return ( _First );
  }

 static void __cdecl assign ( _Elem & _Left, const _Elem & _Right )
  {
  _Left = _Right;
  }

 static bool __cdecl eq ( const _Elem & _Left, const _Elem & _Right )
  {
  return ( _Left == _Right );
  }

 static bool __cdecl lt ( const _Elem & _Left, const _Elem & _Right )
  {
  return ( _Left < _Right );
  }

 static _Elem __cdecl to_char_type ( const int_type & _Meta )
  {
  return ( ( _Elem ) _Meta );
  }

 static int_type __cdecl to_int_type ( const _Elem & _Ch )
  {
  return ( ( int_type ) _Ch );
  }

 static bool __cdecl eq_int_type ( const int_type & _Left,
  const int_type & _Right )
  {
  return ( _Left == _Right );
  }

 static int_type __cdecl not_eof ( const int_type & _Meta )
  {
  return ( _Meta != eof ( ) ? ( int_type ) _Meta : ( int_type ) ! eof ( ) );
  }

 static int_type __cdecl eof ( )
  {
  return ( ( int_type ) ( - 1 ) );
  }
 };
#line 256
template< class _Elem> 
#line 257
struct char_traits : public _Char_traits< _Elem, long>  { 
#line 260
}; 
#line 280 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iosfwd"
template<> struct char_traits< __wchar_t>  { 
#line 282
typedef __wchar_t _Elem; 
#line 283
typedef _Elem char_type; 
#line 284
typedef wint_t int_type; 
#line 285
typedef streampos pos_type; 
#line 286
typedef streamoff off_type; 
#line 287
typedef _Mbstatet state_type; 
#line 289
static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
#line 290
_Count) 
#line 291
{ 
#line 292
return ::wmemcmp(_First1, _First2, _Count); 
#line 293
} 
#line 295
static size_t __cdecl length(const _Elem *_First) 
#line 296
{ 
#line 297
return ::wcslen(_First); 
#line 298
} 
#line 300
static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
#line 301
_Count) 
#line 302
{ 
#line 303
return (_Elem *)::wmemcpy(_First1, _First2, _Count); 
#line 304
} 
#line 306
static _Elem *__cdecl _Copy_s(_Elem *
#line 307
_First1, size_t _Size_in_words, const _Elem *
#line 308
_First2, size_t _Count) 
#line 309
{ 
#line 310
::wmemcpy_s(_First1, _Size_in_words, _First2, _Count); 
#line 311
return _First1; 
#line 312
} 
#line 314
static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
#line 315
_Ch) 
#line 316
{ 
#line 317
return (const _Elem *)::wmemchr(_First, _Ch, _Count); 
#line 318
} 
#line 320
static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
#line 321
_Count) 
#line 322
{ 
#line 323
return (_Elem *)::wmemmove(_First1, _First2, _Count); 
#line 324
} 
#line 326
static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch) 
#line 327
{ 
#line 328
return (_Elem *)::wmemset(_First, _Ch, _Count); 
#line 329
} 
#line 331
static void __cdecl assign(_Elem &_Left, const _Elem &_Right) 
#line 332
{ 
#line 333
_Left = _Right; 
#line 334
} 
#line 336
static bool __cdecl eq(const _Elem &_Left, const _Elem &_Right) 
#line 337
{ 
#line 338
return _Left == _Right; 
#line 339
} 
#line 341
static bool __cdecl lt(const _Elem &_Left, const _Elem &_Right) 
#line 342
{ 
#line 343
return _Left < _Right; 
#line 344
} 
#line 346
static _Elem __cdecl to_char_type(const int_type &_Meta) 
#line 347
{ 
#line 348
return _Meta; 
#line 349
} 
#line 351
static int_type __cdecl to_int_type(const _Elem &_Ch) 
#line 352
{ 
#line 353
return _Ch; 
#line 354
} 
#line 356
static bool __cdecl eq_int_type(const int_type &_Left, const int_type &
#line 357
_Right) 
#line 358
{ 
#line 359
return _Left == _Right; 
#line 360
} 
#line 362
static int_type __cdecl not_eof(const int_type &_Meta) 
#line 363
{ 
#line 364
return (_Meta != (eof())) ? (_Meta) : (!(eof())); 
#line 365
} 
#line 367
static int_type __cdecl eof() 
#line 368
{ 
#line 369
return (wint_t)65535; 
#line 370
} 
#line 371
}; 
#line 375
template<> struct char_traits< unsigned short>  { 
#line 377
typedef unsigned short _Elem; 
#line 378
typedef _Elem char_type; 
#line 379
typedef wint_t int_type; 
#line 380
typedef streampos pos_type; 
#line 381
typedef streamoff off_type; 
#line 382
typedef _Mbstatet state_type; 
#line 384
static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
#line 385
_Count) 
#line 386
{ 
#line 387
return ::wmemcmp((const __wchar_t *)_First1, (const __wchar_t *)_First2, _Count); 
#line 389
} 
#line 391
static size_t __cdecl length(const _Elem *_First) 
#line 392
{ 
#line 393
return ::wcslen((const __wchar_t *)_First); 
#line 394
} 
#line 396
static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
#line 397
_Count) 
#line 398
{ 
#line 399
return (_Elem *)::wmemcpy((__wchar_t *)_First1, (const __wchar_t *)_First2, _Count); 
#line 401
} 
#line 403
static _Elem *__cdecl _Copy_s(_Elem *
#line 404
_First1, size_t _Size_in_words, const _Elem *
#line 405
_First2, size_t _Count) 
#line 406
{ 
#line 407
::wmemcpy_s((__wchar_t *)_First1, _Size_in_words, (const __wchar_t *)_First2, _Count); 
#line 408
return _First1; 
#line 409
} 
#line 411
static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
#line 412
_Ch) 
#line 413
{ 
#line 414
return (const _Elem *)::wmemchr((const __wchar_t *)_First, _Ch, _Count); 
#line 416
} 
#line 418
static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
#line 419
_Count) 
#line 420
{ 
#line 421
return (_Elem *)::wmemmove((__wchar_t *)_First1, (const __wchar_t *)_First2, _Count); 
#line 423
} 
#line 425
static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch) 
#line 426
{ 
#line 427
return (_Elem *)::wmemset((__wchar_t *)_First, _Ch, _Count); 
#line 428
} 
#line 430
static void __cdecl assign(_Elem &_Left, const _Elem &_Right) 
#line 431
{ 
#line 432
_Left = _Right; 
#line 433
} 
#line 435
static bool __cdecl eq(const _Elem &_Left, const _Elem &_Right) 
#line 436
{ 
#line 437
return _Left == _Right; 
#line 438
} 
#line 440
static bool __cdecl lt(const _Elem &_Left, const _Elem &_Right) 
#line 441
{ 
#line 442
return _Left < _Right; 
#line 443
} 
#line 445
static _Elem __cdecl to_char_type(const int_type &_Meta) 
#line 446
{ 
#line 447
return _Meta; 
#line 448
} 
#line 450
static int_type __cdecl to_int_type(const _Elem &_Ch) 
#line 451
{ 
#line 452
return _Ch; 
#line 453
} 
#line 455
static bool __cdecl eq_int_type(const int_type &_Left, const int_type &
#line 456
_Right) 
#line 457
{ 
#line 458
return _Left == _Right; 
#line 459
} 
#line 461
static int_type __cdecl not_eof(const int_type &_Meta) 
#line 462
{ 
#line 463
return (_Meta != (eof())) ? (_Meta) : (!(eof())); 
#line 464
} 
#line 466
static int_type __cdecl eof() 
#line 467
{ 
#line 468
return (wint_t)65535; 
#line 469
} 
#line 470
}; 
#line 474 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iosfwd"
template<> struct char_traits< char>  { 
#line 476
typedef char _Elem; 
#line 477
typedef _Elem char_type; 
#line 478
typedef int int_type; 
#line 479
typedef streampos pos_type; 
#line 480
typedef streamoff off_type; 
#line 481
typedef _Mbstatet state_type; 
#line 483
static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
#line 484
_Count) 
#line 485
{ 
#line 486
return ::memcmp(_First1, _First2, _Count); 
#line 487
} 
#line 489
static size_t __cdecl length(const _Elem *_First) 
#line 490
{ 
#line 491
return ::strlen(_First); 
#line 492
} 
#line 494
static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
#line 495
_Count) 
#line 496
{ 
#line 497
return (_Elem *)::memcpy(_First1, _First2, _Count); 
#line 498
} 
#line 500
static _Elem *__cdecl _Copy_s(_Elem *
#line 501
_First1, size_t _Size_in_bytes, const _Elem *
#line 502
_First2, size_t _Count) 
#line 503
{ 
#line 504
::memcpy_s(_First1, _Size_in_bytes, _First2, _Count); 
#line 505
return _First1; 
#line 506
} 
#line 508
static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
#line 509
_Ch) 
#line 510
{ 
#line 511
return (const _Elem *)::memchr(_First, _Ch, _Count); 
#line 512
} 
#line 514
static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
#line 515
_Count) 
#line 516
{ 
#line 517
return (_Elem *)::memmove(_First1, _First2, _Count); 
#line 518
} 
#line 520
static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch) 
#line 521
{ 
#line 522
return (_Elem *)::memset(_First, _Ch, _Count); 
#line 523
} 
#line 525
static void __cdecl assign(_Elem &_Left, const _Elem &_Right) 
#line 526
{ 
#line 527
_Left = _Right; 
#line 528
} 
#line 530
static bool __cdecl eq(const _Elem &_Left, const _Elem &_Right) 
#line 531
{ 
#line 532
return _Left == _Right; 
#line 533
} 
#line 535
static bool __cdecl lt(const _Elem &_Left, const _Elem &_Right) 
#line 536
{ 
#line 537
return ((unsigned char)_Left) < ((unsigned char)_Right); 
#line 538
} 
#line 540
static _Elem __cdecl to_char_type(const int_type &_Meta) 
#line 541
{ 
#line 542
return (_Elem)_Meta; 
#line 543
} 
#line 545
static int_type __cdecl to_int_type(const _Elem &_Ch) 
#line 546
{ 
#line 547
return (unsigned char)_Ch; 
#line 548
} 
#line 550
static bool __cdecl eq_int_type(const int_type &_Left, const int_type &
#line 551
_Right) 
#line 552
{ 
#line 553
return _Left == _Right; 
#line 554
} 
#line 556
static int_type __cdecl not_eof(const int_type &_Meta) 
#line 557
{ 
#line 558
return (_Meta != eof()) ? _Meta : (!(eof())); 
#line 559
} 
#line 561
static int_type __cdecl eof() 
#line 562
{ 
#line 563
return -1; 
#line 564
} 
#line 565
}; 
#line 568
template < class _Ty >
 class allocator;
#line 570
class ios_base; 
#line 571
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ios;
#line 574
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class istreambuf_iterator;
#line 577
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class ostreambuf_iterator;
#line 580
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_streambuf;
#line 583
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_istream;
#line 586
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ostream;
#line 589
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_iostream;
#line 592
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Alloc = allocator < _Elem > >
 class basic_stringbuf;
#line 596
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Alloc = allocator < _Elem > >
 class basic_istringstream;
#line 600
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Alloc = allocator < _Elem > >
 class basic_ostringstream;
#line 604
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Alloc = allocator < _Elem > >
 class basic_stringstream;
#line 608
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_filebuf;
#line 611
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ifstream;
#line 614
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ofstream;
#line 617
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_fstream;
#line 622
template < class _Elem,
 class _InIt >
 class num_get;
#line 625
template < class _Elem,
 class _OutIt >
 class num_put;
#line 628
template< class _Elem> class collate; 
#line 633 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iosfwd"
typedef basic_ios< char, char_traits< char> >  ios; 
#line 634
typedef basic_streambuf< char, char_traits< char> >  streambuf; 
#line 635
typedef basic_istream< char, char_traits< char> >  istream; 
#line 636
typedef basic_ostream< char, char_traits< char> >  ostream; 
#line 637
typedef basic_iostream< char, char_traits< char> >  iostream; 
#line 639
typedef basic_stringbuf< char, char_traits< char> , allocator< char> >  stringbuf; 
#line 641
typedef basic_istringstream< char, char_traits< char> , allocator< char> >  istringstream; 
#line 643
typedef basic_ostringstream< char, char_traits< char> , allocator< char> >  ostringstream; 
#line 645
typedef basic_stringstream< char, char_traits< char> , allocator< char> >  stringstream; 
#line 646
typedef basic_filebuf< char, char_traits< char> >  filebuf; 
#line 647
typedef basic_ifstream< char, char_traits< char> >  ifstream; 
#line 648
typedef basic_ofstream< char, char_traits< char> >  ofstream; 
#line 649
typedef basic_fstream< char, char_traits< char> >  fstream; 
#line 652
typedef basic_ios< __wchar_t, char_traits< __wchar_t> >  wios; 
#line 654
typedef basic_streambuf< __wchar_t, char_traits< __wchar_t> >  wstreambuf; 
#line 655
typedef basic_istream< __wchar_t, char_traits< __wchar_t> >  wistream; 
#line 656
typedef basic_ostream< __wchar_t, char_traits< __wchar_t> >  wostream; 
#line 657
typedef basic_iostream< __wchar_t, char_traits< __wchar_t> >  wiostream; 
#line 659
typedef basic_stringbuf< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstringbuf; 
#line 661
typedef basic_istringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wistringstream; 
#line 663
typedef basic_ostringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wostringstream; 
#line 665
typedef basic_stringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstringstream; 
#line 666
typedef basic_filebuf< __wchar_t, char_traits< __wchar_t> >  wfilebuf; 
#line 667
typedef basic_ifstream< __wchar_t, char_traits< __wchar_t> >  wifstream; 
#line 668
typedef basic_ofstream< __wchar_t, char_traits< __wchar_t> >  wofstream; 
#line 669
typedef basic_fstream< __wchar_t, char_traits< __wchar_t> >  wfstream; 
#line 674
typedef num_get< char, istreambuf_iterator< char, char_traits< char> > >  numget; 
#line 676
typedef num_get< __wchar_t, istreambuf_iterator< __wchar_t, char_traits< __wchar_t> > >  wnumget; 
#line 678
typedef num_put< char, ostreambuf_iterator< char, char_traits< char> > >  numput; 
#line 680
typedef num_put< __wchar_t, ostreambuf_iterator< __wchar_t, char_traits< __wchar_t> > >  wnumput; 
#line 681
typedef collate< char>  ncollate; 
#line 682
typedef collate< __wchar_t>  wcollate; 
#line 684 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iosfwd"
}
#line 686
#pragma warning(pop)
#pragma pack ( pop )
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ymath.h"
#pragma pack ( push, 8 )
#line 35
extern "C" { typedef 
#line 30
union { 
#line 31
unsigned short _Word[8]; 
#line 32
float _Float; 
#line 33
double _Double; 
#line 34
long double _Long_double; 
#line 35
} _Dconst; }
#line 38
extern "C" { void __cdecl _Feraise(int); } 
#line 41
extern "C" { __declspec(dllimport) double __cdecl _Cosh(double, double); } 
#line 42
extern "C" { __declspec(dllimport) short __cdecl _Dtest(double *); } 
#line 43
extern "C" { __declspec(dllimport) short __cdecl _Exp(double *, double, short); } 
#line 44
extern "C" { __declspec(dllimport) double __cdecl _Sinh(double, double); } 
#line 45
extern "C" __declspec(dllimport) _Dconst _Denorm, _Hugeval, _Inf, 
#line 46
_Nan, _Snan; 
#line 49
extern "C" { __declspec(dllimport) float __cdecl _FCosh(float, float); } 
#line 50
extern "C" { __declspec(dllimport) short __cdecl _FDtest(float *); } 
#line 51
extern "C" { __declspec(dllimport) short __cdecl _FExp(float *, float, short); } 
#line 52
extern "C" { __declspec(dllimport) float __cdecl _FSinh(float, float); } 
#line 53
extern "C" __declspec(dllimport) _Dconst _FDenorm, _FInf, _FNan, _FSnan; 
#line 56
extern "C" { __declspec(dllimport) long double __cdecl _LCosh(long double, long double); } 
#line 57
extern "C" { __declspec(dllimport) short __cdecl _LDtest(long double *); } 
#line 58
extern "C" { __declspec(dllimport) short __cdecl _LExp(long double *, long double, short); } 
#line 59
extern "C" { __declspec(dllimport) long double __cdecl _LSinh(long double, long double); } 
#line 60
extern "C" __declspec(dllimport) _Dconst _LDenorm, _LInf, _LNan, _LSnan; 
#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ymath.h"
#pragma pack ( pop )
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\float.h"
extern "C" { __declspec(dllimport) unsigned __cdecl _clearfp(); } 
#pragma warning(push)
#pragma warning(disable: 4141)
extern "C" { __declspec(dllimport) unsigned __cdecl _controlfp(unsigned , unsigned ); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) void __cdecl _set_controlfp(unsigned , unsigned ); } 
#line 89
extern "C" { __declspec(dllimport) errno_t __cdecl _controlfp_s(unsigned * , unsigned , unsigned ); } 
#line 90
extern "C" { __declspec(dllimport) unsigned __cdecl _statusfp(); } 
#line 91
extern "C" { __declspec(dllimport) void __cdecl _fpreset(); } 
#line 172 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\float.h"
extern "C" { __declspec(dllimport) unsigned __cdecl _control87(unsigned , unsigned ); } 
#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\float.h"
extern "C" { __declspec(dllimport) extern int *__cdecl __fpecode(); } 
#line 216
extern "C" { __declspec(dllimport) double __cdecl _scalb(double , long ); } 
#line 217
extern "C" { __declspec(dllimport) double __cdecl _logb(double ); } 
#line 218
extern "C" { __declspec(dllimport) double __cdecl _nextafter(double , double ); } 
#line 219
extern "C" { __declspec(dllimport) int __cdecl _finite(double ); } 
#line 220
extern "C" { __declspec(dllimport) int __cdecl _isnan(double ); } 
#line 221
extern "C" { __declspec(dllimport) int __cdecl _fpclass(double ); } 
#line 224
extern "C" { __declspec(dllimport) float __cdecl _scalbf(float , long ); } 
#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\float.h"
extern "C" { __declspec(dllimport) void __cdecl fpreset(); } 
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
#pragma warning(push,3)
#line 13
#pragma pack ( push, 8 )
#line 16
namespace std { 
#line 35
typedef 
#line 31
enum { 
#line 32
denorm_indeterminate = (-1), 
#line 33
denorm_absent = 0, 
#line 34
denorm_present
#line 35
} float_denorm_style; 
#line 45
typedef 
#line 39
enum { 
#line 40
round_indeterminate = (-1), 
#line 41
round_toward_zero = 0, 
#line 42
round_to_nearest, 
#line 43
round_toward_infinity, 
#line 44
round_toward_neg_infinity
#line 45
} float_round_style; 
#line 48
struct __declspec(dllimport) _Num_base { 
#line 50
static const float_denorm_style has_denorm = ((float_denorm_style)denorm_absent); 
#line 51
static const bool has_denorm_loss = ((bool)false); 
#line 52
static const bool has_infinity = ((bool)false); 
#line 53
static const bool has_quiet_NaN = ((bool)false); 
#line 54
static const bool has_signaling_NaN = ((bool)false); 
#line 55
static const bool is_bounded = ((bool)false); 
#line 56
static const bool is_exact = ((bool)false); 
#line 57
static const bool is_iec559 = ((bool)false); 
#line 58
static const bool is_integer = ((bool)false); 
#line 59
static const bool is_modulo = ((bool)false); 
#line 60
static const bool is_signed = ((bool)false); 
#line 61
static const bool is_specialized = ((bool)false); 
#line 62
static const bool tinyness_before = ((bool)false); 
#line 63
static const bool traps = ((bool)false); 
#line 64
static const float_round_style round_style = ((float_round_style)round_toward_zero); 
#line 65
static const int digits = ((int)0); 
#line 66
static const int digits10 = ((int)0); 
#line 69
static const int max_digits10 = ((int)0); 
#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_exponent = ((int)0); 
#line 73
static const int max_exponent10 = ((int)0); 
#line 74
static const int min_exponent = ((int)0); 
#line 75
static const int min_exponent10 = ((int)0); 
#line 76
static const int radix = ((int)0); 
#line 77
}; 
#line 80
template < class _Ty >
 class numeric_limits
  : public _Num_base
 {
public :
 static _Ty ( __cdecl min ) ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

 static _Ty ( __cdecl max ) ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }


 static _Ty __cdecl lowest ( ) throw ( )
  {
  return ( ( min ) ( ) );
  }


 static _Ty __cdecl epsilon ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

 static _Ty __cdecl round_error ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

 static _Ty __cdecl denorm_min ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

 static _Ty __cdecl infinity ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

 static _Ty __cdecl quiet_NaN ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

 static _Ty __cdecl signaling_NaN ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }
 };
#line 133 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
template< class _Ty> 
#line 134
class numeric_limits< const _Ty>  : public numeric_limits< _Ty>  { 
#line 137
}; 
#line 139
template< class _Ty> 
#line 140
class numeric_limits< volatile _Ty>  : public numeric_limits< _Ty>  { 
#line 143
}; 
#line 145
template< class _Ty> 
#line 146
class numeric_limits< const volatile _Ty>  : public numeric_limits< _Ty>  { 
#line 149
}; 
#line 152
struct __declspec(dllimport) _Num_int_base : public _Num_base { 
#line 155
static const bool is_bounded = ((bool)true); 
#line 156
static const bool is_exact = ((bool)true); 
#line 157
static const bool is_integer = ((bool)true); 
#line 158
static const bool is_modulo = ((bool)true); 
#line 159
static const bool is_specialized = ((bool)true); 
#line 160
static const int radix = ((int)2); 
#line 161
}; 
#line 164
struct __declspec(dllimport) _Num_float_base : public _Num_base { 
#line 167
static const float_denorm_style has_denorm = ((float_denorm_style)denorm_present); 
#line 168
static const bool has_denorm_loss = ((bool)true); 
#line 169
static const bool has_infinity = ((bool)true); 
#line 170
static const bool has_quiet_NaN = ((bool)true); 
#line 171
static const bool has_signaling_NaN = ((bool)true); 
#line 172
static const bool is_bounded = ((bool)true); 
#line 173
static const bool is_exact = ((bool)false); 
#line 174
static const bool is_iec559 = ((bool)true); 
#line 175
static const bool is_integer = ((bool)false); 
#line 176
static const bool is_modulo = ((bool)false); 
#line 177
static const bool is_signed = ((bool)true); 
#line 178
static const bool is_specialized = ((bool)true); 
#line 179
static const bool tinyness_before = ((bool)true); 
#line 180
static const bool traps = ((bool)true); 
#line 181
static const float_round_style round_style = ((float_round_style)round_to_nearest); 
#line 182
static const int radix = ((int)2); 
#line 183
}; 
#line 186
template<> class __declspec(dllimport) numeric_limits< char>  : public _Num_int_base { 
#line 190
public: typedef char _Ty; 
#line 192
static _Ty __cdecl min() throw() 
#line 193
{ 
#line 194
return -128; 
#line 195
} 
#line 197
static _Ty __cdecl max() throw() 
#line 198
{ 
#line 199
return 127; 
#line 200
} 
#line 203
static _Ty __cdecl lowest() throw() 
#line 204
{ 
#line 205
return min(); 
#line 206
} 
#line 209 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 210
{ 
#line 211
return 0; 
#line 212
} 
#line 214
static _Ty __cdecl round_error() throw() 
#line 215
{ 
#line 216
return 0; 
#line 217
} 
#line 219
static _Ty __cdecl denorm_min() throw() 
#line 220
{ 
#line 221
return 0; 
#line 222
} 
#line 224
static _Ty __cdecl infinity() throw() 
#line 225
{ 
#line 226
return 0; 
#line 227
} 
#line 229
static _Ty __cdecl quiet_NaN() throw() 
#line 230
{ 
#line 231
return 0; 
#line 232
} 
#line 234
static _Ty __cdecl signaling_NaN() throw() 
#line 235
{ 
#line 236
return 0; 
#line 237
} 
#line 239
static const bool is_signed = ((bool)((-128) != 0)); 
#line 240
static const int digits = ((int)(8 - (((-128) != 0) ? 1 : 0))); 
#line 241
static const int digits10 = ((int)(((8 - (((-128) != 0) ? 1 : 0)) * 301L) / (1000))); 
#line 245 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_digits10 = ((int)((2) + (((8 - (((-128) != 0) ? 1 : 0)) * 301L) / (1000)))); 
#line 248 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}; 
#line 251
template<> class __declspec(dllimport) numeric_limits< __wchar_t>  : public _Num_int_base { 
#line 255
public: typedef __wchar_t _Ty; 
#line 257
static _Ty __cdecl min() throw() 
#line 258
{ 
#line 259
return (_Ty)0; 
#line 260
} 
#line 262
static _Ty __cdecl max() throw() 
#line 263
{ 
#line 264
return (_Ty)65535; 
#line 265
} 
#line 268
static _Ty __cdecl lowest() throw() 
#line 269
{ 
#line 270
return min(); 
#line 271
} 
#line 274 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 275
{ 
#line 276
return 0; 
#line 277
} 
#line 279
static _Ty __cdecl round_error() throw() 
#line 280
{ 
#line 281
return 0; 
#line 282
} 
#line 284
static _Ty __cdecl denorm_min() throw() 
#line 285
{ 
#line 286
return 0; 
#line 287
} 
#line 289
static _Ty __cdecl infinity() throw() 
#line 290
{ 
#line 291
return 0; 
#line 292
} 
#line 294
static _Ty __cdecl quiet_NaN() throw() 
#line 295
{ 
#line 296
return 0; 
#line 297
} 
#line 299
static _Ty __cdecl signaling_NaN() throw() 
#line 300
{ 
#line 301
return 0; 
#line 302
} 
#line 304
static const bool is_signed = ((bool)(0 != 0)); 
#line 305
static const int digits = ((int)(((8) * sizeof(__wchar_t)) - ((0 != 0) ? 1 : 0))); 
#line 307 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int digits10 = ((int)(((((8) * sizeof(__wchar_t)) - ((0 != 0) ? 1 : 0)) * (301L)) / (1000))); 
#line 311 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_digits10 = ((int)((2) + (((((8) * sizeof(__wchar_t)) - ((0 != 0) ? 1 : 0)) * (301L)) / (1000)))); 
#line 314 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}; 
#line 317
template<> class __declspec(dllimport) numeric_limits< bool>  : public _Num_int_base { 
#line 321
public: typedef bool _Ty; 
#line 323
static _Ty __cdecl min() throw() 
#line 324
{ 
#line 325
return false; 
#line 326
} 
#line 328
static _Ty __cdecl max() throw() 
#line 329
{ 
#line 330
return true; 
#line 331
} 
#line 334
static _Ty __cdecl lowest() throw() 
#line 335
{ 
#line 336
return min(); 
#line 337
} 
#line 340 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 341
{ 
#line 342
return 0; 
#line 343
} 
#line 345
static _Ty __cdecl round_error() throw() 
#line 346
{ 
#line 347
return 0; 
#line 348
} 
#line 350
static _Ty __cdecl denorm_min() throw() 
#line 351
{ 
#line 352
return 0; 
#line 353
} 
#line 355
static _Ty __cdecl infinity() throw() 
#line 356
{ 
#line 357
return 0; 
#line 358
} 
#line 360
static _Ty __cdecl quiet_NaN() throw() 
#line 361
{ 
#line 362
return 0; 
#line 363
} 
#line 365
static _Ty __cdecl signaling_NaN() throw() 
#line 366
{ 
#line 367
return 0; 
#line 368
} 
#line 370
static const bool is_modulo = ((bool)false); 
#line 371
static const bool is_signed = ((bool)false); 
#line 372
static const int digits = ((int)1); 
#line 373
static const int digits10 = ((int)0); 
#line 376
static const int max_digits10 = ((int)0); 
#line 378 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}; 
#line 381
template<> class __declspec(dllimport) numeric_limits< signed char>  : public _Num_int_base { 
#line 385
public: typedef signed char _Ty; 
#line 387
static _Ty __cdecl min() throw() 
#line 388
{ 
#line 389
return -128; 
#line 390
} 
#line 392
static _Ty __cdecl max() throw() 
#line 393
{ 
#line 394
return 127; 
#line 395
} 
#line 398
static _Ty __cdecl lowest() throw() 
#line 399
{ 
#line 400
return min(); 
#line 401
} 
#line 404 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 405
{ 
#line 406
return 0; 
#line 407
} 
#line 409
static _Ty __cdecl round_error() throw() 
#line 410
{ 
#line 411
return 0; 
#line 412
} 
#line 414
static _Ty __cdecl denorm_min() throw() 
#line 415
{ 
#line 416
return 0; 
#line 417
} 
#line 419
static _Ty __cdecl infinity() throw() 
#line 420
{ 
#line 421
return 0; 
#line 422
} 
#line 424
static _Ty __cdecl quiet_NaN() throw() 
#line 425
{ 
#line 426
return 0; 
#line 427
} 
#line 429
static _Ty __cdecl signaling_NaN() throw() 
#line 430
{ 
#line 431
return 0; 
#line 432
} 
#line 434
static const bool is_signed = ((bool)true); 
#line 435
static const int digits = ((int)(8 - 1)); 
#line 436
static const int digits10 = ((int)(((8 - 1) * 301L) / (1000))); 
#line 439
static const int max_digits10 = ((int)((2) + (((8 - 1) * 301L) / (1000)))); 
#line 441 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}; 
#line 444
template<> class __declspec(dllimport) numeric_limits< unsigned char>  : public _Num_int_base { 
#line 448
public: typedef unsigned char _Ty; 
#line 450
static _Ty __cdecl min() throw() 
#line 451
{ 
#line 452
return 0; 
#line 453
} 
#line 455
static _Ty __cdecl max() throw() 
#line 456
{ 
#line 457
return 255; 
#line 458
} 
#line 461
static _Ty __cdecl lowest() throw() 
#line 462
{ 
#line 463
return min(); 
#line 464
} 
#line 467 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 468
{ 
#line 469
return 0; 
#line 470
} 
#line 472
static _Ty __cdecl round_error() throw() 
#line 473
{ 
#line 474
return 0; 
#line 475
} 
#line 477
static _Ty __cdecl denorm_min() throw() 
#line 478
{ 
#line 479
return 0; 
#line 480
} 
#line 482
static _Ty __cdecl infinity() throw() 
#line 483
{ 
#line 484
return 0; 
#line 485
} 
#line 487
static _Ty __cdecl quiet_NaN() throw() 
#line 488
{ 
#line 489
return 0; 
#line 490
} 
#line 492
static _Ty __cdecl signaling_NaN() throw() 
#line 493
{ 
#line 494
return 0; 
#line 495
} 
#line 497
static const bool is_signed = ((bool)false); 
#line 498
static const int digits = ((int)8); 
#line 499
static const int digits10 = ((int)(((8) * 301L) / (1000))); 
#line 502
static const int max_digits10 = ((int)((2) + (((8) * 301L) / (1000)))); 
#line 504 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}; 
#line 507
template<> class __declspec(dllimport) numeric_limits< short>  : public _Num_int_base { 
#line 511
public: typedef short _Ty; 
#line 513
static _Ty __cdecl min() throw() 
#line 514
{ 
#line 515
return -32768; 
#line 516
} 
#line 518
static _Ty __cdecl max() throw() 
#line 519
{ 
#line 520
return 32767; 
#line 521
} 
#line 524
static _Ty __cdecl lowest() throw() 
#line 525
{ 
#line 526
return min(); 
#line 527
} 
#line 530 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 531
{ 
#line 532
return 0; 
#line 533
} 
#line 535
static _Ty __cdecl round_error() throw() 
#line 536
{ 
#line 537
return 0; 
#line 538
} 
#line 540
static _Ty __cdecl denorm_min() throw() 
#line 541
{ 
#line 542
return 0; 
#line 543
} 
#line 545
static _Ty __cdecl infinity() throw() 
#line 546
{ 
#line 547
return 0; 
#line 548
} 
#line 550
static _Ty __cdecl quiet_NaN() throw() 
#line 551
{ 
#line 552
return 0; 
#line 553
} 
#line 555
static _Ty __cdecl signaling_NaN() throw() 
#line 556
{ 
#line 557
return 0; 
#line 558
} 
#line 560
static const bool is_signed = ((bool)true); 
#line 561
static const int digits = ((int)(((8) * sizeof(short)) - (1))); 
#line 562
static const int digits10 = ((int)(((((8) * sizeof(short)) - (1)) * (301L)) / (1000))); 
#line 566 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_digits10 = ((int)((2) + (((((8) * sizeof(short)) - (1)) * (301L)) / (1000)))); 
#line 569 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}; 
#line 573
template<> class __declspec(dllimport) numeric_limits< unsigned short>  : public _Num_int_base { 
#line 577
public: typedef unsigned short _Ty; 
#line 579
static _Ty __cdecl min() throw() 
#line 580
{ 
#line 581
return 0; 
#line 582
} 
#line 584
static _Ty __cdecl max() throw() 
#line 585
{ 
#line 586
return 65535; 
#line 587
} 
#line 590
static _Ty __cdecl lowest() throw() 
#line 591
{ 
#line 592
return min(); 
#line 593
} 
#line 596 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 597
{ 
#line 598
return 0; 
#line 599
} 
#line 601
static _Ty __cdecl round_error() throw() 
#line 602
{ 
#line 603
return 0; 
#line 604
} 
#line 606
static _Ty __cdecl denorm_min() throw() 
#line 607
{ 
#line 608
return 0; 
#line 609
} 
#line 611
static _Ty __cdecl infinity() throw() 
#line 612
{ 
#line 613
return 0; 
#line 614
} 
#line 616
static _Ty __cdecl quiet_NaN() throw() 
#line 617
{ 
#line 618
return 0; 
#line 619
} 
#line 621
static _Ty __cdecl signaling_NaN() throw() 
#line 622
{ 
#line 623
return 0; 
#line 624
} 
#line 626
static const bool is_signed = ((bool)false); 
#line 627
static const int digits = ((int)((8) * sizeof(unsigned short))); 
#line 628
static const int digits10 = ((int)((((8) * sizeof(unsigned short)) * (301L)) / (1000))); 
#line 632 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_digits10 = ((int)((2) + ((((8) * sizeof(unsigned short)) * (301L)) / (1000)))); 
#line 635 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}; 
#line 701 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
template<> class __declspec(dllimport) numeric_limits< int>  : public _Num_int_base { 
#line 705
public: typedef int _Ty; 
#line 707
static _Ty __cdecl min() throw() 
#line 708
{ 
#line 709
return (-2147483647) - 1; 
#line 710
} 
#line 712
static _Ty __cdecl max() throw() 
#line 713
{ 
#line 714
return 2147483647; 
#line 715
} 
#line 718
static _Ty __cdecl lowest() throw() 
#line 719
{ 
#line 720
return min(); 
#line 721
} 
#line 724 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 725
{ 
#line 726
return 0; 
#line 727
} 
#line 729
static _Ty __cdecl round_error() throw() 
#line 730
{ 
#line 731
return 0; 
#line 732
} 
#line 734
static _Ty __cdecl denorm_min() throw() 
#line 735
{ 
#line 736
return 0; 
#line 737
} 
#line 739
static _Ty __cdecl infinity() throw() 
#line 740
{ 
#line 741
return 0; 
#line 742
} 
#line 744
static _Ty __cdecl quiet_NaN() throw() 
#line 745
{ 
#line 746
return 0; 
#line 747
} 
#line 749
static _Ty __cdecl signaling_NaN() throw() 
#line 750
{ 
#line 751
return 0; 
#line 752
} 
#line 754
static const bool is_signed = ((bool)true); 
#line 755
static const int digits = ((int)(((8) * sizeof(int)) - (1))); 
#line 756
static const int digits10 = ((int)(((((8) * sizeof(int)) - (1)) * (301L)) / (1000))); 
#line 760 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_digits10 = ((int)((2) + (((((8) * sizeof(int)) - (1)) * (301L)) / (1000)))); 
#line 763 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}; 
#line 766
template<> class __declspec(dllimport) numeric_limits< unsigned>  : public _Num_int_base { 
#line 770
public: typedef unsigned _Ty; 
#line 772
static _Ty __cdecl min() throw() 
#line 773
{ 
#line 774
return 0; 
#line 775
} 
#line 777
static _Ty __cdecl max() throw() 
#line 778
{ 
#line 779
return 4294967295U; 
#line 780
} 
#line 783
static _Ty __cdecl lowest() throw() 
#line 784
{ 
#line 785
return min(); 
#line 786
} 
#line 789 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 790
{ 
#line 791
return 0; 
#line 792
} 
#line 794
static _Ty __cdecl round_error() throw() 
#line 795
{ 
#line 796
return 0; 
#line 797
} 
#line 799
static _Ty __cdecl denorm_min() throw() 
#line 800
{ 
#line 801
return 0; 
#line 802
} 
#line 804
static _Ty __cdecl infinity() throw() 
#line 805
{ 
#line 806
return 0; 
#line 807
} 
#line 809
static _Ty __cdecl quiet_NaN() throw() 
#line 810
{ 
#line 811
return 0; 
#line 812
} 
#line 814
static _Ty __cdecl signaling_NaN() throw() 
#line 815
{ 
#line 816
return 0; 
#line 817
} 
#line 819
static const bool is_signed = ((bool)false); 
#line 820
static const int digits = ((int)((8) * sizeof(unsigned))); 
#line 821
static const int digits10 = ((int)((((8) * sizeof(unsigned)) * (301L)) / (1000))); 
#line 825 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_digits10 = ((int)((2) + ((((8) * sizeof(unsigned)) * (301L)) / (1000)))); 
#line 828 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}; 
#line 831
template<> class __declspec(dllimport) numeric_limits< long>  : public _Num_int_base { 
#line 835
public: typedef long _Ty; 
#line 837
static _Ty __cdecl min() throw() 
#line 838
{ 
#line 839
return (-2147483647L) - (1); 
#line 840
} 
#line 842
static _Ty __cdecl max() throw() 
#line 843
{ 
#line 844
return 2147483647L; 
#line 845
} 
#line 848
static _Ty __cdecl lowest() throw() 
#line 849
{ 
#line 850
return min(); 
#line 851
} 
#line 854 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 855
{ 
#line 856
return 0; 
#line 857
} 
#line 859
static _Ty __cdecl round_error() throw() 
#line 860
{ 
#line 861
return 0; 
#line 862
} 
#line 864
static _Ty __cdecl denorm_min() throw() 
#line 865
{ 
#line 866
return 0; 
#line 867
} 
#line 869
static _Ty __cdecl infinity() throw() 
#line 870
{ 
#line 871
return 0; 
#line 872
} 
#line 874
static _Ty __cdecl quiet_NaN() throw() 
#line 875
{ 
#line 876
return 0; 
#line 877
} 
#line 879
static _Ty __cdecl signaling_NaN() throw() 
#line 880
{ 
#line 881
return 0; 
#line 882
} 
#line 884
static const bool is_signed = ((bool)true); 
#line 885
static const int digits = ((int)(((8) * sizeof(long)) - (1))); 
#line 886
static const int digits10 = ((int)(((((8) * sizeof(long)) - (1)) * (301L)) / (1000))); 
#line 890 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_digits10 = ((int)((2) + (((((8) * sizeof(long)) - (1)) * (301L)) / (1000)))); 
#line 893 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}; 
#line 896
template<> class __declspec(dllimport) numeric_limits< unsigned long>  : public _Num_int_base { 
#line 900
public: typedef unsigned long _Ty; 
#line 902
static _Ty __cdecl min() throw() 
#line 903
{ 
#line 904
return 0; 
#line 905
} 
#line 907
static _Ty __cdecl max() throw() 
#line 908
{ 
#line 909
return 4294967295UL; 
#line 910
} 
#line 913
static _Ty __cdecl lowest() throw() 
#line 914
{ 
#line 915
return min(); 
#line 916
} 
#line 919 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 920
{ 
#line 921
return 0; 
#line 922
} 
#line 924
static _Ty __cdecl round_error() throw() 
#line 925
{ 
#line 926
return 0; 
#line 927
} 
#line 929
static _Ty __cdecl denorm_min() throw() 
#line 930
{ 
#line 931
return 0; 
#line 932
} 
#line 934
static _Ty __cdecl infinity() throw() 
#line 935
{ 
#line 936
return 0; 
#line 937
} 
#line 939
static _Ty __cdecl quiet_NaN() throw() 
#line 940
{ 
#line 941
return 0; 
#line 942
} 
#line 944
static _Ty __cdecl signaling_NaN() throw() 
#line 945
{ 
#line 946
return 0; 
#line 947
} 
#line 949
static const bool is_signed = ((bool)false); 
#line 950
static const int digits = ((int)((8) * sizeof(unsigned long))); 
#line 951
static const int digits10 = ((int)((((8) * sizeof(unsigned long)) * (301L)) / (1000))); 
#line 955 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_digits10 = ((int)((2) + ((((8) * sizeof(unsigned long)) * (301L)) / (1000)))); 
#line 958 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}; 
#line 1024 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
template<> class __declspec(dllimport) numeric_limits< __int64>  : public _Num_int_base { 
#line 1028
public: typedef __int64 _Ty; 
#line 1030
static _Ty __cdecl min() throw() 
#line 1031
{ 
#line 1032
return (-9223372036854775807i64) - (1); 
#line 1033
} 
#line 1035
static _Ty __cdecl max() throw() 
#line 1036
{ 
#line 1037
return 9223372036854775807i64; 
#line 1038
} 
#line 1041
static _Ty __cdecl lowest() throw() 
#line 1042
{ 
#line 1043
return min(); 
#line 1044
} 
#line 1047 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 1048
{ 
#line 1049
return 0; 
#line 1050
} 
#line 1052
static _Ty __cdecl round_error() throw() 
#line 1053
{ 
#line 1054
return 0; 
#line 1055
} 
#line 1057
static _Ty __cdecl denorm_min() throw() 
#line 1058
{ 
#line 1059
return 0; 
#line 1060
} 
#line 1062
static _Ty __cdecl infinity() throw() 
#line 1063
{ 
#line 1064
return 0; 
#line 1065
} 
#line 1067
static _Ty __cdecl quiet_NaN() throw() 
#line 1068
{ 
#line 1069
return 0; 
#line 1070
} 
#line 1072
static _Ty __cdecl signaling_NaN() throw() 
#line 1073
{ 
#line 1074
return 0; 
#line 1075
} 
#line 1077
static const bool is_signed = ((bool)true); 
#line 1078
static const int digits = ((int)(((8) * sizeof(__int64)) - (1))); 
#line 1079
static const int digits10 = ((int)(((((8) * sizeof(__int64)) - (1)) * (301L)) / (1000))); 
#line 1083 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_digits10 = ((int)((2) + (((((8) * sizeof(__int64)) - (1)) * (301L)) / (1000)))); 
#line 1086 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}; 
#line 1089
template<> class __declspec(dllimport) numeric_limits< unsigned __int64>  : public _Num_int_base { 
#line 1093
public: typedef unsigned __int64 _Ty; 
#line 1095
static _Ty __cdecl min() throw() 
#line 1096
{ 
#line 1097
return 0; 
#line 1098
} 
#line 1100
static _Ty __cdecl max() throw() 
#line 1101
{ 
#line 1102
return 18446744073709551615Ui64; 
#line 1103
} 
#line 1106
static _Ty __cdecl lowest() throw() 
#line 1107
{ 
#line 1108
return min(); 
#line 1109
} 
#line 1112 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 1113
{ 
#line 1114
return 0; 
#line 1115
} 
#line 1117
static _Ty __cdecl round_error() throw() 
#line 1118
{ 
#line 1119
return 0; 
#line 1120
} 
#line 1122
static _Ty __cdecl denorm_min() throw() 
#line 1123
{ 
#line 1124
return 0; 
#line 1125
} 
#line 1127
static _Ty __cdecl infinity() throw() 
#line 1128
{ 
#line 1129
return 0; 
#line 1130
} 
#line 1132
static _Ty __cdecl quiet_NaN() throw() 
#line 1133
{ 
#line 1134
return 0; 
#line 1135
} 
#line 1137
static _Ty __cdecl signaling_NaN() throw() 
#line 1138
{ 
#line 1139
return 0; 
#line 1140
} 
#line 1142
static const bool is_signed = ((bool)false); 
#line 1143
static const int digits = ((int)((8) * sizeof(unsigned __int64))); 
#line 1144
static const int digits10 = ((int)((((8) * sizeof(unsigned __int64)) * (301L)) / (1000))); 
#line 1148 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_digits10 = ((int)((2) + ((((8) * sizeof(unsigned __int64)) * (301L)) / (1000)))); 
#line 1151 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}; 
#line 1155 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
template<> class __declspec(dllimport) numeric_limits< float>  : public _Num_float_base { 
#line 1159
public: typedef float _Ty; 
#line 1161
static _Ty __cdecl min() throw() 
#line 1162
{ 
#line 1163
return (1.175494351e-038F); 
#line 1164
} 
#line 1166
static _Ty __cdecl max() throw() 
#line 1167
{ 
#line 1168
return (3.402823466e+038F); 
#line 1169
} 
#line 1172
static _Ty __cdecl lowest() throw() 
#line 1173
{ 
#line 1174
return -max(); 
#line 1175
} 
#line 1178 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 1179
{ 
#line 1180
return (1.192092896e-007F); 
#line 1181
} 
#line 1183
static _Ty __cdecl round_error() throw() 
#line 1184
{ 
#line 1185
return (0.5); 
#line 1186
} 
#line 1188
static _Ty __cdecl denorm_min() throw() 
#line 1189
{ 
#line 1190
return ::_FDenorm._Float; 
#line 1191
} 
#line 1193
static _Ty __cdecl infinity() throw() 
#line 1194
{ 
#line 1195
return ::_FInf._Float; 
#line 1196
} 
#line 1198
static _Ty __cdecl quiet_NaN() throw() 
#line 1199
{ 
#line 1200
return ::_FNan._Float; 
#line 1201
} 
#line 1203
static _Ty __cdecl signaling_NaN() throw() 
#line 1204
{ 
#line 1205
return ::_FSnan._Float; 
#line 1206
} 
#line 1208
static const int digits = ((int)24); 
#line 1209
static const int digits10 = ((int)6); 
#line 1212
static const int max_digits10 = ((int)(2 + 6)); 
#line 1215 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_exponent = ((int)((int)128)); 
#line 1216
static const int max_exponent10 = ((int)((int)38)); 
#line 1217
static const int min_exponent = ((int)((int)(-125))); 
#line 1218
static const int min_exponent10 = ((int)((int)(-37))); 
#line 1219
}; 
#line 1222
template<> class __declspec(dllimport) numeric_limits< double>  : public _Num_float_base { 
#line 1226
public: typedef double _Ty; 
#line 1228
static _Ty __cdecl min() throw() 
#line 1229
{ 
#line 1230
return (2.2250738585072014e-308); 
#line 1231
} 
#line 1233
static _Ty __cdecl max() throw() 
#line 1234
{ 
#line 1235
return (1.7976931348623157e+308); 
#line 1236
} 
#line 1239
static _Ty __cdecl lowest() throw() 
#line 1240
{ 
#line 1241
return -max(); 
#line 1242
} 
#line 1245 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 1246
{ 
#line 1247
return (2.2204460492503131e-016); 
#line 1248
} 
#line 1250
static _Ty __cdecl round_error() throw() 
#line 1251
{ 
#line 1252
return (0.5); 
#line 1253
} 
#line 1255
static _Ty __cdecl denorm_min() throw() 
#line 1256
{ 
#line 1257
return ::_Denorm._Double; 
#line 1258
} 
#line 1260
static _Ty __cdecl infinity() throw() 
#line 1261
{ 
#line 1262
return ::_Inf._Double; 
#line 1263
} 
#line 1265
static _Ty __cdecl quiet_NaN() throw() 
#line 1266
{ 
#line 1267
return ::_Nan._Double; 
#line 1268
} 
#line 1270
static _Ty __cdecl signaling_NaN() throw() 
#line 1271
{ 
#line 1272
return ::_Snan._Double; 
#line 1273
} 
#line 1275
static const int digits = ((int)53); 
#line 1276
static const int digits10 = ((int)15); 
#line 1279
static const int max_digits10 = ((int)(2 + 15)); 
#line 1282 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_exponent = ((int)((int)1024)); 
#line 1283
static const int max_exponent10 = ((int)((int)308)); 
#line 1284
static const int min_exponent = ((int)((int)(-1021))); 
#line 1285
static const int min_exponent10 = ((int)((int)(-307))); 
#line 1286
}; 
#line 1289
template<> class __declspec(dllimport) numeric_limits< long double>  : public _Num_float_base { 
#line 1293
public: typedef long double _Ty; 
#line 1295
static _Ty __cdecl min() throw() 
#line 1296
{ 
#line 1297
return (2.2250738585072014e-308); 
#line 1298
} 
#line 1300
static _Ty __cdecl max() throw() 
#line 1301
{ 
#line 1302
return (1.7976931348623157e+308); 
#line 1303
} 
#line 1306
static _Ty __cdecl lowest() throw() 
#line 1307
{ 
#line 1308
return -max(); 
#line 1309
} 
#line 1312 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static _Ty __cdecl epsilon() throw() 
#line 1313
{ 
#line 1314
return (2.2204460492503131e-016); 
#line 1315
} 
#line 1317
static _Ty __cdecl round_error() throw() 
#line 1318
{ 
#line 1319
return (0.5); 
#line 1320
} 
#line 1322
static _Ty __cdecl denorm_min() throw() 
#line 1323
{ 
#line 1324
return ::_LDenorm._Long_double; 
#line 1325
} 
#line 1327
static _Ty __cdecl infinity() throw() 
#line 1328
{ 
#line 1329
return ::_LInf._Long_double; 
#line 1330
} 
#line 1332
static _Ty __cdecl quiet_NaN() throw() 
#line 1333
{ 
#line 1334
return ::_LNan._Long_double; 
#line 1335
} 
#line 1337
static _Ty __cdecl signaling_NaN() throw() 
#line 1338
{ 
#line 1339
return ::_LSnan._Long_double; 
#line 1340
} 
#line 1342
static const int digits = ((int)53); 
#line 1343
static const int digits10 = ((int)15); 
#line 1346
static const int max_digits10 = ((int)(2 + 15)); 
#line 1349 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
static const int max_exponent = ((int)((int)1024)); 
#line 1350
static const int max_exponent10 = ((int)((int)308)); 
#line 1351
static const int min_exponent = ((int)((int)(-1021))); 
#line 1352
static const int min_exponent10 = ((int)((int)(-307))); 
#line 1353
}; 
#line 1637 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
}
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xtr1common"
#pragma warning(push,3)
#line 1639 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\limits"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xtr1common"
#pragma pack ( push, 8 )
#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xtr1common"
namespace std { 
#line 153
template< class _T1, class 
#line 154
_Ret> struct unary_function; 
#line 158
template< class _T1, class 
#line 159
_T2, class 
#line 160
_Ret> struct binary_function; 
#line 163
namespace tr1 { 
#line 165
struct _Nil { 
#line 167
}; 
#line 168
static _Nil _Nil_obj; 
#line 171
template< class _Ty, _Ty 
#line 172
_Val> 
#line 173
struct integral_constant { 
#line 175
static const _Ty value = _Val; 
#line 177
typedef _Ty value_type; 
#line 178
typedef integral_constant type; 
#line 179
}; 
#line 181
typedef integral_constant< bool, true>  true_type; 
#line 182
typedef integral_constant< bool, false>  false_type; 
#line 185
template< bool _First, bool 
#line 186
_Second> struct _Or; 
#line 189
template<> struct _Or< false, false>  : public false_type { 
#line 192
}; 
#line 195
template<> struct _Or< false, true>  : public true_type { 
#line 198
}; 
#line 201
template<> struct _Or< true, false>  : public true_type { 
#line 204
}; 
#line 207
template<> struct _Or< true, true>  : public true_type { 
#line 210
}; 
#line 213
template< bool __T0> struct _Cat_base; 
#line 216
template<> struct _Cat_base< false>  : public false_type { 
#line 219
}; 
#line 222
template<> struct _Cat_base< true>  : public true_type { 
#line 225
}; 
#line 228
template< class _Ty> 
#line 229
struct _Is_integral : public false_type { 
#line 232
}; 
#line 235
template<> struct _Is_integral< bool>  : public true_type { 
#line 238
}; 
#line 241
template<> struct _Is_integral< char>  : public true_type { 
#line 244
}; 
#line 247
template<> struct _Is_integral< unsigned char>  : public true_type { 
#line 250
}; 
#line 253
template<> struct _Is_integral< signed char>  : public true_type { 
#line 256
}; 
#line 260
template<> struct _Is_integral< __wchar_t>  : public true_type { 
#line 263
}; 
#line 267 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xtr1common"
template<> struct _Is_integral< unsigned short>  : public true_type { 
#line 270
}; 
#line 273
template<> struct _Is_integral< signed short>  : public true_type { 
#line 276
}; 
#line 279
template<> struct _Is_integral< unsigned>  : public true_type { 
#line 282
}; 
#line 285
template<> struct _Is_integral< signed int>  : public true_type { 
#line 288
}; 
#line 291
template<> struct _Is_integral< unsigned long>  : public true_type { 
#line 294
}; 
#line 297
template<> struct _Is_integral< signed long>  : public true_type { 
#line 300
}; 
#line 304
template<> struct _Is_integral< __int64>  : public true_type { 
#line 307
}; 
#line 310
template<> struct _Is_integral< unsigned __int64>  : public true_type { 
#line 313
}; 
#line 317 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xtr1common"
template< class _Ty> 
#line 318
struct _Is_floating_point : public false_type { 
#line 321
}; 
#line 324
template<> struct _Is_floating_point< float>  : public true_type { 
#line 327
}; 
#line 330
template<> struct _Is_floating_point< double>  : public true_type { 
#line 333
}; 
#line 336
template<> struct _Is_floating_point< long double>  : public true_type { 
#line 339
}; 
#line 342
template< class _Ty> 
#line 343
struct _Remove_reference { 
#line 345
typedef _Ty _Type; 
#line 346
}; 
#line 348
template< class _Ty> 
#line 349
struct _Remove_reference< _Ty &>  { 
#line 351
typedef _Ty _Type; 
#line 352
}; 
#line 354
template< class _Ty> 
#line 355
struct _Remove_reference< _Ty &&>  { 
#line 357
typedef _Ty _Type; 
#line 358
}; 
#line 361
template< class _Ty> 
#line 362
struct _Remove_rvalue_reference { 
#line 364
typedef _Ty _Type; 
#line 365
}; 
#line 367
template< class _Ty> 
#line 368
struct _Remove_rvalue_reference< _Ty &&>  { 
#line 370
typedef _Ty _Type; 
#line 371
}; 
#line 374
template< class _Tgt, class 
#line 375
_Src> 
#line 376
struct _Copy_cv { 
#line 378
typedef typename _Remove_reference< _Tgt> ::_Type _Tgtx; 
#line 379
typedef _Tgtx &_Type; 
#line 380
}; 
#line 382
template< class _Tgt, class 
#line 383
_Src> 
#line 384
struct _Copy_cv< _Tgt, const _Src>  { 
#line 386
typedef typename _Remove_reference< _Tgt> ::_Type _Tgtx; 
#line 387
typedef const _Tgtx &_Type; 
#line 388
}; 
#line 390
template< class _Tgt, class 
#line 391
_Src> 
#line 392
struct _Copy_cv< _Tgt, volatile _Src>  { 
#line 394
typedef typename _Remove_reference< _Tgt> ::_Type _Tgtx; 
#line 395
typedef volatile _Tgtx &_Type; 
#line 396
}; 
#line 398
template< class _Tgt, class 
#line 399
_Src> 
#line 400
struct _Copy_cv< _Tgt, const volatile _Src>  { 
#line 402
typedef typename _Remove_reference< _Tgt> ::_Type _Tgtx; 
#line 403
typedef const volatile _Tgtx &_Type; 
#line 404
}; 
#line 406
template< class _Tgt, class 
#line 407
_Src> 
#line 408
struct _Copy_cv< _Tgt, _Src &>  { 
#line 410
typedef typename tr1::_Copy_cv< _Tgt, _Src> ::_Type _Type; 
#line 411
}; 
#line 422
_No _Has_result_type(...); 
#line 424
template< class _Ty> _Yes _Has_result_type(_Ty *, typename _Remove_reference< typename _Ty::result_type> ::_Type * = 0); 
#line 430
}
#line 431
}
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
#pragma warning(push,3)
#line 433 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xtr1common"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
#pragma pack ( push, 8 )
#line 50
namespace std { 
#line 51
namespace tr1 { 
#line 53
template< class _Ty> 
#line 54
struct _Ptr_traits { 
#line 56
}; 
#line 58
template< class _Ty> 
#line 59
struct _Ptr_traits< _Ty *>  { 
#line 61
static const bool _Is_const = false; 
#line 62
static const bool _Is_volatile = false; 
#line 63
}; 
#line 65
template< class _Ty> 
#line 66
struct _Ptr_traits< const _Ty *>  { 
#line 68
static const bool _Is_const = true; 
#line 69
static const bool _Is_volatile = false; 
#line 70
}; 
#line 72
template< class _Ty> 
#line 73
struct _Ptr_traits< volatile _Ty *>  { 
#line 75
static const bool _Is_const = false; 
#line 76
static const bool _Is_volatile = true; 
#line 77
}; 
#line 79
template< class _Ty> 
#line 80
struct _Ptr_traits< const volatile _Ty *>  { 
#line 82
static const bool _Is_const = true; 
#line 83
static const bool _Is_volatile = true; 
#line 84
}; 
#line 86
template< class _Ty> 
#line 87
struct _Is_funptr : public false_type { 
#line 90
}; 
#line 92
template< class _Ty> 
#line 93
struct _Is_memfunptr : public false_type { 
#line 96
}; 
#line 4 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template< class _Ret> 
#line 5
struct _Is_funptr< _Ret (*)(void)>  : public true_type { 
#line 8
}; 
#line 10
template< class _Ret> 
#line 11
struct _Is_funptr< _Ret (*)(...)>  : public true_type { 
#line 14
}; 
#line 4 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template< class _Ret, class _Arg0> 
#line 5
struct _Is_funptr< _Ret (*)(_Arg0)>  : public true_type { 
#line 8
}; 
#line 10
template< class _Ret, class _Arg0> 
#line 11
struct _Is_funptr< _Ret (*)(_Arg0, ...)>  : public true_type { 
#line 14
}; 
#line 17
template< class _Ret, class _Arg0> 
#line 18
struct _Is_memfunptr< _Ret (_Arg0::*)(void)>  : public true_type { 
#line 21
}; 
#line 23
template< class _Ret, class _Arg0> 
#line 24
struct _Is_memfunptr< _Ret (_Arg0::*)(...)>  : public true_type { 
#line 27
}; 
#line 29
template< class _Ret, class _Arg0> 
#line 30
struct _Is_memfunptr< _Ret (_Arg0::*)(void) const>  : public true_type { 
#line 33
}; 
#line 35
template< class _Ret, class _Arg0> 
#line 36
struct _Is_memfunptr< _Ret (_Arg0::*)(...) const>  : public true_type { 
#line 39
}; 
#line 41
template< class _Ret, class _Arg0> 
#line 42
struct _Is_memfunptr< _Ret (_Arg0::*)(void) volatile>  : public true_type { 
#line 45
}; 
#line 47
template< class _Ret, class _Arg0> 
#line 48
struct _Is_memfunptr< _Ret (_Arg0::*)(...) volatile>  : public true_type { 
#line 51
}; 
#line 53
template< class _Ret, class _Arg0> 
#line 54
struct _Is_memfunptr< _Ret (_Arg0::*)(void) const volatile>  : public true_type { 
#line 57
}; 
#line 59
template< class _Ret, class _Arg0> 
#line 60
struct _Is_memfunptr< _Ret (_Arg0::*)(...) const volatile>  : public true_type { 
#line 63
}; 
#line 4 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template< class _Ret, class _Arg0, class _Arg1> 
#line 5
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1)>  : public true_type { 
#line 8
}; 
#line 10
template< class _Ret, class _Arg0, class _Arg1> 
#line 11
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, ...)>  : public true_type { 
#line 14
}; 
#line 17
template< class _Ret, class _Arg0, class _Arg1> 
#line 18
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1)>  : public true_type { 
#line 21
}; 
#line 23
template< class _Ret, class _Arg0, class _Arg1> 
#line 24
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, ...)>  : public true_type { 
#line 27
}; 
#line 29
template< class _Ret, class _Arg0, class _Arg1> 
#line 30
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1) const>  : public true_type { 
#line 33
}; 
#line 35
template< class _Ret, class _Arg0, class _Arg1> 
#line 36
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, ...) const>  : public true_type { 
#line 39
}; 
#line 41
template< class _Ret, class _Arg0, class _Arg1> 
#line 42
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1) volatile>  : public true_type { 
#line 45
}; 
#line 47
template< class _Ret, class _Arg0, class _Arg1> 
#line 48
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, ...) volatile>  : public true_type { 
#line 51
}; 
#line 53
template< class _Ret, class _Arg0, class _Arg1> 
#line 54
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1) const volatile>  : public true_type { 
#line 57
}; 
#line 59
template< class _Ret, class _Arg0, class _Arg1> 
#line 60
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, ...) const volatile>  : public true_type { 
#line 63
}; 
#line 4 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2> 
#line 5
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2)>  : public true_type { 
#line 8
}; 
#line 10
template< class _Ret, class _Arg0, class _Arg1, class _Arg2> 
#line 11
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, ...)>  : public true_type { 
#line 14
}; 
#line 17
template< class _Ret, class _Arg0, class _Arg1, class _Arg2> 
#line 18
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2)>  : public true_type { 
#line 21
}; 
#line 23
template< class _Ret, class _Arg0, class _Arg1, class _Arg2> 
#line 24
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, ...)>  : public true_type { 
#line 27
}; 
#line 29
template< class _Ret, class _Arg0, class _Arg1, class _Arg2> 
#line 30
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2) const>  : public true_type { 
#line 33
}; 
#line 35
template< class _Ret, class _Arg0, class _Arg1, class _Arg2> 
#line 36
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, ...) const>  : public true_type { 
#line 39
}; 
#line 41
template< class _Ret, class _Arg0, class _Arg1, class _Arg2> 
#line 42
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2) volatile>  : public true_type { 
#line 45
}; 
#line 47
template< class _Ret, class _Arg0, class _Arg1, class _Arg2> 
#line 48
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, ...) volatile>  : public true_type { 
#line 51
}; 
#line 53
template< class _Ret, class _Arg0, class _Arg1, class _Arg2> 
#line 54
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2) const volatile>  : public true_type { 
#line 57
}; 
#line 59
template< class _Ret, class _Arg0, class _Arg1, class _Arg2> 
#line 60
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, ...) const volatile>  : public true_type { 
#line 63
}; 
#line 4 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 5
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3)>  : public true_type { 
#line 8
}; 
#line 10
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 11
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, ...)>  : public true_type { 
#line 14
}; 
#line 17
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 18
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3)>  : public true_type { 
#line 21
}; 
#line 23
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 24
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, ...)>  : public true_type { 
#line 27
}; 
#line 29
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 30
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3) const>  : public true_type { 
#line 33
}; 
#line 35
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 36
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, ...) const>  : public true_type { 
#line 39
}; 
#line 41
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 42
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3) volatile>  : public true_type { 
#line 45
}; 
#line 47
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 48
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, ...) volatile>  : public true_type { 
#line 51
}; 
#line 53
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 54
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3) const volatile>  : public true_type { 
#line 57
}; 
#line 59
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 60
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, ...) const volatile>  : public true_type { 
#line 63
}; 
#line 4 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 5
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4)>  : public true_type { 
#line 8
}; 
#line 10
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 11
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, ...)>  : public true_type { 
#line 14
}; 
#line 17
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 18
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4)>  : public true_type { 
#line 21
}; 
#line 23
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 24
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, ...)>  : public true_type { 
#line 27
}; 
#line 29
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 30
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) const>  : public true_type { 
#line 33
}; 
#line 35
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 36
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, ...) const>  : public true_type { 
#line 39
}; 
#line 41
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 42
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) volatile>  : public true_type { 
#line 45
}; 
#line 47
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 48
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, ...) volatile>  : public true_type { 
#line 51
}; 
#line 53
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 54
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) const volatile>  : public true_type { 
#line 57
}; 
#line 59
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 60
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, ...) const volatile>  : public true_type { 
#line 63
}; 
#line 4 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 5
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5)>  : public true_type { 
#line 8
}; 
#line 10
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 11
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, ...)>  : public true_type { 
#line 14
}; 
#line 17
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 18
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5)>  : public true_type { 
#line 21
}; 
#line 23
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 24
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, ...)>  : public true_type { 
#line 27
}; 
#line 29
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 30
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const>  : public true_type { 
#line 33
}; 
#line 35
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 36
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, ...) const>  : public true_type { 
#line 39
}; 
#line 41
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 42
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) volatile>  : public true_type { 
#line 45
}; 
#line 47
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 48
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, ...) volatile>  : public true_type { 
#line 51
}; 
#line 53
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 54
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const volatile>  : public true_type { 
#line 57
}; 
#line 59
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 60
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, ...) const volatile>  : public true_type { 
#line 63
}; 
#line 4 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 5
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6)>  : public true_type { 
#line 8
}; 
#line 10
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 11
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, ...)>  : public true_type { 
#line 14
}; 
#line 17
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 18
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6)>  : public true_type { 
#line 21
}; 
#line 23
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 24
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, ...)>  : public true_type { 
#line 27
}; 
#line 29
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 30
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const>  : public true_type { 
#line 33
}; 
#line 35
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 36
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, ...) const>  : public true_type { 
#line 39
}; 
#line 41
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 42
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) volatile>  : public true_type { 
#line 45
}; 
#line 47
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 48
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, ...) volatile>  : public true_type { 
#line 51
}; 
#line 53
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 54
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const volatile>  : public true_type { 
#line 57
}; 
#line 59
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 60
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, ...) const volatile>  : public true_type { 
#line 63
}; 
#line 4 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 5
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7)>  : public true_type { 
#line 8
}; 
#line 10
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 11
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, ...)>  : public true_type { 
#line 14
}; 
#line 17
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 18
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7)>  : public true_type { 
#line 21
}; 
#line 23
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 24
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, ...)>  : public true_type { 
#line 27
}; 
#line 29
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 30
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const>  : public true_type { 
#line 33
}; 
#line 35
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 36
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, ...) const>  : public true_type { 
#line 39
}; 
#line 41
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 42
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) volatile>  : public true_type { 
#line 45
}; 
#line 47
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 48
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, ...) volatile>  : public true_type { 
#line 51
}; 
#line 53
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 54
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const volatile>  : public true_type { 
#line 57
}; 
#line 59
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 60
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, ...) const volatile>  : public true_type { 
#line 63
}; 
#line 4 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 5
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8)>  : public true_type { 
#line 8
}; 
#line 10
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 11
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, ...)>  : public true_type { 
#line 14
}; 
#line 17
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 18
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8)>  : public true_type { 
#line 21
}; 
#line 23
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 24
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, ...)>  : public true_type { 
#line 27
}; 
#line 29
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 30
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const>  : public true_type { 
#line 33
}; 
#line 35
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 36
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, ...) const>  : public true_type { 
#line 39
}; 
#line 41
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 42
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) volatile>  : public true_type { 
#line 45
}; 
#line 47
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 48
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, ...) volatile>  : public true_type { 
#line 51
}; 
#line 53
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 54
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const volatile>  : public true_type { 
#line 57
}; 
#line 59
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 60
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, ...) const volatile>  : public true_type { 
#line 63
}; 
#line 4 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxtype_traits"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 5
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9)>  : public true_type { 
#line 8
}; 
#line 10
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 11
struct _Is_funptr< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, ...)>  : public true_type { 
#line 14
}; 
#line 17
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 18
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9)>  : public true_type { 
#line 21
}; 
#line 23
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 24
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, ...)>  : public true_type { 
#line 27
}; 
#line 29
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 30
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const>  : public true_type { 
#line 33
}; 
#line 35
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 36
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, ...) const>  : public true_type { 
#line 39
}; 
#line 41
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 42
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) volatile>  : public true_type { 
#line 45
}; 
#line 47
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 48
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, ...) volatile>  : public true_type { 
#line 51
}; 
#line 53
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 54
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const volatile>  : public true_type { 
#line 57
}; 
#line 59
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 60
struct _Is_memfunptr< _Ret (_Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, ...) const volatile>  : public true_type { 
#line 63
}; 
#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
template< class _Ty> 
#line 104
struct remove_const { 
#line 106
typedef _Ty type; 
#line 107
}; 
#line 109
template< class _Ty> 
#line 110
struct remove_const< const _Ty>  { 
#line 112
typedef _Ty type; 
#line 113
}; 
#line 115
template< class _Ty> 
#line 116
struct remove_const< const _Ty []>  { 
#line 118
typedef _Ty type[]; 
#line 119
}; 
#line 121
template< class _Ty, unsigned _Nx> 
#line 122
struct remove_const< const _Ty [_Nx]>  { 
#line 124
typedef _Ty type[_Nx]; 
#line 125
}; 
#line 128
template< class _Ty> 
#line 129
struct remove_volatile { 
#line 131
typedef _Ty type; 
#line 132
}; 
#line 134
template< class _Ty> 
#line 135
struct remove_volatile< volatile _Ty>  { 
#line 137
typedef _Ty type; 
#line 138
}; 
#line 140
template< class _Ty> 
#line 141
struct remove_volatile< volatile _Ty []>  { 
#line 143
typedef _Ty type[]; 
#line 144
}; 
#line 146
template< class _Ty, unsigned _Nx> 
#line 147
struct remove_volatile< volatile _Ty [_Nx]>  { 
#line 149
typedef _Ty type[_Nx]; 
#line 150
}; 
#line 153
template< class _Ty> 
#line 154
struct remove_cv { 
#line 157
typedef typename remove_const< typename remove_volatile< _Ty> ::type> ::type type; 
#line 158
}; 
#line 161
template< class _Ty> 
#line 162
struct add_const { 
#line 164
typedef const _Ty type; 
#line 165
}; 
#line 167
template< class _Ty> 
#line 168
struct add_const< _Ty &>  { 
#line 170
typedef _Ty &type; 
#line 171
}; 
#line 174
template< class _Ty> 
#line 175
struct add_volatile { 
#line 177
typedef volatile _Ty type; 
#line 178
}; 
#line 180
template< class _Ty> 
#line 181
struct add_volatile< _Ty &>  { 
#line 183
typedef _Ty &type; 
#line 184
}; 
#line 187
template< class _Ty> 
#line 188
struct add_cv { 
#line 190
typedef typename add_const< typename add_volatile< _Ty> ::type> ::type type; 
#line 191
}; 
#line 194
template< class _Ty> 
#line 195
struct remove_reference : public _Remove_reference< _Ty>  { 
#line 198
typedef typename ::std::tr1::_Remove_reference< _Ty> ::_Type type; 
#line 199
}; 
#line 202
template< class _Ty> 
#line 203
struct add_reference { 
#line 205
typedef typename _Remove_reference< _Ty> ::_Type &type; 
#line 206
}; 
#line 209
template<> struct add_reference< void>  { 
#line 211
typedef void type; 
#line 212
}; 
#line 215
template<> struct add_reference< const void>  { 
#line 217
typedef const void type; 
#line 218
}; 
#line 221
template<> struct add_reference< volatile void>  { 
#line 223
typedef volatile void type; 
#line 224
}; 
#line 227
template<> struct add_reference< const volatile void>  { 
#line 229
typedef const volatile void type; 
#line 230
}; 
#line 233
template< class _Ty> 
#line 234
struct add_lvalue_reference { 
#line 236
typedef typename add_reference< _Ty> ::type type; 
#line 237
}; 
#line 240
template< class _Ty> 
#line 241
struct add_rvalue_reference { 
#line 243
typedef _Ty &&type; 
#line 244
}; 
#line 246
template< class _Ty> 
#line 247
struct add_rvalue_reference< _Ty &>  { 
#line 249
typedef _Ty &type; 
#line 250
}; 
#line 253
template<> struct add_rvalue_reference< void>  { 
#line 255
typedef void type; 
#line 256
}; 
#line 259
template<> struct add_rvalue_reference< const void>  { 
#line 261
typedef const void type; 
#line 262
}; 
#line 265
template<> struct add_rvalue_reference< volatile void>  { 
#line 267
typedef volatile void type; 
#line 268
}; 
#line 271
template<> struct add_rvalue_reference< const volatile void>  { 
#line 273
typedef const volatile void type; 
#line 274
}; 
#line 277
template< class _Ty> 
#line 278
struct remove_extent { 
#line 280
typedef _Ty type; 
#line 281
}; 
#line 283
template< class _Ty, unsigned _Ix> 
#line 284
struct remove_extent< _Ty [_Ix]>  { 
#line 286
typedef _Ty type; 
#line 287
}; 
#line 289
template< class _Ty> 
#line 290
struct remove_extent< _Ty []>  { 
#line 292
typedef _Ty type; 
#line 293
}; 
#line 296
template< class _Ty> 
#line 297
struct remove_all_extents { 
#line 299
typedef _Ty type; 
#line 300
}; 
#line 302
template< class _Ty, unsigned _Ix> 
#line 303
struct remove_all_extents< _Ty [_Ix]>  { 
#line 305
typedef typename tr1::remove_all_extents< _Ty> ::type type; 
#line 306
}; 
#line 308
template< class _Ty> 
#line 309
struct remove_all_extents< _Ty []>  { 
#line 311
typedef typename tr1::remove_all_extents< _Ty> ::type type; 
#line 312
}; 
#line 315
template< class _Ty> 
#line 316
struct remove_pointer { 
#line 318
typedef _Ty type; 
#line 319
}; 
#line 321
template< class _Ty> 
#line 322
struct remove_pointer< _Ty *>  { 
#line 324
typedef _Ty type; 
#line 325
}; 
#line 327
template< class _Ty> 
#line 328
struct remove_pointer< _Ty *const>  { 
#line 330
typedef _Ty type; 
#line 331
}; 
#line 333
template< class _Ty> 
#line 334
struct remove_pointer< _Ty *volatile>  { 
#line 336
typedef _Ty type; 
#line 337
}; 
#line 339
template< class _Ty> 
#line 340
struct remove_pointer< _Ty *const volatile>  { 
#line 342
typedef _Ty type; 
#line 343
}; 
#line 346
template< class _Ty> 
#line 347
struct add_pointer { 
#line 349
typedef typename remove_reference< _Ty> ::type *type; 
#line 350
}; 
#line 354
template< class _Ty> 
#line 355
struct _Is_void : public false_type { 
#line 358
}; 
#line 361
template<> struct _Is_void< void>  : public true_type { 
#line 364
}; 
#line 366
template< class _Ty> 
#line 367
struct is_void : public _Is_void< typename remove_cv< _Ty> ::type>  { 
#line 370
}; 
#line 373
template< class _Ty> 
#line 374
struct is_integral : public _Is_integral< typename remove_cv< _Ty> ::type>  { 
#line 377
}; 
#line 380
template< class _Ty> 
#line 381
struct is_floating_point : public _Is_floating_point< typename remove_cv< _Ty> ::type>  { 
#line 384
}; 
#line 387
template< class _Ty> 
#line 388
struct is_array : public false_type { 
#line 391
}; 
#line 393
template< class _Ty, size_t _Nx> 
#line 394
struct is_array< _Ty [_Nx]>  : public true_type { 
#line 397
}; 
#line 399
template< class _Ty> 
#line 400
struct is_array< _Ty []>  : public true_type { 
#line 403
}; 
#line 407
template< class _Ty> 
#line 408
struct is_lvalue_reference : public false_type { 
#line 411
}; 
#line 413
template< class _Ty> 
#line 414
struct is_lvalue_reference< _Ty &>  : public true_type { 
#line 417
}; 
#line 420
template< class _Ty> 
#line 421
struct is_rvalue_reference : public false_type { 
#line 424
}; 
#line 426
template< class _Ty> 
#line 427
struct is_rvalue_reference< _Ty &&>  : public true_type { 
#line 430
}; 
#line 433
template< class _Ty> 
#line 434
struct is_reference : public _Cat_base< is_lvalue_reference< _Ty> ::value || is_rvalue_reference< _Ty> ::value>  { 
#line 438
}; 
#line 456 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
template< class _Ty> 
#line 457
struct _Is_member_object_pointer : public false_type { 
#line 460
}; 
#line 462
template< class _Ty1, class _Ty2> 
#line 463
struct _Is_member_object_pointer< _Ty1 _Ty2::*>  : public _Cat_base< !_Is_memfunptr< _Ty1 _Ty2::*> ::value>  { 
#line 466
}; 
#line 468
template< class _Ty> 
#line 469
struct is_member_object_pointer : public _Is_member_object_pointer< typename remove_cv< _Ty> ::type>  { 
#line 472
}; 
#line 475
template< class _Ty> 
#line 476
struct is_member_function_pointer : public _Cat_base< _Is_memfunptr< typename remove_cv< _Ty> ::type> ::value>  { 
#line 479
}; 
#line 482
template< class _Ty> 
#line 483
struct _Is_pointer : public false_type { 
#line 486
}; 
#line 488
template< class _Ty> 
#line 489
struct _Is_pointer< _Ty *>  : public _Cat_base< (!is_member_object_pointer< _Ty *> ::value) && (!is_member_function_pointer< _Ty *> ::value)>  { 
#line 493
}; 
#line 495
template< class _Ty> 
#line 496
struct is_pointer : public _Is_pointer< typename remove_cv< _Ty> ::type>  { 
#line 499
}; 
#line 502
template< class _Ty> 
#line 503
struct is_union : public _Cat_base< __is_union(_Ty)>  { 
#line 505
}; 
#line 508
template< class _Ty> 
#line 509
struct is_class : public _Cat_base< __is_class(_Ty)>  { 
#line 511
}; 
#line 514
template< class _Ty> 
#line 515
struct is_function : public _Cat_base< _Is_funptr< typename remove_cv< _Ty> ::type *> ::value>  { 
#line 518
}; 
#line 520
template< class _Ty> 
#line 521
struct is_function< _Ty &>  : public false_type { 
#line 524
}; 
#line 527
template< class _Ty> 
#line 528
struct is_arithmetic : public _Cat_base< is_integral< _Ty> ::value || is_floating_point< _Ty> ::value>  { 
#line 532
}; 
#line 535
template< class _Ty> 
#line 536
struct is_fundamental : public _Cat_base< is_arithmetic< _Ty> ::value || is_void< _Ty> ::value>  { 
#line 540
}; 
#line 543
template< class _Ty> 
#line 544
struct is_object : public _Cat_base< ((!is_function< _Ty> ::value) && (!is_reference< _Ty> ::value)) && (!is_void< _Ty> ::value)>  { 
#line 549
}; 
#line 553
template< class _From, class _To> 
#line 554
struct is_convertible : public _Cat_base< (is_void< _From> ::value && is_void< _To> ::value) || __is_convertible_to(_From, _To)>  { 
#line 556
}; 
#line 560
template< class _Ty> 
#line 561
struct is_enum : public _Cat_base< __is_enum(_Ty)>  { 
#line 563
}; 
#line 566
template< class _Ty> 
#line 567
struct is_compound : public _Cat_base< !is_fundamental< _Ty> ::value>  { 
#line 570
}; 
#line 573
template< class _Ty> 
#line 574
struct is_member_pointer : public _Cat_base< is_member_object_pointer< _Ty> ::value || is_member_function_pointer< _Ty> ::value>  { 
#line 578
}; 
#line 581
template< class _Ty> 
#line 582
struct is_scalar : public _Cat_base< ((is_arithmetic< _Ty> ::value || is_enum< _Ty> ::value) || is_pointer< _Ty> ::value) || is_member_pointer< _Ty> ::value>  { 
#line 588
}; 
#line 590
template< class _Ty> 
#line 591
struct is_scalar< _Ty &>  : public false_type { 
#line 594
}; 
#line 597
template< class _Ty> 
#line 598
struct is_const : public _Cat_base< _Ptr_traits< _Ty *> ::_Is_const && (!is_function< _Ty> ::value)>  { 
#line 602
}; 
#line 604
template< class _Ty, unsigned _Nx> 
#line 605
struct is_const< _Ty [_Nx]>  : public false_type { 
#line 608
}; 
#line 610
template< class _Ty, unsigned _Nx> 
#line 611
struct is_const< const _Ty [_Nx]>  : public true_type { 
#line 614
}; 
#line 616
template< class _Ty> 
#line 617
struct is_const< _Ty &>  : public false_type { 
#line 620
}; 
#line 623
template< class _Ty> 
#line 624
struct is_volatile : public _Cat_base< _Ptr_traits< _Ty *> ::_Is_volatile && (!is_function< _Ty> ::value)>  { 
#line 628
}; 
#line 630
template< class _Ty> 
#line 631
struct is_volatile< _Ty &>  : public false_type { 
#line 634
}; 
#line 637
template< class _Ty> 
#line 638
struct _Is_pod : public _Cat_base< (is_void< _Ty> ::value || is_scalar< _Ty> ::value) || (__has_trivial_constructor(_Ty) && __is_pod(_Ty))>  { 
#line 640
}; 
#line 642
template< class _Ty> 
#line 643
struct is_pod : public _Is_pod< typename remove_all_extents< _Ty> ::type>  { 
#line 646
}; 
#line 649
template< class _Ty> 
#line 650
struct is_empty : public _Cat_base< __is_empty(_Ty)>  { 
#line 652
}; 
#line 655
template< class _Ty> 
#line 656
struct is_polymorphic : public _Cat_base< __is_polymorphic(_Ty)>  { 
#line 658
}; 
#line 661
template< class _Ty> 
#line 662
struct is_abstract : public _Cat_base< __is_abstract(_Ty)>  { 
#line 664
}; 
#line 668
template< class _Ty> 
#line 669
struct is_standard_layout : public is_pod< _Ty>  { 
#line 671
}; 
#line 674
template< class _Ty> 
#line 675
struct is_trivial : public is_pod< _Ty>  { 
#line 677
}; 
#line 681 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
template< class _Ty> 
#line 682
struct has_trivial_constructor : public _Cat_base< is_pod< _Ty> ::value || __has_trivial_constructor(_Ty)>  { 
#line 684
}; 
#line 687
template< class _Ty> 
#line 688
struct has_trivial_copy : public _Cat_base< is_pod< _Ty> ::value || __has_trivial_copy(_Ty)>  { 
#line 690
}; 
#line 694
template< class _Ty> 
#line 695
struct has_trivial_default_constructor : public _Cat_base< is_pod< _Ty> ::value || __has_trivial_constructor(_Ty)>  { 
#line 697
}; 
#line 700
template< class _Ty> 
#line 701
struct has_trivial_copy_constructor : public _Cat_base< is_pod< _Ty> ::value || __has_trivial_copy(_Ty)>  { 
#line 703
}; 
#line 707 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
template< class _Ty> 
#line 708
struct has_trivial_assign : public _Cat_base< is_pod< _Ty> ::value || __has_trivial_assign(_Ty)>  { 
#line 710
}; 
#line 713
template< class _Ty> 
#line 714
struct has_trivial_destructor : public _Cat_base< (!is_void< _Ty> ::value) && (is_pod< _Ty> ::value || __has_trivial_destructor(_Ty))>  { 
#line 716
}; 
#line 719
template< class _Ty> 
#line 720
struct has_nothrow_constructor : public _Cat_base< is_pod< _Ty> ::value || __has_nothrow_constructor(_Ty)>  { 
#line 722
}; 
#line 725
template< class _Ty> 
#line 726
struct has_nothrow_copy : public _Cat_base< is_pod< _Ty> ::value || __has_nothrow_copy(_Ty)>  { 
#line 728
}; 
#line 732
template< class _Ty> 
#line 733
struct has_nothrow_default_constructor : public _Cat_base< is_pod< _Ty> ::value || __has_nothrow_constructor(_Ty)>  { 
#line 735
}; 
#line 738
template< class _Ty> 
#line 739
struct has_nothrow_copy_constructor : public _Cat_base< is_pod< _Ty> ::value || __has_nothrow_copy(_Ty)>  { 
#line 741
}; 
#line 745 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
template< class _Ty> 
#line 746
struct has_nothrow_assign : public _Cat_base< is_pod< _Ty> ::value || __has_nothrow_assign(_Ty)>  { 
#line 748
}; 
#line 751
template< class _Ty> 
#line 752
struct has_virtual_destructor : public _Cat_base< __has_virtual_destructor(_Ty)>  { 
#line 754
}; 
#line 757
template< class _Ty> 
#line 758
struct _Has_signed_vals : public _Cat_base< (((typename remove_cv< _Ty> ::type)((-1))) < ((typename remove_cv< _Ty> ::type)(0)))>  { 
#line 762
}; 
#line 764
template< class _Ty> 
#line 765
struct is_signed : public _Cat_base< is_floating_point< _Ty> ::value || (is_integral< _Ty> ::value && _Has_signed_vals< typename _If< is_integral< _Ty> ::value, _Ty, int> ::_Type> ::value)>  { 
#line 770
}; 
#line 773
template< class _Ty> 
#line 774
struct is_unsigned : public _Cat_base< is_integral< _Ty> ::value && (!_Has_signed_vals< typename _If< is_integral< _Ty> ::value, _Ty, int> ::_Type> ::value)>  { 
#line 779
}; 
#line 782
template< class _Ty> 
#line 783
struct make_signed { 
#line 785
static const size_t _Bytes = sizeof(_Ty); 
#line 793
typedef typename _If< is_signed< _Ty> ::value, _Ty, typename _If< sizeof(_Ty) <= sizeof(char), signed char, typename _If< sizeof(_Ty) <= sizeof(short), short, typename _If< sizeof(_Ty) <= sizeof(int), int, typename _If< sizeof(_Ty) <= sizeof(long), long, __int64> ::_Type> ::_Type> ::_Type> ::_Type> ::_Type type; 
#line 794
}; 
#line 797
template< class _Ty> 
#line 798
struct make_unsigned { 
#line 800
static const size_t _Bytes = sizeof(_Ty); 
#line 808
typedef typename _If< is_unsigned< _Ty> ::value, _Ty, typename _If< sizeof(_Ty) <= sizeof(char), unsigned char, typename _If< sizeof(_Ty) <= sizeof(short), unsigned short, typename _If< sizeof(_Ty) <= sizeof(int), unsigned, typename _If< sizeof(_Ty) <= sizeof(long), unsigned long, unsigned __int64> ::_Type> ::_Type> ::_Type> ::_Type> ::_Type type; 
#line 809
}; 
#line 812
template< class _Ty> 
#line 813
struct _Get_align { 
#line 815
_Ty _Elt0; 
#line 816
char _Elt1; 
#line 817
_Ty _Elt2; 
#line 818
}; 
#line 822
template< class _Ty> 
#line 823
struct alignment_of : public integral_constant< unsigned __int64, sizeof(_Get_align< _Ty> ) - (2Ui64 * sizeof(_Ty))>  { 
#line 826
}; 
#line 828
template< class _Ty> 
#line 829
struct alignment_of< _Ty &>  : public integral_constant< unsigned __int64, sizeof(_Get_align< _Ty *> ) - (2Ui64 * sizeof(_Ty *))>  { 
#line 832
}; 
#line 839
template< class _Ty, size_t _Len> union _Align_type { 
#line 841
_Ty _Val; 
#line 842
char _Pad[_Len]; 
#line 843
}; 
#line 845
template< size_t _Len, size_t _Align, class _Ty, bool _Ok> struct _Aligned; 
#line 848
template< size_t _Len, size_t _Align, class _Ty> 
#line 849
struct _Aligned< _Len, _Align, _Ty, true>  { 
#line 851
typedef _Align_type< _Ty, _Len>  _Type; 
#line 852
}; 
#line 854
template< size_t _Len, size_t _Align> 
#line 855
struct _Aligned< _Len, _Align, long, false>  { 
#line 857
typedef _Align_type< double, _Len>  _Type; 
#line 858
}; 
#line 860
template< size_t _Len, size_t _Align> 
#line 861
struct _Aligned< _Len, _Align, int, false>  { 
#line 863
typedef typename tr1::_Aligned< _Len, _Align, long, _Align == 4Ui64> ::_Type _Type; 
#line 864
}; 
#line 866
template< size_t _Len, size_t _Align> 
#line 867
struct _Aligned< _Len, _Align, short, false>  { 
#line 869
typedef typename tr1::_Aligned< _Len, _Align, int, _Align == 4Ui64> ::_Type _Type; 
#line 870
}; 
#line 872
template< size_t _Len, size_t _Align> 
#line 873
struct _Aligned< _Len, _Align, char, false>  { 
#line 875
typedef typename tr1::_Aligned< _Len, _Align, short, _Align == 2Ui64> ::_Type _Type; 
#line 876
}; 
#line 878
template< size_t _Len, size_t _Align> 
#line 879
struct aligned_storage { 
#line 881
typedef typename _Aligned< _Len, _Align, char, _Align == 1Ui64> ::_Type type; 
#line 882
}; 
#line 889
template< class _Ty> 
#line 890
struct rank : public integral_constant< unsigned __int64, 0Ui64>  { 
#line 893
}; 
#line 895
template< class _Ty, unsigned _Ix> 
#line 896
struct rank< _Ty [_Ix]>  : public integral_constant< unsigned __int64, rank< _Ty> ::value + 1>  { 
#line 899
}; 
#line 901
template< class _Ty> 
#line 902
struct rank< _Ty []>  : public integral_constant< unsigned __int64, rank< _Ty> ::value + 1>  { 
#line 905
}; 
#line 908
template< class _Ty, unsigned _Nx> 
#line 909
struct _Extent : public integral_constant< unsigned __int64, 0Ui64>  { 
#line 912
}; 
#line 914
template< class _Ty, unsigned _Ix> 
#line 915
struct _Extent< _Ty [_Ix], 0>  : public integral_constant< unsigned __int64, _Ix>  { 
#line 918
}; 
#line 920
template< class _Ty, unsigned _Nx, unsigned _Ix> 
#line 921
struct _Extent< _Ty [_Ix], _Nx>  : public _Extent< _Ty, _Nx - 1U>  { 
#line 924
}; 
#line 926
template< class _Ty, unsigned _Nx> 
#line 927
struct _Extent< _Ty [], _Nx>  : public _Extent< _Ty, _Nx - 1U>  { 
#line 930
}; 
#line 932
template< class _Ty, unsigned _Nx = 0U> 
#line 933
struct extent : public _Extent< _Ty, _Nx>  { 
#line 936
}; 
#line 939
template< class _Ty1, class _Ty2> 
#line 940
struct is_same : public false_type { 
#line 943
}; 
#line 945
template< class _Ty1> 
#line 946
struct is_same< _Ty1, _Ty1>  : public true_type { 
#line 949
}; 
#line 952
template< class _Base, class _Der> 
#line 953
struct is_base_of : public _Cat_base< __is_base_of(_Base, _Der)>  { 
#line 955
}; 
#line 959
template< class _Ty> 
#line 960
struct decay { 
#line 962
typedef typename remove_reference< _Ty> ::type _Ty1; 
#line 968
typedef typename _If< is_array< typename remove_reference< _Ty> ::type> ::value, typename remove_extent< typename remove_reference< _Ty> ::type> ::type *, typename _If< is_function< typename remove_reference< _Ty> ::type> ::value, typename add_pointer< typename remove_reference< _Ty> ::type> ::type, typename remove_cv< typename remove_reference< _Ty> ::type> ::type> ::_Type> ::_Type type; 
#line 969
}; 
#line 972
template< bool _Test, class 
#line 973
_Type = void> 
#line 974
struct enable_if { 
#line 976
}; 
#line 978
template< class _Type> 
#line 979
struct enable_if< true, _Type>  { 
#line 981
typedef _Type type; 
#line 982
}; 
#line 985
template< bool _Test, class 
#line 986
_Ty1, class 
#line 987
_Ty2> 
#line 988
struct conditional { 
#line 990
typedef _Ty2 type; 
#line 991
}; 
#line 993
template< class _Ty1, class 
#line 994
_Ty2> 
#line 995
struct conditional< true, _Ty1, _Ty2>  { 
#line 997
typedef _Ty1 type; 
#line 998
}; 
#line 1000
}
#line 1003
using tr1::add_const;
#line 1004
using tr1::add_cv;
#line 1005
using tr1::add_pointer;
#line 1006
using tr1::add_lvalue_reference;
#line 1007
using tr1::add_reference;
#line 1008
using tr1::add_rvalue_reference;
#line 1009
using tr1::add_volatile;
#line 1010
using tr1::aligned_storage;
#line 1011
using tr1::alignment_of;
#line 1012
using tr1::conditional;
#line 1013
using tr1::decay;
#line 1014
using tr1::enable_if;
#line 1015
using tr1::extent;
#line 1016
using tr1::false_type;
#line 1017
using tr1::has_nothrow_assign;
#line 1018
using tr1::has_nothrow_constructor;
#line 1019
using tr1::has_nothrow_copy;
#line 1020
using tr1::has_nothrow_copy_constructor;
#line 1021
using tr1::has_nothrow_default_constructor;
#line 1022
using tr1::has_trivial_assign;
#line 1023
using tr1::has_trivial_constructor;
#line 1024
using tr1::has_trivial_copy;
#line 1025
using tr1::has_trivial_copy_constructor;
#line 1026
using tr1::has_trivial_default_constructor;
#line 1027
using tr1::has_trivial_destructor;
#line 1028
using tr1::has_virtual_destructor;
#line 1029
using tr1::integral_constant;
#line 1030
using tr1::is_abstract;
#line 1031
using tr1::is_arithmetic;
#line 1032
using tr1::is_array;
#line 1033
using tr1::is_base_of;
#line 1034
using tr1::is_class;
#line 1035
using tr1::is_compound;
#line 1036
using tr1::is_const;
#line 1037
using tr1::is_convertible;
#line 1038
using tr1::is_empty;
#line 1039
using tr1::is_enum;
#line 1040
using tr1::is_floating_point;
#line 1041
using tr1::is_function;
#line 1042
using tr1::is_fundamental;
#line 1043
using tr1::is_integral;
#line 1044
using tr1::is_lvalue_reference;
#line 1045
using tr1::is_member_function_pointer;
#line 1046
using tr1::is_member_object_pointer;
#line 1047
using tr1::is_member_pointer;
#line 1048
using tr1::is_object;
#line 1049
using tr1::is_pod;
#line 1050
using tr1::is_pointer;
#line 1051
using tr1::is_polymorphic;
#line 1052
using tr1::is_reference;
#line 1053
using tr1::is_rvalue_reference;
#line 1054
using tr1::is_same;
#line 1055
using tr1::is_scalar;
#line 1056
using tr1::is_signed;
#line 1057
using tr1::is_standard_layout;
#line 1058
using tr1::is_trivial;
#line 1059
using tr1::is_union;
#line 1060
using tr1::is_unsigned;
#line 1061
using tr1::is_void;
#line 1062
using tr1::is_volatile;
#line 1063
using tr1::make_signed;
#line 1064
using tr1::make_unsigned;
#line 1065
using tr1::rank;
#line 1066
using tr1::remove_all_extents;
#line 1067
using tr1::remove_const;
#line 1068
using tr1::remove_cv;
#line 1069
using tr1::remove_extent;
#line 1070
using tr1::remove_pointer;
#line 1071
using tr1::remove_reference;
#line 1072
using tr1::_Remove_rvalue_reference;
#line 1073
using tr1::remove_volatile;
#line 1074
using tr1::true_type;
#line 1079 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
template< class _Ty> struct _Arithmetic_traits; 
#line 1083
template<> struct _Arithmetic_traits< bool>  { 
#line 1085
static const int _Rank = 1; 
#line 1086
}; 
#line 1089
template<> struct _Arithmetic_traits< char>  { 
#line 1091
static const int _Rank = (std::_Arithmetic_traits< bool> ::_Rank + 1); 
#line 1092
}; 
#line 1095
template<> struct _Arithmetic_traits< signed char>  { 
#line 1097
static const int _Rank = std::_Arithmetic_traits< char> ::_Rank; 
#line 1098
}; 
#line 1101
template<> struct _Arithmetic_traits< unsigned char>  { 
#line 1103
static const int _Rank = std::_Arithmetic_traits< char> ::_Rank; 
#line 1104
}; 
#line 1107
template<> struct _Arithmetic_traits< short>  { 
#line 1109
static const int _Rank = (std::_Arithmetic_traits< char> ::_Rank + 1); 
#line 1110
}; 
#line 1113
template<> struct _Arithmetic_traits< unsigned short>  { 
#line 1115
static const int _Rank = std::_Arithmetic_traits< short> ::_Rank; 
#line 1116
}; 
#line 1119
template<> struct _Arithmetic_traits< int>  { 
#line 1121
static const int _Rank = (std::_Arithmetic_traits< short> ::_Rank + 1); 
#line 1122
}; 
#line 1125
template<> struct _Arithmetic_traits< unsigned>  { 
#line 1127
static const int _Rank = std::_Arithmetic_traits< int> ::_Rank; 
#line 1128
}; 
#line 1131
template<> struct _Arithmetic_traits< long>  { 
#line 1133
static const int _Rank = (std::_Arithmetic_traits< int> ::_Rank + 1); 
#line 1134
}; 
#line 1137
template<> struct _Arithmetic_traits< unsigned long>  { 
#line 1139
static const int _Rank = std::_Arithmetic_traits< long> ::_Rank; 
#line 1140
}; 
#line 1143
template<> struct _Arithmetic_traits< __int64>  { 
#line 1145
static const int _Rank = (std::_Arithmetic_traits< long> ::_Rank + 1); 
#line 1146
}; 
#line 1149
template<> struct _Arithmetic_traits< unsigned __int64>  { 
#line 1151
static const int _Rank = std::_Arithmetic_traits< __int64> ::_Rank; 
#line 1152
}; 
#line 1155
template<> struct _Arithmetic_traits< float>  { 
#line 1157
static const int _Rank = (std::_Arithmetic_traits< __int64> ::_Rank + 1); 
#line 1158
}; 
#line 1161
template<> struct _Arithmetic_traits< double>  { 
#line 1163
static const int _Rank = (std::_Arithmetic_traits< float> ::_Rank + 1); 
#line 1164
}; 
#line 1167
template<> struct _Arithmetic_traits< long double>  { 
#line 1169
static const int _Rank = (std::_Arithmetic_traits< double> ::_Rank + 1); 
#line 1170
}; 
#line 1172
template< bool _Unsigned> struct _Pickinteger { 
#line 1174
typedef int _Type; 
#line 1175
}; 
#line 1178
template<> struct _Pickinteger< true>  { 
#line 1180
typedef unsigned _Type; 
#line 1181
}; 
#line 1183
template< class _Ty, bool 
#line 1184
_Small> struct _Promote_to_int; 
#line 1187
template< class _Ty> 
#line 1188
struct _Promote_to_int< _Ty, true>  { 
#line 1190
typedef int _Type; 
#line 1191
}; 
#line 1193
template< class _Ty> 
#line 1194
struct _Promote_to_int< _Ty, false>  { 
#line 1196
typedef typename _Pickinteger< tr1::is_unsigned< _Ty> ::value> ::_Type _Type; 
#line 1197
}; 
#line 1199
template< class _Ty, bool 
#line 1200
_Small> struct _Maybepromote; 
#line 1203
template< class _Ty> 
#line 1204
struct _Maybepromote< _Ty, false>  { 
#line 1206
typedef _Ty _Type; 
#line 1207
}; 
#line 1209
template< class _Ty> 
#line 1210
struct _Maybepromote< _Ty, true>  { 
#line 1213
typedef typename _Promote_to_int< _Ty, ((sizeof(_Ty)) < sizeof(int))> ::_Type _Type; 
#line 1214
}; 
#line 1216
template< class _Ty> 
#line 1217
struct _Ipromo { 
#line 1219
static const bool _Lessthan = (_Arithmetic_traits< _Ty> ::_Rank < _Arithmetic_traits< int> ::_Rank); 
#line 1221
typedef typename _Maybepromote< _Ty, ((_Arithmetic_traits< _Ty> ::_Rank) < _Arithmetic_traits< int> ::_Rank)> ::_Type _Type; 
#line 1222
}; 
#line 1224
template< class _Ty0, class 
#line 1225
_Ty1, bool 
#line 1226
_Second> 
#line 1227
struct _Common_typeX { 
#line 1229
typedef _Ty1 _Type; 
#line 1230
}; 
#line 1232
template< class _Ty0, class 
#line 1233
_Ty1> 
#line 1234
struct _Common_typeX< _Ty0, _Ty1, false>  { 
#line 1236
typedef _Ty0 _Type; 
#line 1237
}; 
#line 1239
template< class _Ty0, class 
#line 1240
_Ty1, bool 
#line 1241
_Uns0, bool 
#line 1242
_Uns1> 
#line 1243
struct _Common_typeY { 
#line 1245
typedef _Ty0 _Type; 
#line 1246
}; 
#line 1248
template< class _Ty0, class 
#line 1249
_Ty1> 
#line 1250
struct _Common_typeY< _Ty0, _Ty1, false, true>  { 
#line 1252
typedef _Ty1 _Type; 
#line 1253
}; 
#line 1255
template< class _Ty0, class 
#line 1256
_Ty1, int 
#line 1257
_Rank0, int 
#line 1258
_Rank1> 
#line 1259
struct _Common_type { 
#line 1261
typedef typename _Common_typeX< _Ty0, _Ty1, ((_Rank0) < _Rank1)> ::_Type _Type; 
#line 1262
}; 
#line 1264
template< class _Ty0, class 
#line 1265
_Ty1, int 
#line 1266
_Rank> 
#line 1267
struct _Common_type< _Ty0, _Ty1, _Rank, _Rank>  { 
#line 1271
typedef typename _Common_typeY< _Ty0, _Ty1, tr1::is_unsigned< _Ty0> ::value, tr1::is_unsigned< _Ty1> ::value> ::_Type _Type; 
#line 1272
}; 
#line 1274
template< class _Ty0, class 
#line 1275
_Ty1> 
#line 1276
struct common_type { 
#line 1278
typedef typename _Ipromo< _Ty0> ::_Type _PromoTy0; 
#line 1279
typedef typename _Ipromo< _Ty1> ::_Type _PromoTy1; 
#line 1282
typedef typename _Common_type< typename _Ipromo< _Ty0> ::_Type, typename _Ipromo< _Ty1> ::_Type, _Arithmetic_traits< typename _Ipromo< _Ty0> ::_Type> ::_Rank, _Arithmetic_traits< typename _Ipromo< _Ty1> ::_Type> ::_Rank> ::_Type type; 
#line 1283
}; 
#line 1286 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
}
#pragma warning(pop)
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\utility"
#pragma warning(push,3)
#line 14
#pragma warning(disable: 4180 4512)
#line 1288 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\type_traits"
#pragma pack ( pop )
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\utility"
#pragma pack ( push, 8 )
#line 16
namespace std { 
#line 17
namespace tr1 { 
#line 19
template < class _Type >
 class reference_wrapper;
#line 23
template< class _Type> 
#line 24
struct _Unrefwrap { 
#line 26
typedef typename decay< _Type> ::type type; 
#line 27
}; 
#line 29
template< class _Type> 
#line 30
struct _Unrefwrap< reference_wrapper< _Type> >  { 
#line 32
typedef _Type &type; 
#line 33
}; 
#line 35
template< class _Type> 
#line 36
struct _Unrefwrap< const reference_wrapper< _Type> >  { 
#line 38
typedef _Type &type; 
#line 39
}; 
#line 41
template< class _Type> 
#line 42
struct _Unrefwrap< volatile reference_wrapper< _Type> >  { 
#line 44
typedef _Type &type; 
#line 45
}; 
#line 47
template< class _Type> 
#line 48
struct _Unrefwrap< const volatile reference_wrapper< _Type> >  { 
#line 50
typedef _Type &type; 
#line 51
}; 
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\utility"
}
#line 61
using tr1::_Unrefwrap;
#line 64
template < class _Ty >
 struct identity
 {
 typedef _Ty type;

 const _Ty & operator ( ) ( const _Ty & _Left ) const
  {
  return ( _Left );
  }
 };
#line 76
template < class _Ty > inline
 _Ty && forward ( typename identity < _Ty > :: type & _Arg )
 {
 return ( ( _Ty && ) _Arg );
 }
#line 83
template < class _Ty > inline
 typename tr1 :: _Remove_reference < _Ty > :: _Type &&
  move ( _Ty && _Arg )
 {
 return ( ( typename tr1 :: _Remove_reference < _Ty > :: _Type && ) _Arg );
 }
#line 91
template < class _Ty > inline
 typename tr1 :: _Remove_reference < _Ty > :: _Type &&
  _Move ( _Ty && _Arg )
 {
 return ( ( typename tr1 :: _Remove_reference < _Ty > :: _Type && ) _Arg );
 }
#line 99
template < class _Ty > inline
 void swap ( _Ty & _Left, _Ty & _Right )
 {
 _Ty _Tmp = _Move ( _Left );
 _Left = _Move ( _Right );
 _Right = _Move ( _Tmp );
 }
#line 108
template < class _Ty > inline
 void _Swap_adl ( _Ty & _Left, _Ty & _Right )
 {
 swap ( _Left, _Right );
 }
#line 116
template < class _Ty1,
 class _Ty2 >
 struct _Pair_base
 {
 typedef _Pair_base < _Ty1, _Ty2 > _Myt;
 typedef _Ty1 first_type;
 typedef _Ty2 second_type;

 _Pair_base ( )
  : first ( _Ty1 ( ) ), second ( _Ty2 ( ) )
  {
  }

 _Pair_base ( const _Pair_base < _Ty1, _Ty2 > & _Right )
  : first ( _Right . first ), second ( _Right . second )
  {
  }

 _Pair_base ( const _Ty1 & _Val1, const _Ty2 & _Val2 )
  : first ( _Val1 ), second ( _Val2 )
  {
  }

 typedef typename tr1 :: remove_reference < _Ty1 > :: type _Ty1x;
 typedef typename tr1 :: remove_reference < _Ty2 > :: type _Ty2x;

 _Pair_base ( _Ty1x && _Val1, _Ty2x && _Val2 )
  : first ( :: std :: move ( _Val1 ) ),
   second ( :: std :: move ( _Val2 ) )
  {
  }

 _Pair_base ( const _Ty1x & _Val1, _Ty2x && _Val2 )
  : first ( _Val1 ), second ( :: std :: move ( _Val2 ) )
  {
  }

 _Pair_base ( _Ty1x && _Val1, const _Ty2x & _Val2 )
  : first ( :: std :: move ( _Val1 ) ), second ( _Val2 )
  {
  }

 template < class _Other1,
  class _Other2 >
  _Pair_base ( _Other1 && _Val1, _Other2 && _Val2 )
  : first ( :: std :: forward < _Other1 > ( _Val1 ) ),
   second ( :: std :: forward < _Other2 > ( _Val2 ) )
  {
  }

 _Ty1 first;
 _Ty2 second;
 };
#line 170
template < class _Ty1,
 class _Ty2 >
 struct pair
  : public _Pair_base < _Ty1, _Ty2 >
 {
 typedef _Pair_base < _Ty1, _Ty2 > _Mybase;

 typedef pair < _Ty1, _Ty2 > _Myt;
 typedef _Ty1 first_type;
 typedef _Ty2 second_type;

 pair ( )
  : _Mybase ( )
  {
  }

 pair ( const _Ty1 & _Val1, const _Ty2 & _Val2 )
  : _Mybase ( _Val1, _Val2 )
  {
  }

 template < class _Other1,
  class _Other2 >
  pair ( pair < _Other1, _Other2 > & _Right )
  : _Mybase ( _Right . first, _Right . second )
  {
  }

 template < class _Other1,
  class _Other2 >
  pair ( const pair < _Other1, _Other2 > & _Right )
  : _Mybase ( _Right . first, _Right . second )
  {
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Swap_adl ( this -> first, _Right . first );
   _Swap_adl ( this -> second, _Right . second );
   }
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  this -> first = _Right . first;
  this -> second = _Right . second;
  return ( * this );
  }

 typedef typename tr1 :: remove_reference < _Ty1 > :: type _Ty1x;
 typedef typename tr1 :: remove_reference < _Ty2 > :: type _Ty2x;

 pair ( _Ty1x && _Val1, _Ty2x && _Val2 )
  : _Mybase ( :: std :: move ( _Val1 ),
   :: std :: move ( _Val2 ) )
  {
  }

 pair ( const _Ty1x & _Val1, _Ty2x && _Val2 )
  : _Mybase ( _Val1,
   :: std :: move ( _Val2 ) )
  {
  }

 pair ( _Ty1x && _Val1, const _Ty2x & _Val2 )
  : _Mybase ( :: std :: move ( _Val1 ),
   _Val2 )
  {
  }

 template < class _Other1,
  class _Other2 >
  pair ( _Other1 && _Val1, _Other2 && _Val2 )
  : _Mybase ( :: std :: forward < _Other1 > ( _Val1 ),
   :: std :: forward < _Other2 > ( _Val2 ) )
  {
  }

 template < class _Other1,
  class _Other2 >
  pair ( pair < _Other1, _Other2 > && _Right )
  : _Mybase ( :: std :: forward < _Other1 > ( _Right . first ),
   :: std :: forward < _Other2 > ( _Right . second ) )
  {
  }

 pair & operator = ( pair < _Ty1, _Ty2 > && _Right )
  {
  this -> first = :: std :: move ( _Right . first );
  this -> second = :: std :: move ( _Right . second );
  return ( * this );
  }

 void swap ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   this -> first = :: std :: move ( _Right . first );
   this -> second = :: std :: move ( _Right . second );
   }
  }
 };
#line 277
template < class _Ty1,
 class _Ty2 > inline
 void swap ( pair < _Ty1, _Ty2 > & _Left, pair < _Ty1, _Ty2 > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 284
template < class _Ty1,
 class _Ty2 > inline
 void swap ( pair < _Ty1, _Ty2 > & _Left, pair < _Ty1, _Ty2 > && _Right )
 {
 typedef pair < _Ty1, _Ty2 > _Myt;
 _Left . swap ( :: std :: forward < _Myt > ( _Right ) );
 }
#line 292
template < class _Ty1,
 class _Ty2 > inline
 void swap ( pair < _Ty1, _Ty2 > && _Left, pair < _Ty1, _Ty2 > & _Right )
 {
 typedef pair < _Ty1, _Ty2 > _Myt;
 _Right . swap ( :: std :: forward < _Myt > ( _Left ) );
 }
#line 300
template < class _Ty1,
 class _Ty2 > inline
 bool operator == ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Left . first == _Right . first && _Left . second == _Right . second );
 }
#line 308
template < class _Ty1,
 class _Ty2 > inline
 bool operator != ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 316
template < class _Ty1,
 class _Ty2 > inline
 bool operator < ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Left . first < _Right . first ||
  ! ( _Right . first < _Left . first ) && _Left . second < _Right . second );
 }
#line 325
template < class _Ty1,
 class _Ty2 > inline
 bool operator > ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 333
template < class _Ty1,
 class _Ty2 > inline
 bool operator <= ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 341
template < class _Ty1,
 class _Ty2 > inline
 bool operator >= ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 351
template < class _Ty1,
 class _Ty2 > inline
 pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type >
  make_pair ( _Ty1 && _Val1, _Ty2 && _Val2 )
 {
 typedef pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type > _Mypair;
 return ( _Mypair ( :: std :: forward < _Ty1 > ( _Val1 ),
  :: std :: forward < _Ty2 > ( _Val2 ) ) );
 }
#line 363
template < class _Ty1,
 class _Ty2 > inline
 pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type >
  make_pair ( const _Ty1 & _Val1, _Ty2 && _Val2 )
 {
 typedef pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type > _Mypair;
 return ( _Mypair ( ( typename _Unrefwrap < _Ty1 > :: type ) _Val1,
  :: std :: forward < _Ty2 > ( _Val2 ) ) );
 }
#line 375
template < class _Ty1,
 class _Ty2 > inline
 pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type >
  make_pair ( _Ty1 && _Val1, const _Ty2 & _Val2 )
 {
 typedef pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type > _Mypair;
 return ( _Mypair ( :: std :: forward < _Ty1 > ( _Val1 ),
  ( typename _Unrefwrap < _Ty2 > :: type ) _Val2 ) );
 }
#line 387
template < class _Ty1,
 class _Ty2 > inline
 pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type >
  make_pair ( const _Ty1 & _Val1, const _Ty2 & _Val2 )
 {
 typedef pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type > _Mypair;
 return ( _Mypair ( ( typename _Unrefwrap < _Ty1 > :: type ) _Val1,
  ( typename _Unrefwrap < _Ty2 > :: type ) _Val2 ) );
 }
#line 400
template < class _InIt > inline
 _InIt begin ( const pair < _InIt, _InIt > & _Pair )
 {
 return ( _Pair . first );
 }
#line 406
template < class _InIt > inline
 _InIt end ( const pair < _InIt, _InIt > & _Pair )
 {
 return ( _Pair . second );
 }
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\utility"
namespace rel_ops { 
#line 416
template < class _Ty > inline
 bool operator != ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 422
template < class _Ty > inline
 bool operator > ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( _Right < _Left );
 }
#line 428
template < class _Ty > inline
 bool operator <= ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 434
template < class _Ty > inline
 bool operator >= ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 439
}
#line 440
}
#line 443
namespace std { 
#line 444
namespace tr1 { 
#line 446
template< class _Tuple> struct tuple_size; 
#line 448
template< size_t _Idx, class 
#line 449
_Tuple> struct tuple_element; 
#line 451
template< class _Ty1, class 
#line 452
_Ty2> 
#line 453
struct tuple_size< pair< _Ty1, _Ty2> >  { 
#line 455
static const int value = 2; 
#line 456
}; 
#line 458
template< int _Idx, class 
#line 459
_Ty> struct _Pair_data; 
#line 461
template < class _Ty1,
 class _Ty2 >
 struct _Pair_data < 0, :: std :: pair < _Ty1, _Ty2 > >
 {
 typedef _Ty1 & _Type;
 typedef const _Ty1 & _CType;

 static _Type _Val ( :: std :: pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . first );
  }

 static _CType _Val ( const :: std :: pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . first );
  }
 };
#line 479
template < class _Ty1,
 class _Ty2 >
 struct _Pair_data < 1, :: std :: pair < _Ty1, _Ty2 > >
 {
 typedef _Ty2 & _Type;
 typedef const _Ty2 & _CType;

 static _Type _Val ( :: std :: pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . second );
  }

 static _CType _Val ( const :: std :: pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . second );
  }
 };
#line 497
template< class _Ty1, class 
#line 498
_Ty2> 
#line 499
struct tuple_element< 0, pair< _Ty1, _Ty2> >  { 
#line 501
typedef _Ty1 type; 
#line 502
}; 
#line 504
template< class _Ty1, class 
#line 505
_Ty2> 
#line 506
struct tuple_element< 1, pair< _Ty1, _Ty2> >  { 
#line 508
typedef _Ty2 type; 
#line 509
}; 
#line 511
template < int _Idx,
 class _Ty1,
 class _Ty2 >
 typename _Pair_data < _Idx, :: std :: pair < _Ty1, _Ty2 > > :: _Type
  get ( :: std :: pair < _Ty1, _Ty2 > & _Pr )
 {
 return ( _Pair_data < _Idx, :: std :: pair < _Ty1, _Ty2 > > :: _Val ( _Pr ) );
 }
#line 520
template < int _Idx,
 class _Ty1,
 class _Ty2 >
 typename _Pair_data < _Idx, :: std :: pair < _Ty1, _Ty2 > > :: _CType
  get ( const :: std :: pair < _Ty1, _Ty2 > & _Pr )
 {
 return ( _Pair_data < _Idx, :: std :: pair < _Ty1, _Ty2 > > :: _Val ( _Pr ) );
 }
#line 528
}
#line 529
}
#line 533 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\utility"
namespace std { 
#line 534
using tr1::get;
#line 535
using tr1::tuple_element;
#line 536
using tr1::tuple_size;
#line 537
}
#line 540 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\utility"
#pragma warning(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
#pragma warning(push,3)
#line 541 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\utility"
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
struct __declspec(dllimport) _Container_base0 { 
#line 36
void _Orphan_all() 
#line 37
{ 
#line 38
} 
#line 40
void _Swap_all(_Container_base0 &) 
#line 41
{ 
#line 42
} 
#line 43
}; 
#line 45
struct _Iterator_base0 { 
#line 47
void _Adopt(const void *) 
#line 48
{ 
#line 49
} 
#line 51
const _Container_base0 *_Getcont() const 
#line 52
{ 
#line 53
return 0; 
#line 54
} 
#line 55
}; 
#line 57
struct _Container_base12; 
#line 58
struct _Iterator_base12; 
#line 61
struct _Container_proxy { 
#line 63
_Container_proxy() : _Mycont(0), _Myfirstiter(0) 
#line 65
{ 
#line 66
} 
#line 68
const _Container_base12 *_Mycont; 
#line 69
_Iterator_base12 *_Myfirstiter; 
#line 70
}; 
#line 72
struct __declspec(dllimport) _Container_base12 { 
#line 75
_Container_base12() : _Myproxy(0) 
#line 77
{ 
#line 78
} 
#line 80
_Container_base12(const _Container_base12 &) : _Myproxy(0) 
#line 82
{ 
#line 83
} 
#line 85
_Container_base12 &operator=(const _Container_base12 &) 
#line 86
{ 
#line 87
return *this; 
#line 88
} 
#line 90
~_Container_base12() 
#line 91
{ 
#line 92
this->_Orphan_all(); 
#line 93
} 
#line 95
_Iterator_base12 **_Getpfirst() const 
#line 96
{ 
#line 97
return ((_Myproxy) == (0)) ? (0) : (&((_Myproxy)->_Myfirstiter)); 
#line 98
} 
#line 100
inline void _Orphan_all(); 
#line 101
inline void _Swap_all(_Container_base12 &); 
#line 103
_Container_proxy *_Myproxy; 
#line 104
}; 
#line 106
struct _Iterator_base12 { 
#line 109
_Iterator_base12() : _Myproxy(0), _Mynextiter(0) 
#line 111
{ 
#line 112
} 
#line 114
_Iterator_base12(const _Iterator_base12 &_Right) : _Myproxy(0), _Mynextiter(0) 
#line 116
{ 
#line 117
((*this) = _Right); 
#line 118
} 
#line 120
_Iterator_base12 &operator=(const _Iterator_base12 &_Right) 
#line 121
{ 
#line 122
if ((_Myproxy) != (_Right._Myproxy)) { 
#line 123
this->_Adopt((_Right._Myproxy)->_Mycont); }  
#line 124
return *this; 
#line 125
} 
#line 127
~_Iterator_base12() 
#line 128
{ 
#line 133 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
} 
#line 135
void _Adopt(const _Container_base12 *_Parent) 
#line 136
{ 
#line 137
if (_Parent != (0)) 
#line 138
{ 
#line 139
_Container_proxy *_Parent_proxy = _Parent->_Myproxy; 
#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
(_Myproxy) = _Parent_proxy; 
#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
}  
#line 154
} 
#line 156
void _Clrcont() 
#line 157
{ 
#line 158
(_Myproxy) = (0); 
#line 159
} 
#line 161
const _Container_base12 *_Getcont() const 
#line 162
{ 
#line 163
return ((_Myproxy) == (0)) ? (0) : ((_Myproxy)->_Mycont); 
#line 164
} 
#line 166
_Iterator_base12 **_Getpnext() 
#line 167
{ 
#line 168
return &(_Mynextiter); 
#line 169
} 
#line 171
void _Orphan_me() 
#line 172
{ 
#line 186 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
} 
#line 188
_Container_proxy *_Myproxy; 
#line 189
_Iterator_base12 *_Mynextiter; 
#line 190
}; 
#line 193
inline void _Container_base12::_Orphan_all() 
#line 194
{ 
#line 206 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
} 
#line 208
inline void _Container_base12::_Swap_all(_Container_base12 &_Right) 
#line 209
{ 
#line 214 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
_Container_proxy *_Temp = _Myproxy; 
#line 215
(_Myproxy) = (_Right._Myproxy); 
#line 216
(_Right._Myproxy) = _Temp; 
#line 218
if ((_Myproxy) != (0)) { 
#line 219
((_Myproxy)->_Mycont) = ((_Container_base12 *)this); }  
#line 220
if ((_Right._Myproxy) != (0)) { 
#line 221
((_Right._Myproxy)->_Mycont) = ((_Container_base12 *)(&_Right)); }  
#line 222
} 
#line 225
typedef _Container_base0 _Container_base; 
#line 226
typedef _Iterator_base0 _Iterator_base; 
#line 237 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
tr1::_No _Has_unchecked_type(...); 
#line 239
template< class _Ty> tr1::_Yes _Has_unchecked_type(_Ty *, typename _Ty::_Unchecked_type * = 0); 
#line 243
template< class _Iter, bool 
#line 244
__T1> 
#line 245
struct _Unchecked_helper { 
#line 247
typedef _Iter type; 
#line 248
}; 
#line 250
template< class _Iter> 
#line 251
struct _Unchecked_helper< _Iter, true>  { 
#line 253
typedef typename _Iter::_Unchecked_type type; 
#line 254
}; 
#line 256
template< class _Iter> 
#line 257
struct _Get_unchecked_type { 
#line 260
typedef typename _Unchecked_helper< _Iter, sizeof(_Has_unchecked_type((_Iter *)0)) == sizeof(char [2])> ::type type; 
#line 261
}; 
#line 264
template < class _Iter > inline
 _Iter _Unchecked ( _Iter _Src )
 {
 return ( _Src );
 }
#line 271
template < class _Iter,
 class _UIter > inline
 _Iter & _Rechecked ( _Iter & _Dest, _UIter _Src )
 {
 _Dest = _Src;
 return ( _Dest );
 }
#line 280
template< class _Iter> 
#line 281
struct _Is_checked_helper : public tr1::integral_constant< bool, sizeof(_Has_unchecked_type((_Iter *)0)) == sizeof(char [2])>  { 
#line 284
}; 
#line 287
template < class _Iter > inline
 _Is_checked_helper < _Iter > _Is_checked ( _Iter )
 {
 return ( _Is_checked_helper < _Iter > ( ) );
 }
#line 295
struct input_iterator_tag { 
#line 297
}; 
#line 299
struct output_iterator_tag { 
#line 301
}; 
#line 303
struct forward_iterator_tag : public input_iterator_tag, public output_iterator_tag { 
#line 306
}; 
#line 308
struct bidirectional_iterator_tag : public forward_iterator_tag { 
#line 311
}; 
#line 313
struct random_access_iterator_tag : public bidirectional_iterator_tag { 
#line 316
}; 
#line 318
struct _Int_iterator_tag { 
#line 320
}; 
#line 323
struct _Nonscalar_ptr_iterator_tag { 
#line 325
}; 
#line 326
struct _Scalar_ptr_iterator_tag { 
#line 328
}; 
#line 331
template< class _Category, class 
#line 332
_Ty, class 
#line 333
_Diff = ptrdiff_t, class 
#line 334
_Pointer = _Ty *, class 
#line 335
_Reference = _Ty &> 
#line 336
struct iterator { 
#line 338
typedef _Category iterator_category; 
#line 339
typedef _Ty value_type; 
#line 340
typedef _Diff difference_type; 
#line 341
typedef _Diff distance_type; 
#line 342
typedef _Pointer pointer; 
#line 343
typedef _Reference reference; 
#line 344
}; 
#line 346
template< class _Category, class 
#line 347
_Ty, class 
#line 348
_Diff, class 
#line 349
_Pointer, class 
#line 350
_Reference, class 
#line 351
_Base> 
#line 352
struct _Iterator012 : public _Base { 
#line 355
typedef _Category iterator_category; 
#line 356
typedef _Ty value_type; 
#line 357
typedef _Diff difference_type; 
#line 358
typedef _Diff distance_type; 
#line 359
typedef _Pointer pointer; 
#line 360
typedef _Reference reference; 
#line 361
}; 
#line 363
struct _Outit : public iterator< output_iterator_tag, void, void, void, void>  { 
#line 367
}; 
#line 370
template< class _Iter> 
#line 371
struct iterator_traits { 
#line 373
typedef typename _Iter::iterator_category iterator_category; 
#line 374
typedef typename _Iter::value_type value_type; 
#line 375
typedef typename _Iter::difference_type difference_type; 
#line 376
typedef difference_type distance_type; 
#line 377
typedef typename _Iter::pointer pointer; 
#line 378
typedef typename _Iter::reference reference; 
#line 379
}; 
#line 381
template< class _Ty> 
#line 382
struct iterator_traits< _Ty *>  { 
#line 384
typedef random_access_iterator_tag iterator_category; 
#line 385
typedef _Ty value_type; 
#line 386
typedef ptrdiff_t difference_type; 
#line 387
typedef ptrdiff_t distance_type; 
#line 388
typedef _Ty *pointer; 
#line 389
typedef _Ty &reference; 
#line 390
}; 
#line 392
template< class _Ty> 
#line 393
struct iterator_traits< const _Ty *>  { 
#line 395
typedef random_access_iterator_tag iterator_category; 
#line 396
typedef _Ty value_type; 
#line 397
typedef ptrdiff_t difference_type; 
#line 398
typedef ptrdiff_t distance_type; 
#line 399
typedef const _Ty *pointer; 
#line 400
typedef const _Ty &reference; 
#line 401
}; 
#line 403
template<> struct iterator_traits< bool>  { 
#line 405
typedef _Int_iterator_tag iterator_category; 
#line 406
}; 
#line 408
template<> struct iterator_traits< char>  { 
#line 410
typedef _Int_iterator_tag iterator_category; 
#line 411
}; 
#line 413
template<> struct iterator_traits< signed char>  { 
#line 415
typedef _Int_iterator_tag iterator_category; 
#line 416
}; 
#line 418
template<> struct iterator_traits< unsigned char>  { 
#line 420
typedef _Int_iterator_tag iterator_category; 
#line 421
}; 
#line 424
template<> struct iterator_traits< __wchar_t>  { 
#line 426
typedef _Int_iterator_tag iterator_category; 
#line 427
}; 
#line 430 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template<> struct iterator_traits< short>  { 
#line 432
typedef _Int_iterator_tag iterator_category; 
#line 433
}; 
#line 435
template<> struct iterator_traits< unsigned short>  { 
#line 437
typedef _Int_iterator_tag iterator_category; 
#line 438
}; 
#line 440
template<> struct iterator_traits< int>  { 
#line 442
typedef _Int_iterator_tag iterator_category; 
#line 443
}; 
#line 445
template<> struct iterator_traits< unsigned>  { 
#line 447
typedef _Int_iterator_tag iterator_category; 
#line 448
}; 
#line 450
template<> struct iterator_traits< long>  { 
#line 452
typedef _Int_iterator_tag iterator_category; 
#line 453
}; 
#line 455
template<> struct iterator_traits< unsigned long>  { 
#line 457
typedef _Int_iterator_tag iterator_category; 
#line 458
}; 
#line 461
template<> struct iterator_traits< __int64>  { 
#line 463
typedef _Int_iterator_tag iterator_category; 
#line 464
}; 
#line 466
template<> struct iterator_traits< unsigned __int64>  { 
#line 468
typedef _Int_iterator_tag iterator_category; 
#line 469
}; 
#line 473 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _Iter > inline
 typename iterator_traits < _Iter > :: iterator_category
  _Iter_cat ( const _Iter & )
 {
 typename iterator_traits < _Iter > :: iterator_category _Cat;
 return ( _Cat );
 }
#line 482
template < class _Iter1,
 class _Iter2 > inline
 _Nonscalar_ptr_iterator_tag _Ptr_cat ( _Iter1 &, _Iter2 & )
 {
 _Nonscalar_ptr_iterator_tag _Cat;
 return ( _Cat );
 }
#line 490
template< class _Elem1, class 
#line 491
_Elem2> 
#line 492
struct _Ptr_cat_helper { 
#line 494
typedef _Nonscalar_ptr_iterator_tag _Type; 
#line 495
}; 
#line 497
template< class _Elem> 
#line 498
struct _Ptr_cat_helper< _Elem, _Elem>  { 
#line 503
typedef typename tr1::conditional< tr1::is_scalar< _Elem> ::value, _Scalar_ptr_iterator_tag, _Nonscalar_ptr_iterator_tag> ::type _Type; 
#line 504
}; 
#line 506
template< class _Anything> 
#line 507
struct _Ptr_cat_helper< _Anything *, const _Anything *>  { 
#line 509
typedef _Scalar_ptr_iterator_tag _Type; 
#line 510
}; 
#line 512
template < class _Elem1,
 class _Elem2 > inline
 typename _Ptr_cat_helper < _Elem1, _Elem2 > :: _Type
  _Ptr_cat ( _Elem1 *, _Elem2 * )
 {
 typename _Ptr_cat_helper < _Elem1, _Elem2 > :: _Type _Cat;
 return ( _Cat );
 }
#line 521
template < class _Elem1,
 class _Elem2 > inline
 typename _Ptr_cat_helper < _Elem1, _Elem2 > :: _Type
  _Ptr_cat ( const _Elem1 *, _Elem2 * )
 {
 typename _Ptr_cat_helper < _Elem1, _Elem2 > :: _Type _Cat;
 return ( _Cat );
 }
#line 787 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _Iter > inline
 typename iterator_traits < _Iter > :: value_type * _Val_type ( _Iter )
 {
 return ( 0 );
 }
#line 794
template < class _InIt,
 class _Diff > inline
 void advance ( _InIt & _Where, _Diff _Off )
 {
 _Advance ( _Where, _Off, _Iter_cat ( _Where ) );
 }
#line 801
template < class _InIt,
 class _Diff > inline
 void _Advance ( _InIt & _Where, _Diff _Off, input_iterator_tag )
 {





 for (; 0 < _Off; -- _Off )
  ++ _Where;
 }
#line 814 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _FI,
 class _Diff > inline
 void _Advance ( _FI & _Where, _Diff _Off, forward_iterator_tag )
 {





 for (; 0 < _Off; -- _Off )
  ++ _Where;
 }
#line 827 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _BI,
 class _Diff > inline
 void _Advance ( _BI & _Where, _Diff _Off, bidirectional_iterator_tag )
 {
 for (; 0 < _Off; -- _Off )
  ++ _Where;
 for (; _Off < 0; ++ _Off )
  -- _Where;
 }
#line 837
template < class _RI,
 class _Diff > inline
 void _Advance ( _RI & _Where, _Diff _Off, random_access_iterator_tag )
 {
 _Where += _Off;
 }
#line 846
template < class _Iter > inline
 typename iterator_traits < _Iter > :: difference_type
  * _Dist_type ( _Iter )
 {
 return ( 0 );
 }
#line 854
template < class _InIt,
 class _Diff > inline
  void _Distance2 ( _InIt _First, _InIt _Last, _Diff & _Off,
   input_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  ++ _Off;
 }
#line 863
template < class _FwdIt,
 class _Diff > inline
  void _Distance2 ( _FwdIt _First, _FwdIt _Last, _Diff & _Off,
   forward_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  ++ _Off;
 }
#line 872
template < class _BidIt,
 class _Diff > inline
  void _Distance2 ( _BidIt _First, _BidIt _Last, _Diff & _Off,
   bidirectional_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  ++ _Off;
 }
#line 881
template < class _RanIt,
 class _Diff > inline
  void _Distance2 ( _RanIt _First, _RanIt _Last, _Diff & _Off,
   random_access_iterator_tag )
 {








 _Off += _Last - _First;
 }
#line 897 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _InIt > inline
 typename iterator_traits < _InIt > :: difference_type
  distance ( _InIt _First, _InIt _Last )
 {
 typename iterator_traits < _InIt > :: difference_type _Off = 0;
 _Distance2 ( _First, _Last, _Off, _Iter_cat ( _First ) );
 return ( _Off );
 }
#line 906
template < class _InIt,
 class _Diff > inline
  void _Distance ( _InIt _First, _InIt _Last, _Diff & _Off )
 {
 _Distance2 ( _First, _Last, _Off, _Iter_cat ( _First ) );
 }
#line 915
template < class _InIt,
 class _Diff > inline
  _InIt _Increment ( _InIt _First, _Diff _Off,
   input_iterator_tag )
 {
 for (; 0 < _Off; -- _Off )
  ++ _First;
 return ( _First );
 }
#line 925
template < class _FwdIt,
 class _Diff > inline
  _FwdIt _Increment ( _FwdIt _First, _Diff _Off,
   forward_iterator_tag )
 {
 for (; 0 < _Off; -- _Off )
  ++ _First;
 return ( _First );
 }
#line 935
template < class _BidIt,
 class _Diff > inline
  _BidIt _Increment ( _BidIt _First, _Diff _Off,
   bidirectional_iterator_tag )
 {
 for (; _Off < 0; ++ _Off )
  -- _First;
 for (; 0 < _Off; -- _Off )
  ++ _First;
 return ( _First );
 }
#line 947
template < class _RanIt,
 class _Diff > inline
  _RanIt _Increment ( _RanIt _First, _Diff _Off,
   random_access_iterator_tag )
 {
 return ( _First + _Off );
 }
#line 955
template < class _InIt > inline
 _InIt next ( _InIt _First,
  typename iterator_traits < _InIt > :: difference_type _Off = 1 )
 {
 return ( _Increment ( _First, _Off, _Iter_cat ( _First ) ) );
 }
#line 962
template < class _InIt > inline
 _InIt prev ( _InIt _First,
  typename iterator_traits < _InIt > :: difference_type _Off = 1 )
 {
 return ( _Increment ( _First, - _Off, _Iter_cat ( _First ) ) );
 }
#line 969
template < class _Container > inline
 typename _Container :: iterator begin ( _Container & _Cont )
 {
 return ( _Cont . begin ( ) );
 }
#line 975
template < class _Container > inline
 typename _Container :: const_iterator begin ( const _Container & _Cont )
 {
 return ( _Cont . begin ( ) );
 }
#line 981
template < class _Container > inline
 typename _Container :: iterator end ( _Container & _Cont )
 {
 return ( _Cont . end ( ) );
 }
#line 987
template < class _Container > inline
 typename _Container :: const_iterator end ( const _Container & _Cont )
 {
 return ( _Cont . end ( ) );
 }
#line 993
template < class _Ty,
 size_t _Size > inline
 _Ty * begin ( _Ty ( & _Array ) [ _Size ] )
 {
 return ( & _Array [ 0 ] );
 }
#line 1000
template < class _Ty,
 size_t _Size > inline
 _Ty * end ( _Ty ( & _Array ) [ _Size ] )
 {
 return ( & _Array [ 0 ] + _Size );
 }
#line 1009 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _RanIt,
 class _Base >
 class _Revranit
  : public _Base
 {
public :
 typedef _Revranit < _RanIt, _Base > _Myt;
  typedef typename _Base :: difference_type difference_type;
 typedef typename _Base :: pointer pointer;
 typedef typename _Base :: reference reference;
 typedef _RanIt iterator_type;

 _Revranit ( )
  {
  }

 explicit _Revranit ( _RanIt _Right )
  : current ( _Right )
  {
  }

 template < class _RanIt2,
  class _Base2 >
  _Revranit ( const _Revranit < _RanIt2, _Base2 > & _Right )
  : current ( _Right . base ( ) )
  {
  }

 _RanIt base ( ) const
  {
  return ( current );
  }

 reference operator * ( ) const
  {
  _RanIt _Tmp = current;
  return ( * -- _Tmp );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myt & operator ++ ( )
  {
  -- current;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  ++ current;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

 template < class _RanIt2,
  class _Base2 >
  bool _Equal ( const _Revranit < _RanIt2, _Base2 > & _Right ) const
  {
  return ( current == _Right . base ( ) );
  }



 _Myt & operator += ( difference_type _Off )
  {
  current -= _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  return ( _Myt ( current - _Off ) );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  current += _Off;
  return ( * this );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  return ( _Myt ( current + _Off ) );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 template < class _RanIt2,
  class _Base2 >
  bool _Less ( const _Revranit < _RanIt2, _Base2 > & _Right ) const
  {
  return ( _Right . base ( ) < current );
  }

 difference_type operator - ( const _Myt & _Right ) const
  {
  return ( _Right . base ( ) - current );
  }

protected :
 _RanIt current;
 };
#line 1132
template < class _RanIt,
 class _Base,
 class _Diff > inline
 _Revranit < _RanIt, _Base >
  operator + ( _Diff _Off,
  const _Revranit < _RanIt, _Base > & _Right )
 {
 return ( _Right + _Off );
 }
#line 1142
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 typename _Base1 :: difference_type operator - (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Right . base ( ) - _Left . base ( ) );
 }
#line 1153
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator == (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }
#line 1164
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator != (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 1175
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator < (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Left . _Less ( _Right ) );
 }
#line 1186
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator > (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 1197
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator <= (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 1208
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator >= (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 1220
template < class _RanIt >
 class reverse_iterator
  : public _Revranit < _RanIt, iterator <
   typename iterator_traits < _RanIt > :: iterator_category,
   typename iterator_traits < _RanIt > :: value_type,
   typename iterator_traits < _RanIt > :: difference_type,
   typename iterator_traits < _RanIt > :: pointer,
   typename iterator_traits < _RanIt > :: reference > >
 {
 typedef reverse_iterator < _RanIt > _Myt;
 typedef _Revranit < _RanIt, iterator <
  typename iterator_traits < _RanIt > :: iterator_category,
  typename iterator_traits < _RanIt > :: value_type,
  typename iterator_traits < _RanIt > :: difference_type,
  typename iterator_traits < _RanIt > :: pointer,
  typename iterator_traits < _RanIt > :: reference > > _Mybase;

public :
  typedef typename iterator_traits < _RanIt > :: difference_type difference_type;
 typedef typename iterator_traits < _RanIt > :: pointer pointer;
 typedef typename iterator_traits < _RanIt > :: reference reference;
 typedef _RanIt iterator_type;

 reverse_iterator ( )
  {
  }

 explicit reverse_iterator ( _RanIt _Right )
  : _Mybase ( _Right )
  {
  }

 template < class _Other >
  reverse_iterator ( const reverse_iterator < _Other > & _Right )
  : _Mybase ( _Right . base ( ) )
  {
  }

 reverse_iterator ( _Mybase _Right )
  : _Mybase ( _Right )
  {
  }

 _Myt & operator ++ ( )
  {
  ++ * ( ( _Mybase * ) this );
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  -- * ( ( _Mybase * ) this );
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myt & operator += ( difference_type _Off )
  {
  * ( ( _Mybase * ) this ) += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  * ( ( _Mybase * ) this ) -= _Off;
  return ( * this );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }
 };
#line 1314
template< class _RanIt> 
#line 1315
struct _Is_checked_helper< reverse_iterator< _RanIt> >  : public _Is_checked_helper< _RanIt>  { 
#line 1318
}; 
#line 1321
template < class _RanIt,
 class _Diff > inline
 reverse_iterator < _RanIt > operator + ( _Diff _Off,
  const reverse_iterator < _RanIt > & _Right )
 {
 return ( _Right + _Off );
 }
#line 1329
template < class _RanIt1,
 class _RanIt2 > inline
 typename reverse_iterator < _RanIt1 > :: difference_type
  operator - ( const reverse_iterator < _RanIt1 > & _Left,
   const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Right . base ( ) - _Left . base ( ) );
 }
#line 1338
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator == ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }
#line 1346
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator != ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 1354
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator < ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Less ( _Right ) );
 }
#line 1362
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator > ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 1370
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator <= ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 1378
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator >= ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 1387
template < class _BidIt,
 class _Ty,
 class _Reference = _Ty &,
 class _Pointer = _Ty *,
 class _Diff = ptrdiff_t >
 class reverse_bidirectional_iterator
  : public iterator < bidirectional_iterator_tag, _Ty, _Diff,
   _Pointer, _Reference >
 {
public :
 typedef reverse_bidirectional_iterator < _BidIt, _Ty, _Reference,
  _Pointer, _Diff > _Myt;
 typedef _BidIt iterator_type;

 reverse_bidirectional_iterator ( )
  {
  }

 explicit reverse_bidirectional_iterator ( _BidIt _Right )
  : current ( _Right )
  {
  }

 _BidIt base ( ) const
  {
  return ( current );
  }

 _Reference operator * ( ) const
  {
  _BidIt _Tmp = current;
  return ( * -- _Tmp );
  }

 _Pointer operator -> ( ) const
  {
  _Reference _Tmp = * * this;
  return ( & _Tmp );
  }

 _Myt & operator ++ ( )
  {
  -- current;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  ++ current;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

 bool operator == ( const _Myt & _Right ) const
  {
  return ( current == _Right . current );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

protected :
 _BidIt current;
 };
#line 1468
template < class _BidIt,
 class _BidIt2 = _BidIt >
 class _Revbidit
  : public iterator <
   typename iterator_traits < _BidIt > :: iterator_category,
   typename iterator_traits < _BidIt > :: value_type,
   typename iterator_traits < _BidIt > :: difference_type,
   typename iterator_traits < _BidIt > :: pointer,
   typename iterator_traits < _BidIt > :: reference >
 {
public :
 typedef _Revbidit < _BidIt, _BidIt2 > _Myt;
 typedef typename iterator_traits < _BidIt > :: difference_type _Diff;
 typedef typename iterator_traits < _BidIt > :: pointer _Pointer;
 typedef typename iterator_traits < _BidIt > :: reference _Reference;
 typedef _BidIt iterator_type;

 _Revbidit ( )
  {
  }

 explicit _Revbidit ( _BidIt _Right )
  : current ( _Right )
  {
  }

 _Revbidit ( const _Revbidit < _BidIt2 > & _Other )
  : current ( _Other . base ( ) )
  {
  }

 _BidIt base ( ) const
  {
  return ( current );
  }

 _Reference operator * ( ) const
  {
  _BidIt _Tmp = current;
  return ( * -- _Tmp );
  }

 _Pointer operator -> ( ) const
  {
  _Reference _Tmp = * * this;
  return ( & _Tmp );
  }

 _Myt & operator ++ ( )
  {
  -- current;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  ++ current;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

 bool operator == ( const _Myt & _Right ) const
  {
  return ( current == _Right . current );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

protected :
 _BidIt current;
 };
#line 1557
template < class _Ty,
 size_t _Size >
 class _Array_const_iterator
  : public _Iterator012 < random_access_iterator_tag,
   _Ty,
   ptrdiff_t,
   const _Ty *,
   const _Ty &,
   _Iterator_base >
 {
public :
 typedef _Array_const_iterator < _Ty, _Size > _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef const _Ty * pointer;
 typedef const _Ty & reference;
 enum { _EEN_SIZE = _Size };
 enum { _EEN_IDL =
  0 };


 _Array_const_iterator ( )
  {
  _Ptr = 0;
  }

 explicit _Array_const_iterator ( pointer _Parg, size_t _Off = 0 )
  {
  _Ptr = _Parg + _Off;
  }

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  _Ptr = _Right;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Ptr );
  }

 reference operator * ( ) const
  {
  return ( * _Ptr );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myiter & operator ++ ( )
  {
  ++ _Ptr;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
  -- _Ptr;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
  _Ptr += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myiter & _Right ) const
  {
  return ( _Ptr - _Right . _Ptr );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myiter & _Right ) const
  {
  return ( _Ptr == _Right . _Ptr );
  }

 bool operator != ( const _Myiter & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myiter & _Right ) const
  {
  return ( _Ptr < _Right . _Ptr );
  }

 bool operator > ( const _Myiter & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myiter & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myiter & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }

 pointer _Ptr;











































































































































































































 };
#line 1909 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _Ty,
 size_t _Size > inline
 typename _Array_const_iterator < _Ty, _Size > :: _Unchecked_type
  _Unchecked ( _Array_const_iterator < _Ty, _Size > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 1917
template < class _Ty,
 size_t _Size > inline
 _Array_const_iterator < _Ty, _Size > &
  _Rechecked ( _Array_const_iterator < _Ty, _Size > & _Iter,
   typename _Array_const_iterator < _Ty, _Size >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 1927
template < class _Ty,
 size_t _Size > inline
 _Array_const_iterator < _Ty, _Size > operator + (
  typename _Array_const_iterator < _Ty, _Size > :: difference_type _Off,
  _Array_const_iterator < _Ty, _Size > _Next )
 {
 return ( _Next += _Off );
 }
#line 1937
template < class _Ty,
 size_t _Size >
 class _Array_iterator
  : public _Array_const_iterator < _Ty, _Size >
 {
public :
 typedef _Array_iterator < _Ty, _Size > _Myiter;
 typedef _Array_const_iterator < _Ty, _Size > _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef _Ty * pointer;
 typedef _Ty & reference;

 _Array_iterator ( )
  {
  }

 explicit _Array_iterator ( pointer _Parg, size_t _Off = 0 )
  : _Mybase ( _Parg, _Off )
  {
  }
 enum { _EEN_SIZE = _Size };
 enum { _EEN_IDL =
  0 };

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  ( ( _Mybase * ) this ) -> _Rechecked ( _Right );
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( ( pointer ) ( ( _Mybase * ) this ) -> _Unchecked ( ) );
  }

 reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myiter & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 2048
template < class _Ty,
 size_t _Size > inline
 typename _Array_iterator < _Ty, _Size > :: _Unchecked_type
  _Unchecked ( _Array_iterator < _Ty, _Size > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 2056
template < class _Ty,
 size_t _Size > inline
 _Array_iterator < _Ty, _Size > &
  _Rechecked ( _Array_iterator < _Ty, _Size > & _Iter,
   typename _Array_iterator < _Ty, _Size >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 2066
template < class _Ty,
 size_t _Size > inline
 _Array_iterator < _Ty, _Size > operator + (
  typename _Array_iterator < _Ty, _Size > :: difference_type _Off,
  _Array_iterator < _Ty, _Size > _Next )
 {
 return ( _Next += _Off );
 }
#line 2077
template < class _Ty > inline
 const _Ty & ( max ) ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ( ( _Left ) < ( _Right ) ) ? _Right : _Left );
 }
#line 2084
template < class _Ty,
 class _Pr > inline
 const _Ty & ( max ) ( const _Ty & _Left, const _Ty & _Right, _Pr _Pred )
 {
 return ( _Pred ( _Left, _Right ) ? _Right : _Left );
 }
#line 2092
template < class _Ty > inline
 const _Ty & ( min ) ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ( ( _Right ) < ( _Left ) ) ? _Right : _Left );
 }
#line 2099
template < class _Ty,
 class _Pr > inline
 const _Ty & ( min ) ( const _Ty & _Left, const _Ty & _Right, _Pr _Pred )
 {
 return ( _Pred ( _Right, _Left ) ? _Right : _Left );
 }
#line 2109
template < class _Ty > inline
 pair < const _Ty, const _Ty >
  minmax ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( _Right < _Left
  ? pair < const _Ty, const _Ty > ( _Right, _Left )
  : pair < const _Ty, const _Ty > ( _Left, _Right ) );
 }
#line 2119
template < class _Ty,
 class _Pr > inline
 pair < const _Ty, const _Ty >
  minmax ( const _Ty & _Left, const _Ty & _Right, _Pr _Pred )
 {
 return ( _Pred ( _Right, _Left )
  ? pair < const _Ty, const _Ty > ( _Right, _Left )
  : pair < const _Ty, const _Ty > ( _Left, _Right ) );
 }
#line 2130
template < class _FwdIt1,
 class _FwdIt2 > inline
 void iter_swap ( _FwdIt1 _Left, _FwdIt2 _Right )
 {
 swap ( * _Left, * _Right );
 }
#line 2138
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_impl ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _Dest, ++ _First )
  * _Dest = * _First;
 return ( _Dest );
 }
#line 2148
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_impl ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove ( & * _Dest, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest + _Count );
 }
#line 2159
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_impl ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 return ( _Copy_impl ( _First, _Last,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2169
template < class _InIt,
 class _OutIt > inline
 _OutIt copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 return ( _Rechecked ( _Dest,
  _Copy_impl ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Unchecked ( _Dest ) ) ) );
 }
#line 2244 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, input_iterator_tag )
 {
 * _Dest = * _First;
 while ( 0 < -- _Count )
  * ++ _Dest = * ++ _First;
 return ( ++ _Dest );
 }
#line 2256
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, forward_iterator_tag )
 {
 for (; 0 < _Count; -- _Count, ++ _Dest, ++ _First )
  * _Dest = * _First;
 return ( _Dest );
 }
#line 2267
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag )
 {
 return ( _Copy_n ( _First, _Count,
  _Dest, _Iter_cat ( _First ) ) );
 }
#line 2277
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 :: memmove ( & * _Dest, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest + _Count );
 }
#line 2288
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest )
 {
 return ( _Copy_n ( _First, _Count,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2299
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest )
 {
 if ( _Count <= 0 )
  return ( _Dest );
 else
  return ( _Rechecked ( _Dest,
   _Copy_n ( _Unchecked ( _First ), _Count,
    _Unchecked ( _Dest ) ) ) );
 }
#line 2434 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag )
 {
 while ( _First != _Last )
  * -- _Dest = * -- _Last;
 return ( _Dest );
 }
#line 2444
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_backward ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove ( & * _Dest - _Count, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest - _Count );
 }
#line 2455
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 return ( _Copy_backward ( _First, _Last,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2465
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 copy_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 return ( _Rechecked ( _Dest,
  _Copy_backward ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Unchecked ( _Dest ) ) ) );
 }
#line 2508 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _Dest, ++ _First )
  * _Dest = :: std :: move ( * _First );
 return ( _Dest );
 }
#line 2518
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove ( & * _Dest, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest + _Count );
 }
#line 2529
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 return ( _Move ( _First, _Last,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2539
template < class _InIt,
 class _OutIt > inline
 _OutIt move ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 return ( _Rechecked ( _Dest,
  _Move ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Unchecked ( _Dest ) ) ) );
 }
#line 2613 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag )
 {
 while ( _First != _Last )
  * -- _Dest = :: std :: move ( * -- _Last );
 return ( _Dest );
 }
#line 2623
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move_backward ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove ( & * _Dest - _Count, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest - _Count );
 }
#line 2634
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 return ( _Move_backward ( _First, _Last,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2644
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 move_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 return ( _Rechecked ( _Dest,
  _Move_backward ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Unchecked ( _Dest ) ) ) );
 }
#line 2687 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _FwdIt,
 class _Ty > inline
 void _Fill ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 for (; _First != _Last; ++ _First )
  * _First = _Val;
 }
#line 2695
inline void _Fill(char *_First, char *_Last, int _Val) 
#line 2696
{ 
#line 2697
::memset(_First, _Val, _Last - _First); 
#line 2698
} 
#line 2700
inline void _Fill(signed char *_First, signed char *_Last, int _Val) 
#line 2701
{ 
#line 2702
::memset(_First, _Val, _Last - _First); 
#line 2703
} 
#line 2705
inline void _Fill(unsigned char *_First, unsigned char *_Last, int _Val) 
#line 2706
{ 
#line 2707
::memset(_First, _Val, _Last - _First); 
#line 2708
} 
#line 2710
template < class _FwdIt,
 class _Ty > inline
 void fill ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 ;
 _Fill ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val );
 }
#line 2719
template < class _OutIt,
 class _Diff,
 class _Ty > inline
 void _Fill_n ( _OutIt _Dest, _Diff _Count, const _Ty & _Val )
 {
 for (; 0 < _Count; -- _Count, ++ _Dest )
  * _Dest = _Val;
 }
#line 2728
inline void _Fill_n(char *_Dest, size_t _Count, int _Val) 
#line 2729
{ 
#line 2730
::memset(_Dest, _Val, _Count); 
#line 2731
} 
#line 2733
inline void _Fill_n(signed char *_Dest, size_t _Count, int _Val) 
#line 2734
{ 
#line 2735
::memset(_Dest, _Val, _Count); 
#line 2736
} 
#line 2738
inline void _Fill_n(unsigned char *_Dest, size_t _Count, int _Val) 
#line 2739
{ 
#line 2740
::memset(_Dest, _Val, _Count); 
#line 2741
} 
#line 2744
template < class _OutIt,
 class _Diff,
 class _Ty > inline
 void fill_n ( _OutIt _Dest, _Diff _Count, const _Ty & _Val )
 {
 _Fill_n ( _Unchecked ( _Dest ), _Count, _Val );
 }
#line 2815 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _InIt1,
 class _InIt2 > inline
 pair < _InIt1, _InIt2 >
  _Mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2 )
 {
 for (; _First1 != _Last1 && * _First1 == * _First2; )
  ++ _First1, ++ _First2;
 return ( pair < _InIt1, _InIt2 > ( _First1, _First2 ) );
 }
#line 2827
template < class _InIt1,
 class _InIt2 > inline
 pair < _InIt1, _InIt2 >
  mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2 )
 {
 :: std :: pair < typename _Get_unchecked_type < _InIt1 > :: type, _InIt2 > _Ans (
  :: std :: _Mismatch ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _First2 ) );
 return ( :: std :: pair < _InIt1, _InIt2 > (
  _Rechecked ( _First1, _Ans . first ),
  _Ans . second ) );
 }
#line 2897 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 pair < _InIt1, _InIt2 >
  _Mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr _Pred )
 {
 for (; _First1 != _Last1 && _Pred ( * _First1, * _First2 ); )
  ++ _First1, ++ _First2;
 return ( pair < _InIt1, _InIt2 > ( _First1, _First2 ) );
 }
#line 2910
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 pair < _InIt1, _InIt2 >
  mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr _Pred )
 {
 :: std :: pair < typename _Get_unchecked_type < _InIt1 > :: type, _InIt2 > _Ans (
  :: std :: _Mismatch ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _First2, _Pred ) );
 return ( :: std :: pair < _InIt1, _InIt2 > (
  _Rechecked ( _First1, _Ans . first ),
  _Ans . second ) );
 }
#line 2985 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _InIt1,
 class _InIt2 > inline
 bool _Equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 )
 {
 for (; _First1 != _Last1; ++ _First1, ++ _First2 )
  if ( ! ( * _First1 == * _First2 ) )
   return ( false );
 return ( true );
 }
#line 2995
inline bool _Equal(const char *_First1, const char *_Last1, const char *
#line 2996
_First2) 
#line 2997
{ 
#line 2998
return ::memcmp(_First1, _First2, _Last1 - _First1) == 0; 
#line 2999
} 
#line 3001
inline bool _Equal(const signed char *_First1, const signed char *_Last1, const signed char *
#line 3002
_First2) 
#line 3003
{ 
#line 3004
return ::memcmp(_First1, _First2, _Last1 - _First1) == 0; 
#line 3005
} 
#line 3007
inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1, const unsigned char *
#line 3008
_First2) 
#line 3009
{ 
#line 3010
return ::memcmp(_First1, _First2, _Last1 - _First1) == 0; 
#line 3011
} 
#line 3014
template < class _InIt1,
 class _InIt2 > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2 )
 {
 return ( _Equal ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ) ) );
 }
#line 3066 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred )
 {
 for (; _First1 != _Last1; ++ _First1, ++ _First2 )
  if ( ! _Pred ( * _First1, * _First2 ) )
   return ( false );
 return ( true );
 }
#line 3079
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred )
 {
 return ( _Equal ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Pred ) );
 }
#line 3136 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _InIt1,
 class _InIt2 > inline
 bool _Lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 )
  if ( ( ( * _First1 ) < ( * _First2 ) ) )
   return ( true );
  else if ( * _First2 < * _First1 )
   return ( false );
 return ( _First1 == _Last1 && _First2 != _Last2 );
 }
#line 3149
inline bool _Lexicographical_compare(const unsigned char *
#line 3150
_First1, const unsigned char *_Last1, const unsigned char *
#line 3151
_First2, const unsigned char *_Last2) 
#line 3152
{ 
#line 3153
ptrdiff_t _Num1 = _Last1 - _First1; 
#line 3154
ptrdiff_t _Num2 = _Last2 - _First2; 
#line 3155
int _Ans = ::memcmp(_First1, _First2, (_Num1 < _Num2) ? _Num1 : _Num2); 
#line 3156
return (_Ans < 0) || ((_Ans == 0) && (_Num1 < _Num2)); 
#line 3157
} 
#line 3171 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
template < class _InIt1,
 class _InIt2 > inline
 bool lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 ;
 ;
 return ( _Lexicographical_compare ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ) ) );
 }
#line 3183
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 )
  if ( _Pred ( * _First1, * _First2 ) )
   return ( true );
  else if ( _Pred ( * _First2, * _First1 ) )
   return ( false );
 return ( _First1 == _Last1 && _First2 != _Last2 );
 }
#line 3197
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 ;
 ;
 ;
 return ( _Lexicographical_compare ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred ) );
 }
#line 3211
template < class _BidIt > inline
 void _Reverse ( _BidIt _First, _BidIt _Last, bidirectional_iterator_tag )
 {
 for (; _First != _Last && _First != -- _Last; ++ _First )
  :: std :: iter_swap ( _First, _Last );
 }
#line 3218
template < class _BidIt > inline
 void reverse ( _BidIt _First, _BidIt _Last )
 {
 ;
 _Reverse ( _Unchecked ( _First ), _Unchecked ( _Last ), _Iter_cat ( _First ) );
 }
#line 3226
template < class _FwdIt > inline
 void _Rotate ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  forward_iterator_tag )
 {
 for ( _FwdIt _Next = _Mid;; )
  {
  :: std :: iter_swap ( _First, _Next );
  if ( ++ _First == _Mid )
   if ( ++ _Next == _Last )
    break;
   else
    _Mid = _Next;
  else if ( ++ _Next == _Last )
   _Next = _Mid;
  }
 }
#line 3243
template < class _BidIt > inline
 void _Rotate ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  bidirectional_iterator_tag )
 {
 :: std :: reverse ( _First, _Mid );
 :: std :: reverse ( _Mid, _Last );
 :: std :: reverse ( _First, _Last );
 }
#line 3252
template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Rotate ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty * )
 {
 _Diff _Shift = _Mid - _First;
 _Diff _Count = _Last - _First;

 for ( _Diff _Factor = _Shift; _Factor != 0; )
  {
  _Diff _Tmp = _Count % _Factor;
  _Count = _Factor;
  _Factor = _Tmp;
  }

 if ( _Count < _Last - _First )
  for (; 0 < _Count; -- _Count )
   {
   _RanIt _Hole = _First + _Count;
   _RanIt _Next = _Hole;
   _RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;
   for (;; )
    {
    iter_swap ( _Next, _Next1 );
    _Next = _Next1;
    _Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
     : _First + ( _Shift - ( _Last - _Next1 ) );
    if ( _Next1 == _Hole )
     break;
    }
   }
 }
#line 3285
template < class _RanIt > inline
 void _Rotate ( _RanIt _First, _RanIt _Mid, _RanIt _Last,
  random_access_iterator_tag )
 {
 _Rotate ( _First, _Mid, _Last, _Dist_type ( _First ), _Val_type ( _First ) );
 }
#line 3292
template < class _FwdIt > inline
 _FwdIt rotate ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last )
 {
 ;
 ;
 if ( _First != _Mid && _Mid != _Last )
  {
  _Rotate ( _Unchecked ( _First ), _Unchecked ( _Mid ), _Unchecked ( _Last ),
   _Iter_cat ( _First ) );
  :: std :: advance ( _First, :: std :: distance ( _Mid, _Last ) );
  }
 return ( _First );
 }
#line 3307
template < class _Elem >
 class __declspec ( dllimport ) _Yarn
 {
public :
 typedef _Yarn < _Elem > _Myt;

  _Yarn ( )
  : _Myptr ( 0 ), _Nul ( 0 )
  {
  }

  _Yarn ( const _Myt & _Right )
  : _Myptr ( 0 ), _Nul ( 0 )
  {
  * this = _Right;
  }

  _Yarn ( const _Elem * _Right )
  : _Myptr ( 0 ), _Nul ( 0 )
  {
  * this = _Right;
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  return ( * this = _Right . _Myptr );
  }

 _Myt & operator = ( const _Elem * _Right )
  {
  if ( _Myptr != _Right )
   {
   _Tidy ( );

   if ( _Right != 0 )
    {
    const _Elem * _Ptr = _Right;
    while ( * _Ptr != ( _Elem ) 0 )
     ++ _Ptr;
    size_t _Count = ( ( const char * ) ++ _Ptr - ( const char * ) _Right )
     * sizeof ( _Elem );






    _Myptr = ( _Elem * ) :: malloc ( _Count );


    if ( _Myptr != 0 )
     :: memcpy ( _Myptr, _Right, _Count );
    }
   }
  return ( * this );
  }

  ~ _Yarn ( )
  {
  _Tidy ( );
  }

 bool empty ( ) const
  {
  return ( _Myptr == 0 );
  }

 const _Elem * c_str ( ) const
  {
  return ( _Myptr != 0 ? _Myptr : & _Nul );
  }

 bool _Empty ( ) const
  {
  return ( _Myptr == 0 );
  }

 const _Elem * _C_str ( ) const
  {
  return ( _Myptr != 0 ? _Myptr : & _Nul );
  }

private :
 void _Tidy ( )
  {
  if ( _Myptr != 0 )





   :: free ( _Myptr );


  _Myptr = 0;
  }

 _Elem * _Myptr;
 _Elem _Nul;
 };
#line 3408 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xinvalid_argument(const char *); 
#line 3409
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xlength_error(const char *); 
#line 3410
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xout_of_range(const char *); 
#line 3411
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xoverflow_error(const char *); 
#line 3412
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xruntime_error(const char *); 
#line 3413
}
#pragma warning(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xmemory"
#pragma warning(push,3)
#line 18
#pragma warning(disable: 4100)
#line 3415 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xutility"
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xmemory"
#pragma pack ( push, 8 )
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xmemory"
namespace std { 
#line 28
template < class _Ty > inline
 _Ty * _Allocate ( size_t _Count, _Ty * )
 {
 void * _Ptr = 0;

 if ( _Count <= 0 )
  _Count = 0;
 else if ( ( ( size_t ) ( - 1 ) / sizeof ( _Ty ) < _Count )
  || ( _Ptr = :: operator new ( _Count * sizeof ( _Ty ) ) ) == 0 )
  throw bad_alloc ( 0 );

 return ( ( _Ty * ) _Ptr );
 }
#line 43
template < class _Ty1,
 class _Ty2 > inline
 void _Construct ( _Ty1 * _Ptr, _Ty2 && _Val )
 {
 void * _Vptr = _Ptr;
 :: new ( _Vptr ) _Ty1 ( :: std :: forward < _Ty2 > ( _Val ) );
 }
#line 51
template < class _Ty1 > inline
 void _Construct ( _Ty1 * _Ptr )
 {
 void * _Vptr = _Ptr;

 :: new ( _Vptr ) _Ty1 ( );
 }
#line 60
template < class _Ty > inline
 void _Destroy ( _Ty * _Ptr )
 {
 _Ptr -> ~ _Ty ( );
 }
#line 67
template<> inline void _Destroy(char *) 
#line 68
{ 
#line 69
} 
#line 72
template<> inline void _Destroy(__wchar_t *) 
#line 73
{ 
#line 74
} 
#line 78
template<> inline void _Destroy(unsigned short *) 
#line 79
{ 
#line 80
} 
#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xmemory"
template < class _Alloc > inline
 void _Destroy_range ( typename _Alloc :: pointer _First,
  typename _Alloc :: pointer _Last, _Alloc & _Al )
 {
 _Destroy_range ( _First, _Last, _Al, _Ptr_cat ( _First, _Last ) );
 }
#line 91
template < class _Alloc > inline
 void _Destroy_range ( typename _Alloc :: pointer _First,
  typename _Alloc :: pointer _Last, _Alloc & _Al,
  _Nonscalar_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  _Dest_val ( _Al, _First );
 }
#line 100
template < class _Alloc > inline
 void _Destroy_range ( typename _Alloc :: pointer _First,
  typename _Alloc :: pointer _Last, _Alloc & _Al,
  _Scalar_ptr_iterator_tag )
 {
 }
#line 108
template < class _Ty > inline
 _Ty * addressof ( _Ty & _Val )
 {
 return ( ( _Ty * ) & ( char & ) _Val );
 }
#line 115
template< class _Ty> 
#line 116
struct _Allocator_base { 
#line 118
typedef _Ty value_type; 
#line 119
}; 
#line 122
template< class _Ty> 
#line 123
struct _Allocator_base< const _Ty>  { 
#line 125
typedef _Ty value_type; 
#line 126
}; 
#line 129
template < class _Ty >
 class allocator
  : public _Allocator_base < _Ty >
 {
public :
 typedef _Allocator_base < _Ty > _Mybase;
 typedef typename _Mybase :: value_type value_type;

 typedef value_type * pointer;
 typedef value_type & reference;
 typedef const value_type * const_pointer;
 typedef const value_type & const_reference;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 template < class _Other >
  struct rebind
  {
  typedef allocator < _Other > other;
  };

 pointer address ( reference _Val ) const
  {
  return ( ( pointer ) & ( char & ) _Val );
  }

 const_pointer address ( const_reference _Val ) const
  {
  return ( ( const_pointer ) & ( char & ) _Val );
  }

 allocator ( ) throw ( )
  {
  }

 allocator ( const allocator < _Ty > & ) throw ( )
  {
  }

 template < class _Other >
  allocator ( const allocator < _Other > & ) throw ( )
  {
  }

 template < class _Other >
  allocator < _Ty > & operator = ( const allocator < _Other > & )
  {
  return ( * this );
  }

 void deallocate ( pointer _Ptr, size_type )
  {
  :: operator delete ( _Ptr );
  }

 pointer allocate ( size_type _Count )
  {
  return ( _Allocate ( _Count, ( pointer ) 0 ) );
  }

 pointer allocate ( size_type _Count, const void * )
  {
  return ( allocate ( _Count ) );
  }

 void construct ( pointer _Ptr, const _Ty & _Val )
  {
  _Construct ( _Ptr, _Val );
  }

 void construct ( pointer _Ptr, _Ty && _Val )
  {
  :: new ( ( void * ) _Ptr ) _Ty ( :: std :: forward < _Ty > ( _Val ) );
  }

 template < class _Other >
  void construct ( pointer _Ptr, _Other && _Val )
  {
  :: new ( ( void * ) _Ptr ) _Ty ( :: std :: forward < _Other > ( _Val ) );
  }

 void destroy ( pointer _Ptr )
  {
  _Destroy ( _Ptr );
  }

 size_t max_size ( ) const throw ( )
  {
  size_t _Count = ( size_t ) ( - 1 ) / sizeof ( _Ty );
  return ( 0 < _Count ? _Count : 1 );
  }
 };
#line 224
#pragma pack(8)
template<> 
#line 224
class allocator< void>  { 
#line 227
public: typedef void _Ty; 
#line 228
typedef _Ty *pointer; 
#line 229
typedef const _Ty *const_pointer; 
#line 230
typedef _Ty value_type; 
#line 232
template< class _Other> 
#line 233
struct rebind { 
#line 235
typedef std::allocator< _Other>  other; 
#line 236
}; 
#line 238
allocator() throw() 
#line 239
{ 
#line 240
} 
#line 242
allocator(const std::allocator< void>  &) throw() 
#line 243
{ 
#line 244
} 
#line 246
template < class _Other >
  allocator ( const allocator < _Other > & ) throw ( )
  {
  }
#line 251
template < class _Other >
  allocator < _Ty > & operator = ( const allocator < _Other > & )
  {
  return ( * this );
  }
#line 256
}; 
#pragma pack(8)
template < class _Ty,
 class _Other > inline
 bool operator == ( const allocator < _Ty > &,
  const allocator < _Other > & ) throw ( )
 {
 return ( true );
 }
#line 266
template < class _Ty,
 class _Other > inline
 bool operator != ( const allocator < _Ty > & _Left,
  const allocator < _Other > & _Right ) throw ( )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 275
template < class _Alloc,
 class _Ty1,
 class _Ty2 >
 void _Cons_val ( _Alloc & _Alval, _Ty1 * _Pdest, _Ty2 && _Src )
 {
 _Alval . construct ( _Pdest, :: std :: forward < _Ty2 > ( _Src ) );
 }
#line 283
template < class _Alloc,
 class _Ty1 >
 void _Dest_val ( _Alloc & _Alval, _Ty1 * _Pdest )
 {
 _Alval . destroy ( _Pdest );
 }
#line 289
}
#line 293
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
#pragma warning(push,3)
#line 14
#pragma warning(disable: 4700)
#line 294 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xmemory"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
#pragma pack ( push, 8 )
#line 16
namespace std { 
#line 18
template < class _Ty > inline
 pair < _Ty *, ptrdiff_t >

  get_temporary_buffer ( ptrdiff_t _Count )

 {
 _Ty * _Pbuf;

 if ( _Count < 0 )
  _Count = 0;
 else if ( ( ( size_t ) ( - 1 ) / sizeof ( _Ty ) < _Count ) )
  throw bad_alloc ( 0 );
 for ( _Pbuf = 0; 0 < _Count; _Count /= 2 )
  if ( ( _Pbuf = ( _Ty * ) operator new (
   ( size_t ) _Count * sizeof ( _Ty ), nothrow ) ) != 0 )
   break;

 return ( pair < _Ty *, ptrdiff_t > ( _Pbuf, _Count ) );
 }
#line 39
template < class _Ty > inline
 void return_temporary_buffer ( _Ty * _Pbuf )
 {
 operator delete ( _Pbuf );
 }
#line 46
template < class _InIt,
 class _Diff,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_n ( _InIt _First, _Diff _Count,
  _FwdIt _Dest, input_iterator_tag )
 {
 _FwdIt _Next = _Dest;

 try {
 _Construct ( & * _Dest, * _First );
 while ( 0 < -- _Count )
  _Construct ( & * ++ _Dest, * ++ _First );
 } catch ( ... ) {
 for (; _Next != _Dest; ++ _Next )
  _Destroy ( & * _Next );
 throw;
 }
 return ( ++ _Dest );
 }
#line 66
template < class _InIt,
 class _Diff,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_n ( _InIt _First, _Diff _Count,
  _FwdIt _Dest, forward_iterator_tag )
 {
 _FwdIt _Next = _Dest;

 try {
 for (; 0 < _Count; -- _Count, ++ _Dest, ++ _First )
  _Construct ( & * _Dest, * _First );
 } catch ( ... ) {
 for (; _Next != _Dest; ++ _Next )
  _Destroy ( & * _Next );
 throw;
 }
 return ( _Dest );
 }
#line 85
template < class _InIt,
 class _Diff,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_n ( _InIt _First, _Diff _Count,
  _FwdIt _Dest, _Nonscalar_ptr_iterator_tag )
 {
 return ( _Uninitialized_copy_n ( _First, _Count,
  _Dest, _Iter_cat ( _First ) ) );
 }
#line 95
template < class _InIt,
 class _Diff,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_n ( _InIt _First, _Diff _Count,
  _FwdIt _Dest, _Scalar_ptr_iterator_tag )
 {
 :: memmove ( & * _Dest, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest + _Count );
 }
#line 106
template < class _InIt,
 class _Diff,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_n ( _InIt _First, _Diff _Count,
  _FwdIt _Dest )
 {
 return ( _Uninitialized_copy_n ( _First, _Count,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 117
template < class _InIt,
 class _Diff,
 class _FwdIt > inline
 _FwdIt uninitialized_copy_n ( _InIt _First, _Diff _Count,
  _FwdIt _Dest )
 {
 if ( _Count <= 0 )
  return ( _Dest );
 else
  return ( _Rechecked ( _Dest,
   _Uninitialized_copy_n ( _First, _Count,
    _Unchecked ( _Dest ) ) ) );
 }
#line 251 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy0 ( _InIt _First, _InIt _Last,
  _FwdIt _Dest, _Nonscalar_ptr_iterator_tag )
 {
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++ _Dest, ++ _First )
  _Construct ( & * _Dest, * _First );
 } catch ( ... ) {
 for (; _Next != _Dest; ++ _Next )
  _Destroy ( & * _Next );
 throw;
 }
 return ( _Dest );
 }
#line 269
template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy0 ( _InIt _First, _InIt _Last,
  _FwdIt _Dest, _Scalar_ptr_iterator_tag )
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove ( & * _Dest, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest + _Count );
 }
#line 280
template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy0 ( _InIt _First, _InIt _Last,
  _FwdIt _Dest )
 {
 return ( _Uninitialized_copy0 ( _First, _Last,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 290
template < class _InIt,
 class _FwdIt > inline
 _FwdIt uninitialized_copy ( _InIt _First, _InIt _Last,
  _FwdIt _Dest )
 {
 return ( _Rechecked ( _Dest,
  _Uninitialized_copy0 ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Unchecked ( _Dest ) ) ) );
 }
#line 364 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninit_copy ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc & _Al, _Nonscalar_ptr_iterator_tag )
 {
 ;
 ;
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++ _Dest, ++ _First )
  _Cons_val ( _Al, _Dest, * _First );
 } catch ( ... ) {
 for (; _Next != _Dest; ++ _Next )
  _Dest_val ( _Al, _Next );
 throw;
 }
 return ( _Dest );
 }
#line 385
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninit_copy ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc & _Al, _Scalar_ptr_iterator_tag )
 {
 return ( _Uninit_copy ( _First, _Last, _Dest,
  _Al, _Nonscalar_ptr_iterator_tag ( ) ) );
 }
#line 395
template < class _Ty1,
 class _Ty2 > inline
 _Ty2 * _Uninit_copy ( _Ty1 * _First, _Ty1 * _Last, _Ty2 * _Dest,
  allocator < _Ty2 > &, _Scalar_ptr_iterator_tag )
 {
 ;
 ;
 size_t _Count = ( size_t ) ( _Last - _First );
 return ( ( _Ty2 * ) :: memmove ( & * _Dest, & * _First,
  _Count * sizeof ( * _First ) ) + _Count );
 }
#line 407
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninitialized_copy ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc & _Al )
 {
 return ( _Uninit_copy ( _First, _Last, _Dest, _Al,
  _Ptr_cat ( _First, _Dest ) ) );
 }
#line 418
template < class _InIt,
 class _FwdIt,
 class _Alloc,
 class _Valty > inline
 _FwdIt _Uninit_move ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc & _Al, _Valty *, _Nonscalar_ptr_iterator_tag )
 {
 ;
 ;
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++ _Dest, ++ _First )
  _Cons_val ( _Al, _Dest, ( _Valty && ) * _First );
 } catch ( ... ) {
 for (; _Next != _Dest; ++ _Next )
  _Dest_val ( _Al, _Next );
 throw;
 }
 return ( _Dest );
 }
#line 440
template < class _InIt,
 class _FwdIt,
 class _Alloc,
 class _Valty > inline
 _FwdIt _Uninit_move ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc & _Al, _Valty *, _Scalar_ptr_iterator_tag )
 {
 return ( _Uninit_move ( _First, _Last, _Dest,
  _Al, ( _Valty * ) 0, _Nonscalar_ptr_iterator_tag ( ) ) );
 }
#line 451
template < class _Ty1,
 class _Ty2,
 class _Valty > inline
 _Ty2 * _Uninit_move ( _Ty1 * _First, _Ty1 * _Last, _Ty2 * _Dest,
  allocator < _Ty2 > &, _Valty *, _Scalar_ptr_iterator_tag )
 {
 ;
 ;
 size_t _Count = ( size_t ) ( _Last - _First );
 return ( ( _Ty2 * ) :: memmove ( & * _Dest, & * _First,
  _Count * sizeof ( * _First ) ) + _Count );
 }
#line 464
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninitialized_move ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc & _Al )
 {
 return ( _Uninit_move ( _First, _Last, _Dest, _Al,
  _Val_type ( _First ), _Ptr_cat ( _First, _Dest ) ) );
 }
#line 475
template < class _FwdIt,
 class _Tval > inline
 void _Uninit_fill ( _FwdIt _First, _FwdIt _Last, const _Tval & _Val,
  _Nonscalar_ptr_iterator_tag )
 {
 ;
 _FwdIt _Next = _First;

 try {
 for (; _First != _Last; ++ _First )
  _Construct ( & * _First, _Val );
 } catch ( ... ) {
 for (; _Next != _First; ++ _Next )
  _Destroy ( & * _Next );
 throw;
 }
 }
#line 493
template < class _Ty,
 class _Tval > inline
 void _Uninit_fill ( _Ty * _First, _Ty * _Last, const _Tval & _Val,
  _Scalar_ptr_iterator_tag )
 {
 :: std :: fill ( _First, _Last, _Val );
 }
#line 501
template < class _FwdIt,
 class _Tval > inline
 void uninitialized_fill ( _FwdIt _First, _FwdIt _Last, const _Tval & _Val )
 {
 _Uninit_fill ( _First, _Last, _Val, _Ptr_cat ( _First, _First ) );
 }
#line 509
template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 void _Uninit_fill_n ( _FwdIt _First, _Diff _Count, const _Tval & _Val,
  _Nonscalar_ptr_iterator_tag )
 {





 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; -- _Count, ++ _First )
  _Construct ( & * _First, _Val );
 } catch ( ... ) {
 for (; _Next != _First; ++ _Next )
  _Destroy ( & * _Next );
 throw;
 }
 }
#line 532 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
template < class _Ty,
 class _Diff,
 class _Tval > inline
 void _Uninit_fill_n ( _Ty * _First, _Diff _Count, const _Tval & _Val,
  _Scalar_ptr_iterator_tag )
 {
 :: std :: _Fill_n ( _First, _Count, _Val );
 }
#line 541
template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 void uninitialized_fill_n ( _FwdIt _First, _Diff _Count, const _Tval & _Val )
 {
 _Uninit_fill_n ( _First, _Count, _Val, _Ptr_cat ( _First, _First ) );
 }
#line 550
template < class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc,
 class _Valty > inline
 void _Uninit_fill_n ( _FwdIt _First, _Diff _Count,
  const _Tval * _Pval, _Alloc & _Al,
   _Valty *, _Nonscalar_ptr_iterator_tag )
 {





 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; -- _Count, ++ _First )
  _Cons_val ( _Al, _First, * _Pval );
 } catch ( ... ) {
 for (; _Next != _First; ++ _Next )
  _Dest_val ( _Al, _Next );
 throw;
 }
 }
#line 576 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
template < class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc,
 class _Valty > inline
 void _Uninit_fill_n ( _FwdIt _First, _Diff _Count,
  const _Tval * _Pval, _Alloc & _Al,
   _Valty *, _Scalar_ptr_iterator_tag )
 {
 _Uninit_fill_n ( _First, _Count,
  _Pval, _Al, ( _Valty * ) 0, _Nonscalar_ptr_iterator_tag ( ) );
 }
#line 589
template < class _Ty,
 class _Diff,
 class _Tval,
 class _Valty > inline
 void _Uninit_fill_n ( _Ty * _First, _Diff _Count,
  const _Tval * _Pval, allocator < _Ty > &,
   _Valty *, _Scalar_ptr_iterator_tag )
 {
 _Fill_n ( _First, _Count, * _Pval );
 }
#line 600
template < class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc > inline
 void _Uninitialized_fill_n ( _FwdIt _First, _Diff _Count,
  const _Tval * _Pval, _Alloc & _Al )
 {
 _Uninit_fill_n ( _First, _Count, _Pval, _Al,
  _Val_type ( _First ), _Ptr_cat ( _First, _First ) );
 }
#line 612
template < class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc,
 class _Valty > inline
 void _Uninit_def_fill_n ( _FwdIt _First, _Diff _Count,
  const _Tval *, _Alloc & _Al,
   _Valty *, _Nonscalar_ptr_iterator_tag )
 {





 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; -- _Count, ++ _First )

  _Cons_val ( _Al, _First, _Valty ( ) );

 } catch ( ... ) {
 for (; _Next != _First; ++ _Next )
  _Dest_val ( _Al, _Next );
 throw;
 }
 }
#line 640 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
template < class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc,
 class _Valty > inline
 void _Uninit_def_fill_n ( _FwdIt _First, _Diff _Count,
  const _Tval * _Pval, _Alloc & _Al,
   _Valty *, _Scalar_ptr_iterator_tag )
 {
 _Uninit_def_fill_n ( _First, _Count,
  _Pval, _Al, ( _Valty * ) 0, _Nonscalar_ptr_iterator_tag ( ) );
 }
#line 653
template < class _Ty,
 class _Diff,
 class _Tval,
 class _Valty > inline
 void _Uninit_def_fill_n ( _Ty * _First, _Diff _Count,
  const _Tval *, allocator < _Ty > &,
   _Valty *, _Scalar_ptr_iterator_tag )
 {
 _Fill_n ( _First, _Count, ( _Valty ) 0 );
 }
#line 664
template < class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc > inline
 void _Uninitialized_default_fill_n ( _FwdIt _First, _Diff _Count,
  const _Tval * _Pval, _Alloc & _Al )
 {
 _Uninit_def_fill_n ( _First, _Count, _Pval, _Al,
  _Val_type ( _First ), _Ptr_cat ( _First, _First ) );
 }
#line 676
template < class _FwdIt,
 class _Ty >
 class raw_storage_iterator
  : public _Outit
 {
public :
 typedef _FwdIt iterator_type;
 typedef _FwdIt iter_type;
 typedef _Ty element_type;

 explicit raw_storage_iterator ( _FwdIt _First )
  : _Next ( _First )
  {
  }

 raw_storage_iterator < _FwdIt, _Ty > & operator * ( )
  {
  return ( * this );
  }

 raw_storage_iterator < _FwdIt, _Ty > & operator = ( const _Ty & _Val )
  {
  _Construct ( & * _Next, _Val );
  return ( * this );
  }

 raw_storage_iterator < _FwdIt, _Ty > & operator ++ ( )
  {
  ++ _Next;
  return ( * this );
  }

 raw_storage_iterator < _FwdIt, _Ty > operator ++ ( int )
  {
  raw_storage_iterator < _FwdIt, _Ty > _Ans = * this;
  ++ _Next;
  return ( _Ans );
  }

private :
 _FwdIt _Next;
 };
#line 720
template < class _Ty >
 class _Temp_iterator
  : public _Outit
 {
public :
 typedef _Ty * _Pty;

 _Temp_iterator ( ptrdiff_t _Count = 0 )
  {
  _Buf . _Begin = 0;
  _Buf . _Current = 0;
  _Buf . _Hiwater = 0;
  _Buf . _Size = _Count;
  _Pbuf = & _Buf;
  }

 _Temp_iterator ( const _Temp_iterator < _Ty > & _Right )
  {
  _Buf . _Begin = 0;
  _Buf . _Current = 0;
  _Buf . _Hiwater = 0;
  _Buf . _Size = 0;
  * this = _Right;
  }

 ~ _Temp_iterator ( )
  {
  if ( _Buf . _Begin != 0 )
   {
   for ( _Pty _Next = _Buf . _Begin;
    _Next != _Buf . _Hiwater; ++ _Next )
    _Destroy ( & * _Next );
   :: std :: return_temporary_buffer ( _Buf . _Begin );
   }
  }

 _Temp_iterator < _Ty > & operator = ( const _Temp_iterator < _Ty > & _Right )
  {
  _Pbuf = _Right . _Pbuf;
  return ( * this );
  }

 _Temp_iterator < _Ty > & operator = ( const _Ty & _Val )
  {
  if ( _Pbuf -> _Current < _Pbuf -> _Hiwater )
   * _Pbuf -> _Current ++ = _Val;
  else
   {
   _Pty _Ptr = & * _Pbuf -> _Current;
   _Construct ( _Ptr, _Val );
   _Pbuf -> _Hiwater = ++ _Pbuf -> _Current;
   }
  return ( * this );
  }

 _Temp_iterator < _Ty > & operator = ( _Ty && _Val )
  {
  if ( _Pbuf -> _Current < _Pbuf -> _Hiwater )
   * _Pbuf -> _Current ++ =
    :: std :: forward < _Ty > ( _Val );
  else
   {
   _Pty _Ptr = & * _Pbuf -> _Current;
   _Construct ( _Ptr, :: std :: forward < _Ty > ( _Val ) );
   _Pbuf -> _Hiwater = ++ _Pbuf -> _Current;
   }
  return ( * this );
  }

 _Temp_iterator < _Ty > & operator * ( )
  {
  return ( * this );
  }

 _Temp_iterator < _Ty > & operator ++ ( )
  {
  return ( * this );
  }

 _Temp_iterator < _Ty > & operator ++ ( int )
  {
  return ( * this );
  }

 _Temp_iterator < _Ty > & _Init ( )
  {
  _Pbuf -> _Current = _Pbuf -> _Begin;
  return ( * this );
  }

 _Pty _First ( ) const
  {
  return ( _Pbuf -> _Begin );
  }

 _Pty _Last ( ) const
  {
  return ( _Pbuf -> _Current );
  }

 ptrdiff_t _Maxlen ( )
  {
  if ( _Pbuf -> _Begin == 0 && 0 < _Pbuf -> _Size )
   {
   pair < _Pty, ptrdiff_t > _Pair =

    :: std :: get_temporary_buffer < _Ty > ( _Pbuf -> _Size );

   _Pbuf -> _Begin = _Pair . first;
   _Pbuf -> _Current = _Pair . first;
   _Pbuf -> _Hiwater = _Pair . first;
   _Pbuf -> _Size = _Pair . second;
   }
  return ( _Pbuf -> _Size );
  }

private :
 struct _Bufpar
  {
  _Pty _Begin;
  _Pty _Current;
  _Pty _Hiwater;
  ptrdiff_t _Size;
  };
 _Bufpar _Buf;
 _Bufpar * _Pbuf;
 };
#line 849
template < class _Ty >
 class auto_ptr;
#line 852
template < class _Ty >
 struct auto_ptr_ref
  {
 explicit auto_ptr_ref ( _Ty * _Right )
  : _Ref ( _Right )
  {
  }

 _Ty * _Ref;
 };
#line 863
template < class _Ty >
 class auto_ptr
  {
public :
 typedef auto_ptr < _Ty > _Myt;
 typedef _Ty element_type;

 explicit auto_ptr ( _Ty * _Ptr = 0 ) throw ( )
  : _Myptr ( _Ptr )
  {
  }

 auto_ptr ( _Myt & _Right ) throw ( )
  : _Myptr ( _Right . release ( ) )
  {
  }

 auto_ptr ( auto_ptr_ref < _Ty > _Right ) throw ( )
  {
  _Ty * _Ptr = _Right . _Ref;
  _Right . _Ref = 0;
  _Myptr = _Ptr;
  }

 template < class _Other >
  operator auto_ptr < _Other > ( ) throw ( )
  {
  return ( auto_ptr < _Other > ( * this ) );
  }

 template < class _Other >
  operator auto_ptr_ref < _Other > ( ) throw ( )
  {
  _Other * _Cvtptr = _Myptr;
  auto_ptr_ref < _Other > _Ans ( _Cvtptr );
  _Myptr = 0;
  return ( _Ans );
  }

 template < class _Other >
  _Myt & operator = ( auto_ptr < _Other > & _Right ) throw ( )
  {
  reset ( _Right . release ( ) );
  return ( * this );
  }

 template < class _Other >
  auto_ptr ( auto_ptr < _Other > & _Right ) throw ( )
  : _Myptr ( _Right . release ( ) )
  {
  }

 _Myt & operator = ( _Myt & _Right ) throw ( )
  {
  reset ( _Right . release ( ) );
  return ( * this );
  }

 _Myt & operator = ( auto_ptr_ref < _Ty > _Right ) throw ( )
  {
  _Ty * _Ptr = _Right . _Ref;
  _Right . _Ref = 0;
  reset ( _Ptr );
  return ( * this );
  }

 ~ auto_ptr ( )
  {
  delete _Myptr;
  }

 _Ty & operator * ( ) const throw ( )
  {





  return ( * get ( ) );
  }

 _Ty * operator -> ( ) const throw ( )
  {





  return ( get ( ) );
  }

 _Ty * get ( ) const throw ( )
  {
  return ( _Myptr );
  }

 _Ty * release ( ) throw ( )
  {
  _Ty * _Tmp = _Myptr;
  _Myptr = 0;
  return ( _Tmp );
  }

 void reset ( _Ty * _Ptr = 0 )
  {
  if ( _Ptr != _Myptr )
   delete _Myptr;
  _Myptr = _Ptr;
  }

private :
 _Ty * _Myptr;
 };
#line 976 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
}
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\typeinfo"
#pragma pack ( push, 8 )
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\typeinfo"
struct __type_info_node { 
#line 37
void *_MemPtr; 
#line 38
__type_info_node *_Next; 
#line 39
}; 
#line 41
extern __type_info_node __type_info_root_node; 
#line 43
class type_info { 
#line 46
public: size_t hash_code() const throw() 
#line 47
{ 
#line 48
const char *_Keyval = this->name(); 
#line 49
size_t _Val = (2166136261U); 
#line 50
size_t _First = (0); 
#line 51
size_t _Last = ::strlen(_Keyval); 
#line 52
size_t _Stride = (1) + (_Last / (10)); 
#line 54
for (; _First < _Last; _First += _Stride) { 
#line 55
_Val = (((16777619U) * _Val) ^ ((size_t)(_Keyval[_First]))); }  
#line 56
return _Val; 
#line 57
} 
#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\typeinfo"
virtual ~type_info(); 
#line 64
__declspec(dllimport) bool operator==(const type_info & ) const; 
#line 65
__declspec(dllimport) bool operator!=(const type_info & ) const; 
#line 66
__declspec(dllimport) int before(const type_info & ) const; 
#line 67
__declspec(dllimport) const char *name(__type_info_node *  = &__type_info_root_node) const; 
#line 68
__declspec(dllimport) const char *raw_name() const; 
#line 70
private: void *_M_data; 
#line 71
char _M_d_name[1]; 
#line 72
type_info(const type_info & ); 
#line 73
type_info &operator=(const type_info & ); 
#line 74
__declspec(dllimport) static const char *__cdecl _Name_base(const type_info *, __type_info_node * ); 
#line 75
__declspec(dllimport) static void __cdecl _Type_info_dtor(type_info *); 
#line 76
}; 
#line 80
namespace std { 
#line 82
using ::type_info;
#line 84
}
#line 90
namespace std { 
#line 92
class __declspec(dllimport) bad_cast : public exception { 
#line 104
public: bad_cast(const char *  = "bad cast"); 
#line 105
bad_cast(const bad_cast &); 
#line 106
virtual ~bad_cast(); 
#line 108 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\typeinfo"
}; 
#line 110
class __declspec(dllimport) bad_typeid : public exception { 
#line 122
public: bad_typeid(const char *  = "bad typeid"); 
#line 123
bad_typeid(const bad_typeid &); 
#line 124
virtual ~bad_typeid(); 
#line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\typeinfo"
}; 
#line 129
class __declspec(dllimport) __non_rtti_object : public bad_typeid { 
#line 141
public: __non_rtti_object(const char * ); 
#line 142
__non_rtti_object(const __non_rtti_object &); 
#line 143
virtual ~__non_rtti_object(); 
#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\typeinfo"
}; 
#line 147
}
#line 210 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\typeinfo"
#pragma pack ( pop )
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\setjmp.h"
#pragma pack ( push, 8 )
#line 195 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\setjmp.h"
extern "C" { typedef 
#line 193
struct __declspec(align(16)) _SETJMP_FLOAT128 { 
#line 194
unsigned __int64 Part[2]; 
#line 195
} SETJMP_FLOAT128; }
#line 198
extern "C" { typedef SETJMP_FLOAT128 _JBTYPE; }
#line 228 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\setjmp.h"
extern "C" { typedef 
#line 204
struct _JUMP_BUFFER { 
#line 205
unsigned __int64 Frame; 
#line 206
unsigned __int64 Rbx; 
#line 207
unsigned __int64 Rsp; 
#line 208
unsigned __int64 Rbp; 
#line 209
unsigned __int64 Rsi; 
#line 210
unsigned __int64 Rdi; 
#line 211
unsigned __int64 R12; 
#line 212
unsigned __int64 R13; 
#line 213
unsigned __int64 R14; 
#line 214
unsigned __int64 R15; 
#line 215
unsigned __int64 Rip; 
#line 216
unsigned __int64 Spare; 
#line 218
SETJMP_FLOAT128 Xmm6; 
#line 219
SETJMP_FLOAT128 Xmm7; 
#line 220
SETJMP_FLOAT128 Xmm8; 
#line 221
SETJMP_FLOAT128 Xmm9; 
#line 222
SETJMP_FLOAT128 Xmm10; 
#line 223
SETJMP_FLOAT128 Xmm11; 
#line 224
SETJMP_FLOAT128 Xmm12; 
#line 225
SETJMP_FLOAT128 Xmm13; 
#line 226
SETJMP_FLOAT128 Xmm14; 
#line 227
SETJMP_FLOAT128 Xmm15; 
#line 228
} _JUMP_BUFFER; }
#line 236 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\setjmp.h"
extern "C" { typedef _JBTYPE jmp_buf[16]; }
#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\setjmp.h"
extern "C" { int __cdecl _setjmp(jmp_buf ); } 
#line 252 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\setjmp.h"
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl longjmp(jmp_buf , int ) throw(...); } 
#line 258 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\setjmp.h"
#pragma pack ( pop )
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\mmintrin.h"
extern "C" { typedef 
#line 31
union __declspec(intrin_type) __declspec(align(8)) __m64 { 
#line 33
unsigned __int64 m64_u64; 
#line 34
float m64_f32[2]; 
#line 35
char m64_i8[8]; 
#line 36
short m64_i16[4]; 
#line 37
int m64_i32[2]; 
#line 38
__int64 m64_i64; 
#line 39
unsigned char m64_u8[8]; 
#line 40
unsigned short m64_u16[4]; 
#line 41
unsigned m64_u32[2]; 
#line 42
} __m64; }
#line 45
extern "C" { void _m_empty(); } 
#line 46
extern "C" { __m64 _m_from_int(int ); } 
#line 47
extern "C" { int _m_to_int(__m64 ); } 
#line 48
extern "C" { __m64 _m_packsswb(__m64 , __m64 ); } 
#line 49
extern "C" { __m64 _m_packssdw(__m64 , __m64 ); } 
#line 50
extern "C" { __m64 _m_packuswb(__m64 , __m64 ); } 
#line 51
extern "C" { __m64 _m_punpckhbw(__m64 , __m64 ); } 
#line 52
extern "C" { __m64 _m_punpckhwd(__m64 , __m64 ); } 
#line 53
extern "C" { __m64 _m_punpckhdq(__m64 , __m64 ); } 
#line 54
extern "C" { __m64 _m_punpcklbw(__m64 , __m64 ); } 
#line 55
extern "C" { __m64 _m_punpcklwd(__m64 , __m64 ); } 
#line 56
extern "C" { __m64 _m_punpckldq(__m64 , __m64 ); } 
#line 59
extern "C" { __m64 _m_paddb(__m64 , __m64 ); } 
#line 60
extern "C" { __m64 _m_paddw(__m64 , __m64 ); } 
#line 61
extern "C" { __m64 _m_paddd(__m64 , __m64 ); } 
#line 62
extern "C" { __m64 _m_paddsb(__m64 , __m64 ); } 
#line 63
extern "C" { __m64 _m_paddsw(__m64 , __m64 ); } 
#line 64
extern "C" { __m64 _m_paddusb(__m64 , __m64 ); } 
#line 65
extern "C" { __m64 _m_paddusw(__m64 , __m64 ); } 
#line 66
extern "C" { __m64 _m_psubb(__m64 , __m64 ); } 
#line 67
extern "C" { __m64 _m_psubw(__m64 , __m64 ); } 
#line 68
extern "C" { __m64 _m_psubd(__m64 , __m64 ); } 
#line 69
extern "C" { __m64 _m_psubsb(__m64 , __m64 ); } 
#line 70
extern "C" { __m64 _m_psubsw(__m64 , __m64 ); } 
#line 71
extern "C" { __m64 _m_psubusb(__m64 , __m64 ); } 
#line 72
extern "C" { __m64 _m_psubusw(__m64 , __m64 ); } 
#line 73
extern "C" { __m64 _m_pmaddwd(__m64 , __m64 ); } 
#line 74
extern "C" { __m64 _m_pmulhw(__m64 , __m64 ); } 
#line 75
extern "C" { __m64 _m_pmullw(__m64 , __m64 ); } 
#line 78
extern "C" { __m64 _m_psllw(__m64 , __m64 ); } 
#line 79
extern "C" { __m64 _m_psllwi(__m64 , int ); } 
#line 80
extern "C" { __m64 _m_pslld(__m64 , __m64 ); } 
#line 81
extern "C" { __m64 _m_pslldi(__m64 , int ); } 
#line 82
extern "C" { __m64 _m_psllq(__m64 , __m64 ); } 
#line 83
extern "C" { __m64 _m_psllqi(__m64 , int ); } 
#line 84
extern "C" { __m64 _m_psraw(__m64 , __m64 ); } 
#line 85
extern "C" { __m64 _m_psrawi(__m64 , int ); } 
#line 86
extern "C" { __m64 _m_psrad(__m64 , __m64 ); } 
#line 87
extern "C" { __m64 _m_psradi(__m64 , int ); } 
#line 88
extern "C" { __m64 _m_psrlw(__m64 , __m64 ); } 
#line 89
extern "C" { __m64 _m_psrlwi(__m64 , int ); } 
#line 90
extern "C" { __m64 _m_psrld(__m64 , __m64 ); } 
#line 91
extern "C" { __m64 _m_psrldi(__m64 , int ); } 
#line 92
extern "C" { __m64 _m_psrlq(__m64 , __m64 ); } 
#line 93
extern "C" { __m64 _m_psrlqi(__m64 , int ); } 
#line 96
extern "C" { __m64 _m_pand(__m64 , __m64 ); } 
#line 97
extern "C" { __m64 _m_pandn(__m64 , __m64 ); } 
#line 98
extern "C" { __m64 _m_por(__m64 , __m64 ); } 
#line 99
extern "C" { __m64 _m_pxor(__m64 , __m64 ); } 
#line 102
extern "C" { __m64 _m_pcmpeqb(__m64 , __m64 ); } 
#line 103
extern "C" { __m64 _m_pcmpeqw(__m64 , __m64 ); } 
#line 104
extern "C" { __m64 _m_pcmpeqd(__m64 , __m64 ); } 
#line 105
extern "C" { __m64 _m_pcmpgtb(__m64 , __m64 ); } 
#line 106
extern "C" { __m64 _m_pcmpgtw(__m64 , __m64 ); } 
#line 107
extern "C" { __m64 _m_pcmpgtd(__m64 , __m64 ); } 
#line 110
extern "C" { __m64 _mm_setzero_si64(); } 
#line 111
extern "C" { __m64 _mm_set_pi32(int , int ); } 
#line 112
extern "C" { __m64 _mm_set_pi16(short , short , short , short ); } 
#line 113
extern "C" { __m64 _mm_set_pi8(char , char , char , char , char , char , char , char ); } 
#line 115
extern "C" { __m64 _mm_set1_pi32(int ); } 
#line 116
extern "C" { __m64 _mm_set1_pi16(short ); } 
#line 117
extern "C" { __m64 _mm_set1_pi8(char ); } 
#line 118
extern "C" { __m64 _mm_setr_pi32(int , int ); } 
#line 119
extern "C" { __m64 _mm_setr_pi16(short , short , short , short ); } 
#line 120
extern "C" { __m64 _mm_setr_pi8(char , char , char , char , char , char , char , char ); } 
#line 70 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xmmintrin.h"
typedef 
#line 60
union __declspec(intrin_type) __declspec(align(16)) __m128 { 
#line 61
float m128_f32[4]; 
#line 62
unsigned __int64 m128_u64[2]; 
#line 63
char m128_i8[16]; 
#line 64
short m128_i16[8]; 
#line 65
int m128_i32[4]; 
#line 66
__int64 m128_i64[2]; 
#line 67
unsigned char m128_u8[16]; 
#line 68
unsigned short m128_u16[8]; 
#line 69
unsigned m128_u32[4]; 
#line 70
} __m128; 
#line 186 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xmmintrin.h"
extern "C" { extern __m128 _mm_add_ss(__m128 , __m128 ); } 
#line 187
extern "C" { extern __m128 _mm_add_ps(__m128 , __m128 ); } 
#line 188
extern "C" { extern __m128 _mm_sub_ss(__m128 , __m128 ); } 
#line 189
extern "C" { extern __m128 _mm_sub_ps(__m128 , __m128 ); } 
#line 190
extern "C" { extern __m128 _mm_mul_ss(__m128 , __m128 ); } 
#line 191
extern "C" { extern __m128 _mm_mul_ps(__m128 , __m128 ); } 
#line 192
extern "C" { extern __m128 _mm_div_ss(__m128 , __m128 ); } 
#line 193
extern "C" { extern __m128 _mm_div_ps(__m128 , __m128 ); } 
#line 194
extern "C" { extern __m128 _mm_sqrt_ss(__m128 ); } 
#line 195
extern "C" { extern __m128 _mm_sqrt_ps(__m128 ); } 
#line 196
extern "C" { extern __m128 _mm_rcp_ss(__m128 ); } 
#line 197
extern "C" { extern __m128 _mm_rcp_ps(__m128 ); } 
#line 198
extern "C" { extern __m128 _mm_rsqrt_ss(__m128 ); } 
#line 199
extern "C" { extern __m128 _mm_rsqrt_ps(__m128 ); } 
#line 200
extern "C" { extern __m128 _mm_min_ss(__m128 , __m128 ); } 
#line 201
extern "C" { extern __m128 _mm_min_ps(__m128 , __m128 ); } 
#line 202
extern "C" { extern __m128 _mm_max_ss(__m128 , __m128 ); } 
#line 203
extern "C" { extern __m128 _mm_max_ps(__m128 , __m128 ); } 
#line 209
extern "C" { extern __m128 _mm_and_ps(__m128 , __m128 ); } 
#line 210
extern "C" { extern __m128 _mm_andnot_ps(__m128 , __m128 ); } 
#line 211
extern "C" { extern __m128 _mm_or_ps(__m128 , __m128 ); } 
#line 212
extern "C" { extern __m128 _mm_xor_ps(__m128 , __m128 ); } 
#line 218
extern "C" { extern __m128 _mm_cmpeq_ss(__m128 , __m128 ); } 
#line 219
extern "C" { extern __m128 _mm_cmpeq_ps(__m128 , __m128 ); } 
#line 220
extern "C" { extern __m128 _mm_cmplt_ss(__m128 , __m128 ); } 
#line 221
extern "C" { extern __m128 _mm_cmplt_ps(__m128 , __m128 ); } 
#line 222
extern "C" { extern __m128 _mm_cmple_ss(__m128 , __m128 ); } 
#line 223
extern "C" { extern __m128 _mm_cmple_ps(__m128 , __m128 ); } 
#line 224
extern "C" { extern __m128 _mm_cmpgt_ss(__m128 , __m128 ); } 
#line 225
extern "C" { extern __m128 _mm_cmpgt_ps(__m128 , __m128 ); } 
#line 226
extern "C" { extern __m128 _mm_cmpge_ss(__m128 , __m128 ); } 
#line 227
extern "C" { extern __m128 _mm_cmpge_ps(__m128 , __m128 ); } 
#line 228
extern "C" { extern __m128 _mm_cmpneq_ss(__m128 , __m128 ); } 
#line 229
extern "C" { extern __m128 _mm_cmpneq_ps(__m128 , __m128 ); } 
#line 230
extern "C" { extern __m128 _mm_cmpnlt_ss(__m128 , __m128 ); } 
#line 231
extern "C" { extern __m128 _mm_cmpnlt_ps(__m128 , __m128 ); } 
#line 232
extern "C" { extern __m128 _mm_cmpnle_ss(__m128 , __m128 ); } 
#line 233
extern "C" { extern __m128 _mm_cmpnle_ps(__m128 , __m128 ); } 
#line 234
extern "C" { extern __m128 _mm_cmpngt_ss(__m128 , __m128 ); } 
#line 235
extern "C" { extern __m128 _mm_cmpngt_ps(__m128 , __m128 ); } 
#line 236
extern "C" { extern __m128 _mm_cmpnge_ss(__m128 , __m128 ); } 
#line 237
extern "C" { extern __m128 _mm_cmpnge_ps(__m128 , __m128 ); } 
#line 238
extern "C" { extern __m128 _mm_cmpord_ss(__m128 , __m128 ); } 
#line 239
extern "C" { extern __m128 _mm_cmpord_ps(__m128 , __m128 ); } 
#line 240
extern "C" { extern __m128 _mm_cmpunord_ss(__m128 , __m128 ); } 
#line 241
extern "C" { extern __m128 _mm_cmpunord_ps(__m128 , __m128 ); } 
#line 242
extern "C" { extern int _mm_comieq_ss(__m128 , __m128 ); } 
#line 243
extern "C" { extern int _mm_comilt_ss(__m128 , __m128 ); } 
#line 244
extern "C" { extern int _mm_comile_ss(__m128 , __m128 ); } 
#line 245
extern "C" { extern int _mm_comigt_ss(__m128 , __m128 ); } 
#line 246
extern "C" { extern int _mm_comige_ss(__m128 , __m128 ); } 
#line 247
extern "C" { extern int _mm_comineq_ss(__m128 , __m128 ); } 
#line 248
extern "C" { extern int _mm_ucomieq_ss(__m128 , __m128 ); } 
#line 249
extern "C" { extern int _mm_ucomilt_ss(__m128 , __m128 ); } 
#line 250
extern "C" { extern int _mm_ucomile_ss(__m128 , __m128 ); } 
#line 251
extern "C" { extern int _mm_ucomigt_ss(__m128 , __m128 ); } 
#line 252
extern "C" { extern int _mm_ucomige_ss(__m128 , __m128 ); } 
#line 253
extern "C" { extern int _mm_ucomineq_ss(__m128 , __m128 ); } 
#line 259
extern "C" { extern int _mm_cvt_ss2si(__m128 ); } 
#line 260
extern "C" { extern __m64 _mm_cvt_ps2pi(__m128 ); } 
#line 261
extern "C" { extern int _mm_cvtt_ss2si(__m128 ); } 
#line 262
extern "C" { extern __m64 _mm_cvtt_ps2pi(__m128 ); } 
#line 263
extern "C" { extern __m128 _mm_cvt_si2ss(__m128, int); } 
#line 264
extern "C" { extern __m128 _mm_cvt_pi2ps(__m128, __m64); } 
#line 265
extern "C" { extern float _mm_cvtss_f32(__m128 ); } 
#line 271
extern "C" { extern __int64 _mm_cvtss_si64(__m128 ); } 
#line 272
extern "C" { extern __int64 _mm_cvttss_si64(__m128 ); } 
#line 273
extern "C" { extern __m128 _mm_cvtsi64_ss(__m128 , __int64 ); } 
#line 280 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xmmintrin.h"
extern "C" { extern __m128 _mm_shuffle_ps(__m128 , __m128 , unsigned ); } 
#line 281
extern "C" { extern __m128 _mm_unpackhi_ps(__m128 , __m128 ); } 
#line 282
extern "C" { extern __m128 _mm_unpacklo_ps(__m128 , __m128 ); } 
#line 283
extern "C" { extern __m128 _mm_loadh_pi(__m128, const __m64 *); } 
#line 284
extern "C" { extern __m128 _mm_movehl_ps(__m128, __m128); } 
#line 285
extern "C" { extern __m128 _mm_movelh_ps(__m128, __m128); } 
#line 286
extern "C" { extern void _mm_storeh_pi(__m64 *, __m128); } 
#line 287
extern "C" { extern __m128 _mm_loadl_pi(__m128, const __m64 *); } 
#line 288
extern "C" { extern void _mm_storel_pi(__m64 *, __m128); } 
#line 289
extern "C" { extern int _mm_movemask_ps(__m128 ); } 
#line 295
extern "C" { extern int _m_pextrw(__m64, int); } 
#line 296
extern "C" { extern __m64 _m_pinsrw(__m64, int, int); } 
#line 297
extern "C" { extern __m64 _m_pmaxsw(__m64, __m64); } 
#line 298
extern "C" { extern __m64 _m_pmaxub(__m64, __m64); } 
#line 299
extern "C" { extern __m64 _m_pminsw(__m64, __m64); } 
#line 300
extern "C" { extern __m64 _m_pminub(__m64, __m64); } 
#line 301
extern "C" { extern int _m_pmovmskb(__m64); } 
#line 302
extern "C" { extern __m64 _m_pmulhuw(__m64, __m64); } 
#line 303
extern "C" { extern __m64 _m_pshufw(__m64, int); } 
#line 304
extern "C" { extern void _m_maskmovq(__m64, __m64, char *); } 
#line 305
extern "C" { extern __m64 _m_pavgb(__m64, __m64); } 
#line 306
extern "C" { extern __m64 _m_pavgw(__m64, __m64); } 
#line 307
extern "C" { extern __m64 _m_psadbw(__m64, __m64); } 
#line 313
extern "C" { extern __m128 _mm_set_ss(float ); } 
#line 314
extern "C" { extern __m128 _mm_set_ps1(float ); } 
#line 315
extern "C" { extern __m128 _mm_set_ps(float , float , float , float ); } 
#line 316
extern "C" { extern __m128 _mm_setr_ps(float , float , float , float ); } 
#line 317
extern "C" { extern __m128 _mm_setzero_ps(); } 
#line 318
extern "C" { extern __m128 _mm_load_ss(const float * ); } 
#line 319
extern "C" { extern __m128 _mm_load_ps1(const float * ); } 
#line 320
extern "C" { extern __m128 _mm_load_ps(const float * ); } 
#line 321
extern "C" { extern __m128 _mm_loadr_ps(const float * ); } 
#line 322
extern "C" { extern __m128 _mm_loadu_ps(const float * ); } 
#line 323
extern "C" { extern void _mm_store_ss(float * , __m128 ); } 
#line 324
extern "C" { extern void _mm_store_ps1(float * , __m128 ); } 
#line 325
extern "C" { extern void _mm_store_ps(float * , __m128 ); } 
#line 326
extern "C" { extern void _mm_storer_ps(float * , __m128 ); } 
#line 327
extern "C" { extern void _mm_storeu_ps(float * , __m128 ); } 
#line 328
extern "C" { extern void _mm_prefetch(const char * , int ); } 
#line 329
extern "C" { extern void _mm_stream_pi(__m64 *, __m64); } 
#line 330
extern "C" { extern void _mm_stream_ps(float *, __m128); } 
#line 331
extern "C" { extern __m128 _mm_move_ss(__m128 , __m128 ); } 
#line 333
extern "C" { extern void _mm_sfence(); } 
#line 334
extern "C" { extern unsigned _mm_getcsr(); } 
#line 335
extern "C" { extern void _mm_setcsr(unsigned); } 
#line 378
extern "C" { __inline __m128 _mm_cvtpi16_ps(__m64 a) 
#line 379
{ 
#line 380
__m128 tmp; 
#line 381
__m64 ext_val = _m_pcmpgtw(_mm_setzero_si64(), a); 
#line 383
tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(a, ext_val)); 
#line 384
return _mm_cvt_pi2ps(_mm_movelh_ps(tmp, tmp), _m_punpcklwd(a, ext_val)); 
#line 386
} } 
#line 397
extern "C" { __inline __m128 _mm_cvtpu16_ps(__m64 a) 
#line 398
{ 
#line 399
__m128 tmp; 
#line 400
__m64 ext_val = _mm_setzero_si64(); 
#line 402
tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(a, ext_val)); 
#line 403
return _mm_cvt_pi2ps(_mm_movelh_ps(tmp, tmp), _m_punpcklwd(a, ext_val)); 
#line 405
} } 
#line 416
extern "C" { __inline __m64 _mm_cvtps_pi16(__m128 a) 
#line 417
{ 
#line 418
return _m_packssdw(_mm_cvt_ps2pi(a), _mm_cvt_ps2pi(_mm_movehl_ps(a, a))); 
#line 420
} } 
#line 431
extern "C" { __inline __m128 _mm_cvtpi8_ps(__m64 a) 
#line 432
{ 
#line 433
__m64 ext_val = _m_pcmpgtb(_mm_setzero_si64(), a); 
#line 435
return _mm_cvtpi16_ps(_m_punpcklbw(a, ext_val)); 
#line 436
} } 
#line 448
extern "C" { __inline __m128 _mm_cvtpu8_ps(__m64 a) 
#line 449
{ 
#line 450
return _mm_cvtpu16_ps(_m_punpcklbw(a, _mm_setzero_si64())); 
#line 451
} } 
#line 462
extern "C" { __inline __m64 _mm_cvtps_pi8(__m128 a) 
#line 463
{ 
#line 464
return _m_packsswb(_mm_cvtps_pi16(a), _mm_setzero_si64()); 
#line 465
} } 
#line 477
extern "C" { __inline __m128 _mm_cvtpi32x2_ps(__m64 a, __m64 b) 
#line 478
{ 
#line 479
return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), a), _mm_cvt_pi2ps(_mm_setzero_ps(), b)); 
#line 481
} } 
#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\emmintrin.h"
typedef 
#line 35
union __declspec(intrin_type) __declspec(align(16)) __m128i { 
#line 36
char m128i_i8[16]; 
#line 37
short m128i_i16[8]; 
#line 38
int m128i_i32[4]; 
#line 39
__int64 m128i_i64[2]; 
#line 40
unsigned char m128i_u8[16]; 
#line 41
unsigned short m128i_u16[8]; 
#line 42
unsigned m128i_u32[4]; 
#line 43
unsigned __int64 m128i_u64[2]; 
#line 44
} __m128i; 
#line 48
typedef 
#line 46
struct __declspec(intrin_type) __declspec(align(16)) __m128d { 
#line 47
double m128d_f64[2]; 
#line 48
} __m128d; 
#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\emmintrin.h"
extern "C" { extern __m128d _mm_add_sd(__m128d , __m128d ); } 
#line 69
extern "C" { extern __m128d _mm_add_pd(__m128d , __m128d ); } 
#line 70
extern "C" { extern __m128d _mm_sub_sd(__m128d , __m128d ); } 
#line 71
extern "C" { extern __m128d _mm_sub_pd(__m128d , __m128d ); } 
#line 72
extern "C" { extern __m128d _mm_mul_sd(__m128d , __m128d ); } 
#line 73
extern "C" { extern __m128d _mm_mul_pd(__m128d , __m128d ); } 
#line 74
extern "C" { extern __m128d _mm_sqrt_sd(__m128d , __m128d ); } 
#line 75
extern "C" { extern __m128d _mm_sqrt_pd(__m128d ); } 
#line 76
extern "C" { extern __m128d _mm_div_sd(__m128d , __m128d ); } 
#line 77
extern "C" { extern __m128d _mm_div_pd(__m128d , __m128d ); } 
#line 78
extern "C" { extern __m128d _mm_min_sd(__m128d , __m128d ); } 
#line 79
extern "C" { extern __m128d _mm_min_pd(__m128d , __m128d ); } 
#line 80
extern "C" { extern __m128d _mm_max_sd(__m128d , __m128d ); } 
#line 81
extern "C" { extern __m128d _mm_max_pd(__m128d , __m128d ); } 
#line 87
extern "C" { extern __m128d _mm_and_pd(__m128d , __m128d ); } 
#line 88
extern "C" { extern __m128d _mm_andnot_pd(__m128d , __m128d ); } 
#line 89
extern "C" { extern __m128d _mm_or_pd(__m128d , __m128d ); } 
#line 90
extern "C" { extern __m128d _mm_xor_pd(__m128d , __m128d ); } 
#line 96
extern "C" { extern __m128d _mm_cmpeq_sd(__m128d , __m128d ); } 
#line 97
extern "C" { extern __m128d _mm_cmpeq_pd(__m128d , __m128d ); } 
#line 98
extern "C" { extern __m128d _mm_cmplt_sd(__m128d , __m128d ); } 
#line 99
extern "C" { extern __m128d _mm_cmplt_pd(__m128d , __m128d ); } 
#line 100
extern "C" { extern __m128d _mm_cmple_sd(__m128d , __m128d ); } 
#line 101
extern "C" { extern __m128d _mm_cmple_pd(__m128d , __m128d ); } 
#line 102
extern "C" { extern __m128d _mm_cmpgt_sd(__m128d , __m128d ); } 
#line 103
extern "C" { extern __m128d _mm_cmpgt_pd(__m128d , __m128d ); } 
#line 104
extern "C" { extern __m128d _mm_cmpge_sd(__m128d , __m128d ); } 
#line 105
extern "C" { extern __m128d _mm_cmpge_pd(__m128d , __m128d ); } 
#line 106
extern "C" { extern __m128d _mm_cmpneq_sd(__m128d , __m128d ); } 
#line 107
extern "C" { extern __m128d _mm_cmpneq_pd(__m128d , __m128d ); } 
#line 108
extern "C" { extern __m128d _mm_cmpnlt_sd(__m128d , __m128d ); } 
#line 109
extern "C" { extern __m128d _mm_cmpnlt_pd(__m128d , __m128d ); } 
#line 110
extern "C" { extern __m128d _mm_cmpnle_sd(__m128d , __m128d ); } 
#line 111
extern "C" { extern __m128d _mm_cmpnle_pd(__m128d , __m128d ); } 
#line 112
extern "C" { extern __m128d _mm_cmpngt_sd(__m128d , __m128d ); } 
#line 113
extern "C" { extern __m128d _mm_cmpngt_pd(__m128d , __m128d ); } 
#line 114
extern "C" { extern __m128d _mm_cmpnge_sd(__m128d , __m128d ); } 
#line 115
extern "C" { extern __m128d _mm_cmpnge_pd(__m128d , __m128d ); } 
#line 116
extern "C" { extern __m128d _mm_cmpord_pd(__m128d , __m128d ); } 
#line 117
extern "C" { extern __m128d _mm_cmpord_sd(__m128d , __m128d ); } 
#line 118
extern "C" { extern __m128d _mm_cmpunord_pd(__m128d , __m128d ); } 
#line 119
extern "C" { extern __m128d _mm_cmpunord_sd(__m128d , __m128d ); } 
#line 120
extern "C" { extern int _mm_comieq_sd(__m128d , __m128d ); } 
#line 121
extern "C" { extern int _mm_comilt_sd(__m128d , __m128d ); } 
#line 122
extern "C" { extern int _mm_comile_sd(__m128d , __m128d ); } 
#line 123
extern "C" { extern int _mm_comigt_sd(__m128d , __m128d ); } 
#line 124
extern "C" { extern int _mm_comige_sd(__m128d , __m128d ); } 
#line 125
extern "C" { extern int _mm_comineq_sd(__m128d , __m128d ); } 
#line 126
extern "C" { extern int _mm_ucomieq_sd(__m128d , __m128d ); } 
#line 127
extern "C" { extern int _mm_ucomilt_sd(__m128d , __m128d ); } 
#line 128
extern "C" { extern int _mm_ucomile_sd(__m128d , __m128d ); } 
#line 129
extern "C" { extern int _mm_ucomigt_sd(__m128d , __m128d ); } 
#line 130
extern "C" { extern int _mm_ucomige_sd(__m128d , __m128d ); } 
#line 131
extern "C" { extern int _mm_ucomineq_sd(__m128d , __m128d ); } 
#line 137
extern "C" { extern __m128d _mm_cvtepi32_pd(__m128i ); } 
#line 138
extern "C" { extern __m128i _mm_cvtpd_epi32(__m128d ); } 
#line 139
extern "C" { extern __m128i _mm_cvttpd_epi32(__m128d ); } 
#line 140
extern "C" { extern __m128 _mm_cvtepi32_ps(__m128i ); } 
#line 141
extern "C" { extern __m128i _mm_cvtps_epi32(__m128 ); } 
#line 142
extern "C" { extern __m128i _mm_cvttps_epi32(__m128 ); } 
#line 143
extern "C" { extern __m128 _mm_cvtpd_ps(__m128d ); } 
#line 144
extern "C" { extern __m128d _mm_cvtps_pd(__m128 ); } 
#line 145
extern "C" { extern __m128 _mm_cvtsd_ss(__m128 , __m128d ); } 
#line 146
extern "C" { extern __m128d _mm_cvtss_sd(__m128d , __m128 ); } 
#line 148
extern "C" { extern int _mm_cvtsd_si32(__m128d ); } 
#line 149
extern "C" { extern int _mm_cvttsd_si32(__m128d ); } 
#line 150
extern "C" { extern __m128d _mm_cvtsi32_sd(__m128d , int ); } 
#line 152
extern "C" { extern __m64 _mm_cvtpd_pi32(__m128d ); } 
#line 153
extern "C" { extern __m64 _mm_cvttpd_pi32(__m128d ); } 
#line 154
extern "C" { extern __m128d _mm_cvtpi32_pd(__m64 ); } 
#line 160
extern "C" { extern __m128d _mm_unpackhi_pd(__m128d , __m128d ); } 
#line 161
extern "C" { extern __m128d _mm_unpacklo_pd(__m128d , __m128d ); } 
#line 162
extern "C" { extern int _mm_movemask_pd(__m128d ); } 
#line 163
extern "C" { extern __m128d _mm_shuffle_pd(__m128d , __m128d , int ); } 
#line 169
extern "C" { extern __m128d _mm_load_pd(const double * ); } 
#line 170
extern "C" { extern __m128d _mm_load1_pd(const double * ); } 
#line 171
extern "C" { extern __m128d _mm_loadr_pd(const double * ); } 
#line 172
extern "C" { extern __m128d _mm_loadu_pd(const double * ); } 
#line 173
extern "C" { extern __m128d _mm_load_sd(const double * ); } 
#line 174
extern "C" { extern __m128d _mm_loadh_pd(__m128d , const double * ); } 
#line 175
extern "C" { extern __m128d _mm_loadl_pd(__m128d , const double * ); } 
#line 181
extern "C" { extern __m128d _mm_set_sd(double ); } 
#line 182
extern "C" { extern __m128d _mm_set1_pd(double ); } 
#line 183
extern "C" { extern __m128d _mm_set_pd(double , double ); } 
#line 184
extern "C" { extern __m128d _mm_setr_pd(double , double ); } 
#line 185
extern "C" { extern __m128d _mm_setzero_pd(); } 
#line 186
extern "C" { extern __m128d _mm_move_sd(__m128d , __m128d ); } 
#line 192
extern "C" { extern void _mm_store_sd(double * , __m128d ); } 
#line 193
extern "C" { extern void _mm_store1_pd(double * , __m128d ); } 
#line 194
extern "C" { extern void _mm_store_pd(double * , __m128d ); } 
#line 195
extern "C" { extern void _mm_storeu_pd(double * , __m128d ); } 
#line 196
extern "C" { extern void _mm_storer_pd(double * , __m128d ); } 
#line 197
extern "C" { extern void _mm_storeh_pd(double * , __m128d ); } 
#line 198
extern "C" { extern void _mm_storel_pd(double * , __m128d ); } 
#line 204
extern "C" { extern __m128i _mm_add_epi8(__m128i , __m128i ); } 
#line 205
extern "C" { extern __m128i _mm_add_epi16(__m128i , __m128i ); } 
#line 206
extern "C" { extern __m128i _mm_add_epi32(__m128i , __m128i ); } 
#line 207
extern "C" { extern __m64 _mm_add_si64(__m64 , __m64 ); } 
#line 208
extern "C" { extern __m128i _mm_add_epi64(__m128i , __m128i ); } 
#line 209
extern "C" { extern __m128i _mm_adds_epi8(__m128i , __m128i ); } 
#line 210
extern "C" { extern __m128i _mm_adds_epi16(__m128i , __m128i ); } 
#line 211
extern "C" { extern __m128i _mm_adds_epu8(__m128i , __m128i ); } 
#line 212
extern "C" { extern __m128i _mm_adds_epu16(__m128i , __m128i ); } 
#line 213
extern "C" { extern __m128i _mm_avg_epu8(__m128i , __m128i ); } 
#line 214
extern "C" { extern __m128i _mm_avg_epu16(__m128i , __m128i ); } 
#line 215
extern "C" { extern __m128i _mm_madd_epi16(__m128i , __m128i ); } 
#line 216
extern "C" { extern __m128i _mm_max_epi16(__m128i , __m128i ); } 
#line 217
extern "C" { extern __m128i _mm_max_epu8(__m128i , __m128i ); } 
#line 218
extern "C" { extern __m128i _mm_min_epi16(__m128i , __m128i ); } 
#line 219
extern "C" { extern __m128i _mm_min_epu8(__m128i , __m128i ); } 
#line 220
extern "C" { extern __m128i _mm_mulhi_epi16(__m128i , __m128i ); } 
#line 221
extern "C" { extern __m128i _mm_mulhi_epu16(__m128i , __m128i ); } 
#line 222
extern "C" { extern __m128i _mm_mullo_epi16(__m128i , __m128i ); } 
#line 223
extern "C" { extern __m64 _mm_mul_su32(__m64 , __m64 ); } 
#line 224
extern "C" { extern __m128i _mm_mul_epu32(__m128i , __m128i ); } 
#line 225
extern "C" { extern __m128i _mm_sad_epu8(__m128i , __m128i ); } 
#line 226
extern "C" { extern __m128i _mm_sub_epi8(__m128i , __m128i ); } 
#line 227
extern "C" { extern __m128i _mm_sub_epi16(__m128i , __m128i ); } 
#line 228
extern "C" { extern __m128i _mm_sub_epi32(__m128i , __m128i ); } 
#line 229
extern "C" { extern __m64 _mm_sub_si64(__m64 , __m64 ); } 
#line 230
extern "C" { extern __m128i _mm_sub_epi64(__m128i , __m128i ); } 
#line 231
extern "C" { extern __m128i _mm_subs_epi8(__m128i , __m128i ); } 
#line 232
extern "C" { extern __m128i _mm_subs_epi16(__m128i , __m128i ); } 
#line 233
extern "C" { extern __m128i _mm_subs_epu8(__m128i , __m128i ); } 
#line 234
extern "C" { extern __m128i _mm_subs_epu16(__m128i , __m128i ); } 
#line 240
extern "C" { extern __m128i _mm_and_si128(__m128i , __m128i ); } 
#line 241
extern "C" { extern __m128i _mm_andnot_si128(__m128i , __m128i ); } 
#line 242
extern "C" { extern __m128i _mm_or_si128(__m128i , __m128i ); } 
#line 243
extern "C" { extern __m128i _mm_xor_si128(__m128i , __m128i ); } 
#line 249
extern "C" { extern __m128i _mm_slli_si128(__m128i , int ); } 
#line 250
extern "C" { extern __m128i _mm_slli_epi16(__m128i , int ); } 
#line 251
extern "C" { extern __m128i _mm_sll_epi16(__m128i , __m128i ); } 
#line 252
extern "C" { extern __m128i _mm_slli_epi32(__m128i , int ); } 
#line 253
extern "C" { extern __m128i _mm_sll_epi32(__m128i , __m128i ); } 
#line 254
extern "C" { extern __m128i _mm_slli_epi64(__m128i , int ); } 
#line 255
extern "C" { extern __m128i _mm_sll_epi64(__m128i , __m128i ); } 
#line 256
extern "C" { extern __m128i _mm_srai_epi16(__m128i , int ); } 
#line 257
extern "C" { extern __m128i _mm_sra_epi16(__m128i , __m128i ); } 
#line 258
extern "C" { extern __m128i _mm_srai_epi32(__m128i , int ); } 
#line 259
extern "C" { extern __m128i _mm_sra_epi32(__m128i , __m128i ); } 
#line 260
extern "C" { extern __m128i _mm_srli_si128(__m128i , int ); } 
#line 261
extern "C" { extern __m128i _mm_srli_epi16(__m128i , int ); } 
#line 262
extern "C" { extern __m128i _mm_srl_epi16(__m128i , __m128i ); } 
#line 263
extern "C" { extern __m128i _mm_srli_epi32(__m128i , int ); } 
#line 264
extern "C" { extern __m128i _mm_srl_epi32(__m128i , __m128i ); } 
#line 265
extern "C" { extern __m128i _mm_srli_epi64(__m128i , int ); } 
#line 266
extern "C" { extern __m128i _mm_srl_epi64(__m128i , __m128i ); } 
#line 272
extern "C" { extern __m128i _mm_cmpeq_epi8(__m128i , __m128i ); } 
#line 273
extern "C" { extern __m128i _mm_cmpeq_epi16(__m128i , __m128i ); } 
#line 274
extern "C" { extern __m128i _mm_cmpeq_epi32(__m128i , __m128i ); } 
#line 275
extern "C" { extern __m128i _mm_cmpgt_epi8(__m128i , __m128i ); } 
#line 276
extern "C" { extern __m128i _mm_cmpgt_epi16(__m128i , __m128i ); } 
#line 277
extern "C" { extern __m128i _mm_cmpgt_epi32(__m128i , __m128i ); } 
#line 278
extern "C" { extern __m128i _mm_cmplt_epi8(__m128i , __m128i ); } 
#line 279
extern "C" { extern __m128i _mm_cmplt_epi16(__m128i , __m128i ); } 
#line 280
extern "C" { extern __m128i _mm_cmplt_epi32(__m128i , __m128i ); } 
#line 286
extern "C" { extern __m128i _mm_cvtsi32_si128(int ); } 
#line 287
extern "C" { extern int _mm_cvtsi128_si32(__m128i ); } 
#line 293
extern "C" { extern __m128i _mm_packs_epi16(__m128i , __m128i ); } 
#line 294
extern "C" { extern __m128i _mm_packs_epi32(__m128i , __m128i ); } 
#line 295
extern "C" { extern __m128i _mm_packus_epi16(__m128i , __m128i ); } 
#line 296
extern "C" { extern int _mm_extract_epi16(__m128i , int ); } 
#line 297
extern "C" { extern __m128i _mm_insert_epi16(__m128i , int , int ); } 
#line 298
extern "C" { extern int _mm_movemask_epi8(__m128i ); } 
#line 299
extern "C" { extern __m128i _mm_shuffle_epi32(__m128i , int ); } 
#line 300
extern "C" { extern __m128i _mm_shufflehi_epi16(__m128i , int ); } 
#line 301
extern "C" { extern __m128i _mm_shufflelo_epi16(__m128i , int ); } 
#line 302
extern "C" { extern __m128i _mm_unpackhi_epi8(__m128i , __m128i ); } 
#line 303
extern "C" { extern __m128i _mm_unpackhi_epi16(__m128i , __m128i ); } 
#line 304
extern "C" { extern __m128i _mm_unpackhi_epi32(__m128i , __m128i ); } 
#line 305
extern "C" { extern __m128i _mm_unpackhi_epi64(__m128i , __m128i ); } 
#line 306
extern "C" { extern __m128i _mm_unpacklo_epi8(__m128i , __m128i ); } 
#line 307
extern "C" { extern __m128i _mm_unpacklo_epi16(__m128i , __m128i ); } 
#line 308
extern "C" { extern __m128i _mm_unpacklo_epi32(__m128i , __m128i ); } 
#line 309
extern "C" { extern __m128i _mm_unpacklo_epi64(__m128i , __m128i ); } 
#line 315
extern "C" { extern __m128i _mm_load_si128(const __m128i * ); } 
#line 316
extern "C" { extern __m128i _mm_loadu_si128(const __m128i * ); } 
#line 317
extern "C" { extern __m128i _mm_loadl_epi64(const __m128i * ); } 
#line 323
extern "C" { extern __m128i _mm_set_epi64(__m64 , __m64 ); } 
#line 324
extern "C" { extern __m128i _mm_set_epi32(int , int , int , int ); } 
#line 325
extern "C" { extern __m128i _mm_set_epi16(short , short , short , short , short , short , short , short ); } 
#line 327
extern "C" { extern __m128i _mm_set_epi8(char , char , char , char , char , char , char , char , char , char , char , char , char , char , char , char ); } 
#line 331
extern "C" { extern __m128i _mm_set1_epi64(__m64 ); } 
#line 332
extern "C" { extern __m128i _mm_set1_epi32(int ); } 
#line 333
extern "C" { extern __m128i _mm_set1_epi16(short ); } 
#line 334
extern "C" { extern __m128i _mm_set1_epi8(char ); } 
#line 335
extern "C" { extern __m128i _mm_setl_epi64(__m128i ); } 
#line 336
extern "C" { extern __m128i _mm_setr_epi64(__m64 , __m64 ); } 
#line 337
extern "C" { extern __m128i _mm_setr_epi32(int , int , int , int ); } 
#line 338
extern "C" { extern __m128i _mm_setr_epi16(short , short , short , short , short , short , short , short ); } 
#line 340
extern "C" { extern __m128i _mm_setr_epi8(char , char , char , char , char , char , char , char , char , char , char , char , char , char , char , char ); } 
#line 344
extern "C" { extern __m128i _mm_setzero_si128(); } 
#line 350
extern "C" { extern void _mm_store_si128(__m128i * , __m128i ); } 
#line 351
extern "C" { extern void _mm_storeu_si128(__m128i * , __m128i ); } 
#line 352
extern "C" { extern void _mm_storel_epi64(__m128i * , __m128i ); } 
#line 353
extern "C" { extern void _mm_maskmoveu_si128(__m128i , __m128i , char * ); } 
#line 359
extern "C" { extern __m128i _mm_move_epi64(__m128i ); } 
#line 360
extern "C" { extern __m128i _mm_movpi64_epi64(__m64 ); } 
#line 361
extern "C" { extern __m64 _mm_movepi64_pi64(__m128i ); } 
#line 367
extern "C" { extern void _mm_stream_pd(double * , __m128d ); } 
#line 368
extern "C" { extern void _mm_stream_si128(__m128i * , __m128i ); } 
#line 369
extern "C" { extern void _mm_clflush(const void * ); } 
#line 370
extern "C" { extern void _mm_lfence(); } 
#line 371
extern "C" { extern void _mm_mfence(); } 
#line 372
extern "C" { extern void _mm_stream_si32(int * , int ); } 
#line 373
extern "C" { extern void _mm_pause(); } 
#line 379
extern "C" { extern double _mm_cvtsd_f64(__m128d ); } 
#line 387
extern "C" { extern __m128 _mm_castpd_ps(__m128d); } 
#line 388
extern "C" { extern __m128i _mm_castpd_si128(__m128d); } 
#line 389
extern "C" { extern __m128d _mm_castps_pd(__m128); } 
#line 390
extern "C" { extern __m128i _mm_castps_si128(__m128); } 
#line 391
extern "C" { extern __m128 _mm_castsi128_ps(__m128i); } 
#line 392
extern "C" { extern __m128d _mm_castsi128_pd(__m128i); } 
#line 399
extern "C" { extern __int64 _mm_cvtsd_si64(__m128d); } 
#line 400
extern "C" { extern __int64 _mm_cvttsd_si64(__m128d); } 
#line 401
extern "C" { extern __m128d _mm_cvtsi64_sd(__m128d, __int64); } 
#line 402
extern "C" { extern __m128i _mm_cvtsi64_si128(__int64); } 
#line 403
extern "C" { extern __int64 _mm_cvtsi128_si64(__m128i); } 
#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\pmmintrin.h"
extern "C" { extern __m128 _mm_addsub_ps(__m128 , __m128 ); } 
#line 64
extern "C" { extern __m128 _mm_hadd_ps(__m128 , __m128 ); } 
#line 65
extern "C" { extern __m128 _mm_hsub_ps(__m128 , __m128 ); } 
#line 66
extern "C" { extern __m128 _mm_movehdup_ps(__m128 ); } 
#line 67
extern "C" { extern __m128 _mm_moveldup_ps(__m128 ); } 
#line 73
extern "C" { extern __m128d _mm_addsub_pd(__m128d , __m128d ); } 
#line 74
extern "C" { extern __m128d _mm_hadd_pd(__m128d , __m128d ); } 
#line 75
extern "C" { extern __m128d _mm_hsub_pd(__m128d , __m128d ); } 
#line 76
extern "C" { extern __m128d _mm_loaddup_pd(const double * ); } 
#line 77
extern "C" { extern __m128d _mm_movedup_pd(__m128d ); } 
#line 82
extern "C" { extern __m128i _mm_lddqu_si128(const __m128i * ); } 
#line 90
extern "C" { extern void _mm_monitor(const void * , unsigned , unsigned ); } 
#line 95
extern "C" { extern void _mm_mwait(unsigned , unsigned ); } 
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\tmmintrin.h"
extern "C" { extern __m128i _mm_hadd_epi16(__m128i , __m128i ); } 
#line 37
extern "C" { extern __m128i _mm_hadd_epi32(__m128i , __m128i ); } 
#line 38
extern "C" { extern __m128i _mm_hadds_epi16(__m128i , __m128i ); } 
#line 40
extern "C" { extern __m64 _mm_hadd_pi16(__m64 , __m64 ); } 
#line 41
extern "C" { extern __m64 _mm_hadd_pi32(__m64 , __m64 ); } 
#line 42
extern "C" { extern __m64 _mm_hadds_pi16(__m64 , __m64 ); } 
#line 47
extern "C" { extern __m128i _mm_hsub_epi16(__m128i , __m128i ); } 
#line 48
extern "C" { extern __m128i _mm_hsub_epi32(__m128i , __m128i ); } 
#line 49
extern "C" { extern __m128i _mm_hsubs_epi16(__m128i , __m128i ); } 
#line 51
extern "C" { extern __m64 _mm_hsub_pi16(__m64 , __m64 ); } 
#line 52
extern "C" { extern __m64 _mm_hsub_pi32(__m64 , __m64 ); } 
#line 53
extern "C" { extern __m64 _mm_hsubs_pi16(__m64 , __m64 ); } 
#line 58
extern "C" { extern __m128i _mm_maddubs_epi16(__m128i , __m128i ); } 
#line 60
extern "C" { extern __m64 _mm_maddubs_pi16(__m64 , __m64 ); } 
#line 65
extern "C" { extern __m128i _mm_mulhrs_epi16(__m128i , __m128i ); } 
#line 67
extern "C" { extern __m64 _mm_mulhrs_pi16(__m64 , __m64 ); } 
#line 72
extern "C" { extern __m128i _mm_shuffle_epi8(__m128i , __m128i ); } 
#line 74
extern "C" { extern __m64 _mm_shuffle_pi8(__m64 , __m64 ); } 
#line 79
extern "C" { extern __m128i _mm_sign_epi8(__m128i , __m128i ); } 
#line 80
extern "C" { extern __m128i _mm_sign_epi16(__m128i , __m128i ); } 
#line 81
extern "C" { extern __m128i _mm_sign_epi32(__m128i , __m128i ); } 
#line 83
extern "C" { extern __m64 _mm_sign_pi8(__m64 , __m64 ); } 
#line 84
extern "C" { extern __m64 _mm_sign_pi16(__m64 , __m64 ); } 
#line 85
extern "C" { extern __m64 _mm_sign_pi32(__m64 , __m64 ); } 
#line 90
extern "C" { extern __m128i _mm_alignr_epi8(__m128i , __m128i , int ); } 
#line 92
extern "C" { extern __m64 _mm_alignr_pi8(__m64 , __m64 , int ); } 
#line 97
extern "C" { extern __m128i _mm_abs_epi8(__m128i ); } 
#line 98
extern "C" { extern __m128i _mm_abs_epi16(__m128i ); } 
#line 99
extern "C" { extern __m128i _mm_abs_epi32(__m128i ); } 
#line 101
extern "C" { extern __m64 _mm_abs_pi8(__m64 ); } 
#line 102
extern "C" { extern __m64 _mm_abs_pi16(__m64 ); } 
#line 103
extern "C" { extern __m64 _mm_abs_pi32(__m64 ); } 
#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\smmintrin.h"
extern "C" { extern __m128i _mm_blend_epi16(__m128i , __m128i , const int ); } 
#line 86
extern "C" { extern __m128i _mm_blendv_epi8(__m128i , __m128i , __m128i ); } 
#line 91
extern "C" { extern __m128 _mm_blend_ps(__m128 , __m128 , const int ); } 
#line 92
extern "C" { extern __m128 _mm_blendv_ps(__m128 , __m128 , __m128 ); } 
#line 97
extern "C" { extern __m128d _mm_blend_pd(__m128d , __m128d , const int ); } 
#line 98
extern "C" { extern __m128d _mm_blendv_pd(__m128d , __m128d , __m128d ); } 
#line 103
extern "C" { extern __m128 _mm_dp_ps(__m128 , __m128 , const int ); } 
#line 104
extern "C" { extern __m128d _mm_dp_pd(__m128d , __m128d , const int ); } 
#line 109
extern "C" { extern __m128i _mm_cmpeq_epi64(__m128i , __m128i ); } 
#line 113
extern "C" { extern __m128i _mm_min_epi8(__m128i , __m128i ); } 
#line 114
extern "C" { extern __m128i _mm_max_epi8(__m128i , __m128i ); } 
#line 116
extern "C" { extern __m128i _mm_min_epu16(__m128i , __m128i ); } 
#line 117
extern "C" { extern __m128i _mm_max_epu16(__m128i , __m128i ); } 
#line 119
extern "C" { extern __m128i _mm_min_epi32(__m128i , __m128i ); } 
#line 120
extern "C" { extern __m128i _mm_max_epi32(__m128i , __m128i ); } 
#line 121
extern "C" { extern __m128i _mm_min_epu32(__m128i , __m128i ); } 
#line 122
extern "C" { extern __m128i _mm_max_epu32(__m128i , __m128i ); } 
#line 127
extern "C" { extern __m128i _mm_mullo_epi32(__m128i , __m128i ); } 
#line 132
extern "C" { extern __m128i _mm_mul_epi32(__m128i , __m128i ); } 
#line 137
extern "C" { extern int _mm_testz_si128(__m128i , __m128i ); } 
#line 142
extern "C" { extern int _mm_testc_si128(__m128i , __m128i ); } 
#line 148
extern "C" { extern int _mm_testnzc_si128(__m128i , __m128i ); } 
#line 156
extern "C" { extern __m128 _mm_insert_ps(__m128 , __m128 , const int ); } 
#line 166
extern "C" { extern int _mm_extract_ps(__m128 , const int ); } 
#line 184
extern "C" { extern __m128i _mm_insert_epi8(__m128i , int , const int ); } 
#line 185
extern "C" { extern __m128i _mm_insert_epi32(__m128i , int , const int ); } 
#line 188
extern "C" { extern __m128i _mm_insert_epi64(__m128i , __int64 , const int ); } 
#line 193 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\smmintrin.h"
extern "C" { extern int _mm_extract_epi8(__m128i , const int ); } 
#line 194
extern "C" { extern int _mm_extract_epi32(__m128i , const int ); } 
#line 197
extern "C" { extern __int64 _mm_extract_epi64(__m128i , const int ); } 
#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\smmintrin.h"
extern "C" { extern __m128i _mm_minpos_epu16(__m128i ); } 
#line 207
extern "C" { extern __m128d _mm_round_pd(__m128d , int ); } 
#line 208
extern "C" { extern __m128d _mm_round_sd(__m128d , __m128d , int ); } 
#line 212
extern "C" { extern __m128 _mm_round_ps(__m128 , int ); } 
#line 213
extern "C" { extern __m128 _mm_round_ss(__m128 , __m128 , int ); } 
#line 217
extern "C" { extern __m128i _mm_cvtepi8_epi32(__m128i ); } 
#line 218
extern "C" { extern __m128i _mm_cvtepi16_epi32(__m128i ); } 
#line 219
extern "C" { extern __m128i _mm_cvtepi8_epi64(__m128i ); } 
#line 220
extern "C" { extern __m128i _mm_cvtepi32_epi64(__m128i ); } 
#line 221
extern "C" { extern __m128i _mm_cvtepi16_epi64(__m128i ); } 
#line 222
extern "C" { extern __m128i _mm_cvtepi8_epi16(__m128i ); } 
#line 226
extern "C" { extern __m128i _mm_cvtepu8_epi32(__m128i ); } 
#line 227
extern "C" { extern __m128i _mm_cvtepu16_epi32(__m128i ); } 
#line 228
extern "C" { extern __m128i _mm_cvtepu8_epi64(__m128i ); } 
#line 229
extern "C" { extern __m128i _mm_cvtepu32_epi64(__m128i ); } 
#line 230
extern "C" { extern __m128i _mm_cvtepu16_epi64(__m128i ); } 
#line 231
extern "C" { extern __m128i _mm_cvtepu8_epi16(__m128i ); } 
#line 237
extern "C" { extern __m128i _mm_packus_epi32(__m128i , __m128i ); } 
#line 243
extern "C" { extern __m128i _mm_mpsadbw_epu8(__m128i , __m128i , const int ); } 
#line 249
extern "C" { extern __m128i _mm_stream_load_si128(__m128i * ); } 
#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\nmmintrin.h"
extern "C" { extern __m128i _mm_cmpistrm(__m128i , __m128i , const int ); } 
#line 79
extern "C" { extern int _mm_cmpistri(__m128i , __m128i , const int ); } 
#line 81
extern "C" { extern __m128i _mm_cmpestrm(__m128i , int , __m128i , int , const int ); } 
#line 82
extern "C" { extern int _mm_cmpestri(__m128i , int , __m128i , int , const int ); } 
#line 88
extern "C" { extern int _mm_cmpistrz(__m128i , __m128i , const int ); } 
#line 89
extern "C" { extern int _mm_cmpistrc(__m128i , __m128i , const int ); } 
#line 90
extern "C" { extern int _mm_cmpistrs(__m128i , __m128i , const int ); } 
#line 91
extern "C" { extern int _mm_cmpistro(__m128i , __m128i , const int ); } 
#line 92
extern "C" { extern int _mm_cmpistra(__m128i , __m128i , const int ); } 
#line 94
extern "C" { extern int _mm_cmpestrz(__m128i , int , __m128i , int , const int ); } 
#line 95
extern "C" { extern int _mm_cmpestrc(__m128i , int , __m128i , int , const int ); } 
#line 96
extern "C" { extern int _mm_cmpestrs(__m128i , int , __m128i , int , const int ); } 
#line 97
extern "C" { extern int _mm_cmpestro(__m128i , int , __m128i , int , const int ); } 
#line 98
extern "C" { extern int _mm_cmpestra(__m128i , int , __m128i , int , const int ); } 
#line 105
extern "C" { extern __m128i _mm_cmpgt_epi64(__m128i , __m128i ); } 
#line 111
extern "C" { extern int _mm_popcnt_u32(unsigned ); } 
#line 114
extern "C" { extern __int64 _mm_popcnt_u64(unsigned __int64 ); } 
#line 121 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\nmmintrin.h"
extern "C" { extern unsigned _mm_crc32_u8(unsigned , unsigned char ); } 
#line 122
extern "C" { extern unsigned _mm_crc32_u16(unsigned , unsigned short ); } 
#line 123
extern "C" { extern unsigned _mm_crc32_u32(unsigned , unsigned ); } 
#line 126
extern "C" { extern unsigned __int64 _mm_crc32_u64(unsigned __int64 , unsigned __int64 ); } 
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\wmmintrin.h"
extern "C" { extern __m128i _mm_aesdec_si128(__m128i , __m128i ); } 
#line 43
extern "C" { extern __m128i _mm_aesdeclast_si128(__m128i , __m128i ); } 
#line 49
extern "C" { extern __m128i _mm_aesenc_si128(__m128i , __m128i ); } 
#line 55
extern "C" { extern __m128i _mm_aesenclast_si128(__m128i , __m128i ); } 
#line 61
extern "C" { extern __m128i _mm_aesimc_si128(__m128i ); } 
#line 68
extern "C" { extern __m128i _mm_aeskeygenassist_si128(__m128i , const int ); } 
#line 76
extern "C" { extern __m128i _mm_clmulepi64_si128(__m128i , __m128i , const int ); } 
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\immintrin.h"
extern "C" { typedef 
#line 30
union __declspec(intrin_type) __declspec(align(32)) __m256 { 
#line 31
float m256_f32[8]; 
#line 32
} __m256; }
#line 36
extern "C" { typedef 
#line 34
struct __declspec(intrin_type) __declspec(align(32)) { 
#line 35
double m256d_f64[4]; 
#line 36
} __m256d; }
#line 47
extern "C" { typedef 
#line 38
union __declspec(intrin_type) __declspec(align(32)) __m256i { 
#line 39
char m256i_i8[32]; 
#line 40
short m256i_i16[16]; 
#line 41
int m256i_i32[8]; 
#line 42
__int64 m256i_i64[4]; 
#line 43
unsigned char m256i_u8[32]; 
#line 44
unsigned short m256i_u16[16]; 
#line 45
unsigned m256i_u32[8]; 
#line 46
unsigned __int64 m256i_u64[4]; 
#line 47
} __m256i; }
#line 93
extern "C" { extern __m256d __cdecl _mm256_add_pd(__m256d , __m256d ); } 
#line 103
extern "C" { extern __m256 __cdecl _mm256_add_ps(__m256 , __m256 ); } 
#line 116
extern "C" { extern __m256d __cdecl _mm256_addsub_pd(__m256d , __m256d ); } 
#line 129
extern "C" { extern __m256 __cdecl _mm256_addsub_ps(__m256 , __m256 ); } 
#line 138
extern "C" { extern __m256d __cdecl _mm256_and_pd(__m256d , __m256d ); } 
#line 147
extern "C" { extern __m256 __cdecl _mm256_and_ps(__m256 , __m256 ); } 
#line 156
extern "C" { extern __m256d __cdecl _mm256_andnot_pd(__m256d , __m256d ); } 
#line 165
extern "C" { extern __m256 __cdecl _mm256_andnot_ps(__m256 , __m256 ); } 
#line 179
extern "C" { extern __m256d __cdecl _mm256_blend_pd(__m256d , __m256d , const int ); } 
#line 193
extern "C" { extern __m256 __cdecl _mm256_blend_ps(__m256 , __m256 , const int ); } 
#line 203
extern "C" { extern __m256d __cdecl _mm256_blendv_pd(__m256d , __m256d , __m256d ); } 
#line 213
extern "C" { extern __m256 __cdecl _mm256_blendv_ps(__m256 , __m256 , __m256 ); } 
#line 222
extern "C" { extern __m256d __cdecl _mm256_div_pd(__m256d , __m256d ); } 
#line 231
extern "C" { extern __m256 __cdecl _mm256_div_ps(__m256 , __m256 ); } 
#line 246
extern "C" { extern __m256 __cdecl _mm256_dp_ps(__m256 , __m256 , const int ); } 
#line 255
extern "C" { extern __m256d __cdecl _mm256_hadd_pd(__m256d , __m256d ); } 
#line 264
extern "C" { extern __m256 __cdecl _mm256_hadd_ps(__m256 , __m256 ); } 
#line 273
extern "C" { extern __m256d __cdecl _mm256_hsub_pd(__m256d , __m256d ); } 
#line 282
extern "C" { extern __m256 __cdecl _mm256_hsub_ps(__m256 , __m256 ); } 
#line 291
extern "C" { extern __m256d __cdecl _mm256_max_pd(__m256d , __m256d ); } 
#line 300
extern "C" { extern __m256 __cdecl _mm256_max_ps(__m256 , __m256 ); } 
#line 309
extern "C" { extern __m256d __cdecl _mm256_min_pd(__m256d , __m256d ); } 
#line 318
extern "C" { extern __m256 __cdecl _mm256_min_ps(__m256 , __m256 ); } 
#line 328
extern "C" { extern __m256d __cdecl _mm256_mul_pd(__m256d , __m256d ); } 
#line 338
extern "C" { extern __m256 __cdecl _mm256_mul_ps(__m256 , __m256 ); } 
#line 347
extern "C" { extern __m256d __cdecl _mm256_or_pd(__m256d , __m256d ); } 
#line 356
extern "C" { extern __m256 __cdecl _mm256_or_ps(__m256 , __m256 ); } 
#line 368
extern "C" { extern __m256d __cdecl _mm256_shuffle_pd(__m256d , __m256d , const int ); } 
#line 381
extern "C" { extern __m256 __cdecl _mm256_shuffle_ps(__m256 , __m256 , const int ); } 
#line 390
extern "C" { extern __m256d __cdecl _mm256_sub_pd(__m256d , __m256d ); } 
#line 400
extern "C" { extern __m256 __cdecl _mm256_sub_ps(__m256 , __m256 ); } 
#line 409
extern "C" { extern __m256d __cdecl _mm256_xor_pd(__m256d , __m256d ); } 
#line 418
extern "C" { extern __m256 __cdecl _mm256_xor_ps(__m256 , __m256 ); } 
#line 433
extern "C" { extern __m128d __cdecl _mm_cmp_pd(__m128d , __m128d , const int ); } 
#line 434
extern "C" { extern __m256d __cdecl _mm256_cmp_pd(__m256d , __m256d , const int ); } 
#line 449
extern "C" { extern __m128 __cdecl _mm_cmp_ps(__m128 , __m128 , const int ); } 
#line 450
extern "C" { extern __m256 __cdecl _mm256_cmp_ps(__m256 , __m256 , const int ); } 
#line 463
extern "C" { extern __m128d __cdecl _mm_cmp_sd(__m128d , __m128d , const int ); } 
#line 476
extern "C" { extern __m128 __cdecl _mm_cmp_ss(__m128 , __m128 , const int ); } 
#line 485
extern "C" { extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i ); } 
#line 494
extern "C" { extern __m256 __cdecl _mm256_cvtepi32_ps(__m256i ); } 
#line 504
extern "C" { extern __m128 __cdecl _mm256_cvtpd_ps(__m256d ); } 
#line 513
extern "C" { extern __m256i __cdecl _mm256_cvtps_epi32(__m256 ); } 
#line 523
extern "C" { extern __m256d __cdecl _mm256_cvtps_pd(__m128 ); } 
#line 536
extern "C" { extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d ); } 
#line 545
extern "C" { extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d ); } 
#line 558
extern "C" { extern __m256i __cdecl _mm256_cvttps_epi32(__m256 ); } 
#line 566
extern "C" { extern __m128 __cdecl _mm256_extractf128_ps(__m256 , const int ); } 
#line 567
extern "C" { extern __m128d __cdecl _mm256_extractf128_pd(__m256d , const int ); } 
#line 568
extern "C" { extern __m128i __cdecl _mm256_extractf128_si256(__m256i , const int ); } 
#line 575
extern "C" { extern void __cdecl _mm256_zeroall(); } 
#line 583
extern "C" { extern void __cdecl _mm256_zeroupper(); } 
#line 593
extern "C" { extern __m256 __cdecl _mm256_permutevar_ps(__m256 , __m256i ); } 
#line 594
extern "C" { extern __m128 __cdecl _mm_permutevar_ps(__m128 , __m128i ); } 
#line 604
extern "C" { extern __m256 __cdecl _mm256_permute_ps(__m256 , int ); } 
#line 605
extern "C" { extern __m128 __cdecl _mm_permute_ps(__m128 , int ); } 
#line 615
extern "C" { extern __m256d __cdecl _mm256_permutevar_pd(__m256d , __m256i ); } 
#line 616
extern "C" { extern __m128d __cdecl _mm_permutevar_pd(__m128d , __m128i ); } 
#line 626
extern "C" { extern __m256d __cdecl _mm256_permute_pd(__m256d , int ); } 
#line 627
extern "C" { extern __m128d __cdecl _mm_permute_pd(__m128d , int ); } 
#line 636
extern "C" { extern __m256 __cdecl _mm256_permute2f128_ps(__m256 , __m256 , int ); } 
#line 637
extern "C" { extern __m256d __cdecl _mm256_permute2f128_pd(__m256d , __m256d , int ); } 
#line 638
extern "C" { extern __m256i __cdecl _mm256_permute2f128_si256(__m256i , __m256i , int ); } 
#line 647
extern "C" { extern __m256 __cdecl _mm256_broadcast_ss(const float * ); } 
#line 648
extern "C" { extern __m128 __cdecl _mm_broadcast_ss(const float * ); } 
#line 656
extern "C" { extern __m256d __cdecl _mm256_broadcast_sd(const double * ); } 
#line 664
extern "C" { extern __m256 __cdecl _mm256_broadcast_ps(const __m128 * ); } 
#line 665
extern "C" { extern __m256d __cdecl _mm256_broadcast_pd(const __m128d * ); } 
#line 675
extern "C" { extern __m256 __cdecl _mm256_insertf128_ps(__m256, __m128 , int ); } 
#line 676
extern "C" { extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d , int ); } 
#line 677
extern "C" { extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i , int ); } 
#line 686
extern "C" { extern __m256d __cdecl _mm256_load_pd(const double * ); } 
#line 687
extern "C" { extern void __cdecl _mm256_store_pd(double * , __m256d ); } 
#line 696
extern "C" { extern __m256 __cdecl _mm256_load_ps(const float * ); } 
#line 697
extern "C" { extern void __cdecl _mm256_store_ps(float * , __m256 ); } 
#line 706
extern "C" { extern __m256d __cdecl _mm256_loadu_pd(const double * ); } 
#line 707
extern "C" { extern void __cdecl _mm256_storeu_pd(double * , __m256d ); } 
#line 716
extern "C" { extern __m256 __cdecl _mm256_loadu_ps(const float * ); } 
#line 717
extern "C" { extern void __cdecl _mm256_storeu_ps(float * , __m256 ); } 
#line 726
extern "C" { extern __m256i __cdecl _mm256_load_si256(const __m256i * ); } 
#line 727
extern "C" { extern void __cdecl _mm256_store_si256(__m256i * , __m256i ); } 
#line 736
extern "C" { extern __m256i __cdecl _mm256_loadu_si256(const __m256i * ); } 
#line 737
extern "C" { extern void __cdecl _mm256_storeu_si256(__m256i * , __m256i ); } 
#line 757
extern "C" { extern __m256d __cdecl _mm256_maskload_pd(const double * , __m256i ); } 
#line 758
extern "C" { extern void __cdecl _mm256_maskstore_pd(double * , __m256i , __m256d ); } 
#line 759
extern "C" { extern __m128d __cdecl _mm_maskload_pd(const double * , __m128i ); } 
#line 760
extern "C" { extern void __cdecl _mm_maskstore_pd(double * , __m128i , __m128d ); } 
#line 780
extern "C" { extern __m256 __cdecl _mm256_maskload_ps(const float * , __m256i ); } 
#line 781
extern "C" { extern void __cdecl _mm256_maskstore_ps(float * , __m256i , __m256 ); } 
#line 782
extern "C" { extern __m128 __cdecl _mm_maskload_ps(const float * , __m128i ); } 
#line 783
extern "C" { extern void __cdecl _mm_maskstore_ps(float * , __m128i , __m128 ); } 
#line 791
extern "C" { extern __m256 __cdecl _mm256_movehdup_ps(__m256 ); } 
#line 799
extern "C" { extern __m256 __cdecl _mm256_moveldup_ps(__m256 ); } 
#line 807
extern "C" { extern __m256d __cdecl _mm256_movedup_pd(__m256d ); } 
#line 817
extern "C" { extern __m256i __cdecl _mm256_lddqu_si256(const __m256i * ); } 
#line 825
extern "C" { extern void __cdecl _mm256_stream_si256(__m256i * , __m256i ); } 
#line 834
extern "C" { extern void __cdecl _mm256_stream_pd(double * , __m256d ); } 
#line 843
extern "C" { extern void __cdecl _mm256_stream_ps(float * , __m256 ); } 
#line 852
extern "C" { extern __m256 __cdecl _mm256_rcp_ps(__m256 ); } 
#line 863
extern "C" { extern __m256 __cdecl _mm256_rsqrt_ps(__m256 ); } 
#line 872
extern "C" { extern __m256d __cdecl _mm256_sqrt_pd(__m256d ); } 
#line 881
extern "C" { extern __m256 __cdecl _mm256_sqrt_ps(__m256 ); } 
#line 894
extern "C" { extern __m256d __cdecl _mm256_round_pd(__m256d , int ); } 
#line 909
extern "C" { extern __m256 __cdecl _mm256_round_ps(__m256 , int ); } 
#line 919
extern "C" { extern __m256d __cdecl _mm256_unpackhi_pd(__m256d , __m256d ); } 
#line 927
extern "C" { extern __m256 __cdecl _mm256_unpackhi_ps(__m256 , __m256 ); } 
#line 935
extern "C" { extern __m256d __cdecl _mm256_unpacklo_pd(__m256d , __m256d ); } 
#line 943
extern "C" { extern __m256 __cdecl _mm256_unpacklo_ps(__m256 , __m256 ); } 
#line 953
extern "C" { extern int __cdecl _mm256_testz_si256(__m256i , __m256i ); } 
#line 954
extern "C" { extern int __cdecl _mm256_testc_si256(__m256i , __m256i ); } 
#line 955
extern "C" { extern int __cdecl _mm256_testnzc_si256(__m256i , __m256i ); } 
#line 968
extern "C" { extern int __cdecl _mm256_testz_pd(__m256d , __m256d ); } 
#line 969
extern "C" { extern int __cdecl _mm256_testc_pd(__m256d , __m256d ); } 
#line 970
extern "C" { extern int __cdecl _mm256_testnzc_pd(__m256d , __m256d ); } 
#line 971
extern "C" { extern int __cdecl _mm_testz_pd(__m128d , __m128d ); } 
#line 972
extern "C" { extern int __cdecl _mm_testc_pd(__m128d , __m128d ); } 
#line 973
extern "C" { extern int __cdecl _mm_testnzc_pd(__m128d , __m128d ); } 
#line 986
extern "C" { extern int __cdecl _mm256_testz_ps(__m256 , __m256 ); } 
#line 987
extern "C" { extern int __cdecl _mm256_testc_ps(__m256 , __m256 ); } 
#line 988
extern "C" { extern int __cdecl _mm256_testnzc_ps(__m256 , __m256 ); } 
#line 989
extern "C" { extern int __cdecl _mm_testz_ps(__m128 , __m128 ); } 
#line 990
extern "C" { extern int __cdecl _mm_testc_ps(__m128 , __m128 ); } 
#line 991
extern "C" { extern int __cdecl _mm_testnzc_ps(__m128 , __m128 ); } 
#line 1000
extern "C" { extern int __cdecl _mm256_movemask_pd(__m256d ); } 
#line 1009
extern "C" { extern int __cdecl _mm256_movemask_ps(__m256 ); } 
#line 1014
extern "C" { extern __m256d __cdecl _mm256_setzero_pd(); } 
#line 1015
extern "C" { extern __m256 __cdecl _mm256_setzero_ps(); } 
#line 1016
extern "C" { extern __m256i __cdecl _mm256_setzero_si256(); } 
#line 1021
extern "C" { extern __m256d __cdecl _mm256_set_pd(double, double, double, double); } 
#line 1022
extern "C" { extern __m256 __cdecl _mm256_set_ps(float, float, float, float, float, float, float, float); } 
#line 1023
extern "C" { extern __m256i __cdecl _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); } 
#line 1027
extern "C" { extern __m256i __cdecl _mm256_set_epi16(short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short); } 
#line 1029
extern "C" { extern __m256i __cdecl _mm256_set_epi32(int, int, int, int, int, int, int, int); } 
#line 1030
extern "C" { extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64, __int64, __int64); } 
#line 1032
extern "C" { extern __m256d __cdecl _mm256_setr_pd(double, double, double, double); } 
#line 1033
extern "C" { extern __m256 __cdecl _mm256_setr_ps(float, float, float, float, float, float, float, float); } 
#line 1034
extern "C" { extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); } 
#line 1038
extern "C" { extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short); } 
#line 1040
extern "C" { extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int, int, int, int, int); } 
#line 1041
extern "C" { extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64, __int64, __int64); } 
#line 1046
extern "C" { extern __m256d __cdecl _mm256_set1_pd(double); } 
#line 1047
extern "C" { extern __m256 __cdecl _mm256_set1_ps(float); } 
#line 1048
extern "C" { extern __m256i __cdecl _mm256_set1_epi8(char); } 
#line 1049
extern "C" { extern __m256i __cdecl _mm256_set1_epi16(short); } 
#line 1050
extern "C" { extern __m256i __cdecl _mm256_set1_epi32(int); } 
#line 1051
extern "C" { extern __m256i __cdecl _mm256_set1_epi64x(__int64); } 
#line 1059
extern "C" { extern __m256 __cdecl _mm256_castpd_ps(__m256d ); } 
#line 1060
extern "C" { extern __m256d __cdecl _mm256_castps_pd(__m256 ); } 
#line 1061
extern "C" { extern __m256i __cdecl _mm256_castps_si256(__m256 ); } 
#line 1062
extern "C" { extern __m256i __cdecl _mm256_castpd_si256(__m256d ); } 
#line 1063
extern "C" { extern __m256 __cdecl _mm256_castsi256_ps(__m256i ); } 
#line 1064
extern "C" { extern __m256d __cdecl _mm256_castsi256_pd(__m256i ); } 
#line 1065
extern "C" { extern __m128 __cdecl _mm256_castps256_ps128(__m256 ); } 
#line 1066
extern "C" { extern __m128d __cdecl _mm256_castpd256_pd128(__m256d ); } 
#line 1067
extern "C" { extern __m128i __cdecl _mm256_castsi256_si128(__m256i ); } 
#line 1068
extern "C" { extern __m256 __cdecl _mm256_castps128_ps256(__m128 ); } 
#line 1069
extern "C" { extern __m256d __cdecl _mm256_castpd128_pd256(__m128d ); } 
#line 1070
extern "C" { extern __m256i __cdecl _mm256_castsi128_si256(__m128i ); } 
#line 1080
extern "C" { extern unsigned __int64 __cdecl _xgetbv(unsigned ); } 
#line 1083
extern "C" { extern void __cdecl _xsetbv(unsigned , unsigned __int64 ); } 
#line 1090
extern "C" { extern void __cdecl _xsave(void * , unsigned __int64 ); } 
#line 1092
extern "C" { extern void __cdecl _xsave64(void * , unsigned __int64 ); } 
#line 1100 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\immintrin.h"
extern "C" { extern void __cdecl _xsaveopt(void * , unsigned __int64 ); } 
#line 1102
extern "C" { extern void __cdecl _xsaveopt64(void * , unsigned __int64 ); } 
#line 1110 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\immintrin.h"
extern "C" { extern void __cdecl _xrstor(void * , unsigned __int64 ); } 
#line 1112
extern "C" { extern void __cdecl _xrstor64(void * , unsigned __int64 ); } 
#line 1119 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\immintrin.h"
extern "C" { extern void __cdecl _fxsave(void * ); } 
#line 1121
extern "C" { extern void __cdecl _fxsave64(void * ); } 
#line 1128 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\immintrin.h"
extern "C" { extern void __cdecl _fxrstor(void * ); } 
#line 1130
extern "C" { extern void __cdecl _fxrstor64(void * ); } 
#line 118 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ammintrin.h"
extern "C" { __m128 _mm_macc_ps(__m128, __m128, __m128); } 
#line 119
extern "C" { __m128d _mm_macc_pd(__m128d, __m128d, __m128d); } 
#line 120
extern "C" { __m128 _mm_macc_ss(__m128, __m128, __m128); } 
#line 121
extern "C" { __m128d _mm_macc_sd(__m128d, __m128d, __m128d); } 
#line 122
extern "C" { __m128 _mm_maddsub_ps(__m128, __m128, __m128); } 
#line 123
extern "C" { __m128d _mm_maddsub_pd(__m128d, __m128d, __m128d); } 
#line 124
extern "C" { __m128 _mm_msubadd_ps(__m128, __m128, __m128); } 
#line 125
extern "C" { __m128d _mm_msubadd_pd(__m128d, __m128d, __m128d); } 
#line 126
extern "C" { __m128 _mm_msub_ps(__m128, __m128, __m128); } 
#line 127
extern "C" { __m128d _mm_msub_pd(__m128d, __m128d, __m128d); } 
#line 128
extern "C" { __m128 _mm_msub_ss(__m128, __m128, __m128); } 
#line 129
extern "C" { __m128d _mm_msub_sd(__m128d, __m128d, __m128d); } 
#line 130
extern "C" { __m128 _mm_nmacc_ps(__m128, __m128, __m128); } 
#line 131
extern "C" { __m128d _mm_nmacc_pd(__m128d, __m128d, __m128d); } 
#line 132
extern "C" { __m128 _mm_nmacc_ss(__m128, __m128, __m128); } 
#line 133
extern "C" { __m128d _mm_nmacc_sd(__m128d, __m128d, __m128d); } 
#line 134
extern "C" { __m128 _mm_nmsub_ps(__m128, __m128, __m128); } 
#line 135
extern "C" { __m128d _mm_nmsub_pd(__m128d, __m128d, __m128d); } 
#line 136
extern "C" { __m128 _mm_nmsub_ss(__m128, __m128, __m128); } 
#line 137
extern "C" { __m128d _mm_nmsub_sd(__m128d, __m128d, __m128d); } 
#line 140
extern "C" { __m128i _mm_maccs_epi16(__m128i, __m128i, __m128i); } 
#line 141
extern "C" { __m128i _mm_macc_epi16(__m128i, __m128i, __m128i); } 
#line 142
extern "C" { __m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i); } 
#line 143
extern "C" { __m128i _mm_maccd_epi16(__m128i, __m128i, __m128i); } 
#line 144
extern "C" { __m128i _mm_maccs_epi32(__m128i, __m128i, __m128i); } 
#line 145
extern "C" { __m128i _mm_macc_epi32(__m128i, __m128i, __m128i); } 
#line 146
extern "C" { __m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i); } 
#line 147
extern "C" { __m128i _mm_macclo_epi32(__m128i, __m128i, __m128i); } 
#line 148
extern "C" { __m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i); } 
#line 149
extern "C" { __m128i _mm_macchi_epi32(__m128i, __m128i, __m128i); } 
#line 150
extern "C" { __m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i); } 
#line 151
extern "C" { __m128i _mm_maddd_epi16(__m128i, __m128i, __m128i); } 
#line 154
extern "C" { __m128i _mm_haddw_epi8(__m128i); } 
#line 155
extern "C" { __m128i _mm_haddd_epi8(__m128i); } 
#line 156
extern "C" { __m128i _mm_haddq_epi8(__m128i); } 
#line 157
extern "C" { __m128i _mm_haddd_epi16(__m128i); } 
#line 158
extern "C" { __m128i _mm_haddq_epi16(__m128i); } 
#line 159
extern "C" { __m128i _mm_haddq_epi32(__m128i); } 
#line 160
extern "C" { __m128i _mm_haddw_epu8(__m128i); } 
#line 161
extern "C" { __m128i _mm_haddd_epu8(__m128i); } 
#line 162
extern "C" { __m128i _mm_haddq_epu8(__m128i); } 
#line 163
extern "C" { __m128i _mm_haddd_epu16(__m128i); } 
#line 164
extern "C" { __m128i _mm_haddq_epu16(__m128i); } 
#line 165
extern "C" { __m128i _mm_haddq_epu32(__m128i); } 
#line 166
extern "C" { __m128i _mm_hsubw_epi8(__m128i); } 
#line 167
extern "C" { __m128i _mm_hsubd_epi16(__m128i); } 
#line 168
extern "C" { __m128i _mm_hsubq_epi32(__m128i); } 
#line 171
extern "C" { __m128i _mm_cmov_si128(__m128i, __m128i, __m128i); } 
#line 172
extern "C" { __m128i _mm_perm_epi8(__m128i, __m128i, __m128i); } 
#line 175
extern "C" { __m128i _mm_rot_epi8(__m128i, __m128i); } 
#line 176
extern "C" { __m128i _mm_rot_epi16(__m128i, __m128i); } 
#line 177
extern "C" { __m128i _mm_rot_epi32(__m128i, __m128i); } 
#line 178
extern "C" { __m128i _mm_rot_epi64(__m128i, __m128i); } 
#line 179
extern "C" { __m128i _mm_roti_epi8(__m128i, int); } 
#line 180
extern "C" { __m128i _mm_roti_epi16(__m128i, int); } 
#line 181
extern "C" { __m128i _mm_roti_epi32(__m128i, int); } 
#line 182
extern "C" { __m128i _mm_roti_epi64(__m128i, int); } 
#line 183
extern "C" { __m128i _mm_shl_epi8(__m128i, __m128i); } 
#line 184
extern "C" { __m128i _mm_shl_epi16(__m128i, __m128i); } 
#line 185
extern "C" { __m128i _mm_shl_epi32(__m128i, __m128i); } 
#line 186
extern "C" { __m128i _mm_shl_epi64(__m128i, __m128i); } 
#line 187
extern "C" { __m128i _mm_sha_epi8(__m128i, __m128i); } 
#line 188
extern "C" { __m128i _mm_sha_epi16(__m128i, __m128i); } 
#line 189
extern "C" { __m128i _mm_sha_epi32(__m128i, __m128i); } 
#line 190
extern "C" { __m128i _mm_sha_epi64(__m128i, __m128i); } 
#line 194
extern "C" { __m128i _mm_com_epu8(__m128i, __m128i, int); } 
#line 195
extern "C" { __m128i _mm_com_epu16(__m128i, __m128i, int); } 
#line 196
extern "C" { __m128i _mm_com_epu32(__m128i, __m128i, int); } 
#line 197
extern "C" { __m128i _mm_com_epu64(__m128i, __m128i, int); } 
#line 198
extern "C" { __m128i _mm_com_epi8(__m128i, __m128i, int); } 
#line 199
extern "C" { __m128i _mm_com_epi16(__m128i, __m128i, int); } 
#line 200
extern "C" { __m128i _mm_com_epi32(__m128i, __m128i, int); } 
#line 201
extern "C" { __m128i _mm_com_epi64(__m128i, __m128i, int); } 
#line 205
extern "C" { __m128 _mm_frcz_ps(__m128); } 
#line 206
extern "C" { __m128d _mm_frcz_pd(__m128d); } 
#line 207
extern "C" { __m128 _mm_frcz_ss(__m128, __m128); } 
#line 208
extern "C" { __m128d _mm_frcz_sd(__m128d, __m128d); } 
#line 217
extern "C" { __m128 _mm_permute2_ps(__m128, __m128, __m128i, int); } 
#line 218
extern "C" { __m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int); } 
#line 222
extern "C" { __m256 _mm256_macc_ps(__m256, __m256, __m256); } 
#line 223
extern "C" { __m256d _mm256_macc_pd(__m256d, __m256d, __m256d); } 
#line 224
extern "C" { __m256 _mm256_maddsub_ps(__m256, __m256, __m256); } 
#line 225
extern "C" { __m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d); } 
#line 226
extern "C" { __m256 _mm256_msubadd_ps(__m256, __m256, __m256); } 
#line 227
extern "C" { __m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d); } 
#line 228
extern "C" { __m256 _mm256_msub_ps(__m256, __m256, __m256); } 
#line 229
extern "C" { __m256d _mm256_msub_pd(__m256d, __m256d, __m256d); } 
#line 230
extern "C" { __m256 _mm256_nmacc_ps(__m256, __m256, __m256); } 
#line 231
extern "C" { __m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d); } 
#line 232
extern "C" { __m256 _mm256_nmsub_ps(__m256, __m256, __m256); } 
#line 233
extern "C" { __m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d); } 
#line 234
extern "C" { __m256i _mm256_cmov_si256(__m256i, __m256i, __m256i); } 
#line 235
extern "C" { __m256 _mm256_frcz_ps(__m256); } 
#line 236
extern "C" { __m256d _mm256_frcz_pd(__m256d); } 
#line 237
extern "C" { __m256 _mm256_permute2_ps(__m256, __m256, __m256i, int); } 
#line 238
extern "C" { __m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int); } 
#line 241
extern "C" { void __llwpcb(void *); } 
#line 242
extern "C" { void *__slwpcb(); } 
#line 243
extern "C" { void __lwpval32(unsigned, unsigned, unsigned); } 
#line 244
extern "C" { void __lwpval64(unsigned __int64, unsigned, unsigned); } 
#line 245
extern "C" { unsigned char __lwpins32(unsigned, unsigned, unsigned); } 
#line 246
extern "C" { unsigned char __lwpins64(unsigned __int64, unsigned, unsigned); } 
#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\intrin.h"
extern "C" { void *__cdecl _alloca(size_t ); } 
#line 141
extern "C" { int __cdecl abs(int); } 
#line 144
extern "C" { unsigned short __cdecl _byteswap_ushort(unsigned short ); } 
#line 145
extern "C" { unsigned long __cdecl _byteswap_ulong(unsigned long ); } 
#line 146
extern "C" { unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 ); } 
#line 150
extern "C" { __declspec(dllimport) double ceil(double); } 
#line 164
extern "C" { void __cdecl __debugbreak(); } 
#line 165
extern "C" { void __cdecl _disable(); } 
#line 168
extern "C" { __int64 __emul(int, int); } 
#line 169
extern "C" { unsigned __int64 __emulu(unsigned, unsigned); } 
#line 170
extern "C" { void __cdecl _enable(); } 
#line 189
extern "C" { long __cdecl _InterlockedDecrement(volatile long *); } 
#line 196
extern "C" { __int64 _InterlockedDecrement64(volatile __int64 *); } 
#line 197
extern "C" { long _InterlockedExchange(volatile long *, long); } 
#line 203
extern "C" { __int64 _InterlockedExchange64(volatile __int64 *, __int64); } 
#line 206
extern "C" { void *_InterlockedExchangePointer(void *volatile *, void *); } 
#line 207
extern "C" { short _InterlockedExchange16(volatile short *, short); } 
#line 208
extern "C" { char _InterlockedExchange8(volatile char *, char); } 
#line 209
extern "C" { long _InterlockedExchangeAdd(volatile long *, long); } 
#line 216
extern "C" { __int64 _InterlockedExchangeAdd64(volatile __int64 *, __int64); } 
#line 217
extern "C" { short _InterlockedExchangeAdd16(volatile short *, short); } 
#line 218
extern "C" { char _InterlockedExchangeAdd8(volatile char *, char); } 
#line 219
extern "C" { long _InterlockedCompareExchange(volatile long *, long, long); } 
#line 232
extern "C" { __int64 _InterlockedCompareExchange64(volatile __int64 *, __int64, __int64); } 
#line 233
extern "C" { void *_InterlockedCompareExchangePointer(void *volatile *, void *, void *); } 
#line 234
extern "C" { long __cdecl _InterlockedIncrement(volatile long *); } 
#line 241
extern "C" { __int64 _InterlockedIncrement64(volatile __int64 *); } 
#line 242
extern "C" { long _InterlockedOr(volatile long *, long); } 
#line 243
extern "C" { char _InterlockedOr8(volatile char *, char); } 
#line 244
extern "C" { short _InterlockedOr16(volatile short *, short); } 
#line 245
extern "C" { __int64 _InterlockedOr64(volatile __int64 *, __int64); } 
#line 254
extern "C" { long _InterlockedXor(volatile long *, long); } 
#line 255
extern "C" { char _InterlockedXor8(volatile char *, char); } 
#line 256
extern "C" { short _InterlockedXor16(volatile short *, short); } 
#line 257
extern "C" { __int64 _InterlockedXor64(volatile __int64 *, __int64); } 
#line 266
extern "C" { long _InterlockedAnd(volatile long *, long); } 
#line 267
extern "C" { char _InterlockedAnd8(volatile char *, char); } 
#line 268
extern "C" { short _InterlockedAnd16(volatile short *, short); } 
#line 269
extern "C" { __int64 _InterlockedAnd64(volatile __int64 *, __int64); } 
#line 279
extern "C" { int __cdecl _inp(unsigned short); } 
#line 280
extern "C" { int __cdecl inp(unsigned short); } 
#line 281
extern "C" { unsigned long __cdecl _inpd(unsigned short); } 
#line 282
extern "C" { unsigned long __cdecl inpd(unsigned short); } 
#line 283
extern "C" { unsigned short __cdecl _inpw(unsigned short); } 
#line 284
extern "C" { unsigned short __cdecl inpw(unsigned short); } 
#line 292
extern "C" { long __cdecl labs(long); } 
#line 300
extern "C" { unsigned long __cdecl _lrotl(unsigned long, int); } 
#line 301
extern "C" { unsigned long __cdecl _lrotr(unsigned long, int); } 
#line 302
extern "C" { unsigned __int64 __ll_lshift(unsigned __int64, int); } 
#line 303
extern "C" { __int64 __ll_rshift(__int64, int); } 
#line 343
extern "C" { int __cdecl memcmp(const void *, const void *, size_t ); } 
#line 344
extern "C" { void *__cdecl memcpy(void *, const void *, size_t ); } 
#line 345
extern "C" { void *__cdecl memset(void *, int, size_t ); } 
#line 350
extern "C" { int __cdecl _outp(unsigned short, int); } 
#line 351
extern "C" { int __cdecl outp(unsigned short, int); } 
#line 352
extern "C" { unsigned long __cdecl _outpd(unsigned short, unsigned long); } 
#line 353
extern "C" { unsigned long __cdecl outpd(unsigned short, unsigned long); } 
#line 354
extern "C" { unsigned short __cdecl _outpw(unsigned short, unsigned short); } 
#line 355
extern "C" { unsigned short __cdecl outpw(unsigned short, unsigned short); } 
#line 367
extern "C" { void *_ReturnAddress(); } 
#line 371
extern "C" { unsigned __cdecl _rotl(unsigned, int); } 
#line 373
extern "C" { unsigned __cdecl _rotr(unsigned, int); } 
#line 377
extern "C" { int __cdecl _setjmp(jmp_buf); } 
#line 379
extern "C" { int __cdecl _setjmpex(jmp_buf); } 
#line 389
extern "C" { int __cdecl strcmp(const char *, const char *); } 
#line 390
extern "C" { size_t __cdecl strlen(const char *); } 
#line 392
extern "C" { char *__cdecl strset(char *, int); } 
#line 400
extern "C" { unsigned __int64 __ull_rshift(unsigned __int64, int); } 
#line 407
extern "C" { void *_AddressOfReturnAddress(); } 
#line 491
extern "C" { __m128 _mm_add_ss(__m128, __m128); } 
#line 492
extern "C" { __m128 _mm_add_ps(__m128, __m128); } 
#line 493
extern "C" { __m128 _mm_sub_ss(__m128, __m128); } 
#line 494
extern "C" { __m128 _mm_sub_ps(__m128, __m128); } 
#line 495
extern "C" { __m128 _mm_mul_ss(__m128, __m128); } 
#line 496
extern "C" { __m128 _mm_mul_ps(__m128, __m128); } 
#line 497
extern "C" { __m128 _mm_div_ss(__m128, __m128); } 
#line 498
extern "C" { __m128 _mm_div_ps(__m128, __m128); } 
#line 499
extern "C" { __m128 _mm_sqrt_ss(__m128); } 
#line 500
extern "C" { __m128 _mm_sqrt_ps(__m128); } 
#line 501
extern "C" { __m128 _mm_rcp_ss(__m128); } 
#line 502
extern "C" { __m128 _mm_rcp_ps(__m128); } 
#line 503
extern "C" { __m128 _mm_rsqrt_ss(__m128); } 
#line 504
extern "C" { __m128 _mm_rsqrt_ps(__m128); } 
#line 505
extern "C" { __m128 _mm_min_ss(__m128, __m128); } 
#line 506
extern "C" { __m128 _mm_min_ps(__m128, __m128); } 
#line 507
extern "C" { __m128 _mm_max_ss(__m128, __m128); } 
#line 508
extern "C" { __m128 _mm_max_ps(__m128, __m128); } 
#line 509
extern "C" { __m128 _mm_and_ps(__m128, __m128); } 
#line 510
extern "C" { __m128 _mm_andnot_ps(__m128, __m128); } 
#line 511
extern "C" { __m128 _mm_or_ps(__m128, __m128); } 
#line 512
extern "C" { __m128 _mm_xor_ps(__m128, __m128); } 
#line 513
extern "C" { __m128 _mm_cmpeq_ss(__m128, __m128); } 
#line 514
extern "C" { __m128 _mm_cmpeq_ps(__m128, __m128); } 
#line 515
extern "C" { __m128 _mm_cmplt_ss(__m128, __m128); } 
#line 516
extern "C" { __m128 _mm_cmplt_ps(__m128, __m128); } 
#line 517
extern "C" { __m128 _mm_cmple_ss(__m128, __m128); } 
#line 518
extern "C" { __m128 _mm_cmple_ps(__m128, __m128); } 
#line 519
extern "C" { __m128 _mm_cmpgt_ss(__m128, __m128); } 
#line 520
extern "C" { __m128 _mm_cmpgt_ps(__m128, __m128); } 
#line 521
extern "C" { __m128 _mm_cmpge_ss(__m128, __m128); } 
#line 522
extern "C" { __m128 _mm_cmpge_ps(__m128, __m128); } 
#line 523
extern "C" { __m128 _mm_cmpneq_ss(__m128, __m128); } 
#line 524
extern "C" { __m128 _mm_cmpneq_ps(__m128, __m128); } 
#line 525
extern "C" { __m128 _mm_cmpnlt_ss(__m128, __m128); } 
#line 526
extern "C" { __m128 _mm_cmpnlt_ps(__m128, __m128); } 
#line 527
extern "C" { __m128 _mm_cmpnle_ss(__m128, __m128); } 
#line 528
extern "C" { __m128 _mm_cmpnle_ps(__m128, __m128); } 
#line 529
extern "C" { __m128 _mm_cmpngt_ss(__m128, __m128); } 
#line 530
extern "C" { __m128 _mm_cmpngt_ps(__m128, __m128); } 
#line 531
extern "C" { __m128 _mm_cmpnge_ss(__m128, __m128); } 
#line 532
extern "C" { __m128 _mm_cmpnge_ps(__m128, __m128); } 
#line 533
extern "C" { __m128 _mm_cmpord_ss(__m128, __m128); } 
#line 534
extern "C" { __m128 _mm_cmpord_ps(__m128, __m128); } 
#line 535
extern "C" { __m128 _mm_cmpunord_ss(__m128, __m128); } 
#line 536
extern "C" { __m128 _mm_cmpunord_ps(__m128, __m128); } 
#line 537
extern "C" { int _mm_comieq_ss(__m128, __m128); } 
#line 538
extern "C" { int _mm_comilt_ss(__m128, __m128); } 
#line 539
extern "C" { int _mm_comile_ss(__m128, __m128); } 
#line 540
extern "C" { int _mm_comigt_ss(__m128, __m128); } 
#line 541
extern "C" { int _mm_comige_ss(__m128, __m128); } 
#line 542
extern "C" { int _mm_comineq_ss(__m128, __m128); } 
#line 543
extern "C" { int _mm_ucomieq_ss(__m128, __m128); } 
#line 544
extern "C" { int _mm_ucomilt_ss(__m128, __m128); } 
#line 545
extern "C" { int _mm_ucomile_ss(__m128, __m128); } 
#line 546
extern "C" { int _mm_ucomigt_ss(__m128, __m128); } 
#line 547
extern "C" { int _mm_ucomige_ss(__m128, __m128); } 
#line 548
extern "C" { int _mm_ucomineq_ss(__m128, __m128); } 
#line 549
extern "C" { int _mm_cvt_ss2si(__m128); } 
#line 551
extern "C" { int _mm_cvtt_ss2si(__m128); } 
#line 553
extern "C" { __m128 _mm_cvt_si2ss(__m128, int); } 
#line 555
extern "C" { __m128 _mm_shuffle_ps(__m128, __m128, unsigned); } 
#line 556
extern "C" { __m128 _mm_unpackhi_ps(__m128, __m128); } 
#line 557
extern "C" { __m128 _mm_unpacklo_ps(__m128, __m128); } 
#line 558
extern "C" { __m128 _mm_loadh_pi(__m128, const __m64 *); } 
#line 559
extern "C" { void _mm_storeh_pi(__m64 *, __m128); } 
#line 560
extern "C" { __m128 _mm_loadl_pi(__m128, const __m64 *); } 
#line 561
extern "C" { void _mm_storel_pi(__m64 *, __m128); } 
#line 562
extern "C" { int _mm_movemask_ps(__m128); } 
#line 563
extern "C" { __m128 _mm_set_ss(float); } 
#line 564
extern "C" { __m128 _mm_set_ps1(float); } 
#line 565
extern "C" { __m128 _mm_set_ps(float, float, float, float); } 
#line 566
extern "C" { __m128 _mm_setr_ps(float, float, float, float); } 
#line 567
extern "C" { __m128 _mm_setzero_ps(); } 
#line 568
extern "C" { __m128 _mm_load_ss(const float *); } 
#line 569
extern "C" { __m128 _mm_load_ps1(const float *); } 
#line 570
extern "C" { __m128 _mm_load_ps(const float *); } 
#line 571
extern "C" { __m128 _mm_loadr_ps(const float *); } 
#line 572
extern "C" { __m128 _mm_loadu_ps(const float *); } 
#line 573
extern "C" { __m128 _mm_move_ss(__m128, __m128); } 
#line 574
extern "C" { void _mm_store_ss(float *, __m128); } 
#line 575
extern "C" { void _mm_store_ps1(float *, __m128); } 
#line 576
extern "C" { void _mm_store_ps(float *, __m128); } 
#line 577
extern "C" { void _mm_storer_ps(float *, __m128); } 
#line 578
extern "C" { void _mm_storeu_ps(float *, __m128); } 
#line 579
extern "C" { void _mm_prefetch(const char *, int); } 
#line 581
extern "C" { void _mm_stream_ps(float *, __m128); } 
#line 582
extern "C" { void _mm_sfence(); } 
#line 583
extern "C" { unsigned _mm_getcsr(); } 
#line 584
extern "C" { void _mm_setcsr(unsigned); } 
#line 585
extern "C" { __m128 _mm_movelh_ps(__m128, __m128); } 
#line 586
extern "C" { __m128 _mm_movehl_ps(__m128, __m128); } 
#line 587
extern "C" { void _m_prefetch(void *); } 
#line 588
extern "C" { void _m_prefetchw(const volatile void * ); } 
#line 614
extern "C" { __m128d _mm_add_sd(__m128d, __m128d); } 
#line 615
extern "C" { __m128d _mm_add_pd(__m128d, __m128d); } 
#line 616
extern "C" { __m128d _mm_div_sd(__m128d, __m128d); } 
#line 617
extern "C" { __m128d _mm_div_pd(__m128d, __m128d); } 
#line 618
extern "C" { __m128d _mm_max_sd(__m128d, __m128d); } 
#line 619
extern "C" { __m128d _mm_max_pd(__m128d, __m128d); } 
#line 620
extern "C" { __m128d _mm_min_sd(__m128d, __m128d); } 
#line 621
extern "C" { __m128d _mm_min_pd(__m128d, __m128d); } 
#line 622
extern "C" { __m128d _mm_mul_sd(__m128d, __m128d); } 
#line 623
extern "C" { __m128d _mm_mul_pd(__m128d, __m128d); } 
#line 624
extern "C" { __m128d _mm_sqrt_sd(__m128d, __m128d); } 
#line 625
extern "C" { __m128d _mm_sqrt_pd(__m128d); } 
#line 626
extern "C" { __m128d _mm_sub_sd(__m128d, __m128d); } 
#line 627
extern "C" { __m128d _mm_sub_pd(__m128d, __m128d); } 
#line 628
extern "C" { __m128d _mm_and_pd(__m128d, __m128d); } 
#line 629
extern "C" { __m128d _mm_andnot_pd(__m128d, __m128d); } 
#line 630
extern "C" { __m128d _mm_or_pd(__m128d, __m128d); } 
#line 631
extern "C" { __m128d _mm_xor_pd(__m128d, __m128d); } 
#line 632
extern "C" { __m128d _mm_cmpeq_sd(__m128d, __m128d); } 
#line 633
extern "C" { __m128d _mm_cmpeq_pd(__m128d, __m128d); } 
#line 634
extern "C" { __m128d _mm_cmplt_sd(__m128d, __m128d); } 
#line 635
extern "C" { __m128d _mm_cmplt_pd(__m128d, __m128d); } 
#line 636
extern "C" { __m128d _mm_cmple_sd(__m128d, __m128d); } 
#line 637
extern "C" { __m128d _mm_cmple_pd(__m128d, __m128d); } 
#line 638
extern "C" { __m128d _mm_cmpgt_sd(__m128d, __m128d); } 
#line 639
extern "C" { __m128d _mm_cmpgt_pd(__m128d, __m128d); } 
#line 640
extern "C" { __m128d _mm_cmpge_sd(__m128d, __m128d); } 
#line 641
extern "C" { __m128d _mm_cmpge_pd(__m128d, __m128d); } 
#line 642
extern "C" { __m128d _mm_cmpneq_sd(__m128d, __m128d); } 
#line 643
extern "C" { __m128d _mm_cmpneq_pd(__m128d, __m128d); } 
#line 644
extern "C" { __m128d _mm_cmpnlt_sd(__m128d, __m128d); } 
#line 645
extern "C" { __m128d _mm_cmpnlt_pd(__m128d, __m128d); } 
#line 646
extern "C" { __m128d _mm_cmpnle_sd(__m128d, __m128d); } 
#line 647
extern "C" { __m128d _mm_cmpnle_pd(__m128d, __m128d); } 
#line 648
extern "C" { __m128d _mm_cmpngt_sd(__m128d, __m128d); } 
#line 649
extern "C" { __m128d _mm_cmpngt_pd(__m128d, __m128d); } 
#line 650
extern "C" { __m128d _mm_cmpnge_sd(__m128d, __m128d); } 
#line 651
extern "C" { __m128d _mm_cmpnge_pd(__m128d, __m128d); } 
#line 652
extern "C" { __m128d _mm_cmpord_sd(__m128d, __m128d); } 
#line 653
extern "C" { __m128d _mm_cmpord_pd(__m128d, __m128d); } 
#line 654
extern "C" { __m128d _mm_cmpunord_sd(__m128d, __m128d); } 
#line 655
extern "C" { __m128d _mm_cmpunord_pd(__m128d, __m128d); } 
#line 656
extern "C" { int _mm_comieq_sd(__m128d, __m128d); } 
#line 657
extern "C" { int _mm_comilt_sd(__m128d, __m128d); } 
#line 658
extern "C" { int _mm_comile_sd(__m128d, __m128d); } 
#line 659
extern "C" { int _mm_comigt_sd(__m128d, __m128d); } 
#line 660
extern "C" { int _mm_comige_sd(__m128d, __m128d); } 
#line 661
extern "C" { int _mm_comineq_sd(__m128d, __m128d); } 
#line 662
extern "C" { int _mm_ucomieq_sd(__m128d, __m128d); } 
#line 663
extern "C" { int _mm_ucomilt_sd(__m128d, __m128d); } 
#line 664
extern "C" { int _mm_ucomile_sd(__m128d, __m128d); } 
#line 665
extern "C" { int _mm_ucomigt_sd(__m128d, __m128d); } 
#line 666
extern "C" { int _mm_ucomige_sd(__m128d, __m128d); } 
#line 667
extern "C" { int _mm_ucomineq_sd(__m128d, __m128d); } 
#line 668
extern "C" { __m128 _mm_cvtpd_ps(__m128d); } 
#line 669
extern "C" { __m128d _mm_cvtps_pd(__m128); } 
#line 670
extern "C" { __m128d _mm_cvtepi32_pd(__m128i); } 
#line 671
extern "C" { __m128i _mm_cvtpd_epi32(__m128d); } 
#line 672
extern "C" { int _mm_cvtsd_si32(__m128d); } 
#line 673
extern "C" { __m128 _mm_cvtsd_ss(__m128, __m128d); } 
#line 674
extern "C" { __m128d _mm_cvtsi32_sd(__m128d, int); } 
#line 675
extern "C" { __m128d _mm_cvtss_sd(__m128d, __m128); } 
#line 676
extern "C" { __m128i _mm_cvttpd_epi32(__m128d); } 
#line 677
extern "C" { int _mm_cvttsd_si32(__m128d); } 
#line 678
extern "C" { __m128 _mm_cvtepi32_ps(__m128i); } 
#line 679
extern "C" { __m128i _mm_cvtps_epi32(__m128); } 
#line 680
extern "C" { __m128i _mm_cvttps_epi32(__m128); } 
#line 684
extern "C" { __m128d _mm_unpackhi_pd(__m128d, __m128d); } 
#line 685
extern "C" { __m128d _mm_unpacklo_pd(__m128d, __m128d); } 
#line 686
extern "C" { int _mm_movemask_pd(__m128d); } 
#line 687
extern "C" { __m128d _mm_shuffle_pd(__m128d, __m128d, int); } 
#line 688
extern "C" { __m128d _mm_load_pd(const double *); } 
#line 689
extern "C" { __m128d _mm_load1_pd(const double *); } 
#line 690
extern "C" { __m128d _mm_loadr_pd(const double *); } 
#line 691
extern "C" { __m128d _mm_loadu_pd(const double *); } 
#line 692
extern "C" { __m128d _mm_load_sd(const double *); } 
#line 693
extern "C" { __m128d _mm_loadh_pd(__m128d, const double *); } 
#line 694
extern "C" { __m128d _mm_loadl_pd(__m128d, const double *); } 
#line 695
extern "C" { __m128d _mm_set_sd(double); } 
#line 696
extern "C" { __m128d _mm_set1_pd(double); } 
#line 697
extern "C" { __m128d _mm_set_pd(double, double); } 
#line 698
extern "C" { __m128d _mm_setr_pd(double, double); } 
#line 699
extern "C" { __m128d _mm_setzero_pd(); } 
#line 700
extern "C" { __m128d _mm_move_sd(__m128d, __m128d); } 
#line 701
extern "C" { void _mm_store_sd(double *, __m128d); } 
#line 702
extern "C" { void _mm_store1_pd(double *, __m128d); } 
#line 703
extern "C" { void _mm_store_pd(double *, __m128d); } 
#line 704
extern "C" { void _mm_storeu_pd(double *, __m128d); } 
#line 705
extern "C" { void _mm_storer_pd(double *, __m128d); } 
#line 706
extern "C" { void _mm_storeh_pd(double *, __m128d); } 
#line 707
extern "C" { void _mm_storel_pd(double *, __m128d); } 
#line 708
extern "C" { __m128i _mm_add_epi8(__m128i, __m128i); } 
#line 709
extern "C" { __m128i _mm_add_epi16(__m128i, __m128i); } 
#line 710
extern "C" { __m128i _mm_add_epi32(__m128i, __m128i); } 
#line 712
extern "C" { __m128i _mm_add_epi64(__m128i, __m128i); } 
#line 713
extern "C" { __m128i _mm_adds_epi8(__m128i, __m128i); } 
#line 714
extern "C" { __m128i _mm_adds_epi16(__m128i, __m128i); } 
#line 715
extern "C" { __m128i _mm_adds_epu8(__m128i, __m128i); } 
#line 716
extern "C" { __m128i _mm_adds_epu16(__m128i, __m128i); } 
#line 717
extern "C" { __m128i _mm_avg_epu8(__m128i, __m128i); } 
#line 718
extern "C" { __m128i _mm_avg_epu16(__m128i, __m128i); } 
#line 719
extern "C" { __m128i _mm_madd_epi16(__m128i, __m128i); } 
#line 720
extern "C" { __m128i _mm_max_epi16(__m128i, __m128i); } 
#line 721
extern "C" { __m128i _mm_max_epu8(__m128i, __m128i); } 
#line 722
extern "C" { __m128i _mm_min_epi16(__m128i, __m128i); } 
#line 723
extern "C" { __m128i _mm_min_epu8(__m128i, __m128i); } 
#line 724
extern "C" { __m128i _mm_mulhi_epi16(__m128i, __m128i); } 
#line 725
extern "C" { __m128i _mm_mulhi_epu16(__m128i, __m128i); } 
#line 726
extern "C" { __m128i _mm_mullo_epi16(__m128i, __m128i); } 
#line 728
extern "C" { __m128i _mm_mul_epu32(__m128i, __m128i); } 
#line 729
extern "C" { __m128i _mm_sad_epu8(__m128i, __m128i); } 
#line 730
extern "C" { __m128i _mm_sub_epi8(__m128i, __m128i); } 
#line 731
extern "C" { __m128i _mm_sub_epi16(__m128i, __m128i); } 
#line 732
extern "C" { __m128i _mm_sub_epi32(__m128i, __m128i); } 
#line 734
extern "C" { __m128i _mm_sub_epi64(__m128i, __m128i); } 
#line 735
extern "C" { __m128i _mm_subs_epi8(__m128i, __m128i); } 
#line 736
extern "C" { __m128i _mm_subs_epi16(__m128i, __m128i); } 
#line 737
extern "C" { __m128i _mm_subs_epu8(__m128i, __m128i); } 
#line 738
extern "C" { __m128i _mm_subs_epu16(__m128i, __m128i); } 
#line 739
extern "C" { __m128i _mm_andnot_si128(__m128i, __m128i); } 
#line 740
extern "C" { __m128i _mm_and_si128(__m128i, __m128i); } 
#line 741
extern "C" { __m128i _mm_or_si128(__m128i, __m128i); } 
#line 742
extern "C" { __m128i _mm_xor_si128(__m128i, __m128i); } 
#line 743
extern "C" { __m128i _mm_slli_si128(__m128i, int); } 
#line 744
extern "C" { __m128i _mm_slli_epi16(__m128i, int); } 
#line 745
extern "C" { __m128i _mm_sll_epi16(__m128i, __m128i); } 
#line 746
extern "C" { __m128i _mm_slli_epi32(__m128i, int); } 
#line 747
extern "C" { __m128i _mm_sll_epi32(__m128i, __m128i); } 
#line 748
extern "C" { __m128i _mm_slli_epi64(__m128i, int); } 
#line 749
extern "C" { __m128i _mm_sll_epi64(__m128i, __m128i); } 
#line 750
extern "C" { __m128i _mm_srai_epi16(__m128i, int); } 
#line 751
extern "C" { __m128i _mm_sra_epi16(__m128i, __m128i); } 
#line 752
extern "C" { __m128i _mm_srai_epi32(__m128i, int); } 
#line 753
extern "C" { __m128i _mm_sra_epi32(__m128i, __m128i); } 
#line 754
extern "C" { __m128i _mm_srli_si128(__m128i, int); } 
#line 755
extern "C" { __m128i _mm_srli_epi16(__m128i, int); } 
#line 756
extern "C" { __m128i _mm_srl_epi16(__m128i, __m128i); } 
#line 757
extern "C" { __m128i _mm_srli_epi32(__m128i, int); } 
#line 758
extern "C" { __m128i _mm_srl_epi32(__m128i, __m128i); } 
#line 759
extern "C" { __m128i _mm_srli_epi64(__m128i, int); } 
#line 760
extern "C" { __m128i _mm_srl_epi64(__m128i, __m128i); } 
#line 761
extern "C" { __m128i _mm_cmpeq_epi8(__m128i, __m128i); } 
#line 762
extern "C" { __m128i _mm_cmpeq_epi16(__m128i, __m128i); } 
#line 763
extern "C" { __m128i _mm_cmpeq_epi32(__m128i, __m128i); } 
#line 764
extern "C" { __m128i _mm_cmpgt_epi8(__m128i, __m128i); } 
#line 765
extern "C" { __m128i _mm_cmpgt_epi16(__m128i, __m128i); } 
#line 766
extern "C" { __m128i _mm_cmpgt_epi32(__m128i, __m128i); } 
#line 767
extern "C" { __m128i _mm_cmplt_epi8(__m128i, __m128i); } 
#line 768
extern "C" { __m128i _mm_cmplt_epi16(__m128i, __m128i); } 
#line 769
extern "C" { __m128i _mm_cmplt_epi32(__m128i, __m128i); } 
#line 770
extern "C" { __m128i _mm_cvtsi32_si128(int); } 
#line 771
extern "C" { int _mm_cvtsi128_si32(__m128i); } 
#line 772
extern "C" { __m128i _mm_packs_epi16(__m128i, __m128i); } 
#line 773
extern "C" { __m128i _mm_packs_epi32(__m128i, __m128i); } 
#line 774
extern "C" { __m128i _mm_packus_epi16(__m128i, __m128i); } 
#line 775
extern "C" { int _mm_extract_epi16(__m128i, int); } 
#line 776
extern "C" { __m128i _mm_insert_epi16(__m128i, int, int); } 
#line 777
extern "C" { int _mm_movemask_epi8(__m128i); } 
#line 778
extern "C" { __m128i _mm_shuffle_epi32(__m128i, int); } 
#line 779
extern "C" { __m128i _mm_shufflehi_epi16(__m128i, int); } 
#line 780
extern "C" { __m128i _mm_shufflelo_epi16(__m128i, int); } 
#line 781
extern "C" { __m128i _mm_unpackhi_epi8(__m128i, __m128i); } 
#line 782
extern "C" { __m128i _mm_unpackhi_epi16(__m128i, __m128i); } 
#line 783
extern "C" { __m128i _mm_unpackhi_epi32(__m128i, __m128i); } 
#line 784
extern "C" { __m128i _mm_unpackhi_epi64(__m128i, __m128i); } 
#line 785
extern "C" { __m128i _mm_unpacklo_epi8(__m128i, __m128i); } 
#line 786
extern "C" { __m128i _mm_unpacklo_epi16(__m128i, __m128i); } 
#line 787
extern "C" { __m128i _mm_unpacklo_epi32(__m128i, __m128i); } 
#line 788
extern "C" { __m128i _mm_unpacklo_epi64(__m128i, __m128i); } 
#line 789
extern "C" { __m128i _mm_load_si128(const __m128i *); } 
#line 790
extern "C" { __m128i _mm_loadu_si128(const __m128i *); } 
#line 791
extern "C" { __m128i _mm_loadl_epi64(const __m128i *); } 
#line 793
extern "C" { __m128i _mm_set_epi32(int, int, int, int); } 
#line 794
extern "C" { __m128i _mm_set_epi16(short, short, short, short, short, short, short, short); } 
#line 795
extern "C" { __m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); } 
#line 797
extern "C" { __m128i _mm_set1_epi32(int); } 
#line 798
extern "C" { __m128i _mm_set1_epi16(short); } 
#line 799
extern "C" { __m128i _mm_set1_epi8(char); } 
#line 800
extern "C" { __m128i _mm_setl_epi64(__m128i); } 
#line 802
extern "C" { __m128i _mm_setr_epi32(int, int, int, int); } 
#line 803
extern "C" { __m128i _mm_setr_epi16(short, short, short, short, short, short, short, short); } 
#line 804
extern "C" { __m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); } 
#line 805
extern "C" { __m128i _mm_setzero_si128(); } 
#line 806
extern "C" { void _mm_store_si128(__m128i *, __m128i); } 
#line 807
extern "C" { void _mm_storeu_si128(__m128i *, __m128i); } 
#line 808
extern "C" { void _mm_storel_epi64(__m128i *, __m128i); } 
#line 809
extern "C" { void _mm_maskmoveu_si128(__m128i, __m128i, char *); } 
#line 810
extern "C" { __m128i _mm_move_epi64(__m128i); } 
#line 813
extern "C" { void _mm_stream_pd(double *, __m128d); } 
#line 814
extern "C" { void _mm_stream_si128(__m128i *, __m128i); } 
#line 815
extern "C" { void _mm_clflush(const void *); } 
#line 816
extern "C" { void _mm_lfence(); } 
#line 817
extern "C" { void _mm_mfence(); } 
#line 818
extern "C" { void _mm_stream_si32(int *, int); } 
#line 819
extern "C" { void _mm_pause(); } 
#line 820
extern "C" { __m128 _mm_addsub_ps(__m128, __m128); } 
#line 821
extern "C" { __m128d _mm_addsub_pd(__m128d, __m128d); } 
#line 822
extern "C" { __m128 _mm_hadd_ps(__m128, __m128); } 
#line 823
extern "C" { __m128d _mm_hadd_pd(__m128d, __m128d); } 
#line 824
extern "C" { __m128 _mm_hsub_ps(__m128, __m128); } 
#line 825
extern "C" { __m128d _mm_hsub_pd(__m128d, __m128d); } 
#line 826
extern "C" { __m128i _mm_lddqu_si128(const __m128i *); } 
#line 827
extern "C" { void _mm_monitor(const void *, unsigned, unsigned); } 
#line 828
extern "C" { __m128d _mm_movedup_pd(__m128d); } 
#line 829
extern "C" { __m128d _mm_loaddup_pd(const double *); } 
#line 830
extern "C" { __m128 _mm_movehdup_ps(__m128); } 
#line 831
extern "C" { __m128 _mm_moveldup_ps(__m128); } 
#line 832
extern "C" { void _mm_mwait(unsigned, unsigned); } 
#line 833
extern "C" { __m128i _mm_hadd_epi16(__m128i , __m128i ); } 
#line 834
extern "C" { __m128i _mm_hadd_epi32(__m128i , __m128i ); } 
#line 835
extern "C" { __m128i _mm_hadds_epi16(__m128i , __m128i ); } 
#line 836
extern "C" { __m64 _mm_hadd_pi16(__m64 , __m64 ); } 
#line 837
extern "C" { __m64 _mm_hadd_pi32(__m64 , __m64 ); } 
#line 838
extern "C" { __m64 _mm_hadds_pi16(__m64 , __m64 ); } 
#line 839
extern "C" { __m128i _mm_hsub_epi16(__m128i , __m128i ); } 
#line 840
extern "C" { __m128i _mm_hsub_epi32(__m128i , __m128i ); } 
#line 841
extern "C" { __m128i _mm_hsubs_epi16(__m128i , __m128i ); } 
#line 842
extern "C" { __m64 _mm_hsub_pi16(__m64 , __m64 ); } 
#line 843
extern "C" { __m64 _mm_hsub_pi32(__m64 , __m64 ); } 
#line 844
extern "C" { __m64 _mm_hsubs_pi16(__m64 , __m64 ); } 
#line 845
extern "C" { __m128i _mm_maddubs_epi16(__m128i , __m128i ); } 
#line 846
extern "C" { __m64 _mm_maddubs_pi16(__m64 , __m64 ); } 
#line 847
extern "C" { __m128i _mm_mulhrs_epi16(__m128i , __m128i ); } 
#line 848
extern "C" { __m64 _mm_mulhrs_pi16(__m64 , __m64 ); } 
#line 849
extern "C" { __m128i _mm_shuffle_epi8(__m128i , __m128i ); } 
#line 850
extern "C" { __m64 _mm_shuffle_pi8(__m64 , __m64 ); } 
#line 851
extern "C" { __m128i _mm_sign_epi8(__m128i , __m128i ); } 
#line 852
extern "C" { __m128i _mm_sign_epi16(__m128i , __m128i ); } 
#line 853
extern "C" { __m128i _mm_sign_epi32(__m128i , __m128i ); } 
#line 854
extern "C" { __m64 _mm_sign_pi8(__m64 , __m64 ); } 
#line 855
extern "C" { __m64 _mm_sign_pi16(__m64 , __m64 ); } 
#line 856
extern "C" { __m64 _mm_sign_pi32(__m64 , __m64 ); } 
#line 857
extern "C" { __m128i _mm_alignr_epi8(__m128i , __m128i , int ); } 
#line 858
extern "C" { __m64 _mm_alignr_pi8(__m64 , __m64 , int ); } 
#line 859
extern "C" { __m128i _mm_abs_epi8(__m128i ); } 
#line 860
extern "C" { __m128i _mm_abs_epi16(__m128i ); } 
#line 861
extern "C" { __m128i _mm_abs_epi32(__m128i ); } 
#line 862
extern "C" { __m64 _mm_abs_pi8(__m64 ); } 
#line 863
extern "C" { __m64 _mm_abs_pi16(__m64 ); } 
#line 864
extern "C" { __m64 _mm_abs_pi32(__m64 ); } 
#line 865
extern "C" { __int64 _mm_cvtss_si64(__m128 ); } 
#line 866
extern "C" { __int64 _mm_cvttss_si64(__m128 ); } 
#line 867
extern "C" { __m128 _mm_cvtsi64_ss(__m128 , __int64 ); } 
#line 868
extern "C" { __int64 _mm_cvtsd_si64(__m128d); } 
#line 869
extern "C" { __int64 _mm_cvttsd_si64(__m128d); } 
#line 870
extern "C" { __m128d _mm_cvtsi64_sd(__m128d, __int64); } 
#line 871
extern "C" { __m128i _mm_cvtsi64_si128(__int64); } 
#line 872
extern "C" { __int64 _mm_cvtsi128_si64(__m128i); } 
#line 873
extern "C" { __m128i _mm_blend_epi16(__m128i , __m128i , const int ); } 
#line 874
extern "C" { __m128i _mm_blendv_epi8(__m128i , __m128i , __m128i ); } 
#line 875
extern "C" { __m128 _mm_blend_ps(__m128 , __m128 , const int ); } 
#line 876
extern "C" { __m128 _mm_blendv_ps(__m128 , __m128 , __m128 ); } 
#line 877
extern "C" { __m128d _mm_blend_pd(__m128d , __m128d , const int ); } 
#line 878
extern "C" { __m128d _mm_blendv_pd(__m128d , __m128d , __m128d ); } 
#line 879
extern "C" { __m128 _mm_dp_ps(__m128 , __m128 , const int ); } 
#line 880
extern "C" { __m128d _mm_dp_pd(__m128d , __m128d , const int ); } 
#line 881
extern "C" { __m128i _mm_cmpeq_epi64(__m128i , __m128i ); } 
#line 882
extern "C" { __m128i _mm_min_epi8(__m128i , __m128i ); } 
#line 883
extern "C" { __m128i _mm_max_epi8(__m128i , __m128i ); } 
#line 884
extern "C" { __m128i _mm_min_epu16(__m128i , __m128i ); } 
#line 885
extern "C" { __m128i _mm_max_epu16(__m128i , __m128i ); } 
#line 886
extern "C" { __m128i _mm_min_epi32(__m128i , __m128i ); } 
#line 887
extern "C" { __m128i _mm_max_epi32(__m128i , __m128i ); } 
#line 888
extern "C" { __m128i _mm_min_epu32(__m128i , __m128i ); } 
#line 889
extern "C" { __m128i _mm_max_epu32(__m128i , __m128i ); } 
#line 890
extern "C" { __m128i _mm_mullo_epi32(__m128i , __m128i ); } 
#line 891
extern "C" { __m128i _mm_mul_epi32(__m128i , __m128i ); } 
#line 892
extern "C" { int _mm_testz_si128(__m128i , __m128i ); } 
#line 893
extern "C" { int _mm_testc_si128(__m128i , __m128i ); } 
#line 894
extern "C" { int _mm_testnzc_si128(__m128i , __m128i ); } 
#line 895
extern "C" { __m128 _mm_insert_ps(__m128 , __m128 , const int ); } 
#line 896
extern "C" { int _mm_extract_ps(__m128 , const int ); } 
#line 897
extern "C" { __m128i _mm_insert_epi8(__m128i , int , const int ); } 
#line 898
extern "C" { __m128i _mm_insert_epi32(__m128i , int , const int ); } 
#line 899
extern "C" { int _mm_extract_epi8(__m128i , const int ); } 
#line 900
extern "C" { int _mm_extract_epi32(__m128i , const int ); } 
#line 901
extern "C" { __m128i _mm_minpos_epu16(__m128i ); } 
#line 902
extern "C" { __m128d _mm_round_pd(__m128d , int ); } 
#line 903
extern "C" { __m128d _mm_round_sd(__m128d , __m128d , int ); } 
#line 904
extern "C" { __m128 _mm_round_ps(__m128 , int ); } 
#line 905
extern "C" { __m128 _mm_round_ss(__m128 , __m128 , int ); } 
#line 906
extern "C" { __m128i _mm_cvtepi8_epi32(__m128i ); } 
#line 907
extern "C" { __m128i _mm_cvtepi16_epi32(__m128i ); } 
#line 908
extern "C" { __m128i _mm_cvtepi8_epi64(__m128i ); } 
#line 909
extern "C" { __m128i _mm_cvtepi32_epi64(__m128i ); } 
#line 910
extern "C" { __m128i _mm_cvtepi16_epi64(__m128i ); } 
#line 911
extern "C" { __m128i _mm_cvtepi8_epi16(__m128i ); } 
#line 912
extern "C" { __m128i _mm_cvtepu8_epi32(__m128i ); } 
#line 913
extern "C" { __m128i _mm_cvtepu16_epi32(__m128i ); } 
#line 914
extern "C" { __m128i _mm_cvtepu8_epi64(__m128i ); } 
#line 915
extern "C" { __m128i _mm_cvtepu32_epi64(__m128i ); } 
#line 916
extern "C" { __m128i _mm_cvtepu16_epi64(__m128i ); } 
#line 917
extern "C" { __m128i _mm_cvtepu8_epi16(__m128i ); } 
#line 918
extern "C" { __m128i _mm_packus_epi32(__m128i , __m128i ); } 
#line 919
extern "C" { __m128i _mm_mpsadbw_epu8(__m128i , __m128i , const int ); } 
#line 920
extern "C" { __m128i _mm_stream_load_si128(__m128i * ); } 
#line 921
extern "C" { __m128i _mm_insert_epi64(__m128i , __int64 , const int ); } 
#line 922
extern "C" { __int64 _mm_extract_epi64(__m128i , const int ); } 
#line 923
extern "C" { __m128i _mm_cmpistrm(__m128i , __m128i , const int ); } 
#line 924
extern "C" { int _mm_cmpistri(__m128i , __m128i , const int ); } 
#line 925
extern "C" { __m128i _mm_cmpestrm(__m128i , int , __m128i , int , const int ); } 
#line 926
extern "C" { int _mm_cmpestri(__m128i , int , __m128i , int , const int ); } 
#line 927
extern "C" { int _mm_cmpistrz(__m128i , __m128i , const int ); } 
#line 928
extern "C" { int _mm_cmpistrc(__m128i , __m128i , const int ); } 
#line 929
extern "C" { int _mm_cmpistrs(__m128i , __m128i , const int ); } 
#line 930
extern "C" { int _mm_cmpistro(__m128i , __m128i , const int ); } 
#line 931
extern "C" { int _mm_cmpistra(__m128i , __m128i , const int ); } 
#line 932
extern "C" { int _mm_cmpestrz(__m128i , int , __m128i , int , const int ); } 
#line 933
extern "C" { int _mm_cmpestrc(__m128i , int , __m128i , int , const int ); } 
#line 934
extern "C" { int _mm_cmpestrs(__m128i , int , __m128i , int , const int ); } 
#line 935
extern "C" { int _mm_cmpestro(__m128i , int , __m128i , int , const int ); } 
#line 936
extern "C" { int _mm_cmpestra(__m128i , int , __m128i , int , const int ); } 
#line 937
extern "C" { __m128i _mm_cmpgt_epi64(__m128i , __m128i ); } 
#line 938
extern "C" { int _mm_popcnt_u32(unsigned ); } 
#line 939
extern "C" { __int64 _mm_popcnt_u64(unsigned __int64 ); } 
#line 940
extern "C" { unsigned _mm_crc32_u8(unsigned , unsigned char ); } 
#line 941
extern "C" { unsigned _mm_crc32_u16(unsigned , unsigned short ); } 
#line 942
extern "C" { unsigned _mm_crc32_u32(unsigned , unsigned ); } 
#line 943
extern "C" { unsigned __int64 _mm_crc32_u64(unsigned __int64 , unsigned __int64 ); } 
#line 944
extern "C" { void _WriteBarrier(); } 
#line 945
extern "C" { void _ReadWriteBarrier(); } 
#line 948
extern "C" { void __faststorefence(); } 
#line 949
extern "C" { __int64 __mulh(__int64, __int64); } 
#line 950
extern "C" { unsigned __int64 __umulh(unsigned __int64, unsigned __int64); } 
#line 951
extern "C" { unsigned __int64 __readcr0(); } 
#line 952
extern "C" { unsigned __int64 __readcr2(); } 
#line 953
extern "C" { unsigned __int64 __readcr3(); } 
#line 954
extern "C" { unsigned __int64 __readcr4(); } 
#line 955
extern "C" { unsigned __int64 __readcr8(); } 
#line 961
extern "C" { void __writecr0(unsigned __int64); } 
#line 962
extern "C" { void __writecr3(unsigned __int64); } 
#line 963
extern "C" { void __writecr4(unsigned __int64); } 
#line 964
extern "C" { void __writecr8(unsigned __int64); } 
#line 969
extern "C" { unsigned __int64 __readdr(unsigned); } 
#line 971
extern "C" { void __writedr(unsigned, unsigned __int64); } 
#line 973
extern "C" { unsigned __int64 __readeflags(); } 
#line 975
extern "C" { void __writeeflags(unsigned __int64); } 
#line 977
extern "C" { void __wbinvd(); } 
#line 978
extern "C" { void __invlpg(void *); } 
#line 979
extern "C" { unsigned __int64 __readmsr(unsigned long); } 
#line 980
extern "C" { void __writemsr(unsigned long, unsigned __int64); } 
#line 981
extern "C" { unsigned __int64 __rdtsc(); } 
#line 982
extern "C" { void __movsb(unsigned char *, const unsigned char *, size_t); } 
#line 983
extern "C" { void __movsw(unsigned short *, const unsigned short *, size_t); } 
#line 984
extern "C" { void __movsd(unsigned long *, const unsigned long *, size_t); } 
#line 985
extern "C" { void __movsq(unsigned __int64 *, const unsigned __int64 *, size_t); } 
#line 986
extern "C" { unsigned char __readgsbyte(unsigned long ); } 
#line 987
extern "C" { unsigned short __readgsword(unsigned long ); } 
#line 988
extern "C" { unsigned long __readgsdword(unsigned long ); } 
#line 989
extern "C" { unsigned __int64 __readgsqword(unsigned long ); } 
#line 990
extern "C" { void __writegsbyte(unsigned long , unsigned char ); } 
#line 991
extern "C" { void __writegsword(unsigned long , unsigned short ); } 
#line 992
extern "C" { void __writegsdword(unsigned long , unsigned long ); } 
#line 993
extern "C" { void __writegsqword(unsigned long , unsigned __int64 ); } 
#line 1000
extern "C" { void __addgsbyte(unsigned long , unsigned char ); } 
#line 1001
extern "C" { void __addgsword(unsigned long , unsigned short ); } 
#line 1002
extern "C" { void __addgsdword(unsigned long , unsigned long ); } 
#line 1003
extern "C" { void __addgsqword(unsigned long , unsigned __int64 ); } 
#line 1004
extern "C" { void __incgsbyte(unsigned long ); } 
#line 1005
extern "C" { void __incgsword(unsigned long ); } 
#line 1006
extern "C" { void __incgsdword(unsigned long ); } 
#line 1007
extern "C" { void __incgsqword(unsigned long ); } 
#line 1008
extern "C" { unsigned char __inbyte(unsigned short ); } 
#line 1009
extern "C" { unsigned short __inword(unsigned short ); } 
#line 1010
extern "C" { unsigned long __indword(unsigned short ); } 
#line 1011
extern "C" { void __outbyte(unsigned short , unsigned char ); } 
#line 1012
extern "C" { void __outword(unsigned short , unsigned short ); } 
#line 1013
extern "C" { void __outdword(unsigned short , unsigned long ); } 
#line 1014
extern "C" { void __inbytestring(unsigned short , unsigned char * , unsigned long ); } 
#line 1015
extern "C" { void __inwordstring(unsigned short , unsigned short * , unsigned long ); } 
#line 1016
extern "C" { void __indwordstring(unsigned short , unsigned long * , unsigned long ); } 
#line 1017
extern "C" { void __outbytestring(unsigned short , unsigned char * , unsigned long ); } 
#line 1018
extern "C" { void __outwordstring(unsigned short , unsigned short * , unsigned long ); } 
#line 1019
extern "C" { void __outdwordstring(unsigned short , unsigned long * , unsigned long ); } 
#line 1020
extern "C" { unsigned __getcallerseflags(); } 
#line 1021
extern "C" { unsigned char __vmx_vmclear(unsigned __int64 *); } 
#line 1022
extern "C" { unsigned char __vmx_vmlaunch(); } 
#line 1023
extern "C" { unsigned char __vmx_vmptrld(unsigned __int64 *); } 
#line 1024
extern "C" { void __vmx_vmptrst(unsigned __int64 *); } 
#line 1025
extern "C" { unsigned char __vmx_vmread(size_t, size_t *); } 
#line 1026
extern "C" { unsigned char __vmx_vmresume(); } 
#line 1027
extern "C" { unsigned char __vmx_vmwrite(size_t, size_t); } 
#line 1028
extern "C" { void __vmx_off(); } 
#line 1029
extern "C" { unsigned char __vmx_on(unsigned __int64 *); } 
#line 1030
extern "C" { void __svm_clgi(); } 
#line 1031
extern "C" { void __svm_invlpga(void *, int); } 
#line 1032
extern "C" { void __svm_skinit(int); } 
#line 1033
extern "C" { void __svm_stgi(); } 
#line 1034
extern "C" { void __svm_vmload(size_t); } 
#line 1035
extern "C" { void __svm_vmrun(size_t); } 
#line 1036
extern "C" { void __svm_vmsave(size_t); } 
#line 1037
extern "C" { void __halt(); } 
#line 1038
extern "C" { void __sidt(void *); } 
#line 1039
extern "C" { void __lidt(void *); } 
#line 1040
extern "C" { void __ud2(); } 
#line 1041
extern "C" { void __nop(); } 
#line 1042
extern "C" { __m128i _mm_set_epi64x(__int64 , __int64 ); } 
#line 1043
extern "C" { __m128i _mm_set1_epi64x(__int64 ); } 
#line 1044
extern "C" { __int64 _mm_cvtsd_si64x(__m128d ); } 
#line 1045
extern "C" { __m128d _mm_cvtsi64x_sd(__m128d , __int64 ); } 
#line 1046
extern "C" { __m128 _mm_cvtsi64x_ss(__m128 , __int64 ); } 
#line 1047
extern "C" { __int64 _mm_cvtss_si64x(__m128 ); } 
#line 1048
extern "C" { __int64 _mm_cvttsd_si64x(__m128d ); } 
#line 1049
extern "C" { __int64 _mm_cvttss_si64x(__m128 ); } 
#line 1050
extern "C" { __m128i _mm_cvtsi64x_si128(__int64 ); } 
#line 1051
extern "C" { __int64 _mm_cvtsi128_si64x(__m128i ); } 
#line 1052
extern "C" { void _mm_stream_si64x(__int64 *, __int64); } 
#line 1053
extern "C" { void __stosb(unsigned char *, unsigned char, size_t); } 
#line 1054
extern "C" { void __stosw(unsigned short *, unsigned short, size_t); } 
#line 1055
extern "C" { void __stosd(unsigned long *, unsigned long, size_t); } 
#line 1056
extern "C" { void __stosq(unsigned __int64 *, unsigned __int64, size_t); } 
#line 1057
extern "C" { unsigned char _bittest(const long * , long ); } 
#line 1058
extern "C" { unsigned char _bittestandset(long * , long ); } 
#line 1059
extern "C" { unsigned char _bittestandreset(long * , long ); } 
#line 1060
extern "C" { unsigned char _bittestandcomplement(long * , long ); } 
#line 1061
extern "C" { unsigned char _interlockedbittestandset(volatile long * , long ); } 
#line 1062
extern "C" { unsigned char _interlockedbittestandreset(volatile long * , long ); } 
#line 1063
extern "C" { unsigned char _bittest64(const __int64 * , __int64 ); } 
#line 1064
extern "C" { unsigned char _bittestandset64(__int64 * , __int64 ); } 
#line 1065
extern "C" { unsigned char _bittestandreset64(__int64 * , __int64 ); } 
#line 1066
extern "C" { unsigned char _bittestandcomplement64(__int64 * , __int64 ); } 
#line 1067
extern "C" { unsigned char _interlockedbittestandset64(volatile __int64 * , __int64 ); } 
#line 1068
extern "C" { unsigned char _interlockedbittestandreset64(volatile __int64 * , __int64 ); } 
#line 1069
extern "C" { void __cpuid(int  [4], int ); } 
#line 1070
extern "C" { void __cpuidex(int  [4], int , int ); } 
#line 1071
extern "C" { unsigned __int64 __readpmc(unsigned long ); } 
#line 1072
extern "C" { unsigned long __segmentlimit(unsigned long ); } 
#line 1084
extern "C" { unsigned __int64 __cdecl _rotl64(unsigned __int64, int); } 
#line 1085
extern "C" { unsigned __int64 __cdecl _rotr64(unsigned __int64, int); } 
#line 1086
extern "C" { __int64 __cdecl _abs64(__int64); } 
#line 1088
extern "C" { unsigned char _BitScanForward(unsigned long * , unsigned long ); } 
#line 1089
extern "C" { unsigned char _BitScanReverse(unsigned long * , unsigned long ); } 
#line 1090
extern "C" { unsigned char _BitScanForward64(unsigned long * , unsigned __int64 ); } 
#line 1091
extern "C" { unsigned char _BitScanReverse64(unsigned long * , unsigned __int64 ); } 
#line 1092
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcscat(__wchar_t *, const __wchar_t * ); } 
#line 1093
extern "C" { __declspec(dllimport) int __cdecl wcscmp(const __wchar_t *, const __wchar_t *); } 
#line 1094
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcscpy(__wchar_t *, const __wchar_t * ); } 
#line 1095
extern "C" { __declspec(dllimport) size_t __cdecl wcslen(const __wchar_t *); } 
#pragma warning(suppress: 4985)
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsset(__wchar_t *, __wchar_t); } 
#line 1098
extern "C" { unsigned __int64 __shiftleft128(unsigned __int64 , unsigned __int64 , unsigned char ); } 
#line 1099
extern "C" { unsigned __int64 __shiftright128(unsigned __int64 , unsigned __int64 , unsigned char ); } 
#line 1100
extern "C" { unsigned __int64 _umul128(unsigned __int64 , unsigned __int64 , unsigned __int64 * ); } 
#line 1101
extern "C" { __int64 _mul128(__int64 , __int64 , __int64 * ); } 
#line 1102
extern "C" { void __int2c(); } 
#line 1103
extern "C" { void _ReadBarrier(); } 
#line 1104
extern "C" { unsigned char _rotr8(unsigned char , unsigned char ); } 
#line 1105
extern "C" { unsigned short _rotr16(unsigned short , unsigned char ); } 
#line 1106
extern "C" { unsigned char _rotl8(unsigned char , unsigned char ); } 
#line 1107
extern "C" { unsigned short _rotl16(unsigned short , unsigned char ); } 
#line 1108
extern "C" { short _InterlockedIncrement16(volatile short * ); } 
#line 1109
extern "C" { short _InterlockedDecrement16(volatile short * ); } 
#line 1110
extern "C" { short _InterlockedCompareExchange16(volatile short * , short , short ); } 
#line 1111
extern "C" { char _InterlockedCompareExchange8(volatile char * , char , char ); } 
#line 1264
extern "C" { void __nvreg_save_fence(); } 
#line 1265
extern "C" { void __nvreg_restore_fence(); } 
#line 1267
extern "C" { short _InterlockedCompareExchange16_np(volatile short * , short , short ); } 
#line 1268
extern "C" { long _InterlockedCompareExchange_np(volatile long *, long, long); } 
#line 1269
extern "C" { __int64 _InterlockedCompareExchange64_np(volatile __int64 *, __int64, __int64); } 
#line 1270
extern "C" { void *_InterlockedCompareExchangePointer_np(void *volatile *, void *, void *); } 
#line 1271
extern "C" { unsigned char _InterlockedCompareExchange128(volatile __int64 *, __int64, __int64, __int64 *); } 
#line 1272
extern "C" { unsigned char _InterlockedCompareExchange128_np(volatile __int64 *, __int64, __int64, __int64 *); } 
#line 1273
extern "C" { long _InterlockedAnd_np(volatile long *, long); } 
#line 1274
extern "C" { char _InterlockedAnd8_np(volatile char *, char); } 
#line 1275
extern "C" { short _InterlockedAnd16_np(volatile short *, short); } 
#line 1276
extern "C" { __int64 _InterlockedAnd64_np(volatile __int64 *, __int64); } 
#line 1277
extern "C" { long _InterlockedOr_np(volatile long *, long); } 
#line 1278
extern "C" { char _InterlockedOr8_np(volatile char *, char); } 
#line 1279
extern "C" { short _InterlockedOr16_np(volatile short *, short); } 
#line 1280
extern "C" { __int64 _InterlockedOr64_np(volatile __int64 *, __int64); } 
#line 1281
extern "C" { long _InterlockedXor_np(volatile long *, long); } 
#line 1282
extern "C" { char _InterlockedXor8_np(volatile char *, char); } 
#line 1283
extern "C" { short _InterlockedXor16_np(volatile short *, short); } 
#line 1284
extern "C" { __int64 _InterlockedXor64_np(volatile __int64 *, __int64); } 
#line 1286
extern "C" { unsigned short __lzcnt16(unsigned short); } 
#line 1287
extern "C" { unsigned __lzcnt(unsigned); } 
#line 1288
extern "C" { unsigned __int64 __lzcnt64(unsigned __int64); } 
#line 1289
extern "C" { unsigned short __popcnt16(unsigned short); } 
#line 1290
extern "C" { unsigned __popcnt(unsigned); } 
#line 1291
extern "C" { unsigned __int64 __popcnt64(unsigned __int64); } 
#line 1292
extern "C" { __m128i _mm_extract_si64(__m128i, __m128i); } 
#line 1293
extern "C" { __m128i _mm_extracti_si64(__m128i, int, int); } 
#line 1294
extern "C" { __m128i _mm_insert_si64(__m128i, __m128i); } 
#line 1295
extern "C" { __m128i _mm_inserti_si64(__m128i, __m128i, int, int); } 
#line 1296
extern "C" { void _mm_stream_sd(double *, __m128d); } 
#line 1297
extern "C" { void _mm_stream_ss(float *, __m128); } 
#line 1298
extern "C" { unsigned __int64 __rdtscp(unsigned *); } 
#line 993 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
namespace std { 
#line 995
template < class _Ty >
 struct default_delete;
#line 998
template < class _Ty,
 class _Dx = default_delete < _Ty > >
 class unique_ptr;
#line 1003 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
namespace tr1 { 
#line 1005
class bad_weak_ptr : public exception { 
#line 1009
public: explicit bad_weak_ptr(const char * = 0) 
#line 1010
{ 
#line 1011
} 
#line 1013
virtual const char *what() const throw() 
#line 1014
{ 
#line 1015
return "tr1::bad_weak_ptr"; 
#line 1016
} 
#line 1017
}; 
#line 1020
class _Ref_count_base { 
#line 1023
virtual void _Destroy() = 0; 
#line 1024
virtual void _Delete_this() = 0; 
#line 1026
long _Uses; 
#line 1027
long _Weaks; 
#line 1030
protected: _Ref_count_base() : _Uses(1), _Weaks(1) 
#line 1032
{ 
#line 1033
} 
#line 1036
public: virtual ~_Ref_count_base() 
#line 1037
{ 
#line 1038
} 
#line 1040
bool _Incref_nz() 
#line 1041
{ 
#line 1042
for (; ;) 
#line 1043
{ 
#line 1044
long _Count = (long &)(_Uses); 
#line 1045
if (_Count == (0)) { 
#line 1046
return false; }  
#line 1047
if (_InterlockedCompareExchange(&(_Uses), _Count + (1), _Count) == _Count) { 
#line 1048
return true; }  
#line 1049
}  
#line 1050
} 
#line 1052
void _Incref() 
#line 1053
{ 
#line 1054
_InterlockedIncrement(&(_Uses)); 
#line 1055
} 
#line 1057
void _Incwref() 
#line 1058
{ 
#line 1059
_InterlockedIncrement(&(_Weaks)); 
#line 1060
} 
#line 1062
void _Decref() 
#line 1063
{ 
#line 1064
if (_InterlockedDecrement(&(_Uses)) == (0)) 
#line 1065
{ 
#line 1066
this->_Destroy(); 
#line 1067
this->_Decwref(); 
#line 1068
}  
#line 1069
} 
#line 1071
void _Decwref() 
#line 1072
{ 
#line 1073
if (_InterlockedDecrement(&(_Weaks)) == (0)) { 
#line 1074
this->_Delete_this(); }  
#line 1075
} 
#line 1077
long _Use_count() const 
#line 1078
{ 
#line 1079
return _Uses; 
#line 1080
} 
#line 1082
bool _Expired() const 
#line 1083
{ 
#line 1084
return (_Uses) == (0); 
#line 1085
} 
#line 1087
virtual void *_Get_deleter(const type_info &) const 
#line 1088
{ 
#line 1089
return 0; 
#line 1090
} 
#line 1091
}; 
#line 1094
template < class _Ty >
 class _Ref_count
 : public _Ref_count_base
 {
public :
 _Ref_count ( _Ty * _Px )
  : _Ref_count_base ( ), _Ptr ( _Px )
  {
  }

private :
 virtual void _Destroy ( )
  {
  delete _Ptr;
  }

 virtual void _Delete_this ( )
  {
  delete this;
  }

 _Ty * _Ptr;
 };
#line 1118
template < class _Ty,
 class _Dx >
 class _Ref_count_del
 : public _Ref_count_base
 {
public :
 _Ref_count_del ( _Ty * _Px, _Dx _Dt )
  : _Ref_count_base ( ), _Ptr ( _Px ), _Dtor ( _Dt )
  {
  }

 virtual void * _Get_deleter ( const type_info & _Type ) const
  {
  return ( ( void * ) ( _Type == typeid ( _Dx ) ? & _Dtor : 0 ) );
  }

private :
 virtual void _Destroy ( )
  {
  _Dtor ( _Ptr );
  }

 virtual void _Delete_this ( )
  {
  delete this;
  }

 _Ty * _Ptr;
 _Dx _Dtor;
 };
#line 1149
template < class _Ty,
 class _Dx,
 class _Alloc >
 class _Ref_count_del_alloc
 : public _Ref_count_base
 {
public :
 typedef _Ref_count_del_alloc < _Ty, _Dx, _Alloc > _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Ref_count_del_alloc ( _Ty * _Px, _Dx _Dt, _Myalty _Al )
  : _Ref_count_base ( ), _Ptr ( _Px ), _Dtor ( _Dt ), _Myal ( _Al )
  {
  }

 virtual void * _Get_deleter ( const type_info & _Type ) const
  {
  return ( ( void * ) ( _Type == typeid ( _Dx ) ? & _Dtor : 0 ) );
  }

private :
 virtual void _Destroy ( )
  {
  _Dtor ( _Ptr );
  }

 virtual void _Delete_this ( )
  {
  _Myalty _Al = _Myal;
  _Dest_val ( _Al, this );
  _Al . deallocate ( this, 1 );
  }

 _Ty * _Ptr;
 _Dx _Dtor;
 _Myalty _Myal;
 };
#line 1188
template < class _Ty >
 class weak_ptr;
#line 1190
template < class _Ty >
 class shared_ptr;
#line 1192
template < class _Ty >
 class enable_shared_from_this;
#line 1194
struct _Static_tag { }; 
#line 1195
struct _Const_tag { }; 
#line 1196
struct _Dynamic_tag { }; 
#line 1197
template < class _Ty1,
 class _Ty2 >
 void _Do_enable ( _Ty1 *, enable_shared_from_this < _Ty2 > *,
  _Ref_count_base * );
#line 1202
template < class _Ty >
 inline void _Enable_shared ( _Ty * _Ptr, _Ref_count_base * _Refptr,
  typename _Ty :: _EStype * = 0 )
 {
 if ( _Ptr )
  _Do_enable ( _Ptr,
   ( enable_shared_from_this < typename _Ty :: _EStype > * ) _Ptr, _Refptr );
 }
#line 1211
inline void _Enable_shared(const volatile void *, const volatile void *) 
#line 1212
{ 
#line 1213
} 
#line 1216
template < class _Ty >
 class _Ptr_base
 {
public :
 typedef _Ptr_base < _Ty > _Myt;
 typedef _Ty _Elem;
 typedef _Elem element_type;

 _Ptr_base ( )
  : _Ptr ( 0 ), _Rep ( 0 )
  {
  }

 _Ptr_base ( _Myt && _Right )
  : _Ptr ( 0 ), _Rep ( 0 )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 template < class _Ty2 >
  _Ptr_base ( _Ptr_base < _Ty2 > && _Right )
  : _Ptr ( _Right . _Ptr ), _Rep ( _Right . _Rep )
  {
  _Right . _Ptr = 0;
  _Right . _Rep = 0;
  }

 _Myt & operator = ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  if ( this != & _Right )
   _Swap ( _Right );
  }

 long use_count ( ) const
  {
  return ( _Rep ? _Rep -> _Use_count ( ) : 0 );
  }

 void _Swap ( _Ptr_base & _Right )
  {
  :: std :: swap ( _Rep, _Right . _Rep );
  :: std :: swap ( _Ptr, _Right . _Ptr );
  }

 template < class _Ty2 >
  bool owner_before ( const _Ptr_base < _Ty2 > & _Right ) const
  {
  return ( _Rep < _Right . _Rep );
  }

 void * _Get_deleter ( const type_info & _Type ) const
  {
  return ( _Rep ? _Rep -> _Get_deleter ( _Type ) : 0 );
  }

 _Ty * _Get ( ) const
  {
  return ( _Ptr );
  }

 bool _Expired ( ) const
  {
  return ( ! _Rep || _Rep -> _Expired ( ) );
  }

 void _Decref ( )
  {
  if ( _Rep != 0 )
   _Rep -> _Decref ( );
  }

 void _Reset ( )
  {
  _Reset ( 0, 0 );
  }

 template < class _Ty2 >
  void _Reset ( const _Ptr_base < _Ty2 > & _Other )
  {
  _Reset ( _Other . _Ptr, _Other . _Rep, false );
  }

 template < class _Ty2 >
  void _Reset ( const _Ptr_base < _Ty2 > & _Other, bool _Throw )
  {
  _Reset ( _Other . _Ptr, _Other . _Rep, _Throw );
  }

 template < class _Ty2 >
  void _Reset ( const _Ptr_base < _Ty2 > & _Other, const _Static_tag & )
  {
  _Reset ( static_cast < _Elem * > ( _Other . _Ptr ), _Other . _Rep );
  }

 template < class _Ty2 >
  void _Reset ( const _Ptr_base < _Ty2 > & _Other, const _Const_tag & )
  {
  _Reset ( const_cast < _Elem * > ( _Other . _Ptr ), _Other . _Rep );
  }

 template < class _Ty2 >
  void _Reset ( const _Ptr_base < _Ty2 > & _Other, const _Dynamic_tag & )
  {
  _Elem * _Ptr = dynamic_cast < _Elem * > ( _Other . _Ptr );
  if ( _Ptr )
   _Reset ( _Ptr, _Other . _Rep );
  else
   _Reset ( );
  }

 template < class _Ty2 >
  void _Reset ( auto_ptr < _Ty2 > & _Other )
  {
  _Ty2 * _Px = _Other . get ( );
  _Reset0 ( _Px, new _Ref_count < _Elem > ( _Px ) );
  _Other . release ( );
  _Enable_shared ( _Px, _Rep );
  }


 template < class _Ty2 >
  void _Reset ( _Ty * _Ptr, const _Ptr_base < _Ty2 > & _Other )
  {
  _Reset ( _Ptr, _Other . _Rep );
  }


 void _Reset ( _Ty * _Other_ptr, _Ref_count_base * _Other_rep )
  {
  if ( _Other_rep )
   _Other_rep -> _Incref ( );
  _Reset0 ( _Other_ptr, _Other_rep );
  }

 void _Reset ( _Ty * _Other_ptr, _Ref_count_base * _Other_rep, bool _Throw )
  {


  if ( _Other_rep && _Other_rep -> _Incref_nz ( ) )
   _Reset0 ( _Other_ptr, _Other_rep );
  else if ( _Throw )
   throw bad_weak_ptr ( 0 );
  }

 void _Reset0 ( _Ty * _Other_ptr, _Ref_count_base * _Other_rep )
  {
  if ( _Rep != 0 )
   _Rep -> _Decref ( );
  _Rep = _Other_rep;
  _Ptr = _Other_ptr;
  }

 void _Decwref ( )
  {
  if ( _Rep != 0 )
   _Rep -> _Decwref ( );
  }

 void _Resetw ( )
  {
  _Resetw ( ( _Elem * ) 0, 0 );
  }

 template < class _Ty2 >
  void _Resetw ( const _Ptr_base < _Ty2 > & _Other )
  {
  _Resetw ( _Other . _Ptr, _Other . _Rep );
  }

 template < class _Ty2 >
  void _Resetw ( const _Ty2 * _Other_ptr, _Ref_count_base * _Other_rep )
  {
  _Resetw ( const_cast < _Ty2 * > ( _Other_ptr ), _Other_rep );
  }

 template < class _Ty2 >
  void _Resetw ( _Ty2 * _Other_ptr, _Ref_count_base * _Other_rep )
  {
  if ( _Other_rep )
   _Other_rep -> _Incwref ( );
  if ( _Rep != 0 )
   _Rep -> _Decwref ( );
  _Rep = _Other_rep;
  _Ptr = _Other_ptr;
  }

private :
 _Ty * _Ptr;
 _Ref_count_base * _Rep;
 template < class _Ty0 >
  friend class _Ptr_base;
 };
#line 1416 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
template < class _Ty >
 class shared_ptr
  : public _Ptr_base < _Ty >
 {
public :
 typedef shared_ptr < _Ty > _Myt;
 typedef _Ptr_base < _Ty > _Mybase;

 shared_ptr ( )
  {
  }

 template < class _Ux >
  explicit shared_ptr ( _Ux * _Px )
  {
  _Resetp ( _Px );
  }

 template < class _Ux,
  class _Dx >
  shared_ptr ( _Ux * _Px, _Dx _Dt )
  {
  _Resetp ( _Px, _Dt );
  }





 shared_ptr ( :: std :: nullptr_t )
  {
  _Resetp ( ( _Ty * ) 0 );
  }

 template < class _Dx >
  shared_ptr ( :: std :: nullptr_t, _Dx _Dt )
  {
  _Resetp ( ( _Ty * ) 0, _Dt );
  }

 template < class _Dx,
  class _Alloc >
  shared_ptr ( :: std :: nullptr_t, _Dx _Dt, _Alloc _Ax )
  {
  _Resetp ( ( _Ty * ) 0, _Dt, _Ax );
  }


 template < class _Ux,
  class _Dx,
  class _Alloc >
  shared_ptr ( _Ux * _Px, _Dx _Dt, _Alloc _Ax )
  {
  _Resetp ( _Px, _Dt, _Ax );
  }



 template < class _Ty2 >
  shared_ptr ( const shared_ptr < _Ty2 > & _Right, _Ty * _Px )
  {
  this -> _Reset ( _Px, _Right );
  }


 shared_ptr ( const _Myt & _Other )
  {
  this -> _Reset ( _Other );
  }

 template < class _Ty2 >
  shared_ptr ( const shared_ptr < _Ty2 > & _Other,
   typename enable_if < is_convertible < _Ty2 *, _Ty * > :: value,
    void * > :: type * = 0 )
  {
  this -> _Reset ( _Other );
  }

 template < class _Ty2 >
  explicit shared_ptr ( const weak_ptr < _Ty2 > & _Other,
   bool _Throw = true )
  {
  this -> _Reset ( _Other, _Throw );
  }

 template < class _Ty2 >
  shared_ptr ( auto_ptr < _Ty2 > & _Other )
  {
  this -> _Reset ( _Other );
  }

 template < class _Ty2 >
  shared_ptr ( const shared_ptr < _Ty2 > & _Other, const _Static_tag & _Tag )
  {
  this -> _Reset ( _Other, _Tag );
  }

 template < class _Ty2 >
  shared_ptr ( const shared_ptr < _Ty2 > & _Other, const _Const_tag & _Tag )
  {
  this -> _Reset ( _Other, _Tag );
  }

 template < class _Ty2 >
  shared_ptr ( const shared_ptr < _Ty2 > & _Other, const _Dynamic_tag & _Tag )
  {
  this -> _Reset ( _Other, _Tag );
  }

 shared_ptr ( _Myt && _Right )
  : _Mybase ( :: std :: forward < _Myt > ( _Right ) )
  {
  }

 template < class _Ty2 >
  shared_ptr ( shared_ptr < _Ty2 > && _Right,
   typename enable_if < is_convertible < _Ty2 *, _Ty * > :: value,
    void * > :: type * = 0 )
  : _Mybase ( :: std :: forward < shared_ptr < _Ty2 > > ( _Right ) )
  {
  }


 template < class _Ux,
  class _Dx >
  shared_ptr ( :: std :: unique_ptr < _Ux, _Dx > && _Right )
  {
  _Resetp ( _Right . release ( ), _Right . get_deleter ( ) );
  }

 template < class _Ux,
  class _Dx >
  _Myt & operator = ( unique_ptr < _Ux, _Dx > && _Right )
  {
  shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
  return ( * this );
  }


 _Myt & operator = ( _Myt && _Right )
  {
  shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
  return ( * this );
  }

 template < class _Ty2 >
  _Myt & operator = ( shared_ptr < _Ty2 > && _Right )
  {
  shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
  return ( * this );
  }

 void swap ( _Myt && _Right )
  {
  _Mybase :: swap ( :: std :: move ( _Right ) );
  }

 ~ shared_ptr ( )
  {
  this -> _Decref ( );
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  shared_ptr ( _Right ) . swap ( * this );
  return ( * this );
  }

 template < class _Ty2 >
  _Myt & operator = ( const shared_ptr < _Ty2 > & _Right )
  {
  shared_ptr ( _Right ) . swap ( * this );
  return ( * this );
  }

 template < class _Ty2 >
  _Myt & operator = ( auto_ptr < _Ty2 > & _Right )
  {
  shared_ptr ( _Right ) . swap ( * this );
  return ( * this );
  }

 void reset ( )
  {
  shared_ptr ( ) . swap ( * this );
  }

 template < class _Ux >
  void reset ( _Ux * _Px )
  {
  shared_ptr ( _Px ) . swap ( * this );
  }

 template < class _Ux,
  class _Dx >
  void reset ( _Ux * _Px, _Dx _Dt )
  {
  shared_ptr ( _Px, _Dt ) . swap ( * this );
  }


 template < class _Ux,
  class _Dx,
  class _Alloc >
  void reset ( _Ux * _Px, _Dx _Dt, _Alloc _Ax )
  {
  shared_ptr ( _Px, _Dt, _Ax ) . swap ( * this );
  }


 void swap ( _Myt & _Other )
  {
  this -> _Swap ( _Other );
  }

 _Ty * get ( ) const
  {
  return ( this -> _Get ( ) );
  }

 typename tr1 :: add_reference < _Ty > :: type operator * ( ) const
  {
  return ( * this -> _Get ( ) );
  }

 _Ty * operator -> ( ) const
  {
  return ( this -> _Get ( ) );
  }

 bool unique ( ) const
  {
  return ( this -> use_count ( ) == 1 );
  }

 operator :: std :: _Bool_type ( ) const
  {
  return ( this -> _Get ( ) != 0 ? ( & :: std :: _Bool_struct :: _Member ) : 0 );
  }

private :
 template < class _Ux >
  void _Resetp ( _Ux * _Px )
  {
  try {
  _Resetp0 ( _Px, new _Ref_count < _Ux > ( _Px ) );
  } catch ( ... ) {
  delete _Px;
  throw;
  }
  }

 template < class _Ux,
  class _Dx >
  void _Resetp ( _Ux * _Px, _Dx _Dt )
  {
  try {
  _Resetp0 ( _Px, new _Ref_count_del < _Ux, _Dx > ( _Px, _Dt ) );
  } catch ( ... ) {
  _Dt ( _Px );
  throw;
  }
  }


 template < class _Ux,
  class _Dx,
  class _Alloc >
  void _Resetp ( _Ux * _Px, _Dx _Dt, _Alloc _Ax )
  {
  typedef _Ref_count_del_alloc < _Ux, _Dx, _Alloc > _Refd;
  typename _Alloc :: template rebind < _Refd > :: other _Al = _Ax;

  try {
  _Refd * _Ptr = _Al . allocate ( 1 );
  new ( _Ptr ) _Refd ( _Px, _Dt, _Al );
  _Resetp0 ( _Px, _Ptr );
  } catch ( ... ) {
  _Dt ( _Px );
  throw;
  }
  }


public :
 template < class _Ux >
  void _Resetp0 ( _Ux * _Px, _Ref_count_base * _Rx )
  {
  this -> _Reset0 ( _Px, _Rx );
  _Enable_shared ( _Px, _Rx );
  }
 };
#line 1710 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
template < class _Ty1,
 class _Ty2 >
 bool operator == ( const shared_ptr < _Ty1 > & _S1,
  const shared_ptr < _Ty2 > & _S2 )
 {
 return ( _S1 . get ( ) == _S2 . get ( ) );
 }
#line 1718
template < class _Ty1,
 class _Ty2 >
 bool operator != ( const shared_ptr < _Ty1 > & _S1,
  const shared_ptr < _Ty2 > & _S2 )
 {
 return ( ! ( _S1 == _S2 ) );
 }
#line 1726
template < class _Ty1,
 class _Ty2 >
 bool operator < ( const shared_ptr < _Ty1 > & _S1,
  const shared_ptr < _Ty2 > & _S2 )
 {
 return ( _S1 . get ( ) < _S2 . get ( ) );
 }
#line 1734
template < class _Ty1,
 class _Ty2 >
 bool operator >= ( const shared_ptr < _Ty1 > & _S1,
  const shared_ptr < _Ty2 > & _S2 )
 {
 return ( ! ( _S1 < _S2 ) );
 }
#line 1742
template < class _Ty1,
 class _Ty2 >
 bool operator > ( const shared_ptr < _Ty1 > & _S1,
  const shared_ptr < _Ty2 > & _S2 )
 {
 return ( _S2 < _S1 );
 }
#line 1750
template < class _Ty1,
 class _Ty2 >
 bool operator <= ( const shared_ptr < _Ty1 > & _S1,
  const shared_ptr < _Ty2 > & _S2 )
 {
 return ( ! ( _S2 < _S1 ) );
 }
#line 1758
template < class _Elem,
 class _Traits,
 class _Ty >
 basic_ostream < _Elem, _Traits > &
 operator << ( basic_ostream < _Elem, _Traits > & _Out,
  const shared_ptr < _Ty > & _Px )
 {
 return ( _Out << _Px . get ( ) );
 }
#line 1768
template < class _Ty >
 void swap ( shared_ptr < _Ty > & _Left,
  shared_ptr < _Ty > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 1775
template < class _Ty >
 void swap ( shared_ptr < _Ty > & _Left,
  shared_ptr < _Ty > && _Right )
 {
 _Left . swap ( _Right );
 }
#line 1782
template < class _Ty >
 void swap ( shared_ptr < _Ty > && _Left,
  shared_ptr < _Ty > & _Right )
 {
 _Right . swap ( _Left );
 }
#line 1789
template < class _Ty1,
 class _Ty2 >
 shared_ptr < _Ty1 > static_pointer_cast ( const shared_ptr < _Ty2 > & _Other )
 {
 return ( shared_ptr < _Ty1 > ( _Other, _Static_tag ( ) ) );
 }
#line 1796
template < class _Ty1,
 class _Ty2 >
 shared_ptr < _Ty1 > const_pointer_cast ( const shared_ptr < _Ty2 > & _Other )
 {
 return ( shared_ptr < _Ty1 > ( _Other, _Const_tag ( ) ) );
 }
#line 1803
template < class _Ty1,
 class _Ty2 >
 shared_ptr < _Ty1 > dynamic_pointer_cast ( const shared_ptr < _Ty2 > & _Other )
 {
 return ( shared_ptr < _Ty1 > ( _Other, _Dynamic_tag ( ) ) );
 }
#line 1810
template < class _Dx,
 class _Ty >
 _Dx * get_deleter ( const shared_ptr < _Ty > & _Sx )
 {
 return ( ( _Dx * ) _Sx . _Get_deleter ( typeid ( _Dx ) ) );
 }
#line 1820
template < class _Ty >
 class _Ref_count_obj
 : public _Ref_count_base
 {
public :










































































































































































































































































































 _Ref_count_obj ( )
  : _Ref_count_base ( )
  {
  new ( ( void * ) & _Storage ) _Ty ( );
  }










































































































































































































































































































































































































































































 template < class _Arg0 >


 _Ref_count_obj ( _Arg0 && _Ax0 )
  : _Ref_count_base ( )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1 >


 _Ref_count_obj ( _Arg0 && _Ax0, _Arg1 && _Ax1 )
  : _Ref_count_base ( )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2 >


 _Ref_count_obj ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2 )
  : _Ref_count_base ( )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3 >


 _Ref_count_obj ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3 )
  : _Ref_count_base ( )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >


 _Ref_count_obj ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4 )
  : _Ref_count_base ( )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >


 _Ref_count_obj ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5 )
  : _Ref_count_base ( )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >


 _Ref_count_obj ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6 )
  : _Ref_count_base ( )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >


 _Ref_count_obj ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7 )
  : _Ref_count_base ( )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >


 _Ref_count_obj ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8 )
  : _Ref_count_base ( )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >


 _Ref_count_obj ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8, _Arg9 && _Ax9 )
  : _Ref_count_base ( )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ), :: std :: forward < _Arg9 > ( _Ax9 ) );
  }







































































































































































































 _Ty * _Getptr ( ) const
  {
  return ( ( _Ty * ) & _Storage );
  }

private :
 virtual void _Destroy ( )
  {
  _Getptr ( ) -> ~ _Ty ( );
  }

 virtual void _Delete_this ( )
  {
  delete this;
  }

 typename aligned_storage < sizeof ( _Ty ),
  alignment_of < _Ty > :: value > :: type _Storage;
 };
#line 1851 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
template < class _Ty,
 class _Alloc >
 class _Ref_count_obj_alloc
 : public _Ref_count_base
 {
public :
 typedef _Ref_count_obj_alloc < _Ty, _Alloc > _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;
























































































































































































































































































































 _Ref_count_obj_alloc ( _Myalty _Al )
  : _Ref_count_base ( ), _Myal ( _Al )
  {
  new ( ( void * ) & _Storage ) _Ty ( );
  }










































































































































































































































































































































































































































































 template < class _Arg0 >


 _Ref_count_obj_alloc ( _Myalty _Al, _Arg0 && _Ax0 )
  : _Ref_count_base ( ), _Myal ( _Al )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1 >


 _Ref_count_obj_alloc ( _Myalty _Al, _Arg0 && _Ax0, _Arg1 && _Ax1 )
  : _Ref_count_base ( ), _Myal ( _Al )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2 >


 _Ref_count_obj_alloc ( _Myalty _Al, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2 )
  : _Ref_count_base ( ), _Myal ( _Al )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3 >


 _Ref_count_obj_alloc ( _Myalty _Al, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3 )
  : _Ref_count_base ( ), _Myal ( _Al )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >


 _Ref_count_obj_alloc ( _Myalty _Al, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4 )
  : _Ref_count_base ( ), _Myal ( _Al )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >


 _Ref_count_obj_alloc ( _Myalty _Al, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5 )
  : _Ref_count_base ( ), _Myal ( _Al )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >


 _Ref_count_obj_alloc ( _Myalty _Al, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6 )
  : _Ref_count_base ( ), _Myal ( _Al )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >


 _Ref_count_obj_alloc ( _Myalty _Al, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7 )
  : _Ref_count_base ( ), _Myal ( _Al )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >


 _Ref_count_obj_alloc ( _Myalty _Al, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8 )
  : _Ref_count_base ( ), _Myal ( _Al )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ) );
  }









































































































































































































































































































































































































































































 template < class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >


 _Ref_count_obj_alloc ( _Myalty _Al, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8, _Arg9 && _Ax9 )
  : _Ref_count_base ( ), _Myal ( _Al )
  {
  new ( ( void * ) & _Storage ) _Ty ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ), :: std :: forward < _Arg9 > ( _Ax9 ) );
  }


























































































































































































 _Ty * _Getptr ( ) const
  {
  return ( ( _Ty * ) & _Storage );
  }

private :
 virtual void _Destroy ( )
  {
  _Getptr ( ) -> ~ _Ty ( );
  }

 virtual void _Delete_this ( )
  {
  _Myalty _Al = _Myal;
  _Dest_val ( _Al, this );
  _Al . deallocate ( this, 1 );
  }

 typename aligned_storage < sizeof ( _Ty ),
  alignment_of < _Ty > :: value > :: type _Storage;
 _Myalty _Myal;
 };
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxshared"
template < class _Ty > inline
 shared_ptr < _Ty > make_shared ( )
 {
 _Ref_count_obj < _Ty > * _Rx = new _Ref_count_obj < _Ty > ( );

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 43
template < class _Ty,
 class _Alloc > inline
  shared_ptr < _Ty > allocate_shared (
   const _Alloc & _Al_arg )
 {
 typedef _Ref_count_obj_alloc < _Ty, _Alloc > _Refoa;
 typename _Alloc :: template rebind < _Refoa > :: other _Alref = _Al_arg;

 _Refoa * _Rx = _Alref . allocate ( 1 );

 try {
  new ( _Rx ) _Refoa ( _Al_arg );
 } catch ( ... ) {
  _Alref . deallocate ( _Rx, 1 );
 throw;
 }

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxshared"
template < class _Ty, class _Arg0 > inline
 shared_ptr < _Ty > make_shared ( _Arg0 && _Ax0 )
 {
 _Ref_count_obj < _Ty > * _Rx = new _Ref_count_obj < _Ty > ( :: std :: forward < _Arg0 > ( _Ax0 ) );

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 43
template < class _Ty,
 class _Alloc, class _Arg0 > inline
  shared_ptr < _Ty > allocate_shared (
   const _Alloc & _Al_arg, _Arg0 && _Ax0 )
 {
 typedef _Ref_count_obj_alloc < _Ty, _Alloc > _Refoa;
 typename _Alloc :: template rebind < _Refoa > :: other _Alref = _Al_arg;

 _Refoa * _Rx = _Alref . allocate ( 1 );

 try {
  new ( _Rx ) _Refoa ( _Al_arg, :: std :: forward < _Arg0 > ( _Ax0 ) );
 } catch ( ... ) {
  _Alref . deallocate ( _Rx, 1 );
 throw;
 }

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxshared"
template < class _Ty, class _Arg0, class _Arg1 > inline
 shared_ptr < _Ty > make_shared ( _Arg0 && _Ax0, _Arg1 && _Ax1 )
 {
 _Ref_count_obj < _Ty > * _Rx = new _Ref_count_obj < _Ty > ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ) );

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 43
template < class _Ty,
 class _Alloc, class _Arg0, class _Arg1 > inline
  shared_ptr < _Ty > allocate_shared (
   const _Alloc & _Al_arg, _Arg0 && _Ax0, _Arg1 && _Ax1 )
 {
 typedef _Ref_count_obj_alloc < _Ty, _Alloc > _Refoa;
 typename _Alloc :: template rebind < _Refoa > :: other _Alref = _Al_arg;

 _Refoa * _Rx = _Alref . allocate ( 1 );

 try {
  new ( _Rx ) _Refoa ( _Al_arg, :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ) );
 } catch ( ... ) {
  _Alref . deallocate ( _Rx, 1 );
 throw;
 }

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxshared"
template < class _Ty, class _Arg0, class _Arg1, class _Arg2 > inline
 shared_ptr < _Ty > make_shared ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2 )
 {
 _Ref_count_obj < _Ty > * _Rx = new _Ref_count_obj < _Ty > ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ) );

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 43
template < class _Ty,
 class _Alloc, class _Arg0, class _Arg1, class _Arg2 > inline
  shared_ptr < _Ty > allocate_shared (
   const _Alloc & _Al_arg, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2 )
 {
 typedef _Ref_count_obj_alloc < _Ty, _Alloc > _Refoa;
 typename _Alloc :: template rebind < _Refoa > :: other _Alref = _Al_arg;

 _Refoa * _Rx = _Alref . allocate ( 1 );

 try {
  new ( _Rx ) _Refoa ( _Al_arg, :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ) );
 } catch ( ... ) {
  _Alref . deallocate ( _Rx, 1 );
 throw;
 }

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxshared"
template < class _Ty, class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
 shared_ptr < _Ty > make_shared ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3 )
 {
 _Ref_count_obj < _Ty > * _Rx = new _Ref_count_obj < _Ty > ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ) );

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 43
template < class _Ty,
 class _Alloc, class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
  shared_ptr < _Ty > allocate_shared (
   const _Alloc & _Al_arg, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3 )
 {
 typedef _Ref_count_obj_alloc < _Ty, _Alloc > _Refoa;
 typename _Alloc :: template rebind < _Refoa > :: other _Alref = _Al_arg;

 _Refoa * _Rx = _Alref . allocate ( 1 );

 try {
  new ( _Rx ) _Refoa ( _Al_arg, :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ) );
 } catch ( ... ) {
  _Alref . deallocate ( _Rx, 1 );
 throw;
 }

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxshared"
template < class _Ty, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
 shared_ptr < _Ty > make_shared ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4 )
 {
 _Ref_count_obj < _Ty > * _Rx = new _Ref_count_obj < _Ty > ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ) );

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 43
template < class _Ty,
 class _Alloc, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
  shared_ptr < _Ty > allocate_shared (
   const _Alloc & _Al_arg, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4 )
 {
 typedef _Ref_count_obj_alloc < _Ty, _Alloc > _Refoa;
 typename _Alloc :: template rebind < _Refoa > :: other _Alref = _Al_arg;

 _Refoa * _Rx = _Alref . allocate ( 1 );

 try {
  new ( _Rx ) _Refoa ( _Al_arg, :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ) );
 } catch ( ... ) {
  _Alref . deallocate ( _Rx, 1 );
 throw;
 }

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxshared"
template < class _Ty, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
 shared_ptr < _Ty > make_shared ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5 )
 {
 _Ref_count_obj < _Ty > * _Rx = new _Ref_count_obj < _Ty > ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ) );

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 43
template < class _Ty,
 class _Alloc, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
  shared_ptr < _Ty > allocate_shared (
   const _Alloc & _Al_arg, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5 )
 {
 typedef _Ref_count_obj_alloc < _Ty, _Alloc > _Refoa;
 typename _Alloc :: template rebind < _Refoa > :: other _Alref = _Al_arg;

 _Refoa * _Rx = _Alref . allocate ( 1 );

 try {
  new ( _Rx ) _Refoa ( _Al_arg, :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ) );
 } catch ( ... ) {
  _Alref . deallocate ( _Rx, 1 );
 throw;
 }

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxshared"
template < class _Ty, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
 shared_ptr < _Ty > make_shared ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6 )
 {
 _Ref_count_obj < _Ty > * _Rx = new _Ref_count_obj < _Ty > ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ) );

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 43
template < class _Ty,
 class _Alloc, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
  shared_ptr < _Ty > allocate_shared (
   const _Alloc & _Al_arg, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6 )
 {
 typedef _Ref_count_obj_alloc < _Ty, _Alloc > _Refoa;
 typename _Alloc :: template rebind < _Refoa > :: other _Alref = _Al_arg;

 _Refoa * _Rx = _Alref . allocate ( 1 );

 try {
  new ( _Rx ) _Refoa ( _Al_arg, :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ) );
 } catch ( ... ) {
  _Alref . deallocate ( _Rx, 1 );
 throw;
 }

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxshared"
template < class _Ty, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
 shared_ptr < _Ty > make_shared ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7 )
 {
 _Ref_count_obj < _Ty > * _Rx = new _Ref_count_obj < _Ty > ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ) );

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 43
template < class _Ty,
 class _Alloc, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
  shared_ptr < _Ty > allocate_shared (
   const _Alloc & _Al_arg, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7 )
 {
 typedef _Ref_count_obj_alloc < _Ty, _Alloc > _Refoa;
 typename _Alloc :: template rebind < _Refoa > :: other _Alref = _Al_arg;

 _Refoa * _Rx = _Alref . allocate ( 1 );

 try {
  new ( _Rx ) _Refoa ( _Al_arg, :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ) );
 } catch ( ... ) {
  _Alref . deallocate ( _Rx, 1 );
 throw;
 }

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxshared"
template < class _Ty, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
 shared_ptr < _Ty > make_shared ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8 )
 {
 _Ref_count_obj < _Ty > * _Rx = new _Ref_count_obj < _Ty > ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ) );

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 43
template < class _Ty,
 class _Alloc, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
  shared_ptr < _Ty > allocate_shared (
   const _Alloc & _Al_arg, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8 )
 {
 typedef _Ref_count_obj_alloc < _Ty, _Alloc > _Refoa;
 typename _Alloc :: template rebind < _Refoa > :: other _Alref = _Al_arg;

 _Refoa * _Rx = _Alref . allocate ( 1 );

 try {
  new ( _Rx ) _Refoa ( _Al_arg, :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ) );
 } catch ( ... ) {
  _Alref . deallocate ( _Rx, 1 );
 throw;
 }

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxshared"
template < class _Ty, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
 shared_ptr < _Ty > make_shared ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8, _Arg9 && _Ax9 )
 {
 _Ref_count_obj < _Ty > * _Rx = new _Ref_count_obj < _Ty > ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ), :: std :: forward < _Arg9 > ( _Ax9 ) );

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 43
template < class _Ty,
 class _Alloc, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
  shared_ptr < _Ty > allocate_shared (
   const _Alloc & _Al_arg, _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8, _Arg9 && _Ax9 )
 {
 typedef _Ref_count_obj_alloc < _Ty, _Alloc > _Refoa;
 typename _Alloc :: template rebind < _Refoa > :: other _Alref = _Al_arg;

 _Refoa * _Rx = _Alref . allocate ( 1 );

 try {
  new ( _Rx ) _Refoa ( _Al_arg, :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ), :: std :: forward < _Arg9 > ( _Ax9 ) );
 } catch ( ... ) {
  _Alref . deallocate ( _Rx, 1 );
 throw;
 }

 shared_ptr < _Ty > _Ret;
 _Ret . _Resetp0 ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 1896 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
template < class _Ty >
 class weak_ptr
  : public _Ptr_base < _Ty >
 {
 typedef typename _Ptr_base < _Ty > :: _Elem _Elem;

public :
 weak_ptr ( )
  {
  }

 template < class _Ty2 >
  weak_ptr ( const shared_ptr < _Ty2 > & _Other,
   typename enable_if < is_convertible < _Ty2 *, _Ty * > :: value,
    void * > :: type * = 0 )
  {
  this -> _Resetw ( _Other );
  }

 weak_ptr ( const weak_ptr & _Other )
  {
  this -> _Resetw ( _Other );
  }

 template < class _Ty2 >
  weak_ptr ( const weak_ptr < _Ty2 > & _Other,
   typename enable_if < is_convertible < _Ty2 *, _Ty * > :: value,
    void * > :: type * = 0 )
  {
  this -> _Resetw ( _Other );
  }

 ~ weak_ptr ( )
  {
  this -> _Decwref ( );
  }

 weak_ptr & operator = ( const weak_ptr & _Right )
  {
  this -> _Resetw ( _Right );
  return ( * this );
  }

 template < class _Ty2 >
  weak_ptr & operator = ( const weak_ptr < _Ty2 > & _Right )
  {
  this -> _Resetw ( _Right );
  return ( * this );
  }

 template < class _Ty2 >
  weak_ptr & operator = ( shared_ptr < _Ty2 > & _Right )
  {
  this -> _Resetw ( _Right );
  return ( * this );
  }

 void reset ( )
  {
  this -> _Resetw ( );
  }

 void swap ( weak_ptr & _Other )
  {
  this -> _Swap ( _Other );
  }

 bool expired ( ) const
  {
  return ( this -> _Expired ( ) );
  }

 shared_ptr < _Ty > lock ( ) const
  {
  return ( shared_ptr < _Elem > ( * this, false ) );
  }
 };
#line 1982
template < class _Ty >
 void swap ( weak_ptr < _Ty > & _W1, weak_ptr < _Ty > & _W2 )
 {
 _W1 . swap ( _W2 );
 }
#line 1989
template < class _Ty > class enable_shared_from_this
 {
public :
 typedef _Ty _EStype;

 shared_ptr < _Ty > shared_from_this ( )
  {
  return ( shared_ptr < _Ty > ( _Wptr ) );
  }

 shared_ptr < const _Ty > shared_from_this ( ) const
  {
  return ( shared_ptr < const _Ty > ( _Wptr ) );
  }

protected :
 enable_shared_from_this ( )
  {
  }

 enable_shared_from_this ( const enable_shared_from_this & )
  {
  }

 enable_shared_from_this & operator = ( const enable_shared_from_this & )
  {
  return ( * this );
  }

 ~ enable_shared_from_this ( )
  {
  }

private :
 template < class _Ty1,
  class _Ty2 >
  friend void _Do_enable (
   _Ty1 *,
   enable_shared_from_this < _Ty2 > *,
   _Ref_count_base * );

 mutable weak_ptr < _Ty > _Wptr;
 };
#line 2033
template < class _Ty1,
 class _Ty2 >
 inline void _Do_enable (
  _Ty1 * _Ptr,
  enable_shared_from_this < _Ty2 > * _Es,
  _Ref_count_base * _Refptr )
 {
 _Es -> _Wptr . _Resetw ( _Ptr, _Refptr );
 }
#line 2042
}
#line 2043
}
#line 2047 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
namespace std { 
#line 2051
template < class _Ty >
 struct default_delete
 {
 typedef default_delete < _Ty > _Myt;

 default_delete ( )
  {
  }

 template < class _Ty2 >
  default_delete ( const default_delete < _Ty2 > & )
  {
  }

 void operator ( ) ( _Ty * _Ptr ) const
  {
  if ( 0 < sizeof ( _Ty ) )
   delete _Ptr;
  }
 };
#line 2072
template < class _Ty >
 struct default_delete < _Ty [ ] >
 {
 typedef default_delete < _Ty > _Myt;

 default_delete ( )
  {
  }

 void operator ( ) ( _Ty * _Ptr ) const
  {
  if ( 0 < sizeof ( _Ty ) )
   delete [ ] _Ptr;
  }

 template < class _Other >
  void operator ( ) ( _Other * ) const;
 };
#line 2092
tr1::_No _Has_pointer_type(...); 
#line 2094
template< class _Ty> tr1::_Yes _Has_pointer_type(_Ty *, typename _Ty::pointer * = 0); 
#line 2098
template< class _Ty, class 
#line 2099
_Dx, bool 
#line 2100
__T2> 
#line 2101
struct _Hold_pointer_type { 
#line 2103
typedef _Ty *pointer; 
#line 2104
}; 
#line 2106
template< class _Ty, class 
#line 2107
_Dx> 
#line 2108
struct _Hold_pointer_type< _Ty, _Dx, true>  { 
#line 2110
typedef typename _Dx::pointer pointer; 
#line 2111
}; 
#line 2118
template < class _Ty,
 class _Dx,
 bool _Empty_deleter >
 class _Unique_ptr_base
 {
public :
 typedef typename tr1 :: remove_reference < _Dx > :: type _Dx_noref;
 typedef typename _Hold_pointer_type < _Ty, _Dx_noref, ( sizeof ( _Has_pointer_type ( ( _Dx_noref * ) 0 ) ) == sizeof ( :: std :: tr1 :: _Yes ) ) > :: pointer pointer;

 _Unique_ptr_base ( pointer _Ptr, _Dx _Dt )
  : _Myptr ( _Ptr ), _Mydel ( _Dt )
  {
  }

 template < class _Ptr2,
  class _Dx2 >
  _Unique_ptr_base ( _Ptr2 _Ptr, _Dx2 _Dt )
  : _Myptr ( _Ptr ), _Mydel ( _Dt )
  {
  }

 _Dx_noref & get_deleter ( )
  {
  return ( _Mydel );
  }

 const _Dx_noref & get_deleter ( ) const
  {
  return ( _Mydel );
  }

 pointer _Myptr;
 _Dx _Mydel;
 };
#line 2153
template < class _Ty,
 class _Dx >
 class _Unique_ptr_base < _Ty, _Dx, true >
  : public _Dx
 {
public :
 typedef _Dx _Mybase;
 typedef typename tr1 :: remove_reference < _Dx > :: type _Dx_noref;
 typedef typename _Hold_pointer_type < _Ty, _Dx_noref, ( sizeof ( _Has_pointer_type ( ( _Dx_noref * ) 0 ) ) == sizeof ( :: std :: tr1 :: _Yes ) ) > :: pointer pointer;

 _Unique_ptr_base ( pointer _Ptr, _Dx _Dt )
  : _Myptr ( _Ptr ), _Mybase ( _Dt )
  {
  }

 template < class _Ptr2,
  class _Dx2 >
  _Unique_ptr_base ( _Ptr2 _Ptr, _Dx2 _Dt )
  : _Myptr ( _Ptr ), _Mybase ( _Dt )
  {
  }

 _Dx_noref & get_deleter ( )
  {
  return ( * this );
  }

 const _Dx_noref & get_deleter ( ) const
  {
  return ( * this );
  }

 pointer _Myptr;
 };
#line 2189
template < class _Ty,
 class _Dx >
 class unique_ptr
  : public _Unique_ptr_base < _Ty, _Dx,
   tr1 :: is_empty < _Dx > :: value
    || tr1 :: is_same < default_delete < _Ty >, _Dx > :: value >
 {
public :
 typedef unique_ptr < _Ty, _Dx > _Myt;
 typedef _Unique_ptr_base < _Ty, _Dx,
  tr1 :: is_empty < _Dx > :: value
   || tr1 :: is_same < default_delete < _Ty >, _Dx > :: value > _Mybase;
 typedef typename _Mybase :: pointer pointer;
 typedef _Ty element_type;
 typedef _Dx deleter_type;

 unique_ptr ( )
  : _Mybase ( pointer ( ), _Dx ( ) )
  {
  static_assert ( ! is_pointer < _Dx > :: value,
   "unique_ptr constructed with null deleter pointer" );
  }


 unique_ptr ( :: std :: nullptr_t )
  : _Mybase ( pointer ( ), _Dx ( ) )
  {
  static_assert ( ! is_pointer < _Dx > :: value,
   "unique_ptr constructed with null deleter pointer" );
  }

 _Myt & operator = ( :: std :: nullptr_t )
  {
  reset ( );
  return ( * this );
  }


 explicit unique_ptr ( pointer _Ptr )
  : _Mybase ( _Ptr, _Dx ( ) )
  {
  static_assert ( ! is_pointer < _Dx > :: value,
   "unique_ptr constructed with null deleter pointer" );
  }

 unique_ptr ( pointer _Ptr,
  typename _If < tr1 :: is_reference < _Dx > :: value, _Dx,
   const typename tr1 :: remove_reference < _Dx > :: type & > :: _Type _Dt )
  : _Mybase ( _Ptr, _Dt )
  {
  }

 unique_ptr ( pointer _Ptr, typename tr1 :: remove_reference < _Dx > :: type && _Dt )
  : _Mybase ( _Ptr, :: std :: move ( _Dt ) )
  {


  }

 unique_ptr ( unique_ptr && _Right )
  : _Mybase ( _Right . release ( ),
   :: std :: forward < _Dx > ( _Right . get_deleter ( ) ) )
  {
  }

 template < class _Ty2,
  class _Dx2 >
  unique_ptr ( unique_ptr < _Ty2, _Dx2 > && _Right )
   : _Mybase ( _Right . release ( ),
    :: std :: forward < _Dx2 > ( _Right . get_deleter ( ) ) )
  {
  }

 template < class _Ty2,
  class _Dx2 >
  _Myt & operator = ( unique_ptr < _Ty2, _Dx2 > && _Right )
  {
  reset ( _Right . release ( ) );
  this -> get_deleter ( ) = :: std :: move ( _Right . get_deleter ( ) );
  return ( * this );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   reset ( _Right . release ( ) );
   this -> get_deleter ( ) = :: std :: move ( _Right . get_deleter ( ) );
   }
  return ( * this );
  }

 void swap ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   _Swap_adl ( this -> _Myptr, _Right . _Myptr );
   _Swap_adl ( this -> get_deleter ( ),
    _Right . get_deleter ( ) );
   }
  }

 void swap ( _Myt & _Right )
  {
  _Swap_adl ( this -> _Myptr, _Right . _Myptr );
  _Swap_adl ( this -> get_deleter ( ),
   _Right . get_deleter ( ) );
  }

 ~ unique_ptr ( )
  {
  _Delete ( );
  }

 typename tr1 :: add_reference < _Ty > :: type operator * ( ) const
  {
  return ( * this -> _Myptr );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 pointer get ( ) const
  {
  return ( this -> _Myptr );
  }

 operator :: std :: _Bool_type ( ) const
  {
  return ( this -> _Myptr != pointer ( ) ? ( & :: std :: _Bool_struct :: _Member ) : 0 );
  }

 pointer release ( )
  {
  pointer _Ans = this -> _Myptr;
  this -> _Myptr = pointer ( );
  return ( _Ans );
  }

 void reset ( pointer _Ptr = pointer ( ) )
  {
  if ( _Ptr != this -> _Myptr )
   {
   _Delete ( );
   this -> _Myptr = _Ptr;
   }
  }

private :
 void _Delete ( )
  {
  if ( this -> _Myptr != pointer ( ) )
   this -> get_deleter ( ) ( this -> _Myptr );
  }

 unique_ptr ( const _Myt & );
 template < class _Ty2,
  class _Dx2 >
  unique_ptr ( const unique_ptr < _Ty2, _Dx2 > & );

 _Myt & operator = ( const _Myt & );
 template < class _Ty2,
  class _Dx2 >
  _Myt & operator = ( const unique_ptr < _Ty2, _Dx2 > & );
 };
#line 2359 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
template < class _Ty,
 class _Dx >
 class unique_ptr < _Ty [ ], _Dx >
  : public _Unique_ptr_base < _Ty, _Dx,
   tr1 :: is_empty < _Dx > :: value
    || tr1 :: is_same < default_delete < _Ty [ ] >, _Dx > :: value >
 {
public :
 typedef unique_ptr < _Ty [ ], _Dx > _Myt;
 typedef _Unique_ptr_base < _Ty, _Dx,
  tr1 :: is_empty < _Dx > :: value
   || tr1 :: is_same < default_delete < _Ty [ ] >, _Dx > :: value > _Mybase;
 typedef typename _Mybase :: pointer pointer;
 typedef _Ty element_type;
 typedef _Dx deleter_type;

 unique_ptr ( )
  : _Mybase ( pointer ( ), _Dx ( ) )
  {
  static_assert ( ! is_pointer < _Dx > :: value,
   "unique_ptr constructed with null deleter pointer" );
  }

 explicit unique_ptr ( pointer _Ptr )
  : _Mybase ( _Ptr, _Dx ( ) )
  {
  static_assert ( ! is_pointer < _Dx > :: value,
   "unique_ptr constructed with null deleter pointer" );
  }

 unique_ptr ( pointer _Ptr,
  typename _If < tr1 :: is_reference < _Dx > :: value, _Dx,
   const typename tr1 :: remove_reference < _Dx > :: type & > :: _Type _Dt )
  : _Mybase ( _Ptr, _Dt )
  {
  }

public :
 unique_ptr ( pointer _Ptr, typename tr1 :: remove_reference < _Dx > :: type && _Dt )
  : _Mybase ( _Ptr, :: std :: move ( _Dt ) )
  {


  }

 unique_ptr ( unique_ptr && _Right )
  : _Mybase ( _Right . release ( ),
   :: std :: forward < _Dx > ( _Right . get_deleter ( ) ) )
  {
  }

private :
 template < class _Ty2,
  class _Dx2 >
  unique_ptr ( unique_ptr < _Ty2, _Dx2 > && _Right );

 template < class _Ty2,
  class _Dx2 >
  _Myt & operator = ( unique_ptr < _Ty2, _Dx2 > && _Right );

public :
 _Myt & operator = ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   reset ( _Right . release ( ) );
   this -> get_deleter ( ) = :: std :: move ( _Right . get_deleter ( ) );
   }
  return ( * this );
  }

 void swap ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   _Swap_adl ( this -> _Myptr, _Right . _Myptr );
   _Swap_adl ( this -> get_deleter ( ),
    _Right . get_deleter ( ) );
   }
  }


 unique_ptr ( :: std :: nullptr_t )
  : _Mybase ( pointer ( ), _Dx ( ) )
  {
  static_assert ( ! is_pointer < _Dx > :: value,
   "unique_ptr constructed with null deleter pointer" );
  }

 _Myt & operator = ( :: std :: nullptr_t )
  {
  reset ( );
  return ( * this );
  }

 void reset ( :: std :: nullptr_t )
  {
  if ( this -> _Myptr != 0 )
   {
   _Delete ( );
   this -> _Myptr = 0;
   }
  }


 void swap ( _Myt & _Right )
  {
  _Swap_adl ( this -> _Myptr, _Right . _Myptr );
  _Swap_adl ( this -> get_deleter ( ), _Right . get_deleter ( ) );
  }

 ~ unique_ptr ( )
  {
  _Delete ( );
  }

 typename tr1 :: add_reference < _Ty > :: type operator [ ] ( size_t _Idx ) const
  {
  return ( this -> _Myptr [ _Idx ] );
  }

 pointer get ( ) const
  {
  return ( this -> _Myptr );
  }

 operator :: std :: _Bool_type ( ) const
  {
  return ( this -> _Myptr != 0 ? ( & :: std :: _Bool_struct :: _Member ) : 0 );
  }

 pointer release ( )
  {
  pointer _Ans = this -> _Myptr;
  this -> _Myptr = pointer ( );
  return ( _Ans );
  }

 void reset ( pointer _Ptr = pointer ( ) )
  {
  if ( _Ptr != this -> _Myptr )
   {
   _Delete ( );
   this -> _Myptr = _Ptr;
   }
  }

private :
 template < class _Ptr2 >
  explicit unique_ptr ( _Ptr2 );

 template < class _Ptr2,
  class _Dx2 >
  unique_ptr ( _Ptr2, _Dx2 );

 unique_ptr ( const _Myt & );
 template < class _Ty2,
  class _Dx2 >
  unique_ptr ( const unique_ptr < _Ty2, _Dx2 > & );

 _Myt & operator = ( const _Myt & );
 template < class _Ty2,
  class _Dx2 >
  _Myt & operator = ( const unique_ptr < _Ty2, _Dx2 > & );

 template < class _Ptr2 >
  void reset ( _Ptr2 );

 void _Delete ( )
  {
  this -> get_deleter ( ) ( this -> _Myptr );
  }
 };
#line 2534 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
template < class _Ty,
 class _Dx >
 void swap ( unique_ptr < _Ty, _Dx > & _Left,
  unique_ptr < _Ty, _Dx > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 2542
template < class _Ty,
 class _Dx >
 void swap ( unique_ptr < _Ty, _Dx > & _Left,
  unique_ptr < _Ty, _Dx > && _Right )
 {
 _Left . swap ( _Right );
 }
#line 2550
template < class _Ty,
 class _Dx >
 void swap ( unique_ptr < _Ty, _Dx > && _Left,
  unique_ptr < _Ty, _Dx > & _Right )
 {
 _Right . swap ( _Left );
 }
#line 2558
template < class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2 >
 bool operator == ( const unique_ptr < _Ty1, _Dx1 > & _Left,
  const unique_ptr < _Ty2, _Dx2 > & _Right )
 {
 return ( _Left . get ( ) == _Right . get ( ) );
 }
#line 2568
template < class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2 >
 bool operator != ( const unique_ptr < _Ty1, _Dx1 > & _Left,
  const unique_ptr < _Ty2, _Dx2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 2578
template < class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2 >
 bool operator < ( const unique_ptr < _Ty1, _Dx1 > & _Left,
  const unique_ptr < _Ty2, _Dx2 > & _Right )
 {
 return ( _Left . get ( ) < _Right . get ( ) );
 }
#line 2588
template < class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2 >
 bool operator >= ( const unique_ptr < _Ty1, _Dx1 > & _Left,
  const unique_ptr < _Ty2, _Dx2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 2598
template < class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2 >
 bool operator > ( const unique_ptr < _Ty1, _Dx1 > & _Left,
  const unique_ptr < _Ty2, _Dx2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 2608
template < class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2 >
 bool operator <= ( const unique_ptr < _Ty1, _Dx1 > & _Left,
  const unique_ptr < _Ty2, _Dx2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 2619
namespace pointer_safety { 
#line 2620
enum pointer_safety { 
#line 2621
relaxed, 
#line 2622
preferred, 
#line 2623
strict
#line 2624
}; 
#line 2625
}
#line 2627
typedef pointer_safety::pointer_safety _Pointer_safety; 
#line 2629
inline void declare_reachable(void *) 
#line 2630
{ 
#line 2631
} 
#line 2633
template < class _Ty > inline
 _Ty * undeclare_reachable ( _Ty * _Ptr )
 {
 return ( _Ptr );
 }
#line 2639
inline void declare_no_pointers(char *, size_t) 
#line 2640
{ 
#line 2641
} 
#line 2643
inline void undeclare_no_pointers(char *, size_t) 
#line 2644
{ 
#line 2645
} 
#line 2647
inline _Pointer_safety get_pointer_safety() 
#line 2648
{ 
#line 2649
return pointer_safety::relaxed; 
#line 2650
} 
#line 2653
using tr1::allocate_shared;
#line 2654
using tr1::bad_weak_ptr;
#line 2655
using tr1::const_pointer_cast;
#line 2656
using tr1::dynamic_pointer_cast;
#line 2657
using tr1::enable_shared_from_this;
#line 2658
using tr1::get_deleter;
#line 2659
using tr1::make_shared;
#line 2660
using tr1::shared_ptr;
#line 2661
using tr1::static_pointer_cast;
#line 2662
using tr1::swap;
#line 2663
using tr1::weak_ptr;
#line 2667 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
template< class _Ty> struct owner_less; 
#line 2670
template < class _Ty >
 struct owner_less < shared_ptr < _Ty > >
  : public binary_function < shared_ptr < _Ty >, shared_ptr < _Ty >, bool >
 {
 bool operator ( ) ( const shared_ptr < _Ty > & _Left,
  const shared_ptr < _Ty > & _Right ) const
  {
  return ( _Left . owner_before ( _Right ) );
  }

 bool operator ( ) ( const shared_ptr < _Ty > & _Left,
  const weak_ptr < _Ty > & _Right ) const
  {
  return ( _Left . owner_before ( _Right ) );
  }

 bool operator ( ) ( const weak_ptr < _Ty > & _Left,
  const shared_ptr < _Ty > & _Right ) const
  {
  return ( _Left . owner_before ( _Right ) );
  }
 };
#line 2693
template < class _Ty >
 struct owner_less < weak_ptr < _Ty > >
  : public binary_function < weak_ptr < _Ty >, weak_ptr < _Ty >, bool >
 {
 bool operator ( ) ( const weak_ptr < _Ty > & _Left,
  const weak_ptr < _Ty > & _Right ) const
  {
  return ( _Left . owner_before ( _Right ) );
  }

 bool operator ( ) ( const weak_ptr < _Ty > & _Left,
  const shared_ptr < _Ty > & _Right ) const
  {
  return ( _Left . owner_before ( _Right ) );
  }

 bool operator ( ) ( const shared_ptr < _Ty > & _Left,
  const weak_ptr < _Ty > & _Right ) const
  {
  return ( _Left . owner_before ( _Right ) );
  }
 };
#line 2715
}
#line 2720 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
#pragma warning(push,3)
#pragma warning(disable: 4244)
#line 2721 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\memory"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
#pragma pack ( push, 8 )
#line 12
namespace std { 
#line 14
const int _ISORT_MAX = 32; 
#line 17
template < class _InIt,
 class _Fn1 > inline
 _Fn1 _For_each ( _InIt _First, _InIt _Last, _Fn1 _Func )
 {
 for (; _First != _Last; ++ _First )
  _Func ( * _First );
 return ( _Func );
 }
#line 26
template < class _InIt,
 class _Fn1 > inline
 _Fn1 for_each ( _InIt _First, _InIt _Last, _Fn1 _Func )
 {
 ;
 ;
 return ( _For_each ( _Unchecked ( _First ), _Unchecked ( _Last ), _Func ) );
 }
#line 36
template < class _InIt,
 class _Ty > inline
 _InIt _Find ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 for (; _First != _Last; ++ _First )
  if ( * _First == _Val )
   break;
 return ( _First );
 }
#line 46
inline const char *_Find(const char *_First, const char *_Last, int _Val) 
#line 47
{ 
#line 48
_First = ((const char *)::memchr(_First, _Val, _Last - _First)); 
#line 49
return (_First == (0)) ? _Last : _First; 
#line 50
} 
#line 52
inline const signed char *_Find(const signed char *_First, const signed char *
#line 53
_Last, int _Val) 
#line 54
{ 
#line 55
_First = ((const signed char *)::memchr(_First, _Val, _Last - _First)); 
#line 57
return (_First == (0)) ? _Last : _First; 
#line 58
} 
#line 60
inline const unsigned char *_Find(const unsigned char *_First, const unsigned char *
#line 61
_Last, int _Val) 
#line 62
{ 
#line 63
_First = ((const unsigned char *)::memchr(_First, _Val, _Last - _First)); 
#line 65
return (_First == (0)) ? _Last : _First; 
#line 66
} 
#line 68
template < class _InIt,
 class _Ty > inline
 _InIt find ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 ;
 return ( _Rechecked ( _First,
  _Find ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val ) ) );
 }
#line 78
template < class _InIt,
 class _Pr > inline
 _InIt _Find_if ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   break;
 return ( _First );
 }
#line 88
template < class _InIt,
 class _Pr > inline
 _InIt find_if ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Rechecked ( _First,
  _Find_if ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 99
template < class _FwdIt > inline
 _FwdIt _Adjacent_find ( _FwdIt _First, _FwdIt _Last )
 {
 if ( _First != _Last )
  for ( _FwdIt _Firstb; ( _Firstb = _First ), ++ _First != _Last; )
   if ( * _Firstb == * _First )
    return ( _Firstb );
 return ( _Last );
 }
#line 109
template < class _FwdIt > inline
 _FwdIt adjacent_find ( _FwdIt _First, _FwdIt _Last )
 {
 ;
 return ( _Rechecked ( _First,
  _Adjacent_find ( _Unchecked ( _First ), _Unchecked ( _Last ) ) ) );
 }
#line 118
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Adjacent_find ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 if ( _First != _Last )
  for ( _FwdIt _Firstb; ( _Firstb = _First ), ++ _First != _Last; )
   if ( _Pred ( * _Firstb, * _First ) )
    return ( _Firstb );
 return ( _Last );
 }
#line 129
template < class _FwdIt,
 class _Pr > inline
 _FwdIt adjacent_find ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Rechecked ( _First,
  _Adjacent_find ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 140
template < class _InIt,
 class _Ty > inline
 typename iterator_traits < _InIt > :: difference_type
  _Count ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 typename iterator_traits < _InIt > :: difference_type _Count = 0;

 for (; _First != _Last; ++ _First )
  if ( * _First == _Val )
   ++ _Count;
 return ( _Count );
 }
#line 153
template < class _InIt,
 class _Ty > inline
 typename iterator_traits < _InIt > :: difference_type
  count ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 ;
 return ( _Count ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val ) );
 }
#line 163
template < class _InIt,
 class _Pr > inline
 typename iterator_traits < _InIt > :: difference_type
  _Count_if ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 typename iterator_traits < _InIt > :: difference_type _Count = 0;

 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   ++ _Count;
 return ( _Count );
 }
#line 176
template < class _InIt,
 class _Pr > inline
 typename iterator_traits < _InIt > :: difference_type
  count_if ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Count_if ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) );
 }
#line 188
template < class _InIt,
 class _Pr > inline
 bool _All_of ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( ! _Pred ( * _First ) )
   return ( false );
 return ( true );
 }
#line 198
template < class _InIt,
 class _Pr > inline
 bool all_of ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _All_of ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) );
 }
#line 208
template < class _InIt,
 class _Pr > inline
 bool _Any_of ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   return ( true );
 return ( false );
 }
#line 218
template < class _InIt,
 class _Pr > inline
 bool any_of ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Any_of ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) );
 }
#line 228
template < class _InIt,
 class _Pr > inline
 bool _None_of ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   return ( false );
 return ( true );
 }
#line 238
template < class _InIt,
 class _Pr > inline
 bool none_of ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _None_of ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) );
 }
#line 248
template < class _InIt,
 class _Pr > inline
 _InIt _Find_if_not ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( ! _Pred ( * _First ) )
   break;
 return ( _First );
 }
#line 258
template < class _InIt,
 class _Pr > inline
 _InIt find_if_not ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Rechecked ( _First,
  _Find_if_not ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 269
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   * _Dest ++ = * _First;
 return ( _Dest );
 }
#line 282
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr _Pred )
 {
 return ( _Copy_if ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Pred ) );
 }
#line 342 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt,
 class _OutIt1,
 class _OutIt2,
 class _Pr > inline
 :: std :: pair < _OutIt1, _OutIt2 >
  _Partition_copy ( _InIt _First, _InIt _Last,
   _OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   * _Dest1 ++ = * _First;
  else
   * _Dest2 ++ = * _First;
 return ( :: std :: pair < _OutIt1, _OutIt2 > ( _Dest1, _Dest2 ) );
 }
#line 359
template < class _InIt,
 class _OutIt1,
 class _OutIt2,
 class _Pr > inline
 :: std :: pair < _OutIt1, _OutIt2 >
  partition_copy ( _InIt _First, _InIt _Last,
   _OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred )
 {
 return ( :: std :: pair < _OutIt1, _OutIt2 > (
  _Partition_copy ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dest1, _Dest2, _Pred ) ) );
 }
#line 508 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt,
 class _Pr > inline
 bool _Is_partitioned ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( ! _Pred ( * _First ) )
   break;
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   return ( false );
 return ( true );
 }
#line 521
template < class _InIt,
 class _Pr > inline
 bool is_partitioned ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Is_partitioned ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Pred ) );
 }
#line 532
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Partition_point ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( ! _Pred ( * _First ) )
   break;
 return ( _First );
 }
#line 542
template < class _FwdIt,
 class _Pr > inline
 _FwdIt partition_point ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Rechecked ( _First,
  _Partition_point ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Pred ) ) );
 }
#line 555 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2 > inline
 _FwdIt1 _Search ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 * )
 {
 _Diff1 _Count1 = 0;
 _Distance ( _First1, _Last1, _Count1 );
 _Diff2 _Count2 = 0;
 _Distance ( _First2, _Last2, _Count2 );

 for (; _Count2 <= _Count1; ++ _First1, -- _Count1 )
  {
  _FwdIt1 _Mid1 = _First1;
  for ( _FwdIt2 _Mid2 = _First2;; ++ _Mid1, ++ _Mid2 )
   if ( _Mid2 == _Last2 )
    return ( _First1 );
   else if ( ! ( * _Mid1 == * _Mid2 ) )
    break;
  }
 return ( _Last1 );
 }
#line 579
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt1 search ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2 )
 {
 ;
 ;
 return ( _Rechecked ( _First1,
  _Search ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
   _Dist_type ( _First1 ), _Dist_type ( _First2 ) ) ) );
 }
#line 593
template < class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2,
 class _Pr > inline
 _FwdIt1 _Search ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 * )
 {
 _Diff1 _Count1 = 0;
 _Distance ( _First1, _Last1, _Count1 );
 _Diff2 _Count2 = 0;
 _Distance ( _First2, _Last2, _Count2 );

 for (; _Count2 <= _Count1; ++ _First1, -- _Count1 )
  {
  _FwdIt1 _Mid1 = _First1;
  for ( _FwdIt2 _Mid2 = _First2;; ++ _Mid1, ++ _Mid2 )
   if ( _Mid2 == _Last2 )
    return ( _First1 );
   else if ( ! _Pred ( * _Mid1, * _Mid2 ) )
    break;
  }
 return ( _Last1 );
 }
#line 618
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 search ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {
 ;
 ;
 ;
 return ( _Rechecked ( _First1,
  _Search ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred,
   _Dist_type ( _First1 ), _Dist_type ( _First2 ) ) ) );
 }
#line 634
template < class _FwdIt1,
 class _Diff2,
 class _Ty > inline
 _FwdIt1 _Search_n ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty & _Val, forward_iterator_tag )
 {
 if ( _Count <= 0 )
  return ( _First1 );

 for (; _First1 != _Last1; ++ _First1 )
  if ( * _First1 == _Val )
   {
   _FwdIt1 _Mid1 = _First1;

   for ( _Diff2 _Count1 = _Count;; )
    if ( -- _Count1 == 0 )
     return ( _First1 );
    else if ( ++ _Mid1 == _Last1 )
     return ( _Last1 );
    else if ( ! ( * _Mid1 == _Val ) )
     break;

   _First1 = _Mid1;
   }
 return ( _Last1 );
 }
#line 661
template < class _FwdIt1,
 class _Diff2,
 class _Ty > inline
 _FwdIt1 _Search_n ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty & _Val, random_access_iterator_tag )
 {
 if ( _Count <= 0 )
  return ( _First1 );

 _FwdIt1 _Oldfirst1 = _First1;
 for ( _Diff2 _Inc = 0; _Count <= _Last1 - _Oldfirst1; )
  {
  _First1 = _Oldfirst1 + _Inc;
  if ( * _First1 == _Val )
   {
   _Diff2 _Count1 = _Count;
   _FwdIt1 _Mid1 = _First1;

   for (; _Oldfirst1 != _First1 && _First1 [ - 1 ] == _Val; -- _First1 )
    -- _Count1;

   if ( _Count1 <= _Last1 - _Mid1 )
    for (;; )
     if ( -- _Count1 == 0 )
      return ( _First1 );
     else if ( ! ( * ++ _Mid1 == _Val ) )
      break;

   _Oldfirst1 = ++ _Mid1;
   _Inc = 0;
   }
  else
   {
   _Oldfirst1 = _First1 + 1;
   _Inc = _Count - 1;
   }
  }
 return ( _Last1 );
 }
#line 701
template < class _FwdIt1,
 class _Diff2,
 class _Ty > inline
 _FwdIt1 search_n ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty & _Val )
 {
 ;
 return ( _Rechecked ( _First1,
  _Search_n ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ), _Count, _Val,
   _Iter_cat ( _First1 ) ) ) );
 }
#line 714
template < class _FwdIt1,
 class _Diff2,
 class _Ty,
 class _Pr > inline
 _FwdIt1 _Search_n ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty & _Val, _Pr _Pred, forward_iterator_tag )
 {
 if ( _Count <= 0 )
  return ( _First1 );

 for (; _First1 != _Last1; ++ _First1 )
  if ( _Pred ( * _First1, _Val ) )
   {
   _FwdIt1 _Mid1 = _First1;

   for ( _Diff2 _Count1 = _Count;; )
    if ( -- _Count1 == 0 )
     return ( _First1 );
    else if ( ++ _Mid1 == _Last1 )
     return ( _Last1 );
    else if ( ! _Pred ( * _Mid1, _Val ) )
     break;

   _First1 = _Mid1;
   }
 return ( _Last1 );
 }
#line 742
template < class _FwdIt1,
 class _Diff2,
 class _Ty,
 class _Pr > inline
 _FwdIt1 _Search_n ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty & _Val, _Pr _Pred, random_access_iterator_tag )
 {
 if ( _Count <= 0 )
  return ( _First1 );

 _FwdIt1 _Oldfirst1 = _First1;
 for (; _Count <= _Last1 - _Oldfirst1; )
  {
  if ( _Pred ( * _First1, _Val ) )
   {
   _Diff2 _Count1 = _Count;
   _FwdIt1 _Mid1 = _First1;

   for (; _Oldfirst1 != _First1 && _Pred ( _First1 [ - 1 ], _Val );
    -- _First1 )
    -- _Count1;

   if ( _Count1 <= _Last1 - _Mid1 )
    for (;; )
     if ( -- _Count1 == 0 )
      return ( _First1 );
     else if ( ! _Pred ( * ++ _Mid1, _Val ) )
      break;

   _Oldfirst1 = ++ _Mid1;
   _First1 = _Oldfirst1;
   }
  else
   {
   _Oldfirst1 = _First1 + 1;
   _First1 += _Count;
   }
  }
 return ( _Last1 );
 }
#line 783
template < class _FwdIt1,
 class _Diff2,
 class _Ty,
 class _Pr > inline
 _FwdIt1 search_n ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty & _Val, _Pr _Pred )
 {
 ;
 ;
 return ( _Rechecked ( _First1,
  _Search_n ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ), _Count, _Val,
   _Pred, _Iter_cat ( _First1 ) ) ) );
 }
#line 798
template < class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2 > inline
 _FwdIt1 _Find_end ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 * )
 {
 _Diff1 _Count1 = 0;
 _Distance ( _First1, _Last1, _Count1 );
 _Diff2 _Count2 = 0;
 _Distance ( _First2, _Last2, _Count2 );
 _FwdIt1 _Ans = _Last1;

 if ( 0 < _Count2 )
  for (; _Count2 <= _Count1; ++ _First1, -- _Count1 )
   {
   _FwdIt1 _Mid1 = _First1;
   for ( _FwdIt2 _Mid2 = _First2;; ++ _Mid1 )
    if ( ! ( * _Mid1 == * _Mid2 ) )
     break;
    else if ( ++ _Mid2 == _Last2 )
     {
     _Ans = _First1;
     break;
     }
   }
 return ( _Ans );
 }
#line 827
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt1 find_end ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2 )
 {
 ;
 ;
 return ( _Rechecked ( _First1,
  _Find_end ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
   _Dist_type ( _First1 ), _Dist_type ( _First2 ) ) ) );
 }
#line 841
template < class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2,
 class _Pr > inline
 _FwdIt1 _Find_end ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 * )
 {
 _Diff1 _Count1 = 0;
 _Distance ( _First1, _Last1, _Count1 );
 _Diff2 _Count2 = 0;
 _Distance ( _First2, _Last2, _Count2 );
 _FwdIt1 _Ans = _Last1;

 if ( 0 < _Count2 )
  for (; _Count2 <= _Count1; ++ _First1, -- _Count1 )
   {
   _FwdIt1 _Mid1 = _First1;
   for ( _FwdIt2 _Mid2 = _First2;; ++ _Mid1 )
    if ( ! _Pred ( * _Mid1, * _Mid2 ) )
     break;
    else if ( ++ _Mid2 == _Last2 )
     {
     _Ans = _First1;
     break;
     }
   }
 return ( _Ans );
 }
#line 871
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 find_end ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {
 ;
 ;
 ;
 return ( _Rechecked ( _First1,
  _Find_end ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred,
   _Dist_type ( _First1 ), _Dist_type ( _First2 ) ) ) );
 }
#line 887
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt1 _Find_first_of ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2 )
 {
 for (; _First1 != _Last1; ++ _First1 )
  for ( _FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++ _Mid2 )
   if ( * _First1 == * _Mid2 )
    return ( _First1 );
 return ( _First1 );
 }
#line 899
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt1 find_first_of ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2 )
 {
 ;
 ;
 return ( _Rechecked ( _First1,
  _Find_first_of ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _Unchecked ( _First2 ), _Unchecked ( _Last2 ) ) ) );
 }
#line 912
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 _Find_first_of ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {
 for (; _First1 != _Last1; ++ _First1 )
  for ( _FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++ _Mid2 )
   if ( _Pred ( * _First1, * _Mid2 ) )
    return ( _First1 );
 return ( _First1 );
 }
#line 925
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 find_first_of ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {
 ;
 ;
 ;
 return ( _Rechecked ( _First1,
  _Find_first_of ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred ) ) );
 }
#line 940
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt2 _Swap_ranges ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest )
 {
 for (; _First1 != _Last1; ++ _First1, ++ _Dest )
  :: std :: iter_swap ( _First1, _Dest );
 return ( _Dest );
 }
#line 951
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt2 swap_ranges ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest )
 {
 return ( _Swap_ranges ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Dest ) );
 }
#line 1027 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _Ty,
 size_t _Size > inline
 void swap ( _Ty ( & _Left ) [ _Size ], _Ty ( & _Right ) [ _Size ] )
 {
 if ( & _Left != & _Right )
  _Swap_ranges ( & _Left [ 0 ], & _Left [ 0 ] + _Size, & _Right [ 0 ] );
 }
#line 1036
template < class _InIt,
 class _OutIt,
 class _Fn1 > inline
 _OutIt _Transform ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1 _Func )
 {
 for (; _First != _Last; ++ _First, ++ _Dest )
  * _Dest = _Func ( * _First );
 return ( _Dest );
 }
#line 1048
template < class _InIt,
 class _OutIt,
 class _Fn1 > inline
 _OutIt transform ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1 _Func )
 {
 if ( _First != _Last )
  return ( _Transform ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dest, _Func ) );
 return ( _Dest );
 }
#line 1138 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2 > inline
 _OutIt _Transform ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2 _Func )
 {
 for (; _First1 != _Last1; ++ _First1, ++ _First2, ++ _Dest )
  * _Dest = _Func ( * _First1, * _First2 );
 return ( _Dest );
 }
#line 1151
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2 > inline
 _OutIt transform ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2 _Func )
 {
 if ( _First1 != _Last1 )
  return ( _Transform ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _First2, _Dest, _Func ) );
 return ( _Dest );
 }
#line 1305 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _FwdIt,
 class _Ty > inline
 void _Replace ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Oldval, const _Ty & _Newval )
 {
 for (; _First != _Last; ++ _First )
  if ( * _First == _Oldval )
   * _First = _Newval;
 }
#line 1315
template < class _FwdIt,
 class _Ty > inline
 void replace ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Oldval, const _Ty & _Newval )
 {
 ;
 _Replace ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Oldval, _Newval );
 }
#line 1326
template < class _FwdIt,
 class _Pr,
 class _Ty > inline
 void _Replace_if ( _FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty & _Val )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   * _First = _Val;
 }
#line 1336
template < class _FwdIt,
 class _Pr,
 class _Ty > inline
 void replace_if ( _FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty & _Val )
 {
 ;
 ;
 _Replace_if ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Pred, _Val );
 }
#line 1348
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt _Replace_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Oldval, const _Ty & _Newval )
 {
 for (; _First != _Last; ++ _First, ++ _Dest )
  * _Dest = * _First == _Oldval ? _Newval : * _First;
 return ( _Dest );
 }
#line 1360
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt replace_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Oldval, const _Ty & _Newval )
 {
 return ( _Replace_copy ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Oldval, _Newval ) );
 }
#line 1448 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty > inline
 _OutIt _Replace_copy_if ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred, const _Ty & _Val )
 {
 for (; _First != _Last; ++ _First, ++ _Dest )
  * _Dest = _Pred ( * _First ) ? _Val : * _First;
 return ( _Dest );
 }
#line 1461
template < class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty > inline
 _OutIt replace_copy_if ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred, const _Ty & _Val )
 {
 return ( _Replace_copy_if ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Pred, _Val ) );
 }
#line 1557 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _FwdIt,
 class _Fn0 > inline
 void _Generate ( _FwdIt _First, _FwdIt _Last, _Fn0 _Func )
 {
 for (; _First != _Last; ++ _First )
  * _First = _Func ( );
 }
#line 1565
template < class _FwdIt,
 class _Fn0 > inline
 void generate ( _FwdIt _First, _FwdIt _Last, _Fn0 _Func )
 {
 ;
 ;
 _Generate ( _Unchecked ( _First ), _Unchecked ( _Last ), _Func );
 }
#line 1575
template < class _OutIt,
 class _Diff,
 class _Fn0 > inline
 void _Generate_n ( _OutIt _Dest, _Diff _Count, _Fn0 _Func )
 {
 for (; 0 < _Count; -- _Count, ++ _Dest )
  * _Dest = _Func ( );
 }
#line 1585
template < class _OutIt,
 class _Diff,
 class _Fn0 > inline
 void generate_n ( _OutIt _Dest, _Diff _Count, _Fn0 _Func )
 {
 _Generate_n ( _Dest, _Count, _Func );
 }
#line 1658 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt _Remove_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Val )
 {
 for (; _First != _Last; ++ _First )
  if ( ! ( * _First == _Val ) )
   * _Dest ++ = * _First;
 return ( _Dest );
 }
#line 1671
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt remove_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Val )
 {
 return ( _Remove_copy ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Val ) );
 }
#line 1733 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Remove_copy_if ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( ! _Pred ( * _First ) )
   * _Dest ++ = * _First;
 return ( _Dest );
 }
#line 1746
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt remove_copy_if ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred )
 {
 return ( _Remove_copy_if ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Pred ) );
 }
#line 1809 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _FwdIt,
 class _Ty > inline
 _FwdIt _Remove ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 _FwdIt _Next = _First;
 for ( ++ _First; _First != _Last; ++ _First )
  if ( ! ( * _First == _Val ) )
   * _Next ++ = _Move ( * _First );
 return ( _Next );
 }
#line 1820
template < class _FwdIt,
 class _Ty > inline
 _FwdIt remove ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 _First = :: std :: find ( _First, _Last, _Val );
 if ( _First == _Last )
  return ( _First );
 else
  return ( _Rechecked ( _First,
   _Remove ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val ) ) );
 }
#line 1833
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Remove_if ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _FwdIt _Next = _First;
 for ( ++ _First; _First != _Last; ++ _First )
 if ( ! _Pred ( * _First ) )
  * _Next ++ = _Move ( * _First );
 return ( _Next );
 }
#line 1844
template < class _FwdIt,
 class _Pr > inline
 _FwdIt remove_if ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _First = :: std :: find_if ( _First, _Last, _Pred );
 if ( _First == _Last )
  return ( _First );
 else
  return ( _Rechecked ( _First,
   _Remove_if ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 1857
template < class _FwdIt > inline
 _FwdIt _Unique ( _FwdIt _First, _FwdIt _Last )
 {
 if ( _First != _Last )
  for ( _FwdIt _Firstb; ( _Firstb = _First ), ++ _First != _Last; )
   if ( * _Firstb == * _First )
    {
    for (; ++ _First != _Last; )
     if ( ! ( * _Firstb == * _First ) )
      * ++ _Firstb = _Move ( * _First );
    return ( ++ _Firstb );
    }
 return ( _Last );
 }
#line 1872
template < class _FwdIt > inline
 _FwdIt unique ( _FwdIt _First, _FwdIt _Last )
 {
 ;
 return ( _Rechecked ( _First,
  _Unique ( _Unchecked ( _First ), _Unchecked ( _Last ) ) ) );
 }
#line 1881
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Unique ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 if ( _First != _Last )
  for ( _FwdIt _Firstb; ( _Firstb = _First ), ++ _First != _Last; )
   if ( _Pred ( * _Firstb, * _First ) )
    {
    for (; ++ _First != _Last; )
     if ( ! _Pred ( * _Firstb, * _First ) )
      * ++ _Firstb = _Move ( * _First );
    return ( ++ _Firstb );
    }
 return ( _Last );
 }
#line 1897
template < class _FwdIt,
 class _Pr > inline
 _FwdIt unique ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Rechecked ( _First,
  _Unique ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 1908
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt _Unique_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Ty * )
 {
 _Ty _Val = * _First;
 for ( * _Dest ++ = _Val; ++ _First != _Last; )
  if ( ! ( _Val == * _First ) )
   {
   _Val = * _First;
   * _Dest ++ = _Val;
   }
 return ( _Dest );
 }
#line 1924
template < class _InIt,
 class _OutIt > inline
 _OutIt _Unique_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, input_iterator_tag )
 {
 return ( _Unique_copy ( _First, _Last, _Dest,
  _Val_type ( _First ) ) );
 }
#line 1933
template < class _FwdIt,
 class _OutIt > inline
 _OutIt _Unique_copy ( _FwdIt _First, _FwdIt _Last,
  _OutIt _Dest, forward_iterator_tag )
 {
 _FwdIt _Firstb = _First;
 for ( * _Dest ++ = * _Firstb; ++ _First != _Last; )
  if ( ! ( * _Firstb == * _First ) )
   {
   _Firstb = _First;
   * _Dest ++ = * _Firstb;
   }
 return ( _Dest );
 }
#line 1949
template < class _InIt,
 class _OutIt > inline
 _OutIt unique_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 return ( _First == _Last ? _Dest :
  _Unique_copy ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dest, _Iter_cat ( _First ) ) );
 }
#line 2005 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Ty,
 class _Pr > inline
 _OutIt _Unique_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred, _Ty * )
 {
 _Ty _Val = * _First;

 for ( * _Dest ++ = _Val; ++ _First != _Last; )
  if ( ! _Pred ( _Val, * _First ) )
   {
   _Val = * _First;
   * _Dest ++ = _Val;
   }
 return ( _Dest );
 }
#line 2023
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Unique_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred, input_iterator_tag )
 {
 return ( _Unique_copy ( _First, _Last, _Dest, _Pred,
  _Val_type ( _First ) ) );
 }
#line 2033
template < class _FwdIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Unique_copy ( _FwdIt _First, _FwdIt _Last,
  _OutIt _Dest, _Pr _Pred, forward_iterator_tag )
 {
 _FwdIt _Firstb = _First;

 for ( * _Dest ++ = * _Firstb; ++ _First != _Last; )
  if ( ! _Pred ( * _Firstb, * _First ) )
   {
   _Firstb = _First;
   * _Dest ++ = * _Firstb;
   }
 return ( _Dest );
 }
#line 2051
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt unique_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred )
 {
 return ( _First == _Last ? _Dest :
  _Unique_copy ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dest, _Pred, _Iter_cat ( _First ) ) );
 }
#line 2112 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _BidIt,
 class _OutIt > inline
 _OutIt _Reverse_copy ( _BidIt _First, _BidIt _Last,
  _OutIt _Dest )
 {
 for (; _First != _Last; ++ _Dest )
  * _Dest = * -- _Last;
 return ( _Dest );
 }
#line 2123
template < class _BidIt,
 class _OutIt > inline
 _OutIt reverse_copy ( _BidIt _First, _BidIt _Last,
  _OutIt _Dest )
 {
 return ( _Reverse_copy ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest ) );
 }
#line 2201 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _FwdIt,
 class _OutIt > inline
 _OutIt rotate_copy ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  _OutIt _Dest )
 {
 _Dest = :: std :: copy ( _Mid, _Last, _Dest );
 return ( :: std :: copy ( _First, _Mid, _Dest ) );
 }
#line 2211
template < class _RanIt,
 class _Diff > inline
 void _Random_shuffle ( _RanIt _First, _RanIt _Last, _Diff * )
 {
 const int _RANDOM_BITS = 15;
 const int _RANDOM_MAX = ( 1U << _RANDOM_BITS ) - 1;

 _RanIt _Next = _First;
 for ( unsigned long _Index = 2; ++ _Next != _Last; ++ _Index )
  {
  unsigned long _Rm = _RANDOM_MAX;
  unsigned long _Rn = :: rand ( ) & _RANDOM_MAX;
  for (; _Rm < _Index && _Rm != ~ 0UL;
   _Rm = _Rm << _RANDOM_BITS | _RANDOM_MAX )
   _Rn = _Rn << _RANDOM_BITS
    | ( :: rand ( ) & _RANDOM_MAX );

  :: std :: iter_swap ( _Next, _First + _Diff ( _Rn % _Index ) );
  }
 }
#line 2232
template < class _RanIt > inline
 void random_shuffle ( _RanIt _First, _RanIt _Last )
 {
 ;
 if ( _First != _Last )
  _Random_shuffle ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dist_type ( _First ) );
 }
#line 2242
template < class _RanIt,
 class _Fn1,
 class _Diff > inline
 void _Random_shuffle ( _RanIt _First, _RanIt _Last, _Fn1 & _Func, _Diff * )
 {
 _RanIt _Next = _First;
 for ( _Diff _Index = 2; ++ _Next != _Last; ++ _Index )
  :: std :: iter_swap ( _Next, _First + _Diff ( _Func ( _Index ) % _Index ) );
 }
#line 2252
template < class _RanIt,
 class _Fn1 > inline
 void random_shuffle ( _RanIt _First, _RanIt _Last, _Fn1 & _Func )
 {
 ;
 ;
 if ( _First != _Last )
  _Random_shuffle ( _Unchecked ( _First ), _Unchecked ( _Last ), _Func,
   _Dist_type ( _First ) );
 }
#line 2264
template < class _BidIt,
 class _Pr > inline
 _BidIt _Partition ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 for (;; ++ _First )
  {
  for (; _First != _Last && _Pred ( * _First ); ++ _First )
   ;
  if ( _First == _Last )
   break;

  for (; _First != -- _Last && ! _Pred ( * _Last ); )
   ;
  if ( _First == _Last )
   break;

  :: std :: iter_swap ( _First, _Last );
  }
 return ( _First );
 }
#line 2285
template < class _BidIt,
 class _Pr > inline
 _BidIt partition ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Rechecked ( _First,
  _Partition ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 2296
template < class _BidIt,
 class _Pr,
 class _Diff,
 class _Ty > inline
 _BidIt _Stable_partition ( _BidIt _First, _BidIt _Last, _Pr _Pred,
  _Diff _Count, _Temp_iterator < _Ty > & _Tempbuf )
 {
 if ( _Count == 0 )
  return ( _First );
 else if ( _Count == 1 )
  return ( _Pred ( * _First ) ? _Last : _First );
 else if ( _Count <= _Tempbuf . _Maxlen ( ) )
  {
  _BidIt _Next = _First;
  for ( _Tempbuf . _Init ( ); _First != _Last; ++ _First )
   if ( _Pred ( * _First ) )
    * _Next ++ = _Move ( * _First );
   else
    * _Tempbuf ++ = _Move ( * _First );

  _Move ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _Next );
  return ( _Next );
  }
 else
  {
  _BidIt _Mid = _First;
  :: std :: advance ( _Mid, _Count / 2 );

  _BidIt _Left = _Stable_partition ( _First, _Mid, _Pred,
   _Count / 2, _Tempbuf );
  _BidIt _Right = _Stable_partition ( _Mid, _Last, _Pred,
   _Count - _Count / 2, _Tempbuf );

  _Diff _Count1 = 0;
  _Distance ( _Left, _Mid, _Count1 );
  _Diff _Count2 = 0;
  _Distance ( _Mid, _Right, _Count2 );

  return ( _Buffered_rotate ( _Left, _Mid, _Right,
   _Count1, _Count2, _Tempbuf ) );
  }
 }
#line 2339
template < class _BidIt,
 class _Pr,
 class _Diff,
 class _Ty > inline
 _BidIt _Stable_partition ( _BidIt _First, _BidIt _Last, _Pr _Pred,
  _Diff *, _Ty * )
 {
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );
 _Temp_iterator < _Ty > _Tempbuf ( _Count );
 return ( _Stable_partition ( _First, _Last, _Pred, _Count, _Tempbuf ) );
 }
#line 2352
template < class _BidIt,
 class _Pr > inline
 _BidIt stable_partition ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _First == _Last ? _First
  : _Rechecked ( _First,
   _Stable_partition ( _Unchecked ( _First ), _Unchecked ( _Last ),
    _Pred, _Dist_type ( _First ), _Val_type ( _First ) ) ) );
 }
#line 2405 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Push_heap ( _RanIt _First, _Diff _Hole,
  _Diff _Top, _Ty && _Val )
 {
 for ( _Diff _Idx = ( _Hole - 1 ) / 2;
  _Top < _Hole && ( ( * ( _First + _Idx ) ) < ( _Val ) );
  _Idx = ( _Hole - 1 ) / 2 )
  {
  * ( _First + _Hole ) = _Move ( * ( _First + _Idx ) );
  _Hole = _Idx;
  }

 * ( _First + _Hole ) = _Move ( _Val );
 }
#line 2422
template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Push_heap_0 ( _RanIt _First, _RanIt _Last, _Diff *, _Ty * )
 {
 _Diff _Count = _Last - _First;
 if ( 0 < _Count )
  {
  _Ty _Val = _Move ( * _Last );
  _Push_heap ( _First, _Count, _Diff ( 0 ), _Move ( _Val ) );
  }
 }
#line 2435
template < class _RanIt > inline
 void push_heap ( _RanIt _First, _RanIt _Last )
 {
 ;
 if ( _First != _Last )
  {
  -- _Last;
  ;
  _Push_heap_0 ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dist_type ( _First ), _Val_type ( _First ) );
  }
 }
#line 2449
template < class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Push_heap ( _RanIt _First, _Diff _Hole,
  _Diff _Top, _Ty && _Val, _Pr _Pred )
 {
 for ( _Diff _Idx = ( _Hole - 1 ) / 2;
  _Top < _Hole && _Pred ( * ( _First + _Idx ), _Val );
  _Idx = ( _Hole - 1 ) / 2 )
  {
  * ( _First + _Hole ) = _Move ( * ( _First + _Idx ) );
  _Hole = _Idx;
  }

 * ( _First + _Hole ) = _Move ( _Val );
 }
#line 2467
template < class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Push_heap_0 ( _RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty * )
 {
 _Diff _Count = _Last - _First;
 if ( 0 < _Count )
  {
  _Ty _Val = _Move ( * _Last );
  _Push_heap ( _First, _Count, _Diff ( 0 ), _Move ( _Val ), _Pred );
  }
 }
#line 2481
template < class _RanIt,
 class _Pr > inline
 void push_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 ;
 ;
 if ( _First != _Last )
  {
  -- _Last;
  ;
  _Push_heap_0 ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred,
   _Dist_type ( _First ), _Val_type ( _First ) );
  }
 }
#line 2497
template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Adjust_heap ( _RanIt _First, _Diff _Hole, _Diff _Bottom,
  _Ty && _Val )
 {
 _Diff _Top = _Hole;
 _Diff _Idx = 2 * _Hole + 2;

 for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2 )
  {
  if ( ( ( * ( _First + _Idx ) ) < ( * ( _First + ( _Idx - 1 ) ) ) ) )
   -- _Idx;
  * ( _First + _Hole ) = _Move ( * ( _First + _Idx ) );
  _Hole = _Idx;
  }

 if ( _Idx == _Bottom )
  {
  * ( _First + _Hole ) = _Move ( * ( _First + ( _Bottom - 1 ) ) );
  _Hole = _Bottom - 1;
  }
 _Push_heap ( _First, _Hole, _Top, _Move ( _Val ) );
 }
#line 2522
template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Pop_heap ( _RanIt _First, _RanIt _Last, _RanIt _Dest,
  _Ty && _Val, _Diff * )
 {
 * _Dest = _Move ( * _First );
 _Adjust_heap ( _First, _Diff ( 0 ), _Diff ( _Last - _First ),
  _Move ( _Val ) );
 }
#line 2533
template < class _RanIt,
 class _Ty > inline
 void _Pop_heap_0 ( _RanIt _First, _RanIt _Last, _Ty * )
 {
 _Ty _Val = _Move ( * ( _Last - 1 ) );
 _Pop_heap ( _First, _Last - 1, _Last - 1,
  _Move ( _Val ), _Dist_type ( _First ) );
 }
#line 2542
template < class _RanIt > inline
 void _Pop_heap ( _RanIt _First, _RanIt _Last )
 {
 _Pop_heap_0 ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Val_type ( _First ) );
 }
#line 2549
template < class _RanIt > inline
 void pop_heap ( _RanIt _First, _RanIt _Last )
 {
 ;
 ;
 if ( 1 < _Last - _First )
  _Pop_heap ( _Unchecked ( _First ), _Unchecked ( _Last ) );
 }
#line 2559
template < class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Adjust_heap ( _RanIt _First, _Diff _Hole, _Diff _Bottom,
  _Ty && _Val, _Pr _Pred )
 {
 _Diff _Top = _Hole;
 _Diff _Idx = 2 * _Hole + 2;

 for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2 )
  {
  if ( _Pred ( * ( _First + _Idx ), * ( _First + ( _Idx - 1 ) ) ) )
   -- _Idx;
  * ( _First + _Hole ) = _Move ( * ( _First + _Idx ) );
  _Hole = _Idx;
  }

 if ( _Idx == _Bottom )
  {
  * ( _First + _Hole ) = _Move ( * ( _First + ( _Bottom - 1 ) ) );
  _Hole = _Bottom - 1;
  }
 _Push_heap ( _First, _Hole, _Top, _Move ( _Val ), _Pred );
 }
#line 2585
template < class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Pop_heap ( _RanIt _First, _RanIt _Last, _RanIt _Dest,
  _Ty && _Val, _Pr _Pred, _Diff * )
 {
 * _Dest = _Move ( * _First );
 _Adjust_heap ( _First, _Diff ( 0 ), _Diff ( _Last - _First ),
  _Move ( _Val ), _Pred );
 }
#line 2597
template < class _RanIt,
 class _Ty,
 class _Pr > inline
 void _Pop_heap_0 ( _RanIt _First, _RanIt _Last, _Pr _Pred, _Ty * )
 {
 _Ty _Val = _Move ( * ( _Last - 1 ) );
 _Pop_heap ( _First, _Last - 1, _Last - 1,
  _Move ( _Val ), _Pred, _Dist_type ( _First ) );
 }
#line 2607
template < class _RanIt,
 class _Pr > inline
 void _Pop_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 _Pop_heap_0 ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred,
  _Val_type ( _First ) );
 }
#line 2615
template < class _RanIt,
 class _Pr > inline
 void pop_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 ;
 ;
 ;
 if ( 1 < _Last - _First )
  _Pop_heap ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred );
 }
#line 2627
template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Make_heap ( _RanIt _First, _RanIt _Last, _Diff *, _Ty * )
 {
 _Diff _Bottom = _Last - _First;

 for ( _Diff _Hole = _Bottom / 2; 0 < _Hole; )
  {
  -- _Hole;
  _Ty _Val = _Move ( * ( _First + _Hole ) );
  _Adjust_heap ( _First, _Hole, _Bottom,
   _Move ( _Val ) );
  }
 }
#line 2643
template < class _RanIt > inline
 void make_heap ( _RanIt _First, _RanIt _Last )
 {
 ;
 if ( 1 < _Last - _First )
  _Make_heap ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dist_type ( _First ), _Val_type ( _First ) );
 }
#line 2653
template < class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Make_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty * )
 {
 _Diff _Bottom = _Last - _First;
 for ( _Diff _Hole = _Bottom / 2; 0 < _Hole; )
  {
  -- _Hole;
  _Ty _Val = _Move ( * ( _First + _Hole ) );
  _Adjust_heap ( _First, _Hole, _Bottom,
   _Move ( _Val ), _Pred );
  }
 }
#line 2669
template < class _RanIt,
 class _Pr > inline
 void make_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 ;
 ;
 if ( 1 < _Last - _First )
  _Make_heap ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred,
   _Dist_type ( _First ), _Val_type ( _First ) );
 }
#line 2681
template < class _RanIt > inline
 void _Sort_heap ( _RanIt _First, _RanIt _Last )
 {
 for (; 1 < _Last - _First; -- _Last )
  _Pop_heap ( _First, _Last );
 }
#line 2688
template < class _RanIt > inline
 void sort_heap ( _RanIt _First, _RanIt _Last )
 {
 ;
 ;
 _Sort_heap ( _Unchecked ( _First ), _Unchecked ( _Last ) );
 }
#line 2697
template < class _RanIt,
 class _Pr > inline
 void _Sort_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 for (; 1 < _Last - _First; -- _Last )
  _Pop_heap ( _First, _Last, _Pred );
 }
#line 2705
template < class _RanIt,
 class _Pr > inline
 void sort_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 ;
 ;
 ;
 _Sort_heap ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred );
 }
#line 2716
template < class _FwdIt,
 class _Ty,
 class _Diff > inline
 _FwdIt _Lower_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val, _Diff * )
 {
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );

 for (; 0 < _Count; )
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  :: std :: advance ( _Mid, _Count2 );

  if ( * _Mid < _Val )

   {
   _First = ++ _Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }
 return ( _First );
 }
#line 2742
template < class _FwdIt,
 class _Ty > inline
 _FwdIt lower_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {

 return ( _Rechecked ( _First,
  _Lower_bound ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val,
   _Dist_type ( _First ) ) ) );
 }
#line 2753
template < class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr > inline
 _FwdIt _Lower_bound ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred, _Diff * )
 {
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );
 for (; 0 < _Count; )
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  :: std :: advance ( _Mid, _Count2 );

  if ( _Pred ( * _Mid, _Val ) )

   {
   _First = ++ _Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }
 return ( _First );
 }
#line 2780
template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 _FwdIt lower_bound ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred )
 {

 return ( _Rechecked ( _First,
  _Lower_bound ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val, _Pred,
   _Dist_type ( _First ) ) ) );
 }
#line 2793
template < class _FwdIt,
 class _Ty,
 class _Diff > inline
 _FwdIt _Upper_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val, _Diff * )
 {
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );
 for (; 0 < _Count; )
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  :: std :: advance ( _Mid, _Count2 );

  if ( ! ( _Val < * _Mid ) )

   {
   _First = ++ _Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }
 return ( _First );
 }
#line 2818
template < class _FwdIt,
 class _Ty > inline
 _FwdIt upper_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {

 return ( _Rechecked ( _First,
  _Upper_bound ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val,
   _Dist_type ( _First ) ) ) );
 }
#line 2829
template < class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr > inline
 _FwdIt _Upper_bound ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred, _Diff * )
 {
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );
 for (; 0 < _Count; )
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  :: std :: advance ( _Mid, _Count2 );

  if ( ! _Pred ( _Val, * _Mid ) )

   {
   _First = ++ _Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }
 return ( _First );
 }
#line 2856
template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 _FwdIt upper_bound ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred )
 {

 return ( _Rechecked ( _First,
  _Upper_bound ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val, _Pred,
   _Dist_type ( _First ) ) ) );
 }
#line 2869
template < class _FwdIt,
 class _Ty,
 class _Diff > inline
 :: std :: pair < _FwdIt, _FwdIt >
  _Equal_range ( _FwdIt _First, _FwdIt _Last,
   const _Ty & _Val, _Diff * )
 {
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );

 for (; 0 < _Count; )
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  :: std :: advance ( _Mid, _Count2 );

  if ( ( ( * _Mid ) < ( _Val ) ) )
   {
   _First = ++ _Mid;
   _Count -= _Count2 + 1;
   }
  else if ( _Val < * _Mid )
   _Count = _Count2;
  else
   {
   _FwdIt _First2 = :: std :: lower_bound ( _First, _Mid, _Val );
   :: std :: advance ( _First, _Count );
   _FwdIt _Last2 = :: std :: upper_bound ( ++ _Mid, _First, _Val );
   return ( pair < _FwdIt, _FwdIt > ( _First2, _Last2 ) );
   }
  }

 return ( pair < _FwdIt, _FwdIt > ( _First, _First ) );
 }
#line 2904
template < class _FwdIt,
 class _Ty > inline
 :: std :: pair < _FwdIt, _FwdIt >
  equal_range ( _FwdIt _First, _FwdIt _Last,
   const _Ty & _Val )
 {
 ;
 :: std :: pair < typename _Get_unchecked_type < _FwdIt > :: type, typename _Get_unchecked_type < _FwdIt > :: type > _Ans (
  _Equal_range ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Val, _Dist_type ( _First ) ) );
 return ( :: std :: pair < _FwdIt, _FwdIt > (
  _Rechecked ( _First, _Ans . first ),
  _Rechecked ( _Last, _Ans . second ) ) );
 }
#line 2920
template < class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr > inline
 :: std :: pair < _FwdIt, _FwdIt >
  _Equal_range ( _FwdIt _First, _FwdIt _Last,
   const _Ty & _Val, _Pr _Pred, _Diff * )
 {
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );

 for (; 0 < _Count; )
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  :: std :: advance ( _Mid, _Count2 );

  if ( _Pred ( * _Mid, _Val ) )
   {
   _First = ++ _Mid;
   _Count -= _Count2 + 1;
   }
  else if ( _Pred ( _Val, * _Mid ) )
   _Count = _Count2;
  else
   {
   _FwdIt _First2 = :: std :: lower_bound ( _First, _Mid, _Val, _Pred );
   :: std :: advance ( _First, _Count );
   _FwdIt _Last2 = :: std :: upper_bound ( ++ _Mid, _First, _Val, _Pred );
   return ( pair < _FwdIt, _FwdIt > ( _First2, _Last2 ) );
   }
  }

 return ( pair < _FwdIt, _FwdIt > ( _First, _First ) );
 }
#line 2956
template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 :: std :: pair < _FwdIt, _FwdIt >
  equal_range ( _FwdIt _First, _FwdIt _Last,
   const _Ty & _Val, _Pr _Pred )
 {
 ;
 :: std :: pair < typename _Get_unchecked_type < _FwdIt > :: type, typename _Get_unchecked_type < _FwdIt > :: type > _Ans (
  _Equal_range ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Val, _Pred, _Dist_type ( _First ) ) );
 return ( :: std :: pair < _FwdIt, _FwdIt > (
  _Rechecked ( _First, _Ans . first ),
  _Rechecked ( _Last, _Ans . second ) ) );
 }
#line 2973
template < class _FwdIt,
 class _Ty > inline
 bool binary_search ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 _First = :: std :: lower_bound ( _First, _Last, _Val );
 return ( _First != _Last && ! ( _Val < * _First ) );
 }
#line 2982
template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 bool binary_search ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred )
 {
 _First = :: std :: lower_bound ( _First, _Last, _Val, _Pred );
 return ( _First != _Last && ! _Pred ( _Val, * _First ) );
 }
#line 2993
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt _Merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _Dest )
  if ( ( ( * _First2 ) < ( * _First1 ) ) )
   {
   * _Dest = _Move ( * _First2 );
   ++ _First2;
   }
  else
   {
   * _Dest = _Move ( * _First1 );
   ++ _First1;
   }

 _Dest = _Move ( _First1, _Last1, _Dest );
 return ( _Move ( _First2, _Last2, _Dest ) );
 }
#line 3017
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest )
 {
 return ( _Merge ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Dest ) );
 }
#line 3118 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _Dest )
  if ( _Pred ( * _First2, * _First1 ) )
   {
   * _Dest = _Move ( * _First2 );
   ++ _First2;
   }
  else
   {
   * _Dest = _Move ( * _First1 );
   ++ _First1;
   }

 _Dest = _Move ( _First1, _Last1, _Dest );
 return ( _Move ( _First2, _Last2, _Dest ) );
 }
#line 3143
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred )
 {
 return ( _Merge ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Dest, _Pred ) );
 }
#line 3252 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _BidIt,
 class _Diff,
 class _Ty > inline
 _BidIt _Buffered_rotate ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff _Count1, _Diff _Count2, _Temp_iterator < _Ty > & _Tempbuf )
 {
 if ( _Count1 <= _Count2 && _Count1 <= _Tempbuf . _Maxlen ( ) )
  {
  _Move ( _First, _Mid, _Tempbuf . _Init ( ) );
  _Move ( _Mid, _Last, _First );
  return ( _Move_backward ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ),
   _Last ) );
  }
 else if ( _Count2 <= _Tempbuf . _Maxlen ( ) )
  {
  _Move ( _Mid, _Last, _Tempbuf . _Init ( ) );
  _Move_backward ( _First, _Mid, _Last );
  return ( _Move ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _First ) );
  }
 else
  {
  :: std :: rotate ( _First, _Mid, _Last );
  :: std :: advance ( _First, _Count2 );
  return ( _First );
  }
 }
#line 3279
template < class _BidIt1,
 class _BidIt2,
 class _BidIt3 > inline
 _BidIt3 _Merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest )
 {
 for (;; )
  if ( _First1 == _Last1 )
   return ( _Move_backward ( _First2, _Last2, _Dest ) );
  else if ( _First2 == _Last2 )
   return ( _Move_backward ( _First1, _Last1, _Dest ) );
  else if ( ( ( * -- _Last2 ) < ( * -- _Last1 ) ) )
   {
   * -- _Dest = _Move ( * _Last1 );
   ++ _Last2;
   }
  else
   {
   * -- _Dest = _Move ( * _Last2 );
   ++ _Last1;
   }
 }
#line 3302
template < class _BidIt,
 class _Diff,
 class _Ty > inline
 void _Buffered_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff _Count1, _Diff _Count2,
   _Temp_iterator < _Ty > & _Tempbuf )
 {
 if ( _Count1 + _Count2 == 2 )
  {
  if ( ( ( * _Mid ) < ( * _First ) ) )
   :: std :: iter_swap ( _First, _Mid );
  }
 else if ( _Count1 <= _Count2 && _Count1 <= _Tempbuf . _Maxlen ( ) )
  {
  _Move ( _First, _Mid, _Tempbuf . _Init ( ) );
  _Merge ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _Mid, _Last, _First );
  }
 else if ( _Count2 <= _Tempbuf . _Maxlen ( ) )
  {
  _Move ( _Mid, _Last, _Tempbuf . _Init ( ) );
  _Merge_backward ( _First, _Mid,
   _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _Last );
  }
 else
  {
  _BidIt _Firstn, _Lastn;
  _Diff _Count1n, _Count2n;

  if ( _Count2 < _Count1 )
   {
   _Count1n = _Count1 / 2, _Count2n = 0;
   _Firstn = _First;
   :: std :: advance ( _Firstn, _Count1n );
   _Lastn = :: std :: lower_bound ( _Mid, _Last, * _Firstn );
   _Distance ( _Mid, _Lastn, _Count2n );
   }
  else
   {
   _Count1n = 0, _Count2n = _Count2 / 2;
   _Lastn = _Mid;
   :: std :: advance ( _Lastn, _Count2n );
   _Firstn = :: std :: upper_bound ( _First, _Mid, * _Lastn );
   _Distance ( _First, _Firstn, _Count1n );
   }

  _BidIt _Midn = _Buffered_rotate ( _Firstn, _Mid, _Lastn,
   _Count1 - _Count1n, _Count2n, _Tempbuf );
  _Buffered_merge ( _First, _Firstn, _Midn,
   _Count1n, _Count2n, _Tempbuf );
  _Buffered_merge ( _Midn, _Lastn, _Last,
   _Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf );
  }
 }
#line 3356
template < class _BidIt,
 class _Diff,
 class _Ty > inline
 void _Inplace_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff *, _Ty * )
 {
 _Diff _Count1 = 0;
 _Distance ( _First, _Mid, _Count1 );
 _Diff _Count2 = 0;
 _Distance ( _Mid, _Last, _Count2 );
 _Temp_iterator < _Ty > _Tempbuf ( _Count1 < _Count2 ? _Count1 : _Count2 );
 _Buffered_merge ( _First, _Mid, _Last,
  _Count1, _Count2, _Tempbuf );
 }
#line 3371
template < class _BidIt > inline
 void inplace_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last )
 {
 ;
 ;
 if ( _First != _Mid && _Mid != _Last )
  _Inplace_merge (
   _Unchecked ( _First ), _Unchecked ( _Mid ), _Unchecked ( _Last ),
   _Dist_type ( _First ), _Val_type ( _First ) );
 }
#line 3383
template < class _BidIt1,
 class _BidIt2,
 class _BidIt3,
 class _Pr > inline
 _BidIt3 _Merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred )
 {
 for (;; )
  if ( _First1 == _Last1 )
   return ( _Move_backward ( _First2, _Last2, _Dest ) );
  else if ( _First2 == _Last2 )
   return ( _Move_backward ( _First1, _Last1, _Dest ) );
  else if ( _Pred ( * -- _Last2, * -- _Last1 ) )
   {
   * -- _Dest = _Move ( * _Last1 );
   ++ _Last2;
   }
  else
   {
   * -- _Dest = _Move ( * _Last2 );
   ++ _Last1;
   }
 }
#line 3407
template < class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Buffered_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff _Count1, _Diff _Count2,
   _Temp_iterator < _Ty > & _Tempbuf, _Pr _Pred )
 {
 if ( _Count1 + _Count2 == 2 )
  {
  if ( _Pred ( * _Mid, * _First ) )
   :: std :: iter_swap ( _First, _Mid );
  }
 else if ( _Count1 <= _Count2 && _Count1 <= _Tempbuf . _Maxlen ( ) )
  {
  _Move ( _First, _Mid, _Tempbuf . _Init ( ) );
  _Merge ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ),
   _Mid, _Last, _First, _Pred );
  }
 else if ( _Count2 <= _Tempbuf . _Maxlen ( ) )
  {
  _Move ( _Mid, _Last, _Tempbuf . _Init ( ) );
  _Merge_backward ( _First, _Mid,
   _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _Last, _Pred );
  }
 else
  {
  _BidIt _Firstn, _Lastn;
  _Diff _Count1n, _Count2n;
  if ( _Count2 < _Count1 )
   {
   _Count1n = _Count1 / 2, _Count2n = 0;
   _Firstn = _First;
   :: std :: advance ( _Firstn, _Count1n );
   _Lastn = :: std :: lower_bound ( _Mid, _Last, * _Firstn, _Pred );
   _Distance ( _Mid, _Lastn, _Count2n );
   }
  else
   {
   _Count1n = 0, _Count2n = _Count2 / 2;
   _Lastn = _Mid;
   :: std :: advance ( _Lastn, _Count2n );
   _Firstn = :: std :: upper_bound ( _First, _Mid, * _Lastn, _Pred );
   _Distance ( _First, _Firstn, _Count1n );
   }
  _BidIt _Midn = _Buffered_rotate ( _Firstn, _Mid, _Lastn,
   _Count1 - _Count1n, _Count2n, _Tempbuf );
  _Buffered_merge ( _First, _Firstn, _Midn,
   _Count1n, _Count2n, _Tempbuf, _Pred );
  _Buffered_merge ( _Midn, _Lastn, _Last,
   _Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred );
  }
 }
#line 3461
template < class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Inplace_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
  _Diff *, _Ty * )
 {
 _Diff _Count1 = 0;
 _Distance ( _First, _Mid, _Count1 );
 _Diff _Count2 = 0;
 _Distance ( _Mid, _Last, _Count2 );
 _Temp_iterator < _Ty > _Tempbuf ( _Count1 < _Count2 ? _Count1 : _Count2 );
 _Buffered_merge ( _First, _Mid, _Last,
  _Count1, _Count2, _Tempbuf, _Pred );
 }
#line 3477
template < class _BidIt,
 class _Pr > inline
 void inplace_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred )
 {
 ;
 ;
 if ( _First != _Mid && _Mid != _Last )
  _Inplace_merge (
   _Unchecked ( _First ), _Unchecked ( _Mid ), _Unchecked ( _Last ), _Pred,
   _Dist_type ( _First ), _Val_type ( _First ) );
 }
#line 3490
template < class _BidIt,
 class _Ty > inline
 void _Insertion_sort1 ( _BidIt _First, _BidIt _Last, _Ty * )
 {
 if ( _First != _Last )
  for ( _BidIt _Next = _First; ++ _Next != _Last; )
   {
   _BidIt _Next1 = _Next;
   _Ty _Val = _Move ( * _Next );

   if ( ( ( _Val ) < ( * _First ) ) )
    {
    _Move_backward ( _First, _Next, ++ _Next1 );
    * _First = _Move ( _Val );
    }
   else
    {
    for ( _BidIt _First1 = _Next1;
     ( ( _Val ) < ( * -- _First1 ) );
     _Next1 = _First1 )
     * _Next1 = _Move ( * _First1 );
    * _Next1 = _Move ( _Val );
    }
   }
 }
#line 3516
template < class _BidIt > inline
 void _Insertion_sort ( _BidIt _First, _BidIt _Last )
 {
 _Insertion_sort1 ( _First, _Last, _Val_type ( _First ) );
 }
#line 3522
template < class _RanIt > inline
 void _Med3 ( _RanIt _First, _RanIt _Mid, _RanIt _Last )
 {
 if ( ( ( * _Mid ) < ( * _First ) ) )
  :: std :: iter_swap ( _Mid, _First );
 if ( ( ( * _Last ) < ( * _Mid ) ) )
  :: std :: iter_swap ( _Last, _Mid );
 if ( ( ( * _Mid ) < ( * _First ) ) )
  :: std :: iter_swap ( _Mid, _First );
 }
#line 3533
template < class _RanIt > inline
 void _Median ( _RanIt _First, _RanIt _Mid, _RanIt _Last )
 {
 if ( 40 < _Last - _First )
  {
  size_t _Step = ( _Last - _First + 1 ) / 8;
  _Med3 ( _First, _First + _Step, _First + 2 * _Step );
  _Med3 ( _Mid - _Step, _Mid, _Mid + _Step );
  _Med3 ( _Last - 2 * _Step, _Last - _Step, _Last );
  _Med3 ( _First + _Step, _Mid, _Last - _Step );
  }
 else
  _Med3 ( _First, _Mid, _Last );
 }
#line 3548
template < class _RanIt > inline
 :: std :: pair < _RanIt, _RanIt >
  _Unguarded_partition ( _RanIt _First, _RanIt _Last )
 {
 _RanIt _Mid = _First + ( _Last - _First ) / 2;
 _Median ( _First, _Mid, _Last - 1 );
 _RanIt _Pfirst = _Mid;
 _RanIt _Plast = _Pfirst + 1;

 while ( _First < _Pfirst
  && ! ( ( * ( _Pfirst - 1 ) ) < ( * _Pfirst ) )
  && ! ( * _Pfirst < * ( _Pfirst - 1 ) ) )
  -- _Pfirst;
 while ( _Plast < _Last
  && ! ( ( * _Plast ) < ( * _Pfirst ) )
  && ! ( * _Pfirst < * _Plast ) )
  ++ _Plast;

 _RanIt _Gfirst = _Plast;
 _RanIt _Glast = _Pfirst;

 for (;; )
  {
  for (; _Gfirst < _Last; ++ _Gfirst )
   if ( ( ( * _Pfirst ) < ( * _Gfirst ) ) )
    ;
   else if ( * _Gfirst < * _Pfirst )
    break;
   else
    :: std :: iter_swap ( _Plast ++, _Gfirst );
  for (; _First < _Glast; -- _Glast )
   if ( ( ( * ( _Glast - 1 ) ) < ( * _Pfirst ) ) )
    ;
   else if ( * _Pfirst < * ( _Glast - 1 ) )
    break;
   else
    :: std :: iter_swap ( -- _Pfirst, _Glast - 1 );
  if ( _Glast == _First && _Gfirst == _Last )
   return ( :: std :: pair < _RanIt, _RanIt > ( _Pfirst, _Plast ) );

  if ( _Glast == _First )
   {
   if ( _Plast != _Gfirst )
    :: std :: iter_swap ( _Pfirst, _Plast );
   ++ _Plast;
   :: std :: iter_swap ( _Pfirst ++, _Gfirst ++ );
   }
  else if ( _Gfirst == _Last )
   {
   if ( -- _Glast != -- _Pfirst )
    :: std :: iter_swap ( _Glast, _Pfirst );
   :: std :: iter_swap ( _Pfirst, -- _Plast );
   }
  else
   :: std :: iter_swap ( _Gfirst ++, -- _Glast );
  }
 }
#line 3606
template < class _RanIt,
 class _Diff > inline
 void _Sort ( _RanIt _First, _RanIt _Last, _Diff _Ideal )
 {
 _Diff _Count;
 for (; _ISORT_MAX < ( _Count = _Last - _First ) && 0 < _Ideal; )
  {
  :: std :: pair < _RanIt, _RanIt > _Mid =
   _Unguarded_partition ( _First, _Last );
  _Ideal /= 2, _Ideal += _Ideal / 2;

  if ( _Mid . first - _First < _Last - _Mid . second )
   {
   _Sort ( _First, _Mid . first, _Ideal );
   _First = _Mid . second;
   }
  else
   {
   _Sort ( _Mid . second, _Last, _Ideal );
   _Last = _Mid . first;
   }
  }

 if ( _ISORT_MAX < _Count )
  {
  :: std :: make_heap ( _First, _Last );
  :: std :: sort_heap ( _First, _Last );
  }
 else if ( 1 < _Count )
  _Insertion_sort ( _First, _Last );
 }
#line 3638
template < class _RanIt > inline
 void sort ( _RanIt _First, _RanIt _Last )
 {
 ;
 _Sort ( _Unchecked ( _First ), _Unchecked ( _Last ), _Last - _First );
 }
#line 3646
template < class _BidIt,
 class _Pr,
 class _Ty > inline
 void _Insertion_sort1 ( _BidIt _First, _BidIt _Last, _Pr _Pred, _Ty * )
 {
 if ( _First != _Last )
  for ( _BidIt _Next = _First; ++ _Next != _Last; )
   {
   _BidIt _Next1 = _Next;
   _Ty _Val = _Move ( * _Next );

   if ( _Pred ( _Val, * _First ) )
    {
    _Move_backward ( _First, _Next, ++ _Next1 );
    * _First = _Move ( _Val );
    }
   else
    {
    for ( _BidIt _First1 = _Next1;
     _Pred ( _Val, * -- _First1 );
     _Next1 = _First1 )
     * _Next1 = _Move ( * _First1 );
    * _Next1 = _Move ( _Val );
    }
   }
 }
#line 3673
template < class _BidIt,
 class _Pr > inline
 void _Insertion_sort ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 _Insertion_sort1 ( _First, _Last, _Pred, _Val_type ( _First ) );
 }
#line 3680
template < class _RanIt,
 class _Pr > inline
 void _Med3 ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred )
 {
 if ( _Pred ( * _Mid, * _First ) )
  :: std :: iter_swap ( _Mid, _First );
 if ( _Pred ( * _Last, * _Mid ) )
  :: std :: iter_swap ( _Last, _Mid );
 if ( _Pred ( * _Mid, * _First ) )
  :: std :: iter_swap ( _Mid, _First );
 }
#line 3692
template < class _RanIt,
 class _Pr > inline
 void _Median ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred )
 {
 if ( 40 < _Last - _First )
  {
  size_t _Step = ( _Last - _First + 1 ) / 8;
  _Med3 ( _First, _First + _Step, _First + 2 * _Step, _Pred );
  _Med3 ( _Mid - _Step, _Mid, _Mid + _Step, _Pred );
  _Med3 ( _Last - 2 * _Step, _Last - _Step, _Last, _Pred );
  _Med3 ( _First + _Step, _Mid, _Last - _Step, _Pred );
  }
 else
  _Med3 ( _First, _Mid, _Last, _Pred );
 }
#line 3708
template < class _RanIt,
 class _Pr > inline
 :: std :: pair < _RanIt, _RanIt >
  _Unguarded_partition ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 _RanIt _Mid = _First + ( _Last - _First ) / 2;
 _Median ( _First, _Mid, _Last - 1, _Pred );
 _RanIt _Pfirst = _Mid;
 _RanIt _Plast = _Pfirst + 1;

 while ( _First < _Pfirst
  && ! _Pred ( * ( _Pfirst - 1 ), * _Pfirst )
  && ! _Pred ( * _Pfirst, * ( _Pfirst - 1 ) ) )
  -- _Pfirst;
 while ( _Plast < _Last
  && ! _Pred ( * _Plast, * _Pfirst )
  && ! _Pred ( * _Pfirst, * _Plast ) )
  ++ _Plast;

 _RanIt _Gfirst = _Plast;
 _RanIt _Glast = _Pfirst;

 for (;; )
  {
  for (; _Gfirst < _Last; ++ _Gfirst )
   if ( _Pred ( * _Pfirst, * _Gfirst ) )
    ;
   else if ( _Pred ( * _Gfirst, * _Pfirst ) )
    break;
   else
    :: std :: iter_swap ( _Plast ++, _Gfirst );
  for (; _First < _Glast; -- _Glast )
   if ( _Pred ( * ( _Glast - 1 ), * _Pfirst ) )
    ;
   else if ( _Pred ( * _Pfirst, * ( _Glast - 1 ) ) )
    break;
   else
    :: std :: iter_swap ( -- _Pfirst, _Glast - 1 );
  if ( _Glast == _First && _Gfirst == _Last )
   return ( :: std :: pair < _RanIt, _RanIt > ( _Pfirst, _Plast ) );

  if ( _Glast == _First )
   {
   if ( _Plast != _Gfirst )
    :: std :: iter_swap ( _Pfirst, _Plast );
   ++ _Plast;
   :: std :: iter_swap ( _Pfirst ++, _Gfirst ++ );
   }
  else if ( _Gfirst == _Last )
   {
   if ( -- _Glast != -- _Pfirst )
    :: std :: iter_swap ( _Glast, _Pfirst );
   :: std :: iter_swap ( _Pfirst, -- _Plast );
   }
  else
   :: std :: iter_swap ( _Gfirst ++, -- _Glast );
  }
 }
#line 3767
template < class _RanIt,
 class _Diff,
 class _Pr > inline
 void _Sort ( _RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr _Pred )
 {
 _Diff _Count;
 for (; _ISORT_MAX < ( _Count = _Last - _First ) && 0 < _Ideal; )
  {
  :: std :: pair < _RanIt, _RanIt > _Mid =
   _Unguarded_partition ( _First, _Last, _Pred );
  _Ideal /= 2, _Ideal += _Ideal / 2;

  if ( _Mid . first - _First < _Last - _Mid . second )
   {
   _Sort ( _First, _Mid . first, _Ideal, _Pred );
   _First = _Mid . second;
   }
  else
   {
   _Sort ( _Mid . second, _Last, _Ideal, _Pred );
   _Last = _Mid . first;
   }
  }

 if ( _ISORT_MAX < _Count )
  {
  :: std :: make_heap ( _First, _Last, _Pred );
  :: std :: sort_heap ( _First, _Last, _Pred );
  }
 else if ( 1 < _Count )
  _Insertion_sort ( _First, _Last, _Pred );
 }
#line 3800
template < class _RanIt,
 class _Pr > inline
 void sort ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 ;
 ;
 _Sort ( _Unchecked ( _First ), _Unchecked ( _Last ), _Last - _First, _Pred );
 }
#line 3810
template < class _BidIt,
 class _OutIt,
 class _Diff > inline
 void _Chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count )
 {
 for ( _Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2 )
  {
  _BidIt _Mid1 = _First;
  :: std :: advance ( _Mid1, _Chunk );
  _BidIt _Mid2 = _Mid1;
  :: std :: advance ( _Mid2, _Chunk );

  _Dest = _Merge ( _First, _Mid1, _Mid1, _Mid2, _Dest );
  _First = _Mid2;
  }

 if ( _Count <= _Chunk )
  _Move ( _First, _Last, _Dest );
 else
  {
  _BidIt _Mid = _First;
  :: std :: advance ( _Mid, _Chunk );

  _Merge ( _First, _Mid, _Mid, _Last, _Dest );
  }
 }
#line 3838
template < class _BidIt,
 class _Diff,
 class _Ty > inline
 void _Buffered_merge_sort ( _BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator < _Ty > & _Tempbuf )
 {
 _BidIt _Mid = _First;
 for ( _Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX )
  {
  _BidIt _Midend = _Mid;
  :: std :: advance ( _Midend, ( int ) _ISORT_MAX );

  _Insertion_sort ( _Mid, _Midend );
  _Mid = _Midend;
  }
 _Insertion_sort ( _Mid, _Last );

 for ( _Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2 )
  {
  _Chunked_merge ( _First, _Last, _Tempbuf . _Init ( ),
   _Chunk, _Count );
  _Chunked_merge ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _First,
   _Chunk *= 2, _Count );
  }
 }
#line 3864
template < class _BidIt,
 class _Diff,
 class _Ty > inline
 void _Stable_sort ( _BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator < _Ty > & _Tempbuf )
 {
 if ( _Count <= _ISORT_MAX )
  _Insertion_sort ( _First, _Last );
 else
  {
  _Diff _Count2 = ( _Count + 1 ) / 2;
  _BidIt _Mid = _First;
  :: std :: advance ( _Mid, _Count2 );

  if ( _Count2 <= _Tempbuf . _Maxlen ( ) )
   {
   _Buffered_merge_sort ( _First, _Mid, _Count2, _Tempbuf );
   _Buffered_merge_sort ( _Mid, _Last, _Count - _Count2, _Tempbuf );
   }
  else
   {
   _Stable_sort ( _First, _Mid, _Count2, _Tempbuf );
   _Stable_sort ( _Mid, _Last, _Count - _Count2, _Tempbuf );
   }

  _Buffered_merge ( _First, _Mid, _Last,
   _Count2, _Count - _Count2, _Tempbuf );
  }
 }
#line 3894
template < class _BidIt,
 class _Diff,
 class _Ty > inline
 void _Stable_sort ( _BidIt _First, _BidIt _Last, _Diff *, _Ty * )
 {
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );
 _Temp_iterator < _Ty > _Tempbuf ( ( _Count + 1 ) / 2 );
 _Stable_sort ( _First, _Last, _Count, _Tempbuf );
 }
#line 3905
template < class _BidIt > inline
 void stable_sort ( _BidIt _First, _BidIt _Last )
 {
 ;
 if ( _First != _Last )
  _Stable_sort ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dist_type ( _First ), _Val_type ( _First ) );
 }
#line 3915
template < class _BidIt,
 class _OutIt,
 class _Diff,
 class _Pr > inline
 void _Chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count, _Pr _Pred )
 {
 for ( _Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2 )
  {
  _BidIt _Mid1 = _First;
  :: std :: advance ( _Mid1, _Chunk );
  _BidIt _Mid2 = _Mid1;
  :: std :: advance ( _Mid2, _Chunk );

  _Dest = _Merge ( _First, _Mid1, _Mid1, _Mid2, _Dest, _Pred );
  _First = _Mid2;
  }

 if ( _Count <= _Chunk )
  _Move ( _First, _Last, _Dest );
 else
  {
  _BidIt _Mid1 = _First;
  :: std :: advance ( _Mid1, _Chunk );

  _Merge ( _First, _Mid1, _Mid1, _Last, _Dest, _Pred );
  }
 }
#line 3944
template < class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Buffered_merge_sort ( _BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator < _Ty > & _Tempbuf, _Pr _Pred )
 {
 _BidIt _Mid = _First;
 for ( _Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX )
  {
  _BidIt _Midn = _Mid;
  :: std :: advance ( _Midn, ( int ) _ISORT_MAX );

  _Insertion_sort ( _Mid, _Midn, _Pred );
  _Mid = _Midn;
  }
 _Insertion_sort ( _Mid, _Last, _Pred );

 for ( _Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2 )
  {
  _Chunked_merge ( _First, _Last, _Tempbuf . _Init ( ),
   _Chunk, _Count, _Pred );
  _Chunked_merge ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _First,
   _Chunk *= 2, _Count, _Pred );
  }
 }
#line 3971
template < class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Stable_sort ( _BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator < _Ty > & _Tempbuf, _Pr _Pred )
 {
 if ( _Count <= _ISORT_MAX )
  _Insertion_sort ( _First, _Last, _Pred );
 else
  {
  _Diff _Count2 = ( _Count + 1 ) / 2;
  _BidIt _Mid = _First;
  :: std :: advance ( _Mid, _Count2 );

  if ( _Count2 <= _Tempbuf . _Maxlen ( ) )
   {
   _Buffered_merge_sort ( _First, _Mid, _Count2, _Tempbuf, _Pred );
   _Buffered_merge_sort ( _Mid, _Last, _Count - _Count2,
    _Tempbuf, _Pred );
   }
  else
   {
   _Stable_sort ( _First, _Mid, _Count2, _Tempbuf, _Pred );
   _Stable_sort ( _Mid, _Last, _Count - _Count2, _Tempbuf, _Pred );
   }

  _Buffered_merge ( _First, _Mid, _Last,
   _Count2, _Count - _Count2, _Tempbuf, _Pred );
  }
 }
#line 4003
template < class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Stable_sort ( _BidIt _First, _BidIt _Last, _Diff *, _Ty *, _Pr _Pred )
 {
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );
 _Temp_iterator < _Ty > _Tempbuf ( ( _Count + 1 ) / 2 );
 _Stable_sort ( _First, _Last, _Count, _Tempbuf, _Pred );
 }
#line 4015
template < class _BidIt,
 class _Pr > inline
 void stable_sort ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 ;
 ;
 if ( _First != _Last )
  _Stable_sort ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dist_type ( _First ), _Val_type ( _First ), _Pred );
 }
#line 4027
template < class _RanIt,
 class _Ty > inline
 void _Partial_sort ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Ty * )
 {
 ;
 ;
 :: std :: make_heap ( _First, _Mid );

 for ( _RanIt _Next = _Mid; _Next < _Last; ++ _Next )
  if ( ( ( * _Next ) < ( * _First ) ) )
   {
   _Ty _Val = _Move ( * _Next );
   _Pop_heap ( _First, _Mid, _Next, _Move ( _Val ),
    _Dist_type ( _First ) );
   }
 :: std :: sort_heap ( _First, _Mid );
 }
#line 4045
template < class _RanIt > inline
 void partial_sort ( _RanIt _First, _RanIt _Mid, _RanIt _Last )
 {
 _Partial_sort (
  _Unchecked ( _First ), _Unchecked ( _Mid ), _Unchecked ( _Last ),
  _Val_type ( _First ) );
 }
#line 4054
template < class _RanIt,
 class _Ty,
 class _Pr > inline
 void _Partial_sort ( _RanIt _First, _RanIt _Mid, _RanIt _Last,
  _Pr _Pred, _Ty * )
 {
 ;
 ;
 ;
 :: std :: make_heap ( _First, _Mid, _Pred );

 for ( _RanIt _Next = _Mid; _Next < _Last; ++ _Next )
  if ( _Pred ( * _Next, * _First ) )
   {
   _Ty _Val = _Move ( * _Next );
   _Pop_heap ( _First, _Mid, _Next, _Move ( _Val ), _Pred,
    _Dist_type ( _First ) );
   }
 :: std :: sort_heap ( _First, _Mid, _Pred );
 }
#line 4075
template < class _RanIt,
 class _Pr > inline
 void partial_sort ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred )
 {
 _Partial_sort (
  _Unchecked ( _First ), _Unchecked ( _Mid ), _Unchecked ( _Last ), _Pred,
  _Val_type ( _First ) );
 }
#line 4085
template < class _InIt,
 class _RanIt,
 class _Diff,
 class _Ty > inline
 _RanIt _Partial_sort_copy ( _InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2, _Diff *, _Ty * )
 {
 _RanIt _Mid2 = _First2;
 for (; _First1 != _Last1 && _Mid2 != _Last2; ++ _First1, ++ _Mid2 )
  * _Mid2 = * _First1;
 :: std :: make_heap ( _First2, _Mid2 );

 for (; _First1 != _Last1; ++ _First1 )
  if ( ( ( * _First1 ) < ( * _First2 ) ) )
   _Adjust_heap ( _First2, _Diff ( 0 ), _Diff ( _Mid2 - _First2 ),
    _Ty ( * _First1 ) );

 :: std :: sort_heap ( _First2, _Mid2 );
 return ( _Mid2 );
 }
#line 4106
template < class _InIt,
 class _RanIt > inline
 _RanIt partial_sort_copy ( _InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2 )
 {
 ;
 ;
 return ( _First1 == _Last1 || _First2 == _Last2 ? _First2
  : _Rechecked ( _First2,
   _Partial_sort_copy (
    _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
    _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
    _Dist_type ( _First2 ), _Val_type ( _First1 ) ) ) );
 }
#line 4122
template < class _InIt,
 class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 _RanIt _Partial_sort_copy ( _InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2, _Pr _Pred, _Diff *, _Ty * )
 {
 _RanIt _Mid2 = _First2;
 for (; _First1 != _Last1 && _Mid2 != _Last2; ++ _First1, ++ _Mid2 )
  * _Mid2 = * _First1;
 :: std :: make_heap ( _First2, _Mid2, _Pred );

 for (; _First1 != _Last1; ++ _First1 )
  if ( _Pred ( * _First1, * _First2 ) )
   _Adjust_heap ( _First2, _Diff ( 0 ), _Diff ( _Mid2 - _First2 ),
    _Ty ( * _First1 ), _Pred );

 :: std :: sort_heap ( _First2, _Mid2, _Pred );
 return ( _Mid2 );
 }
#line 4144
template < class _InIt,
 class _RanIt,
 class _Pr > inline
 _RanIt partial_sort_copy ( _InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2, _Pr _Pred )
 {
 ;
 ;
 ;
 return ( _First1 == _Last1 || _First2 == _Last2 ? _First2
  : _Rechecked ( _First2,
   _Partial_sort_copy (
    _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
    _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred,
    _Dist_type ( _First2 ), _Val_type ( _First1 ) ) ) );
 }
#line 4162
template < class _RanIt > inline
 void _Nth_element ( _RanIt _First, _RanIt _Nth, _RanIt _Last )
 {
 for (; _ISORT_MAX < _Last - _First; )
  {
  :: std :: pair < _RanIt, _RanIt > _Mid =
   _Unguarded_partition ( _First, _Last );

  if ( _Mid . second <= _Nth )
   _First = _Mid . second;
  else if ( _Mid . first <= _Nth )
   return;
  else
   _Last = _Mid . first;
  }

 _Insertion_sort ( _First, _Last );
 }
#line 4181
template < class _RanIt > inline
 void nth_element ( _RanIt _First, _RanIt _Nth, _RanIt _Last )
 {
 ;
 _Nth_element (
  _Unchecked ( _First ), _Unchecked ( _Nth ), _Unchecked ( _Last ) );
 }
#line 4190
template < class _RanIt,
 class _Pr > inline
 void _Nth_element ( _RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred )
 {
 for (; _ISORT_MAX < _Last - _First; )
  {
  :: std :: pair < _RanIt, _RanIt > _Mid =
   _Unguarded_partition ( _First, _Last, _Pred );

  if ( _Mid . second <= _Nth )
   _First = _Mid . second;
  else if ( _Mid . first <= _Nth )
   return;
  else
   _Last = _Mid . first;
  }

 _Insertion_sort ( _First, _Last, _Pred );
 }
#line 4210
template < class _RanIt,
 class _Pr > inline
 void nth_element ( _RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred )
 {
 ;
 ;
 _Nth_element (
  _Unchecked ( _First ), _Unchecked ( _Nth ), _Unchecked ( _Last ), _Pred );
 }
#line 4221
template < class _InIt1,
 class _InIt2 > inline
 bool _Includes ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( ( ( * _First2 ) < ( * _First1 ) ) )
   return ( false );
  else if ( * _First1 < * _First2 )
   ++ _First1;
  else
   {
   ++ _First1;
   ++ _First2;
   }
 return ( _First2 == _Last2 );
 }
#line 4239
template < class _InIt1,
 class _InIt2 > inline
 bool includes ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 ;
 ;
 return ( _Includes ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ) ) );
 }
#line 4251
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Includes ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Pred ( * _First2, * _First1 ) )
   return ( false );
  else if ( _Pred ( * _First1, * _First2 ) )
   ++ _First1;
  else
   {
   ++ _First1;
   ++ _First2;
   }
 return ( _First2 == _Last2 );
 }
#line 4270
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool includes ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 ;
 ;
 return ( _Includes ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred ) );
 }
#line 4283
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt _Set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( ( ( * _First1 ) < ( * _First2 ) ) )
   {
   * _Dest ++ = * _First1;
   ++ _First1;
   }
  else if ( * _First2 < * _First1 )
   {
   * _Dest ++ = * _First2;
   ++ _First2;
   }
  else
   {
   * _Dest ++ = * _First1;
   ++ _First1;
   ++ _First2;
   }
 _Dest = :: std :: copy ( _First1, _Last1, _Dest );
 return ( :: std :: copy ( _First2, _Last2, _Dest ) );
 }
#line 4312
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest )
 {
 return ( _Set_union ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Dest ) );
 }
#line 4380 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Pred ( * _First1, * _First2 ) )
   {
   * _Dest ++ = * _First1;
   ++ _First1;
   }
  else if ( _Pred ( * _First2, * _First1 ) )
   {
   * _Dest ++ = * _First2;
   ++ _First2;
   }
  else
   {
   * _Dest ++ = * _First1;
   ++ _First1;
   ++ _First2;
   }
 _Dest = :: std :: copy ( _First1, _Last1, _Dest );
 return ( :: std :: copy ( _First2, _Last2, _Dest ) );
 }
#line 4409
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return ( _Set_union ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Dest, _Pred ) );
 }
#line 4481 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt _Set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( ( ( * _First1 ) < ( * _First2 ) ) )
   ++ _First1;
  else if ( * _First2 < * _First1 )
   ++ _First2;
  else
   {
   * _Dest ++ = * _First1 ++;
   ++ _First2;
   }
 return ( _Dest );
 }
#line 4501
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return ( _Set_intersection ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Dest ) );
 }
#line 4568 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Pred ( * _First1, * _First2 ) )
   ++ _First1;
  else if ( _Pred ( * _First2, * _First1 ) )
   ++ _First2;
  else
   {
   * _Dest ++ = * _First1 ++;
   ++ _First2;
   }
 return ( _Dest );
 }
#line 4589
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return ( _Set_intersection ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Dest, _Pred ) );
 }
#line 4661 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt _Set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( ( ( * _First1 ) < ( * _First2 ) ) )
   {
   * _Dest ++ = * _First1;
   ++ _First1;
   }
  else if ( * _First2 < * _First1 )
   ++ _First2;
  else
   {
   ++ _First1;
   ++ _First2;
   }
 return ( :: std :: copy ( _First1, _Last1, _Dest ) );
 }
#line 4685
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest )
 {
 return ( _Set_difference ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Dest ) );
 }
#line 4755 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Pred ( * _First1, * _First2 ) )
   {
   * _Dest ++ = * _First1;
   ++ _First1;
   }
  else if ( _Pred ( * _First2, * _First1 ) )
   ++ _First2;
  else
   {
   ++ _First1;
   ++ _First2;
   }
 return ( :: std :: copy ( _First1, _Last1, _Dest ) );
 }
#line 4780
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred )
 {
 return ( _Set_difference ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Dest, _Pred ) );
 }
#line 4855 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt _Set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( ( ( * _First1 ) < ( * _First2 ) ) )
   {
   * _Dest ++ = * _First1;
   ++ _First1;
   }
  else if ( * _First2 < * _First1 )
   {
   * _Dest ++ = * _First2;
   ++ _First2;
   }
  else
   {
   ++ _First1;
   ++ _First2;
   }
 _Dest = :: std :: copy ( _First1, _Last1, _Dest );
 return ( :: std :: copy ( _First2, _Last2, _Dest ) );
 }
#line 4883
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest )
 {
 return ( _Set_symmetric_difference (
  _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Dest ) );
 }
#line 4955 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Pred ( * _First1, * _First2 ) )
   {
   * _Dest ++ = * _First1;
   ++ _First1;
   }
  else if ( _Pred ( * _First2, * _First1 ) )
   {
   * _Dest ++ = * _First2;
   ++ _First2;
   }
  else
   {
   ++ _First1;
   ++ _First2;
   }
 _Dest = :: std :: copy ( _First1, _Last1, _Dest );
 return ( :: std :: copy ( _First2, _Last2, _Dest ) );
 }
#line 4984
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred )
 {
 return ( _Set_symmetric_difference (
  _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Dest, _Pred ) );
 }
#line 5061 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _FwdIt > inline
 _FwdIt _Max_element ( _FwdIt _First, _FwdIt _Last )
 {
 _FwdIt _Found = _First;
 if ( _First != _Last )
  for (; ++ _First != _Last; )
   if ( ( ( * _Found ) < ( * _First ) ) )
    _Found = _First;
 return ( _Found );
 }
#line 5072
template < class _FwdIt > inline
 _FwdIt max_element ( _FwdIt _First, _FwdIt _Last )
 {
 ;
 return ( _Rechecked ( _First,
  _Max_element ( _Unchecked ( _First ), _Unchecked ( _Last ) ) ) );
 }
#line 5081
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Max_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _FwdIt _Found = _First;
 if ( _First != _Last )
  for (; ++ _First != _Last; )
   if ( _Pred ( * _Found, * _First ) )
    _Found = _First;
 return ( _Found );
 }
#line 5093
template < class _FwdIt,
 class _Pr > inline
 _FwdIt max_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Rechecked ( _First,
  _Max_element ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 5104
template < class _FwdIt > inline
 _FwdIt _Min_element ( _FwdIt _First, _FwdIt _Last )
 {
 _FwdIt _Found = _First;
 if ( _First != _Last )
  for (; ++ _First != _Last; )
   if ( ( ( * _First ) < ( * _Found ) ) )
    _Found = _First;
 return ( _Found );
 }
#line 5115
template < class _FwdIt > inline
 _FwdIt min_element ( _FwdIt _First, _FwdIt _Last )
 {
 ;
 return ( _Rechecked ( _First,
  _Min_element ( _Unchecked ( _First ), _Unchecked ( _Last ) ) ) );
 }
#line 5124
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Min_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _FwdIt _Found = _First;
 if ( _First != _Last )
  for (; ++ _First != _Last; )
   if ( _Pred ( * _First, * _Found ) )
    _Found = _First;
 return ( _Found );
 }
#line 5136
template < class _FwdIt,
 class _Pr > inline
 _FwdIt min_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Rechecked ( _First,
  _Min_element ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 5148
template < class _FwdIt > inline
 :: std :: pair < _FwdIt, _FwdIt >
  _Minmax_element ( _FwdIt _First, _FwdIt _Last )
 {
 :: std :: pair < _FwdIt, _FwdIt > _Found ( _First, _First );

 if ( _First != _Last )
  for (; ++ _First != _Last; )
   {
   _FwdIt _Next = _First;
   if ( ++ _Next == _Last )
    {
    if ( ( ( * _First ) < ( * _Found . first ) ) )
     _Found . first = _First;
    else if ( ( ( * _Found . second ) < ( * _First ) ) )
     _Found . second = _First;
    }
   else
    {
    if ( ( ( * _Next ) < ( * _First ) ) )
     {
     if ( ( ( * _Next ) < ( * _Found . first ) ) )
      _Found . first = _Next;
     if ( ( ( * _Found . second ) < ( * _First ) ) )
      _Found . second = _First;
     }
    else
     {
     if ( ( ( * _First ) < ( * _Found . first ) ) )
      _Found . first = _First;
     if ( ( ( * _Found . second ) < ( * _Next ) ) )
      _Found . second = _Next;
     }
    _First = _Next;
    }
   }
 return ( _Found );
 }
#line 5187
template < class _FwdIt > inline
 :: std :: pair < _FwdIt, _FwdIt >
  minmax_element ( _FwdIt _First, _FwdIt _Last )
 {
 ;
 :: std :: pair < typename _Get_unchecked_type < _FwdIt > :: type, typename _Get_unchecked_type < _FwdIt > :: type > _Ans (
  _Minmax_element ( _Unchecked ( _First ), _Unchecked ( _Last ) ) );
 return ( :: std :: pair < _FwdIt, _FwdIt > (
  _Rechecked ( _First, _Ans . first ),
  _Rechecked ( _Last, _Ans . second ) ) );
 }
#line 5200
template < class _FwdIt,
 class _Pr > inline
 :: std :: pair < _FwdIt, _FwdIt >
  _Minmax_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 :: std :: pair < _FwdIt, _FwdIt > _Found ( _First, _First );

 if ( _First != _Last )
  for (; ++ _First != _Last; )
   {
   _FwdIt _Next = _First;
   if ( ++ _Next == _Last )
    {
    if ( _Pred ( * _First, * _Found . first ) )
     _Found . first = _First;
    else if ( _Pred ( * _Found . second, * _First ) )
     _Found . second = _First;
    }
   else
    {
    if ( _Pred ( * _Next, * _First ) )
     {
     if ( _Pred ( * _Next, * _Found . first ) )
      _Found . first = _Next;
     if ( _Pred ( * _Found . second, * _First ) )
      _Found . second = _First;
     }
    else
     {
     if ( _Pred ( * _First, * _Found . first ) )
      _Found . first = _First;
     if ( _Pred ( * _Found . second, * _Next ) )
      _Found . second = _Next;
     }
    _First = _Next;
    }
   }
 return ( _Found );
 }
#line 5240
template < class _FwdIt,
 class _Pr > inline
 :: std :: pair < _FwdIt, _FwdIt >
  minmax_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 ;
 ;
 :: std :: pair < typename _Get_unchecked_type < _FwdIt > :: type, typename _Get_unchecked_type < _FwdIt > :: type > _Ans (
  _Minmax_element ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) );
 return ( :: std :: pair < _FwdIt, _FwdIt > (
  _Rechecked ( _First, _Ans . first ),
  _Rechecked ( _Last, _Ans . second ) ) );
 }
#line 5256 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _BidIt > inline
 bool _Next_permutation ( _BidIt _First, _BidIt _Last )
 {
 _BidIt _Next = _Last;
 if ( _First == _Last || _First == -- _Next )
  return ( false );

 for (;; )
  {
  _BidIt _Next1 = _Next;
  if ( ( ( * -- _Next ) < ( * _Next1 ) ) )
   {
   _BidIt _Mid = _Last;
   for (; ! ( ( * _Next ) < ( * -- _Mid ) ); )
    ;
   :: std :: iter_swap ( _Next, _Mid );
   :: std :: reverse ( _Next1, _Last );
   return ( true );
   }

  if ( _Next == _First )
   {
   :: std :: reverse ( _First, _Last );
   return ( false );
   }
  }
 }
#line 5284
template < class _BidIt > inline
 bool next_permutation ( _BidIt _First, _BidIt _Last )
 {
 ;
 return ( _Next_permutation ( _Unchecked ( _First ), _Unchecked ( _Last ) ) );
 }
#line 5292
template < class _BidIt,
 class _Pr > inline
 bool _Next_permutation ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 _BidIt _Next = _Last;
 if ( _First == _Last || _First == -- _Next )
  return ( false );

 for (;; )
  {
  _BidIt _Next1 = _Next;
  if ( _Pred ( * -- _Next, * _Next1 ) )
   {
   _BidIt _Mid = _Last;
   for (; ! _Pred ( * _Next, * -- _Mid ); )
    ;
   :: std :: iter_swap ( _Next, _Mid );
   :: std :: reverse ( _Next1, _Last );
   return ( true );
   }

  if ( _Next == _First )
   {
   :: std :: reverse ( _First, _Last );
   return ( false );
   }
  }
 }
#line 5321
template < class _BidIt,
 class _Pr > inline
 bool next_permutation ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Next_permutation ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) );
 }
#line 5331
template < class _BidIt > inline
 bool _Prev_permutation ( _BidIt _First, _BidIt _Last )
 {
 _BidIt _Next = _Last;
 if ( _First == _Last || _First == -- _Next )
  return ( false );
 for (;; )
  {
  _BidIt _Next1 = _Next;
  if ( ( ( * _Next1 ) < ( * -- _Next ) ) )
   {
   _BidIt _Mid = _Last;
   for (; ! ( ( * -- _Mid ) < ( * _Next ) ); )
    ;
   :: std :: iter_swap ( _Next, _Mid );
   :: std :: reverse ( _Next1, _Last );
   return ( true );
   }

  if ( _Next == _First )
   {
   :: std :: reverse ( _First, _Last );
   return ( false );
   }
  }
 }
#line 5358
template < class _BidIt > inline
 bool prev_permutation ( _BidIt _First, _BidIt _Last )
 {
 ;
 return ( _Prev_permutation ( _Unchecked ( _First ), _Unchecked ( _Last ) ) );
 }
#line 5366
template < class _BidIt,
 class _Pr > inline
 bool _Prev_permutation ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 _BidIt _Next = _Last;
 if ( _First == _Last || _First == -- _Next )
  return ( false );

 for (;; )
  {
  _BidIt _Next1 = _Next;
  if ( _Pred ( * _Next1, * -- _Next ) )
   {
   _BidIt _Mid = _Last;
   for (; ! _Pred ( * -- _Mid, * _Next ); )
    ;
   :: std :: iter_swap ( _Next, _Mid );
   :: std :: reverse ( _Next1, _Last );
   return ( true );
   }

  if ( _Next == _First )
   {
   :: std :: reverse ( _First, _Last );
   return ( false );
   }
  }
 }
#line 5395
template < class _BidIt,
 class _Pr > inline
 bool prev_permutation ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Prev_permutation ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) );
 }
#line 5406
template < class _RanIt,
 class _Diff > inline
 _RanIt _Is_heap_until ( _RanIt _First, _RanIt _Last, _Diff * )
 {
 _Diff _Size = _Last - _First;

 if ( 2 <= _Size )
  for ( _Diff _Off = 0; ++ _Off < _Size; )
   if ( ( ( * ( _First + ( _Off - 1 ) / 2 ) ) < ( * ( _First + _Off ) ) ) )
    return ( _First + _Off );
 return ( _Last );
 }
#line 5419
template < class _RanIt >
 _RanIt is_heap_until ( _RanIt _First, _RanIt _Last )
 {
 ;
 return ( _Rechecked ( _First,
  _Is_heap_until ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dist_type ( _First ) ) ) );
 }
#line 5428
template < class _RanIt >
 bool is_heap ( _RanIt _First, _RanIt _Last )
 {
 return ( _Is_heap_until ( _First, _Last, _Dist_type ( _First ) )
  == _Last );
 }
#line 5436
template < class _RanIt,
 class _Diff,
 class _Pr > inline
 _RanIt _Is_heap_until ( _RanIt _First, _RanIt _Last, _Pr _Pred, _Diff * )
 {
 _Diff _Size = _Last - _First;

 if ( 2 <= _Size )
  for ( _Diff _Off = 0; ++ _Off < _Size; )
   if ( _Pred ( * ( _First + ( _Off - 1 ) / 2 ), * ( _First + _Off ) ) )

    return ( _First + _Off );
 return ( _Last );
 }
#line 5451 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
template < class _RanIt,
 class _Pr >
 _RanIt is_heap_until ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Rechecked ( _First,
  _Is_heap_until ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred,
   _Dist_type ( _First ) ) ) );
 }
#line 5462
template < class _RanIt,
 class _Pr >
 bool is_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 return ( _Is_heap_until ( _First, _Last, _Pred, _Dist_type ( _First ) )
  == _Last );
 }
#line 5471
template < class _FwdIt > inline
 _FwdIt _Is_sorted_until ( _FwdIt _First, _FwdIt _Last )
 {
 if ( _First != _Last )
  for ( _FwdIt _Next = _First; ++ _Next != _Last; ++ _First )
   if ( ( ( * _Next ) < ( * _First ) ) )
    return ( _Next );
 return ( _Last );
 }
#line 5481
template < class _FwdIt > inline
 _FwdIt is_sorted_until ( _FwdIt _First, _FwdIt _Last )
 {
 ;
 return ( _Rechecked ( _First,
  _Is_sorted_until ( _Unchecked ( _First ), _Unchecked ( _Last ) ) ) );
 }
#line 5489
template < class _FwdIt > inline
 bool is_sorted ( _FwdIt _First, _FwdIt _Last )
 {
 return ( :: std :: is_sorted_until ( _First, _Last ) == _Last );
 }
#line 5496
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Is_sorted_until ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 if ( _First != _Last )
  for ( _FwdIt _Next = _First; ++ _Next != _Last; ++ _First )
   if ( _Pred ( * _Next, * _First ) )
    return ( _Next );
 return ( _Last );
 }
#line 5507
template < class _FwdIt,
 class _Pr > inline
 _FwdIt is_sorted_until ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 ;
 ;
 return ( _Rechecked ( _First,
  _Is_sorted_until ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 5517
template < class _FwdIt,
 class _Pr > inline
 bool is_sorted ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 return ( :: std :: is_sorted_until ( _First, _Last, _Pred ) == _Last );
 }
#line 5524 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
}
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstring"
#pragma warning(push,3)
#line 5526 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\algorithm"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstring"
#pragma pack ( push, 8 )
#line 11
namespace std { 
#pragma warning(disable: 4251)
#line 14
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Ax = allocator < _Elem > >
 class basic_string;
#line 24
template < class _Elem,
 class _Traits,
 class _Alloc >
 class _String_const_iterator
  : public _Iterator012 < random_access_iterator_tag,
   typename _Alloc :: value_type,
   typename _Alloc :: difference_type,
   typename _Alloc :: const_pointer,
   typename _Alloc :: const_reference,
   _Iterator_base >
 {
public :
 typedef _String_const_iterator < _Elem, _Traits, _Alloc > _Myiter;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Alloc :: value_type value_type;
 typedef typename _Alloc :: difference_type difference_type;
 typedef typename _Alloc :: const_pointer pointer;
 typedef typename _Alloc :: const_reference reference;

 _String_const_iterator ( )
  {
  this -> _Ptr = 0;
  }

 _String_const_iterator ( pointer _Parg, const _Container_base * _Pstring )
  {
  this -> _Adopt ( _Pstring );
  this -> _Ptr = _Parg;
  }

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  this -> _Ptr = _Right;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Unchecked_type ( this -> _Ptr ) );
  }

 reference operator * ( ) const
  {



















  ;

  return ( * this -> _Ptr );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myiter & operator ++ ( )
  {

















  ++ this -> _Ptr;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {















  -- this -> _Ptr;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {



















  _Ptr += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Ptr - _Right . _Ptr );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Ptr == _Right . _Ptr );
  }

 bool operator != ( const _Myiter & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Ptr < _Right . _Ptr );
  }

 bool operator > ( const _Myiter & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myiter & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myiter & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }




















 void _Compat ( const _Myiter & ) const
  {
  }


 pointer _Ptr;
 };
#line 270 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstring"
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 typename _String_const_iterator < _Elem, _Traits, _Alloc > :: _Unchecked_type
  _Unchecked ( _String_const_iterator < _Elem, _Traits, _Alloc > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 279
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 _String_const_iterator < _Elem, _Traits, _Alloc >
  _Rechecked ( _String_const_iterator < _Elem, _Traits, _Alloc > & _Iter,
   typename _String_const_iterator < _Elem, _Traits, _Alloc >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 290
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 _String_const_iterator < _Elem, _Traits, _Alloc > operator + (
  typename _String_const_iterator < _Elem, _Traits, _Alloc >
   :: difference_type _Off,
  _String_const_iterator < _Elem, _Traits, _Alloc > _Next )
 {
 return ( _Next += _Off );
 }
#line 302
template < class _Elem,
 class _Traits,
 class _Alloc >
 class _String_iterator
  : public _String_const_iterator < _Elem, _Traits, _Alloc >
 {
public :
 typedef _String_iterator < _Elem, _Traits, _Alloc > _Myiter;
 typedef _String_const_iterator < _Elem, _Traits, _Alloc > _Mybase;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr :: value_type value_type;
 typedef typename _Mystr :: difference_type difference_type;
 typedef typename _Mystr :: pointer pointer;
 typedef typename _Mystr :: reference reference;

 _String_iterator ( )
  {
  }

 _String_iterator ( pointer _Parg, const _Container_base * _Pstring )
  : _Mybase ( _Parg, _Pstring )
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  this -> _Ptr = _Right;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Unchecked_type ( this -> _Ptr ) );
  }

 reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myiter & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( ( _Mybase ) * this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 411
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 typename _String_iterator < _Elem, _Traits, _Alloc > :: _Unchecked_type
  _Unchecked ( _String_iterator < _Elem, _Traits, _Alloc > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 420
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 _String_iterator < _Elem, _Traits, _Alloc >
  _Rechecked ( _String_iterator < _Elem, _Traits, _Alloc > & _Iter,
   typename _String_iterator < _Elem, _Traits, _Alloc >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 431
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 _String_iterator < _Elem, _Traits, _Alloc > operator + (
  typename _String_iterator < _Elem, _Traits, _Alloc >
   :: difference_type _Off,
  _String_iterator < _Elem, _Traits, _Alloc > _Next )
 {
 return ( _Next += _Off );
 }
#line 443
template < class _Elem,
 class _Alloc >
 class _String_val
  : public _Container_base
 {
public :

 typedef typename _Alloc :: template rebind < _Elem > :: other _Alty;

 _String_val ( _Alty _Al = _Alty ( ) )
  : _Alval ( _Al )
  {
  }

 ~ _String_val ( )
  {
  }

























 typedef typename _Alty :: size_type size_type;
 typedef typename _Alty :: difference_type difference_type;
 typedef typename _Alty :: pointer pointer;
 typedef typename _Alty :: const_pointer const_pointer;
 typedef typename _Alty :: reference reference;
 typedef typename _Alty :: const_reference const_reference;
 typedef typename _Alty :: value_type value_type;

 enum
  {
  _BUF_SIZE = 16 / sizeof ( _Elem ) < 1 ? 1
   : 16 / sizeof ( _Elem ) };
 enum
  {
  _ALLOC_MASK = sizeof ( _Elem ) <= 1 ? 15
   : sizeof ( _Elem ) <= 2 ? 7
   : sizeof ( _Elem ) <= 4 ? 3
   : sizeof ( _Elem ) <= 8 ? 1 : 0 };

 union _Bxty
  {
  _Elem _Buf [ _BUF_SIZE ];
  _Elem * _Ptr;
  char _Alias [ _BUF_SIZE ];
  } _Bx;

 size_type _Mysize;
 size_type _Myres;
 _Alty _Alval;
 };
#line 517 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstring"
template < class _Elem,
 class _Traits,
 class _Ax >
 class basic_string
  : public _String_val < _Elem, _Ax >
 {
public :
 typedef basic_string < _Elem, _Traits, _Ax > _Myt;
 typedef _String_val < _Elem, _Ax > _Mybase;
 typedef typename _Mybase :: _Alty _Alloc;
 typedef typename _Alloc :: size_type size_type;
 typedef typename _Alloc :: difference_type difference_type;
 typedef typename _Alloc :: pointer pointer;
 typedef typename _Alloc :: const_pointer const_pointer;
 typedef typename _Alloc :: reference reference;
 typedef typename _Alloc :: const_reference const_reference;
 typedef typename _Alloc :: value_type value_type;

 typedef _String_iterator < _Elem, _Traits, _Alloc > iterator;
 typedef _String_const_iterator < _Elem, _Traits, _Alloc > const_iterator;

 typedef :: std :: reverse_iterator < iterator > reverse_iterator;
 typedef :: std :: reverse_iterator < const_iterator > const_reverse_iterator;

 basic_string ( const _Myt & _Right )
  : _Mybase ( _Right . _Alval )
  {
  _Tidy ( );
  assign ( _Right, 0, npos );
  }

 basic_string ( )
  : _Mybase ( )
  {
  _Tidy ( );
  }

 explicit basic_string ( const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  }

 basic_string ( const _Myt & _Right, size_type _Roff,
  size_type _Count = npos )
  : _Mybase ( _Right . _Alval )
  {
  _Tidy ( );
  assign ( _Right, _Roff, _Count );
  }

 basic_string ( const _Myt & _Right, size_type _Roff, size_type _Count,
  const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Right, _Roff, _Count );
  }

 basic_string ( const _Elem * _Ptr, size_type _Count )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Ptr, _Count );
  }

 basic_string ( const _Elem * _Ptr, size_type _Count, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Ptr, _Count );
  }

 basic_string ( const _Elem * _Ptr )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Ptr );
  }

 basic_string ( const _Elem * _Ptr, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Ptr );
  }

 basic_string ( size_type _Count, _Elem _Ch )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Count, _Ch );
  }

 basic_string ( size_type _Count, _Elem _Ch, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Count, _Ch );
  }

 template < class _It >
  basic_string ( _It _First, _It _Last )
  : _Mybase ( )
  {
  _Tidy ( );
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _It >
  basic_string ( _It _First, _It _Last, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _It >
  void _Construct ( _It _Count,
   _It _Ch, _Int_iterator_tag )
  {
  assign ( ( size_type ) _Count, ( _Elem ) _Ch );
  }

 template < class _It >
  void _Construct ( _It _First,
   _It _Last, input_iterator_tag )
  {
  try {
  for (; _First != _Last; ++ _First )
   append ( ( size_type ) 1, ( _Elem ) * _First );
  } catch ( ... ) {
  _Tidy ( true );
  throw;
  }
  }

 template < class _It >
  void _Construct ( _It _First,
   _It _Last, forward_iterator_tag )
  {
  ;
  size_type _Count = 0;
  _Distance ( _First, _Last, _Count );
  reserve ( _Count );

  try {
  for (; _First != _Last; ++ _First )
   append ( ( size_type ) 1, ( _Elem ) * _First );
  } catch ( ... ) {
  _Tidy ( true );
  throw;
  }
  }

 basic_string ( const_pointer _First, const_pointer _Last )
  : _Mybase ( )
  {
  ;
  _Tidy ( );
  if ( _First != _Last )
   assign ( & * _First, _Last - _First );
  }

 basic_string ( const_pointer _First, const_pointer _Last,
  const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  ;
  _Tidy ( );
  if ( _First != _Last )
   assign ( & * _First, _Last - _First );
  }

 basic_string ( const_iterator _First, const_iterator _Last )
  : _Mybase ( )
  {
  ;
  _Tidy ( );
  if ( _First != _Last )
   assign ( & * _First, _Last - _First );
  }

 basic_string ( _Myt && _Right )
  : _Mybase ( :: std :: forward < _Alloc > ( _Right . _Alval ) )
  {
  _Tidy ( );
  assign ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  return ( assign ( :: std :: forward < _Myt > ( _Right ) ) );
  }

 _Myt & assign ( _Myt && _Right )
  {
  if ( this == & _Right )
   ;
  else if ( get_allocator ( ) != _Right . get_allocator ( )
   && this -> _BUF_SIZE <= _Right . _Myres )
   * this = _Right;
  else
   {
   _Tidy ( true );
   if ( _Right . _Myres < this -> _BUF_SIZE )
    _Traits :: move ( this -> _Bx . _Buf, _Right . _Bx . _Buf,
     _Right . _Mysize + 1 );
   else
    {
    this -> _Bx . _Ptr = _Right . _Bx . _Ptr;
    _Right . _Bx . _Ptr = 0;
    }
   this -> _Mysize = _Right . _Mysize;
   this -> _Myres = _Right . _Myres;

   _Right . _Tidy ( );
   }
  return ( * this );
  }

 void swap ( _Myt && _Right )
  {
  if ( this != & _Right )
   {





   assign ( :: std :: forward < _Myt > ( _Right ) );
   }
  }

 ~ basic_string ( )
  {
  _Tidy ( true );
  }

 typedef _Traits traits_type;
 typedef _Alloc allocator_type;

  static const size_type npos;

 _Myt & operator = ( const _Myt & _Right )
  {
  return ( assign ( _Right ) );
  }

 _Myt & operator = ( const _Elem * _Ptr )
  {
  return ( assign ( _Ptr ) );
  }

 _Myt & operator = ( _Elem _Ch )
  {
  return ( assign ( 1, _Ch ) );
  }

 _Myt & operator += ( const _Myt & _Right )
  {
  return ( append ( _Right ) );
  }

 _Myt & operator += ( const _Elem * _Ptr )
  {
  return ( append ( _Ptr ) );
  }

 _Myt & operator += ( _Elem _Ch )
  {
  return ( append ( ( size_type ) 1, _Ch ) );
  }

 _Myt & append ( const _Myt & _Right )
  {
  return ( append ( _Right, 0, npos ) );
  }

 _Myt & append ( const _Myt & _Right,
  size_type _Roff, size_type _Count )
  {
  if ( _Right . size ( ) < _Roff )
   _Xran ( );
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Num < _Count )
   _Count = _Num;
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );

  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: copy ( _Myptr ( ) + this -> _Mysize,
    _Right . _Myptr ( ) + _Roff, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & append ( const _Elem * _Ptr, size_type _Count )
  {





  if ( _Inside ( _Ptr ) )
   return ( append ( * this, _Ptr - _Myptr ( ), _Count ) );
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );

  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: copy ( _Myptr ( ) + this -> _Mysize, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & append ( const _Elem * _Ptr )
  {
  ;
  return ( append ( _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & append ( size_type _Count, _Elem _Ch )
  {
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );

  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Chassign ( this -> _Mysize, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

 template < class _It >
  _Myt & append ( _It _First, _It _Last )
  {
  return ( _Append ( _First, _Last, _Iter_cat ( _First ) ) );
  }

 template < class _It >
  _Myt & _Append ( _It _Count, _It _Ch, _Int_iterator_tag )
  {
  return ( append ( ( size_type ) _Count, ( _Elem ) _Ch ) );
  }

 template < class _It >
  _Myt & _Append ( _It _First, _It _Last, input_iterator_tag )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

 _Myt & append ( const_pointer _First, const_pointer _Last )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

 _Myt & append ( const_iterator _First, const_iterator _Last )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

 _Myt & assign ( const _Myt & _Right )
  {
  return ( assign ( _Right, 0, npos ) );
  }

 _Myt & assign ( const _Myt & _Right,
  size_type _Roff, size_type _Count )
  {
  if ( _Right . size ( ) < _Roff )
   _Xran ( );
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Count < _Num )
   _Num = _Count;

  if ( this == & _Right )
   erase ( ( size_type ) ( _Roff + _Num ) ), erase ( 0, _Roff );
  else if ( _Grow ( _Num ) )
   {
   _Traits :: copy ( _Myptr ( ), _Right . _Myptr ( ) + _Roff, _Num );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & assign ( const _Elem * _Ptr, size_type _Count )
  {





  if ( _Inside ( _Ptr ) )
   return ( assign ( * this, _Ptr - _Myptr ( ), _Count ) );

  if ( _Grow ( _Count ) )
   {
   _Traits :: copy ( _Myptr ( ), _Ptr, _Count );
   _Eos ( _Count );
   }
  return ( * this );
  }

 _Myt & assign ( const _Elem * _Ptr )
  {
  ;
  return ( assign ( _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & assign ( size_type _Count, _Elem _Ch )
  {
  if ( _Count == npos )
   _Xlen ( );

  if ( _Grow ( _Count ) )
   {
   _Chassign ( 0, _Count, _Ch );
   _Eos ( _Count );
   }
  return ( * this );
  }

 template < class _It >
  _Myt & assign ( _It _First, _It _Last )
  {
  return ( _Assign ( _First, _Last, _Iter_cat ( _First ) ) );
  }

 template < class _It >
  _Myt & _Assign ( _It _Count, _It _Ch, _Int_iterator_tag )
  {
  return ( assign ( ( size_type ) _Count, ( _Elem ) _Ch ) );
  }

 template < class _It >
  _Myt & _Assign ( _It _First, _It _Last, input_iterator_tag )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

 _Myt & assign ( const_pointer _First, const_pointer _Last )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

 _Myt & assign ( const_iterator _First, const_iterator _Last )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

 _Myt & insert ( size_type _Off, const _Myt & _Right )
  {
  return ( insert ( _Off, _Right, 0, npos ) );
  }

 _Myt & insert ( size_type _Off,
  const _Myt & _Right, size_type _Roff, size_type _Count )
  {
  if ( this -> _Mysize < _Off || _Right . size ( ) < _Roff )
   _Xran ( );
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Num < _Count )
   _Count = _Num;
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );

  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off, this -> _Mysize - _Off );
   if ( this == & _Right )
    _Traits :: move ( _Myptr ( ) + _Off,
     _Myptr ( ) + ( _Off < _Roff ? _Roff + _Count : _Roff ),
      _Count );
   else
    _Traits :: copy ( _Myptr ( ) + _Off,
     _Right . _Myptr ( ) + _Roff, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & insert ( size_type _Off,
  const _Elem * _Ptr, size_type _Count )
  {





  if ( _Inside ( _Ptr ) )
   return ( insert ( _Off, * this,
    _Ptr - _Myptr ( ), _Count ) );
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );
  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off, this -> _Mysize - _Off );
   _Traits :: copy ( _Myptr ( ) + _Off, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & insert ( size_type _Off, const _Elem * _Ptr )
  {
  ;
  return ( insert ( _Off, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & insert ( size_type _Off,
  size_type _Count, _Elem _Ch )
  {
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );
  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off, this -> _Mysize - _Off );
   _Chassign ( _Off, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

 iterator insert ( const_iterator _Where )
  {
  return ( insert ( _Where, _Elem ( ) ) );
  }

 iterator insert ( const_iterator _Where, _Elem _Ch )
  {
  size_type _Off = _Pdif ( _Where, begin ( ) );
  insert ( _Off, 1, _Ch );
  return ( begin ( ) + _Off );
  }

 void insert ( const_iterator _Where, size_type _Count, _Elem _Ch )
  {
  size_type _Off = _Pdif ( _Where, begin ( ) );
  insert ( _Off, _Count, _Ch );
  }

 template < class _It >
  void insert ( const_iterator _Where, _It _First, _It _Last )
  {
  _Insert ( _Where, _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _It >
  void _Insert ( const_iterator _Where, _It _Count, _It _Ch,
   _Int_iterator_tag )
  {
  insert ( _Where, ( size_type ) _Count, ( _Elem ) _Ch );
  }

 template < class _It >
  void _Insert ( const_iterator _Where, _It _First, _It _Last,
   input_iterator_tag )
  {
  replace ( _Where, _Where, _First, _Last );
  }

 void insert ( const_iterator _Where,
  const_pointer _First, const_pointer _Last )
  {
  replace ( _Where, _Where, _First, _Last );
  }

 void insert ( const_iterator _Where,
  const_iterator _First, const_iterator _Last )
  {
  replace ( _Where, _Where, _First, _Last );
  }

 _Myt & erase ( size_type _Off = 0,
  size_type _Count = npos )
  {
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _Count )
   _Count = this -> _Mysize - _Off;
  if ( 0 < _Count )
   {
   _Traits :: move ( _Myptr ( ) + _Off, _Myptr ( ) + _Off + _Count,
    this -> _Mysize - _Off - _Count );
   size_type _Newsize = this -> _Mysize - _Count;
   _Eos ( _Newsize );
   }
  return ( * this );
  }

 iterator erase ( const_iterator _Where )
  {
  size_type _Count = _Pdif ( _Where, begin ( ) );
  erase ( _Count, 1 );
  return ( iterator ( _Myptr ( ) + _Count, this ) );
  }

 iterator erase ( const_iterator _First, const_iterator _Last )
  {
  size_type _Count = _Pdif ( _First, begin ( ) );
  erase ( _Count, _Pdif ( _Last, _First ) );
  return ( iterator ( _Myptr ( ) + _Count, this ) );
  }

 void clear ( )
  {
  _Eos ( 0 );
  }

 _Myt & replace ( size_type _Off, size_type _N0, const _Myt & _Right )
  {
  return ( replace ( _Off, _N0, _Right, 0, npos ) );
  }

 _Myt & replace ( size_type _Off,
  size_type _N0, const _Myt & _Right, size_type _Roff, size_type _Count )
  {
  if ( this -> _Mysize < _Off || _Right . size ( ) < _Roff )
   _Xran ( );
  if ( this -> _Mysize - _Off < _N0 )
   _N0 = this -> _Mysize - _Off;
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Num < _Count )
   _Count = _Num;
  if ( npos - _Count <= this -> _Mysize - _N0 )
   _Xlen ( );

  size_type _Nm = this -> _Mysize - _N0 - _Off;
  size_type _Newsize = this -> _Mysize + _Count - _N0;
  if ( this -> _Mysize < _Newsize )
   _Grow ( _Newsize );

  if ( this != & _Right )
   {
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: copy ( _Myptr ( ) + _Off,
    _Right . _Myptr ( ) + _Roff, _Count );
   }
  else if ( _Count <= _N0 )
   {
   _Traits :: move ( _Myptr ( ) + _Off,
    _Myptr ( ) + _Roff, _Count );
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   }
  else if ( _Roff <= _Off )
   {
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: move ( _Myptr ( ) + _Off,
    _Myptr ( ) + _Roff, _Count );
   }
  else if ( _Off + _N0 <= _Roff )
   {
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: move ( _Myptr ( ) + _Off,
    _Myptr ( ) + ( _Roff + _Count - _N0 ), _Count );
   }
  else
   {
   _Traits :: move ( _Myptr ( ) + _Off,
    _Myptr ( ) + _Roff, _N0 );
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: move ( _Myptr ( ) + _Off + _N0, _Myptr ( ) + _Roff + _Count,
    _Count - _N0 );
   }

  _Eos ( _Newsize );
  return ( * this );
  }

 _Myt & replace ( size_type _Off,
  size_type _N0, const _Elem * _Ptr, size_type _Count )
  {





  if ( _Inside ( _Ptr ) )
   return ( replace ( _Off, _N0, * this,
    _Ptr - _Myptr ( ), _Count ) );
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _N0 )
   _N0 = this -> _Mysize - _Off;
  if ( npos - _Count <= this -> _Mysize - _N0 )
   _Xlen ( );
  size_type _Nm = this -> _Mysize - _N0 - _Off;

  if ( _Count < _N0 )
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
  size_type _Num;
  if ( ( 0 < _Count || 0 < _N0 )
   && _Grow ( _Num = this -> _Mysize + _Count - _N0 ) )
   {
   if ( _N0 < _Count )
    _Traits :: move ( _Myptr ( ) + _Off + _Count,
     _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: copy ( _Myptr ( ) + _Off, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & replace ( size_type _Off, size_type _N0, const _Elem * _Ptr )
  {
  ;
  return ( replace ( _Off, _N0, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & replace ( size_type _Off,
  size_type _N0, size_type _Count, _Elem _Ch )
  {
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _N0 )
   _N0 = this -> _Mysize - _Off;
  if ( npos - _Count <= this -> _Mysize - _N0 )
   _Xlen ( );
  size_type _Nm = this -> _Mysize - _N0 - _Off;

  if ( _Count < _N0 )
   _Traits :: move ( _Myptr ( ) + _Off + _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
  size_type _Num;
  if ( ( 0 < _Count || 0 < _N0 )
   && _Grow ( _Num = this -> _Mysize + _Count - _N0 ) )
   {
   if ( _N0 < _Count )
    _Traits :: move ( _Myptr ( ) + _Off + _Count,
     _Myptr ( ) + _Off + _N0, _Nm );
   _Chassign ( _Off, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const _Myt & _Right )
  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Right ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const _Elem * _Ptr, size_type _Count )
  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Ptr, _Count ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const _Elem * _Ptr )
  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Ptr ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  size_type _Count, _Elem _Ch )
  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Count, _Ch ) );
  }

 template < class _It >
  _Myt & replace ( const_iterator _First, const_iterator _Last,
   _It _First2, _It _Last2 )
  {
  return ( _Replace ( _First, _Last,
   _First2, _Last2, _Iter_cat ( _First2 ) ) );
  }

 template < class _It >
  _Myt & _Replace ( const_iterator _First, const_iterator _Last,
   _It _Count, _It _Ch, _Int_iterator_tag )
  {
  return ( replace ( _First, _Last, ( size_type ) _Count, ( _Elem ) _Ch ) );
  }

 template < class _It >
  _Myt & _Replace ( const_iterator _First, const_iterator _Last,
   _It _First2, _It _Last2, input_iterator_tag )
  {
  _Myt _Right ( _First2, _Last2 );
  replace ( _First, _Last, _Right );
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const_pointer _First2, const_pointer _Last2 )
  {
  if ( _First2 == _Last2 )
   erase ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ) );
  else
   replace ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ),
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const_iterator _First2, const_iterator _Last2 )
  {
  if ( _First2 == _Last2 )
   erase ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ) );
  else
   replace ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ),
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

 iterator begin ( )
  {
  return ( iterator ( _Myptr ( ), this ) );
  }

 const_iterator begin ( ) const
  {
  return ( const_iterator ( _Myptr ( ), this ) );
  }

 iterator end ( )
  {
  return ( iterator ( _Myptr ( ) + this -> _Mysize, this ) );
  }

 const_iterator end ( ) const
  {
  return ( const_iterator ( _Myptr ( ) + this -> _Mysize, this ) );
  }

 reverse_iterator rbegin ( )
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( )
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }


 const_iterator cbegin ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> begin ( ) );
  }

 const_iterator cend ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> end ( ) );
  }

 const_reverse_iterator crbegin ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> rbegin ( ) );
  }

 const_reverse_iterator crend ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> rend ( ) );
  }

 void shrink_to_fit ( )
  {
  if ( size ( ) < capacity ( ) )
   {
   _Myt _Tmp ( * this );
   swap ( _Tmp );
   }
  }


 reference at ( size_type _Off )
  {
  if ( this -> _Mysize <= _Off )
   _Xran ( );
  return ( _Myptr ( ) [ _Off ] );
  }

 const_reference at ( size_type _Off ) const
  {
  if ( this -> _Mysize <= _Off )
   _Xran ( );
  return ( _Myptr ( ) [ _Off ] );
  }

 reference operator [ ] ( size_type _Off )
  {










  return ( _Myptr ( ) [ _Off ] );
  }

 const_reference operator [ ] ( size_type _Off ) const
  {








  return ( _Myptr ( ) [ _Off ] );
  }

 void push_back ( _Elem _Ch )
  {
  insert ( end ( ), _Ch );
  }


 void pop_back ( )
  {
  erase ( this -> _Mysize - 1 );
  }

 reference front ( )
  {
  return ( * begin ( ) );
  }

 const_reference front ( ) const
  {
  return ( * begin ( ) );
  }

 reference back ( )
  {
  return ( * ( end ( ) - 1 ) );
  }

 const_reference back ( ) const
  {
  return ( * ( end ( ) - 1 ) );
  }


 const _Elem * c_str ( ) const
  {
  return ( _Myptr ( ) );
  }

 const _Elem * data ( ) const
  {
  return ( c_str ( ) );
  }

 size_type length ( ) const
  {
  return ( this -> _Mysize );
  }

 size_type size ( ) const
  {
  return ( this -> _Mysize );
  }

 size_type max_size ( ) const
  {
  size_type _Num = this -> _Alval . max_size ( );
  return ( _Num <= 1 ? 1 : _Num - 1 );
  }

 void resize ( size_type _Newsize )
  {
  resize ( _Newsize, _Elem ( ) );
  }

 void resize ( size_type _Newsize, _Elem _Ch )
  {
  if ( _Newsize <= this -> _Mysize )
   erase ( _Newsize );
  else
   append ( _Newsize - this -> _Mysize, _Ch );
  }

 size_type capacity ( ) const
  {
  return ( this -> _Myres );
  }

 void reserve ( size_type _Newcap = 0 )
  {
  if ( this -> _Mysize <= _Newcap && this -> _Myres != _Newcap )
   {
   size_type _Size = this -> _Mysize;
   if ( _Grow ( _Newcap, true ) )
    _Eos ( _Size );
   }
  }

 bool empty ( ) const
  {
  return ( this -> _Mysize == 0 );
  }



 size_type copy ( _Elem * _Ptr,
  size_type _Count, size_type _Off = 0 ) const
  {





  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _Count )
   _Count = this -> _Mysize - _Off;
  _Traits :: copy ( _Ptr, _Myptr ( ) + _Off, _Count );
  return ( _Count );
  }

 size_type _Copy_s ( _Elem * _Dest, size_type _Dest_size,
  size_type _Count, size_type _Off = 0 ) const
  {





  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _Count )
   _Count = this -> _Mysize - _Off;
  _Traits :: _Copy_s ( _Dest, _Dest_size, _Myptr ( ) + _Off, _Count );
  return ( _Count );
  }

 void swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( this -> _Alval == _Right . _Alval )
   {




   :: std :: swap ( this -> _Bx, _Right . _Bx );
   :: std :: swap ( this -> _Mysize, _Right . _Mysize );
   :: std :: swap ( this -> _Myres, _Right . _Myres );
   }
  else
   {
   _Myt _Tmp = * this;

   * this = _Right;
   _Right = _Tmp;
   }
  }

 size_type find ( const _Myt & _Right, size_type _Off = 0 ) const
  {
  return ( find ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {





  if ( _Count == 0 && _Off <= this -> _Mysize )
   return ( _Off );

  size_type _Nm;
  if ( _Off < this -> _Mysize && _Count <= ( _Nm = this -> _Mysize - _Off ) )
   {
   const _Elem * _Uptr, * _Vptr;
   for ( _Nm -= _Count - 1, _Vptr = _Myptr ( ) + _Off;
    ( _Uptr = _Traits :: find ( _Vptr, _Nm, * _Ptr ) ) != 0;
    _Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1 )
    if ( _Traits :: compare ( _Uptr, _Ptr, _Count ) == 0 )
     return ( _Uptr - _Myptr ( ) );
   }

  return ( npos );
  }

 size_type find ( const _Elem * _Ptr, size_type _Off = 0 ) const
  {
  ;
  return ( find ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find ( _Elem _Ch, size_type _Off = 0 ) const
  {
  return ( find ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type rfind ( const _Myt & _Right, size_type _Off = npos ) const
  {
  return ( rfind ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type rfind ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {





  if ( _Count == 0 )
   return ( _Off < this -> _Mysize ? _Off
    : this -> _Mysize );
  if ( _Count <= this -> _Mysize )
   {
   const _Elem * _Uptr = _Myptr ( ) +
    ( _Off < this -> _Mysize - _Count ? _Off
     : this -> _Mysize - _Count );
   for (;; -- _Uptr )
    if ( _Traits :: eq ( * _Uptr, * _Ptr )
     && _Traits :: compare ( _Uptr, _Ptr, _Count ) == 0 )
     return ( _Uptr - _Myptr ( ) );
    else if ( _Uptr == _Myptr ( ) )
     break;
   }

  return ( npos );
  }

 size_type rfind ( const _Elem * _Ptr, size_type _Off = npos ) const
  {
  ;
  return ( rfind ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type rfind ( _Elem _Ch, size_type _Off = npos ) const
  {
  return ( rfind ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_first_of ( const _Myt & _Right,
  size_type _Off = 0 ) const
  {
  return ( find_first_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find_first_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {





  if ( 0 < _Count && _Off < this -> _Mysize )
   {
   const _Elem * const _Vptr = _Myptr ( ) + this -> _Mysize;
   for ( const _Elem * _Uptr = _Myptr ( ) + _Off; _Uptr < _Vptr; ++ _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) != 0 )
     return ( _Uptr - _Myptr ( ) );
   }

  return ( npos );
  }

 size_type find_first_of ( const _Elem * _Ptr, size_type _Off = 0 ) const
  {
  ;
  return ( find_first_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_first_of ( _Elem _Ch, size_type _Off = 0 ) const
  {
  return ( find ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_last_of ( const _Myt & _Right,
  size_type _Off = npos ) const
  {
  return ( find_last_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find_last_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {





  if ( 0 < _Count && 0 < this -> _Mysize )
   {
   const _Elem * _Uptr = _Myptr ( )
    + ( _Off < this -> _Mysize ? _Off : this -> _Mysize - 1 );
   for (;; -- _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) != 0 )
     return ( _Uptr - _Myptr ( ) );
    else if ( _Uptr == _Myptr ( ) )
     break;
   }

  return ( npos );
  }

 size_type find_last_of ( const _Elem * _Ptr,
  size_type _Off = npos ) const
  {
  ;
  return ( find_last_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_last_of ( _Elem _Ch, size_type _Off = npos ) const
  {
  return ( rfind ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_first_not_of ( const _Myt & _Right,
  size_type _Off = 0 ) const
  {
  return ( find_first_not_of ( _Right . _Myptr ( ), _Off,
   _Right . size ( ) ) );
  }

 size_type find_first_not_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {





  if ( _Off < this -> _Mysize )
   {
   const _Elem * const _Vptr = _Myptr ( ) + this -> _Mysize;
   for ( const _Elem * _Uptr = _Myptr ( ) + _Off; _Uptr < _Vptr; ++ _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) == 0 )
     return ( _Uptr - _Myptr ( ) );
   }
  return ( npos );
  }

 size_type find_first_not_of ( const _Elem * _Ptr,
  size_type _Off = 0 ) const
  {
  ;
  return ( find_first_not_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_first_not_of ( _Elem _Ch, size_type _Off = 0 ) const
  {
  return ( find_first_not_of ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_last_not_of ( const _Myt & _Right,
  size_type _Off = npos ) const
  {
  return ( find_last_not_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find_last_not_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {





  if ( 0 < this -> _Mysize )
   {
   const _Elem * _Uptr = _Myptr ( )
    + ( _Off < this -> _Mysize ? _Off : this -> _Mysize - 1 );
   for (;; -- _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) == 0 )
     return ( _Uptr - _Myptr ( ) );
    else if ( _Uptr == _Myptr ( ) )
     break;
   }
  return ( npos );
  }

 size_type find_last_not_of ( const _Elem * _Ptr,
  size_type _Off = npos ) const
  {
  ;
  return ( find_last_not_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_last_not_of ( _Elem _Ch, size_type _Off = npos ) const
  {
  return ( find_last_not_of ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 _Myt substr ( size_type _Off = 0, size_type _Count = npos ) const
  {
  return ( _Myt ( * this, _Off, _Count, get_allocator ( ) ) );
  }

 int compare ( const _Myt & _Right ) const
  {
  return ( compare ( 0, this -> _Mysize, _Right . _Myptr ( ), _Right . size ( ) ) );
  }

 int compare ( size_type _Off, size_type _N0,
  const _Myt & _Right ) const
  {
  return ( compare ( _Off, _N0, _Right, 0, npos ) );
  }

 int compare ( size_type _Off,
  size_type _N0, const _Myt & _Right,
  size_type _Roff, size_type _Count ) const
  {
  if ( _Right . size ( ) < _Roff )
   _Xran ( );
  if ( _Right . _Mysize - _Roff < _Count )
   _Count = _Right . _Mysize - _Roff;
  return ( compare ( _Off, _N0, _Right . _Myptr ( ) + _Roff, _Count ) );
  }

 int compare ( const _Elem * _Ptr ) const
  {
  ;
  return ( compare ( 0, this -> _Mysize, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 int compare ( size_type _Off, size_type _N0, const _Elem * _Ptr ) const
  {
  ;
  return ( compare ( _Off, _N0, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 int compare ( size_type _Off,
  size_type _N0, const _Elem * _Ptr, size_type _Count ) const
  {





  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _N0 )
   _N0 = this -> _Mysize - _Off;

  size_type _Ans = _Traits :: compare ( _Myptr ( ) + _Off, _Ptr,
   _N0 < _Count ? _N0 : _Count );
  return ( _Ans != 0 ? ( int ) _Ans : _N0 < _Count ? - 1
   : _N0 == _Count ? 0 : + 1 );
  }

 allocator_type get_allocator ( ) const
  {
  return ( this -> _Alval );
  }

 void _Chassign ( size_type _Off, size_type _Count, _Elem _Ch )
  {
  if ( _Count == 1 )
   _Traits :: assign ( * ( _Myptr ( ) + _Off ), _Ch );
  else
   _Traits :: assign ( _Myptr ( ) + _Off, _Count, _Ch );
  }

 void _Copy ( size_type _Newsize, size_type _Oldlen )
  {
  size_type _Newres = _Newsize | this -> _ALLOC_MASK;
  if ( max_size ( ) < _Newres )
   _Newres = _Newsize;
  else if ( this -> _Myres / 2 <= _Newres / 3 )
   ;
  else if ( this -> _Myres <= max_size ( ) - this -> _Myres / 2 )
   _Newres = this -> _Myres
    + this -> _Myres / 2;
  else
   _Newres = max_size ( );

  _Elem * _Ptr;
  try {
   _Ptr = this -> _Alval . allocate ( _Newres + 1 );
  } catch ( ... ) {
   _Newres = _Newsize;
   try {
    _Ptr = this -> _Alval . allocate ( _Newres + 1 );
   } catch ( ... ) {
   _Tidy ( true );
   throw;
   }
  }

  if ( 0 < _Oldlen )
   _Traits :: copy ( _Ptr, _Myptr ( ), _Oldlen );
  _Tidy ( true );
  this -> _Bx . _Ptr = _Ptr;
  this -> _Myres = _Newres;
  _Eos ( _Oldlen );
  }

 void _Eos ( size_type _Newsize )
  {
  _Traits :: assign ( _Myptr ( ) [ this -> _Mysize = _Newsize ], _Elem ( ) );
  }

 bool _Grow ( size_type _Newsize,
  bool _Trim = false )
  {
  if ( max_size ( ) < _Newsize )
   _Xlen ( );
  if ( this -> _Myres < _Newsize )
   _Copy ( _Newsize, this -> _Mysize );
  else if ( _Trim && _Newsize < this -> _BUF_SIZE )
   _Tidy ( true,
    _Newsize < this -> _Mysize ? _Newsize : this -> _Mysize );
  else if ( _Newsize == 0 )
   _Eos ( 0 );
  return ( 0 < _Newsize );
  }

 bool _Inside ( const _Elem * _Ptr )
  {
  if ( _Ptr == 0 || _Ptr < _Myptr ( ) || _Myptr ( ) + this -> _Mysize <= _Ptr )
   return ( false );
  else
   return ( true );
  }

 static size_type _Pdif ( const_iterator _P2,
  const_iterator _P1 )
  {
  return ( ( _P2 ) . _Ptr == 0 ? 0 : _P2 - _P1 );
  }

 void _Tidy ( bool _Built = false,
  size_type _Newsize = 0 )
  {
  if ( ! _Built )
   ;
  else if ( this -> _BUF_SIZE <= this -> _Myres )
   {
   _Elem * _Ptr = this -> _Bx . _Ptr;
   if ( 0 < _Newsize )
    _Traits :: copy ( this -> _Bx . _Buf, _Ptr, _Newsize );
   this -> _Alval . deallocate ( _Ptr, this -> _Myres + 1 );
   }
  this -> _Myres = this -> _BUF_SIZE - 1;
  _Eos ( _Newsize );
  }

 _Elem * _Myptr ( )
  {
  return ( this -> _BUF_SIZE <= this -> _Myres ? this -> _Bx . _Ptr
   : this -> _Bx . _Buf );
  }

 const _Elem * _Myptr ( ) const
  {
  return ( this -> _BUF_SIZE <= this -> _Myres ? this -> _Bx . _Ptr
   : this -> _Bx . _Buf );
  }

 __declspec ( noreturn ) void _Xlen ( ) const
  {
  _Xlength_error ( "string too long" );
  }

 __declspec ( noreturn ) void _Xran ( ) const
  {
  _Xout_of_range ( "invalid string position" );
  }
 };
#line 2025 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstring"
template< class _Elem, class 
#line 2026
_Traits, class 
#line 2027
_Alloc> const typename basic_string< _Elem, _Traits, _Alloc> ::size_type 
#line 2029
basic_string< _Elem, _Traits, _Alloc> ::npos = ((typename ::std::basic_string< _Elem, _Traits, typename _Alloc::template rebind< _Elem> ::other> ::size_type)(-1)); 
#line 2034
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_string < _Elem, _Traits, _Alloc > & _Left,
  basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 2043
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_string < _Elem, _Traits, _Alloc > & _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 _Left . swap ( _Right );
 }
#line 2052
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_string < _Elem, _Traits, _Alloc > && _Left,
  basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 _Right . swap ( _Left );
 }
#line 2062
typedef basic_string< char, char_traits< char> , allocator< char> >  string; 
#line 2064
typedef basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstring; 
#line 2068
typedef basic_string< unsigned short, char_traits< unsigned short> , allocator< unsigned short> >  u16string; 
#line 2070
typedef basic_string< unsigned, char_traits< unsigned> , allocator< unsigned> >  u32string; 
#line 2072 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstring"
}
#line 2074
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdexcept"
#pragma warning(push,3)
#line 2075 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xstring"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdexcept"
#pragma pack ( push, 8 )
#line 11
namespace std { 
#line 17
class logic_error : public exception { 
#line 21
public: typedef exception _Mybase; 
#line 23
explicit logic_error(const string &_Message) : exception(_Message.c_str()) 
#line 25
{ 
#line 26
} 
#line 28
explicit logic_error(const char *_Message) : exception(_Message) 
#line 30
{ 
#line 31
} 
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdexcept"
}; 
#line 45
class domain_error : public logic_error { 
#line 49
public: typedef logic_error _Mybase; 
#line 51
explicit domain_error(const string &_Message) : logic_error(_Message.c_str()) 
#line 53
{ 
#line 54
} 
#line 56
explicit domain_error(const char *_Message) : logic_error(_Message) 
#line 58
{ 
#line 59
} 
#line 70 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdexcept"
}; 
#line 73
class invalid_argument : public logic_error { 
#line 77
public: typedef logic_error _Mybase; 
#line 79
explicit invalid_argument(const string &_Message) : logic_error(_Message.c_str()) 
#line 81
{ 
#line 82
} 
#line 84
explicit invalid_argument(const char *_Message) : logic_error(_Message) 
#line 86
{ 
#line 87
} 
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdexcept"
}; 
#line 101
class length_error : public logic_error { 
#line 105
public: typedef logic_error _Mybase; 
#line 107
explicit length_error(const string &_Message) : logic_error(_Message.c_str()) 
#line 109
{ 
#line 110
} 
#line 112
explicit length_error(const char *_Message) : logic_error(_Message) 
#line 114
{ 
#line 115
} 
#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdexcept"
}; 
#line 129
class out_of_range : public logic_error { 
#line 133
public: typedef logic_error _Mybase; 
#line 135
explicit out_of_range(const string &_Message) : logic_error(_Message.c_str()) 
#line 137
{ 
#line 138
} 
#line 140
explicit out_of_range(const char *_Message) : logic_error(_Message) 
#line 142
{ 
#line 143
} 
#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdexcept"
}; 
#line 157
class runtime_error : public exception { 
#line 161
public: typedef exception _Mybase; 
#line 163
explicit runtime_error(const string &_Message) : exception(_Message.c_str()) 
#line 165
{ 
#line 166
} 
#line 168
explicit runtime_error(const char *_Message) : exception(_Message) 
#line 170
{ 
#line 171
} 
#line 182 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdexcept"
}; 
#line 185
class overflow_error : public runtime_error { 
#line 189
public: typedef runtime_error _Mybase; 
#line 191
explicit overflow_error(const string &_Message) : runtime_error(_Message.c_str()) 
#line 193
{ 
#line 194
} 
#line 196
explicit overflow_error(const char *_Message) : runtime_error(_Message) 
#line 198
{ 
#line 199
} 
#line 210 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdexcept"
}; 
#line 213
class underflow_error : public runtime_error { 
#line 217
public: typedef runtime_error _Mybase; 
#line 219
explicit underflow_error(const string &_Message) : runtime_error(_Message.c_str()) 
#line 221
{ 
#line 222
} 
#line 224
explicit underflow_error(const char *_Message) : runtime_error(_Message) 
#line 226
{ 
#line 227
} 
#line 238 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdexcept"
}; 
#line 241
class range_error : public runtime_error { 
#line 245
public: typedef runtime_error _Mybase; 
#line 247
explicit range_error(const string &_Message) : runtime_error(_Message.c_str()) 
#line 249
{ 
#line 250
} 
#line 252
explicit range_error(const char *_Message) : runtime_error(_Message) 
#line 254
{ 
#line 255
} 
#line 266 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\stdexcept"
}; 
#line 267
}
#pragma warning(pop)
#pragma pack ( pop )
#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ctype.h"
extern "C" { __declspec(dllimport) int __cdecl _isctype(int , int ); } 
#line 93
extern "C" { __declspec(dllimport) int __cdecl _isctype_l(int , int , _locale_t ); } 
#line 94
extern "C" { __declspec(dllimport) int __cdecl isalpha(int ); } 
#line 95
extern "C" { __declspec(dllimport) int __cdecl _isalpha_l(int , _locale_t ); } 
#line 96
extern "C" { __declspec(dllimport) int __cdecl isupper(int ); } 
#line 97
extern "C" { __declspec(dllimport) int __cdecl _isupper_l(int , _locale_t ); } 
#line 98
extern "C" { __declspec(dllimport) int __cdecl islower(int ); } 
#line 99
extern "C" { __declspec(dllimport) int __cdecl _islower_l(int , _locale_t ); } 
#line 100
extern "C" { __declspec(dllimport) int __cdecl isdigit(int ); } 
#line 101
extern "C" { __declspec(dllimport) int __cdecl _isdigit_l(int , _locale_t ); } 
#line 102
extern "C" { __declspec(dllimport) int __cdecl isxdigit(int ); } 
#line 103
extern "C" { __declspec(dllimport) int __cdecl _isxdigit_l(int , _locale_t ); } 
#line 104
extern "C" { __declspec(dllimport) int __cdecl isspace(int ); } 
#line 105
extern "C" { __declspec(dllimport) int __cdecl _isspace_l(int , _locale_t ); } 
#line 106
extern "C" { __declspec(dllimport) int __cdecl ispunct(int ); } 
#line 107
extern "C" { __declspec(dllimport) int __cdecl _ispunct_l(int , _locale_t ); } 
#line 108
extern "C" { __declspec(dllimport) int __cdecl isalnum(int ); } 
#line 109
extern "C" { __declspec(dllimport) int __cdecl _isalnum_l(int , _locale_t ); } 
#line 110
extern "C" { __declspec(dllimport) int __cdecl isprint(int ); } 
#line 111
extern "C" { __declspec(dllimport) int __cdecl _isprint_l(int , _locale_t ); } 
#line 112
extern "C" { __declspec(dllimport) int __cdecl isgraph(int ); } 
#line 113
extern "C" { __declspec(dllimport) int __cdecl _isgraph_l(int , _locale_t ); } 
#line 114
extern "C" { __declspec(dllimport) int __cdecl iscntrl(int ); } 
#line 115
extern "C" { __declspec(dllimport) int __cdecl _iscntrl_l(int , _locale_t ); } 
#line 116
extern "C" { __declspec(dllimport) int __cdecl toupper(int ); } 
#line 117
extern "C" { __declspec(dllimport) int __cdecl tolower(int ); } 
#line 118
extern "C" { __declspec(dllimport) int __cdecl _tolower(int ); } 
#line 119
extern "C" { __declspec(dllimport) int __cdecl _tolower_l(int , _locale_t ); } 
#line 120
extern "C" { __declspec(dllimport) int __cdecl _toupper(int ); } 
#line 121
extern "C" { __declspec(dllimport) int __cdecl _toupper_l(int , _locale_t ); } 
#line 122
extern "C" { __declspec(dllimport) int __cdecl __isascii(int ); } 
#line 123
extern "C" { __declspec(dllimport) int __cdecl __toascii(int ); } 
#line 124
extern "C" { __declspec(dllimport) int __cdecl __iscsymf(int ); } 
#line 125
extern "C" { __declspec(dllimport) int __cdecl __iscsym(int ); } 
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\locale.h"
#pragma pack ( push, 8 )
#line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\locale.h"
extern "C" { struct lconv { 
#line 56
char *decimal_point; 
#line 57
char *thousands_sep; 
#line 58
char *grouping; 
#line 59
char *int_curr_symbol; 
#line 60
char *currency_symbol; 
#line 61
char *mon_decimal_point; 
#line 62
char *mon_thousands_sep; 
#line 63
char *mon_grouping; 
#line 64
char *positive_sign; 
#line 65
char *negative_sign; 
#line 66
char int_frac_digits; 
#line 67
char frac_digits; 
#line 68
char p_cs_precedes; 
#line 69
char p_sep_by_space; 
#line 70
char n_cs_precedes; 
#line 71
char n_sep_by_space; 
#line 72
char p_sign_posn; 
#line 73
char n_sign_posn; 
#line 74
__wchar_t *_W_decimal_point; 
#line 75
__wchar_t *_W_thousands_sep; 
#line 76
__wchar_t *_W_int_curr_symbol; 
#line 77
__wchar_t *_W_currency_symbol; 
#line 78
__wchar_t *_W_mon_decimal_point; 
#line 79
__wchar_t *_W_mon_thousands_sep; 
#line 80
__wchar_t *_W_positive_sign; 
#line 81
__wchar_t *_W_negative_sign; 
#line 82
}; }
#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\locale.h"
extern "C" { __declspec(dllimport) int __cdecl _configthreadlocale(int ); } 
#line 108
extern "C" { __declspec(dllimport) char *__cdecl setlocale(int , const char * ); } 
#line 109
extern "C" { __declspec(dllimport) lconv *__cdecl localeconv(); } 
#line 110
extern "C" { __declspec(dllimport) _locale_t __cdecl _get_current_locale(); } 
#line 111
extern "C" { __declspec(dllimport) _locale_t __cdecl _create_locale(int , const char * ); } 
#line 112
extern "C" { __declspec(dllimport) void __cdecl _free_locale(_locale_t ); } 
#line 115
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _get_current_lo" "cale instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __get_current_locale(); } 
#line 116
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _create_locale " "instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __create_locale(int , const char * ); } 
#line 117
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _free_locale in" "stead. See online help for details.")) __declspec(dllimport) void __cdecl __free_locale(_locale_t ); } 
#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\locale.h"
#pragma pack ( pop )
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo.h"
#pragma pack ( push, 8 )
#line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo.h"
extern "C" { typedef 
#line 51
struct _Collvec { 
#line 53
unsigned long _Hand; 
#line 54
unsigned _Page; 
#line 55
} _Collvec; }
#line 63
extern "C" { typedef 
#line 57
struct _Ctypevec { 
#line 59
unsigned long _Hand; 
#line 60
unsigned _Page; 
#line 61
const short *_Table; 
#line 62
int _Delfl; 
#line 63
} _Ctypevec; }
#line 69
extern "C" { typedef 
#line 65
struct _Cvtvec { 
#line 67
unsigned long _Hand; 
#line 68
unsigned _Page; 
#line 69
} _Cvtvec; }
#line 72
extern "C" { __declspec(dllimport) _Collvec __cdecl _Getcoll(); } 
#line 73
extern "C" { __declspec(dllimport) _Ctypevec __cdecl _Getctype(); } 
#line 75
extern "C" { __declspec(dllimport) _Cvtvec __cdecl _Getcvt(); } 
#line 77
extern "C" { __declspec(dllimport) int __cdecl _Getdateorder(); } 
#line 83
extern "C" { __declspec(dllimport) int __cdecl _Mbrtowc(__wchar_t *, const char *, size_t, mbstate_t *, const _Cvtvec *); } 
#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo.h"
extern "C" { __declspec(dllimport) float __cdecl _Stof(const char *, char **, long); } 
#line 87
extern "C" { __declspec(dllimport) double __cdecl _Stod(const char *, char **, long); } 
#line 88
extern "C" { __declspec(dllimport) long double __cdecl _Stold(const char *, char **, long); } 
#line 90
extern "C" { __declspec(dllimport) int __cdecl _Strcoll(const char *, const char *, const char *, const char *, const _Collvec *); } 
#line 92
extern "C" { __declspec(dllimport) size_t __cdecl _Strxfrm(char * , char * , const char *, const char *, const _Collvec *); } 
#line 95
extern "C" { __declspec(dllimport) int __cdecl _Tolower(int, const _Ctypevec *); } 
#line 96
extern "C" { __declspec(dllimport) int __cdecl _Toupper(int, const _Ctypevec *); } 
#line 98
extern "C" { __declspec(dllimport) int __cdecl _Wcrtomb(char *, __wchar_t, mbstate_t *, const _Cvtvec *); } 
#line 100
extern "C" { __declspec(dllimport) int __cdecl _Wcscoll(const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *, const _Collvec *); } 
#line 102
extern "C" { __declspec(dllimport) size_t __cdecl _Wcsxfrm(__wchar_t * , __wchar_t * , const __wchar_t *, const __wchar_t *, const _Collvec *); } 
#line 106
extern "C" { __declspec(dllimport) short __cdecl _Getwctype(__wchar_t, const _Ctypevec *); } 
#line 107
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl _Getwctypes(const __wchar_t *, const __wchar_t *, short *, const _Ctypevec *); } 
#line 109
extern "C" { __declspec(dllimport) __wchar_t __cdecl _Towlower(__wchar_t, const _Ctypevec *); } 
#line 110
extern "C" { __declspec(dllimport) __wchar_t __cdecl _Towupper(__wchar_t, const _Ctypevec *); } 
#line 117 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo.h"
extern "C" { __declspec(dllimport) void *__cdecl _Gettnames(); } 
#line 118
extern "C" { __declspec(dllimport) char *__cdecl _Getdays(); } 
#line 119
extern "C" { __declspec(dllimport) char *__cdecl _Getmonths(); } 
#line 120
extern "C" { __declspec(dllimport) size_t __cdecl _Strftime(char *, size_t , const char *, const tm *, void *); } 
#line 129
__declspec(dllimport) _locale_t __cdecl _GetLocaleForCP(unsigned); 
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo"
#pragma warning(push,3)
#pragma warning(disable:4412)
#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo.h"
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo"
#pragma pack ( push, 8 )
#line 14
namespace std { 
#line 17
class __declspec(dllimport) _Timevec { 
#line 20
public: _Timevec(void *_Ptr = 0) : _Timeptr(_Ptr) 
#line 22
{ 
#line 23
} 
#line 25
_Timevec(const _Timevec &_Right) 
#line 26
{ 
#line 27
((*this) = _Right); 
#line 28
} 
#line 30
~_Timevec() 
#line 31
{ 
#line 32
free(_Timeptr); 
#line 33
} 
#line 35
_Timevec &operator=(const _Timevec &_Right) 
#line 36
{ 
#line 37
(_Timeptr) = (_Right._Timeptr); 
#line 38
(((_Timevec *)(&_Right))->_Timeptr) = (0); 
#line 39
return *this; 
#line 40
} 
#line 42
void *_Getptr() const 
#line 43
{ 
#line 44
return _Timeptr; 
#line 45
} 
#line 48
private: void *_Timeptr; 
#line 49
}; 
#line 53
#pragma warning(push)
#pragma warning(disable: 4412)
#line 56
class __declspec(dllimport) _Locinfo { 
#line 59
public: typedef ::_Collvec _Collvec; 
#line 60
typedef ::_Ctypevec _Ctypevec; 
#line 61
typedef ::_Cvtvec _Cvtvec; 
#line 62
typedef std::_Timevec _Timevec; 
#line 64
static void __cdecl _Locinfo_ctor(_Locinfo *, const char *); 
#line 66
static void __cdecl _Locinfo_ctor(_Locinfo *, int, const char *); 
#line 68
static void __cdecl _Locinfo_dtor(_Locinfo *); 
#line 69
static _Locinfo &__cdecl _Locinfo_Addcats(_Locinfo *, int, const char *); 
#line 72
_Locinfo(const char *_Pch = "C") : _Lock(0) 
#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo"
{ 
#line 77
if (_Pch == (0)) { 
#line 78
throw ((runtime_error)("bad locale name")); }  
#line 79
_Locinfo_ctor(this, _Pch); 
#line 80
} 
#line 82
_Locinfo(int _Cat, const char *_Pch) : _Lock(0) 
#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo"
{ 
#line 87
if (_Pch == (0)) { 
#line 88
throw ((runtime_error)("bad locale name")); }  
#line 89
_Locinfo_ctor(this, _Cat, _Pch); 
#line 90
} 
#line 92
~_Locinfo() 
#line 93
{ 
#line 94
_Locinfo_dtor(this); 
#line 95
} 
#line 98
_Locinfo &_Addcats(int _Cat, const char *_Pch) 
#line 99
{ 
#line 100
if (_Pch == (0)) { 
#line 101
throw ((runtime_error)("bad locale name")); }  
#line 102
return _Locinfo_Addcats(this, _Cat, _Pch); 
#line 103
} 
#line 106
const char *_Getname() const 
#line 107
{ 
#line 108
return (_Newlocname)._C_str(); 
#line 109
} 
#line 111
_Collvec _Getcoll() const 
#line 112
{ 
#line 113
return ::_Getcoll(); 
#line 114
} 
#line 116
_Ctypevec _Getctype() const 
#line 117
{ 
#line 118
return ::_Getctype(); 
#line 119
} 
#line 121
_Cvtvec _Getcvt() const 
#line 122
{ 
#line 123
return ::_Getcvt(); 
#line 124
} 
#line 126
const lconv *_Getlconv() const 
#line 127
{ 
#line 128
return localeconv(); 
#line 129
} 
#line 131
_Timevec _Gettnames() const 
#line 132
{ 
#line 133
return ((_Timevec)(::_Gettnames())); 
#line 134
} 
#line 136
const char *_Getdays() const 
#line 137
{ 
#line 138
const char *_Ptr = ::_Getdays(); 
#line 139
if (_Ptr != (0)) 
#line 140
{ 
#line 141
((((_Locinfo *)this)->_Days) = _Ptr); 
#line 142
free((void *)_Ptr); 
#line 143
}  
#line 144
return (!(_Days)._Empty()) ? (_Days)._C_str() : (":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday"); 
#line 147
} 
#line 149
const char *_Getmonths() const 
#line 150
{ 
#line 151
const char *_Ptr = ::_Getmonths(); 
#line 152
if (_Ptr != (0)) 
#line 153
{ 
#line 154
((((_Locinfo *)this)->_Months) = _Ptr); 
#line 155
free((void *)_Ptr); 
#line 156
}  
#line 157
return (!(_Months)._Empty()) ? (_Months)._C_str() : (":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:De" "cember"); 
#line 162
} 
#line 164
const char *_Getfalse() const 
#line 165
{ 
#line 166
return "false"; 
#line 167
} 
#line 169
const char *_Gettrue() const 
#line 170
{ 
#line 171
return "true"; 
#line 172
} 
#line 174
int _Getdateorder() const 
#line 175
{ 
#line 176
return ::_Getdateorder(); 
#line 177
} 
#line 189
private: _Lockit _Lock; 
#line 192 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo"
_Yarn< char>  _Days; 
#line 193
_Yarn< char>  _Months; 
#line 194
_Yarn< char>  _Oldlocname; 
#line 195
_Yarn< char>  _Newlocname; 
#line 196
}; 
#pragma warning(pop)
#line 200
template < class _Elem > inline
 int __cdecl _LStrcoll ( const _Elem * _First1, const _Elem * _Last1,
  const _Elem * _First2, const _Elem * _Last2,
   const _Locinfo :: _Collvec * )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 )
  if ( * _First1 < * _First2 )
   return ( - 1 );
  else if ( * _First2 < * _First1 )
   return ( + 1 );
 return ( _First2 != _Last2 ? - 1 : _First1 != _Last1 ? + 1 : 0 );
 }
#line 214
template<> inline int __cdecl _LStrcoll(const char *_First1, const char *_Last1, const char *
#line 215
_First2, const char *_Last2, const _Locinfo::_Collvec *
#line 216
_Vector) 
#line 217
{ 
#line 218
return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector); 
#line 219
} 
#line 222
template<> inline int __cdecl _LStrcoll(const __wchar_t *_First1, const __wchar_t *_Last1, const __wchar_t *
#line 223
_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
#line 224
_Vector) 
#line 225
{ 
#line 226
return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector); 
#line 227
} 
#line 230
template < class _Elem > inline
 size_t __cdecl _LStrxfrm ( _Elem * _First1, _Elem * _Last1,
  const _Elem * _First2, const _Elem * _Last2,
   const _Locinfo :: _Collvec * )
 {
 size_t _Count = _Last2 - _First2;
 if ( _Count <= ( size_t ) ( _Last1 - _First1 ) )
  :: memcpy_s ( ( _First1 ), ( ( _Last1 - _First1 ) * sizeof ( _Elem ) ), ( _First2 ), ( _Count * sizeof ( _Elem ) ) );

 return ( _Count );
 }
#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo"
template<> inline size_t __cdecl _LStrxfrm(char *
#line 244
_First1, char *
#line 245
_Last1, const char *
#line 246
_First2, const char *_Last2, const _Locinfo::_Collvec *
#line 247
_Vector) 
#line 248
{ 
#line 249
return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
#line 250
} 
#line 253
template<> inline size_t __cdecl _LStrxfrm(__wchar_t *
#line 254
_First1, __wchar_t *
#line 255
_Last1, const __wchar_t *
#line 256
_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
#line 257
_Vector) 
#line 258
{ 
#line 259
return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
#line 260
} 
#line 261
}
#line 263
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xdebug"
#pragma warning(push,3)
#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocinfo"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xdebug"
#pragma pack ( push, 8 )
#line 16
namespace std { 
#line 17
struct _DebugHeapTag_t { 
#line 19
int _Type; 
#line 20
}; 
#line 21
}
#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xdebug"
#pragma warning(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
#pragma warning(push,3)
#line 19
#pragma warning(disable: 4412)
#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xdebug"
#pragma pack ( pop )
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
#pragma pack ( push, 8 )
#line 21
namespace std { 
#line 23
template< class _Dummy> 
#line 24
class _Locbase { 
#line 27
public: static const int collate = ((1 << 1) >> 1); 
#line 28
static const int ctype = ((1 << 2) >> 1); 
#line 29
static const int monetary = ((1 << 3) >> 1); 
#line 30
static const int numeric = ((1 << 4) >> 1); 
#line 31
static const int time = ((1 << 5) >> 1); 
#line 32
static const int messages = ((1 << 6) >> 1); 
#line 33
static const int all = (((1 << 7) >> 1) - 1); 
#line 34
static const int none = 0; 
#line 35
}; 
#line 37
template< class _Dummy> const int 
#line 38
_Locbase< _Dummy> ::collate; 
#line 39
template< class _Dummy> const int 
#line 40
_Locbase< _Dummy> ::ctype; 
#line 41
template< class _Dummy> const int 
#line 42
_Locbase< _Dummy> ::monetary; 
#line 43
template< class _Dummy> const int 
#line 44
_Locbase< _Dummy> ::numeric; 
#line 45
template< class _Dummy> const int 
#line 46
_Locbase< _Dummy> ::time; 
#line 47
template< class _Dummy> const int 
#line 48
_Locbase< _Dummy> ::messages; 
#line 49
template< class _Dummy> const int 
#line 50
_Locbase< _Dummy> ::all; 
#line 51
template< class _Dummy> const int 
#line 52
_Locbase< _Dummy> ::none; 
#line 55
class locale; 
#line 56
template < class _Facet >
 const _Facet & __cdecl use_facet ( const locale & );
#line 59
class locale : public _Locbase< int>  { 
#line 63
public: typedef int category; 
#line 66
class __declspec(dllimport) id { 
#line 69
public: id(size_t _Val = 0) : _Id(_Val) 
#line 71
{ 
#line 72
} 
#line 74
operator size_t() 
#line 75
{ 
#line 76
if ((_Id) == (0)) 
#line 77
{ 
#line 78
{ _Lockit _Lock(0); 
#line 79
if ((_Id) == (0)) { 
#line 80
(_Id) = (++_Id_cnt); }  
#line 81
} 
#line 82
}  
#line 83
return _Id; 
#line 84
} 
#line 87
private: size_t _Id; 
#line 89
static int _Id_cnt; 
#line 91
id(const id &); 
#line 92
id &operator=(const id &); 
#line 93
}; 
#line 95
class _Locimp; 
#line 98
class facet { 
#line 100
friend class locale; 
#line 101
friend class _Locimp; 
#line 104
public: __declspec(dllimport) static size_t __cdecl _Getcat(const facet ** = 0, const locale * = 0) 
#line 106
{ 
#line 107
return (size_t)(-1); 
#line 108
} 
#line 110
__declspec(dllimport) void _Incref() 
#line 111
{ 
#line 112
{ _Lockit _Lock(0); 
#line 113
if ((_Refs) < ((size_t)(-1))) { 
#line 114
++(_Refs); }  
#line 115
} 
#line 116
} 
#line 118
__declspec(dllimport) facet *_Decref() 
#line 119
{ 
#line 120
{ _Lockit _Lock(0); 
#line 121
if (((0) < (_Refs)) && ((_Refs) < ((size_t)(-1)))) { 
#line 122
--(_Refs); }  
#line 123
return ((_Refs) == (0)) ? this : (0); 
#line 124
} 
#line 125
} 
#line 127
void _Register() 
#line 128
{ 
#line 133 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
_Facet_Register(this); 
#line 135 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
} 
#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
__declspec(dllimport) virtual ~facet() 
#line 164
{ 
#line 165
} 
#line 168
protected: __declspec(dllimport) explicit facet(size_t _Initrefs = 0) : _Refs(_Initrefs) 
#line 170
{ 
#line 171
} 
#line 174
private: size_t _Refs; 
#line 176
facet(const facet &); 
#line 178
facet &operator=(const facet &); 
#line 184 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
static void __cdecl _Facet_Register(facet *); 
#line 186 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
}; 
#line 189
#pragma warning(push)
#pragma warning(disable: 4275)
#line 192
class __declspec(dllimport) _Locimp : public facet { 
#line 196
protected: virtual ~_Locimp() 
#line 197
{ 
#line 198
_Locimp_dtor(this); 
#line 199
} 
#line 202
private: static void __cdecl _Locimp_dtor(_Locimp *); 
#line 203
static void __cdecl _Locimp_Addfac(_Locimp *, facet *, size_t); 
#line 205
static void __cdecl _Locimp_ctor(_Locimp *, const _Locimp &); 
#line 207
friend class locale; 
#line 209
_Locimp(bool _Transparent = false) : facet(1), _Facetvec(0), _Facetcount(0), _Catmask(none), _Xparent(_Transparent), _Name("*") 
#line 213
{ 
#line 214
} 
#line 216
_Locimp(const _Locimp &_Right) : facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask), _Xparent(_Right._Xparent), _Name((_Right._Name).c_str()) 
#line 220
{ 
#line 221
_Locimp_ctor(this, _Right); 
#line 222
} 
#line 224
void _Addfac(facet *_Pfacet, size_t _Id) 
#line 225
{ 
#line 226
_Locimp_Addfac(this, _Pfacet, _Id); 
#line 227
} 
#line 229
static _Locimp *__cdecl _Makeloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 232
static void __cdecl _Makewloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 236
static void __cdecl _Makeushloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 240 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
static void __cdecl _Makexloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 243
facet **_Facetvec; 
#line 244
size_t _Facetcount; 
#line 245
category _Catmask; 
#line 246
bool _Xparent; 
#line 247
_Yarn< char>  _Name; 
#line 249
static _Locimp *_Clocptr; 
#line 252
_Locimp &operator=(const _Locimp &); 
#line 253
}; 
#line 255
#pragma warning(pop)
#line 257
template < class _Elem,
  class _Traits,
  class _Alloc >
  bool operator ( ) ( const basic_string < _Elem, _Traits, _Alloc > & _Left,
   const basic_string < _Elem, _Traits, _Alloc > & _Right ) const
  {
  const :: std :: collate < _Elem > & _Coll_fac =
   :: std :: use_facet < :: std :: collate < _Elem > > ( * this );

  return ( _Coll_fac . compare ( _Left . c_str ( ), _Left . c_str ( ) + _Left . size ( ),
   _Right . c_str ( ), _Right . c_str ( ) + _Right . size ( ) ) < 0 );
  }
#line 270
template < class _Facet >
  locale combine ( const locale & _Loc ) const
  {
  _Facet * _Facptr;

  try {
   _Facptr = ( _Facet * ) & :: std :: use_facet < _Facet > ( _Loc );
  } catch ( ... ) {
   _Xruntime_error ( "locale::combine facet missing" );
  }

  _Locimp * _Newimp = new _Locimp ( * _Ptr );
  _Newimp -> _Addfac ( _Facptr, _Facet :: id );
  _Newimp -> _Catmask = 0;
  _Newimp -> _Name = "*";
  return ( locale ( _Newimp ) );
  }
#line 288
template < class _Facet >
  locale ( const locale & _Loc, const _Facet * _Facptr )
   : _Ptr ( new _Locimp ( * _Loc . _Ptr ) )
  {
  if ( _Facptr != 0 )
   {
   _Ptr -> _Addfac ( ( _Facet * ) _Facptr, _Facet :: id );
   if ( _Facet :: _Getcat ( ) != ( size_t ) ( - 1 ) )
    {
    _Ptr -> _Catmask = 0;
    _Ptr -> _Name = "*";
    }
   }
  }
#line 303
locale(_Uninitialized) 
#line 304
{ 
#line 305
} 
#line 307
locale(const locale &_Right) throw() : _Ptr(_Right._Ptr) 
#line 309
{ 
#line 310
(_Ptr)->_Incref(); 
#line 311
} 
#line 313
locale() throw() : _Ptr(_Init()) 
#line 315
{ 
#line 316
_Getgloballocale()->_Incref(); 
#line 317
} 
#line 319
locale(const locale &_Loc, const locale &_Other, category 
#line 320
_Cat) : _Ptr(new _Locimp(*(_Loc._Ptr))) 
#line 322
{ 
#line 323
try { 
#line 324
{ _Locinfo _Lobj((_Loc._Ptr)->_Catmask, ((_Loc._Ptr)->_Name).c_str()); 
#line 325
_Locimp::_Makeloc(_Lobj._Addcats(_Cat & ((_Other._Ptr)->_Catmask), ((_Other._Ptr)->_Name).c_str()), _Cat, _Ptr, &_Other); 
#line 327
} 
#line 328
} catch (...) { 
#line 329
delete (_Ptr)->_Decref(); 
#line 330
throw; 
#line 331
}  
#line 332
} 
#line 334
explicit locale(const char *_Locname, category 
#line 335
_Cat = all) : _Ptr(new _Locimp) 
#line 337
{ 
#line 338
try { 
#line 339
_Init(); 
#line 340
{ _Locinfo _Lobj(_Cat, _Locname); 
#line 341
if (this->_Badname(_Lobj)) { 
#line 342
_Xruntime_error("bad locale name"); }  
#line 343
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0); 
#line 344
} 
#line 345
} catch (...) { 
#line 346
delete (_Ptr)->_Decref(); 
#line 347
throw; 
#line 348
}  
#line 349
} 
#line 351
locale(const locale &_Loc, const char *_Locname, category 
#line 352
_Cat) : _Ptr(new _Locimp(*(_Loc._Ptr))) 
#line 354
{ 
#line 355
try { 
#line 356
{ _Locinfo _Lobj((_Loc._Ptr)->_Catmask, ((_Loc._Ptr)->_Name).c_str()); 
#line 357
bool _Hadname = !this->_Badname(_Lobj); 
#line 358
_Lobj._Addcats(_Cat, _Locname); 
#line 360
if (_Hadname && this->_Badname(_Lobj)) { 
#line 361
_Xruntime_error("bad locale name"); }  
#line 362
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0); 
#line 363
} 
#line 364
} catch (...) { 
#line 365
delete (_Ptr)->_Decref(); 
#line 366
throw; 
#line 367
}  
#line 368
} 
#line 371
explicit locale(const string &_Str, category 
#line 372
_Cat = all) : _Ptr(new _Locimp) 
#line 374
{ 
#line 375
try { 
#line 376
_Init(); 
#line 377
_Locinfo _Lobj(_Cat, _Str.c_str()); 
#line 379
if (this->_Badname(_Lobj)) { 
#line 380
_Xruntime_error("bad locale name"); }  
#line 381
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0); 
#line 382
} catch (...) { 
#line 383
delete (_Ptr)->_Decref(); 
#line 384
throw; 
#line 385
}  
#line 386
} 
#line 388
locale(const locale &_Loc, const string &_Str, category 
#line 389
_Cat) : _Ptr(new _Locimp(*(_Loc._Ptr))) 
#line 391
{ 
#line 392
try { 
#line 393
_Locinfo _Lobj((_Loc._Ptr)->_Catmask, ((_Loc._Ptr)->_Name).c_str()); 
#line 394
bool _Hadname = !this->_Badname(_Lobj); 
#line 395
_Lobj._Addcats(_Cat, _Str.c_str()); 
#line 397
if (_Hadname && this->_Badname(_Lobj)) { 
#line 398
_Xruntime_error("bad locale name"); }  
#line 399
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0); 
#line 400
} catch (...) { 
#line 401
delete (_Ptr)->_Decref(); 
#line 402
throw; 
#line 403
}  
#line 404
} 
#line 408 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
~locale() throw() 
#line 409
{ 
#line 410
if ((_Ptr) != (0)) { 
#line 411
delete (_Ptr)->_Decref(); }  
#line 412
} 
#line 414
locale &operator=(const locale &_Right) throw() 
#line 415
{ 
#line 416
if ((_Ptr) != (_Right._Ptr)) 
#line 417
{ 
#line 418
delete (_Ptr)->_Decref(); 
#line 419
(_Ptr) = (_Right._Ptr); 
#line 420
(_Ptr)->_Incref(); 
#line 421
}  
#line 422
return *this; 
#line 423
} 
#line 425
string name() const 
#line 426
{ 
#line 427
return ((_Ptr)->_Name).c_str(); 
#line 428
} 
#line 430
const char *c_str() const 
#line 431
{ 
#line 432
return ((_Ptr)->_Name).c_str(); 
#line 433
} 
#line 435
const facet *_Getfacet(size_t _Id) const 
#line 436
{ 
#line 437
const facet *_Facptr = (_Id < ((_Ptr)->_Facetcount)) ? (((_Ptr)->_Facetvec)[_Id]) : (0); 
#line 439
if ((_Facptr != (0)) || (!((_Ptr)->_Xparent))) { 
#line 440
return _Facptr; } else 
#line 442
{ 
#line 443
_Locimp *_Ptr = _Getgloballocale(); 
#line 444
return (_Id < (_Ptr->_Facetcount)) ? ((_Ptr->_Facetvec)[_Id]) : (0); 
#line 447
}  
#line 448
} 
#line 450
bool operator==(const locale &_Loc) const 
#line 451
{ 
#line 452
return ((_Ptr) == (_Loc._Ptr)) || (((this->name()).compare("*") != 0) && ((this->name()).compare(_Loc.name()) == 0)); 
#line 454
} 
#line 456
bool operator!=(const locale &_Right) const 
#line 457
{ 
#line 458
return !((*this) == _Right); 
#line 459
} 
#line 461
__declspec(dllimport) static const locale &__cdecl classic(); 
#line 463
__declspec(dllimport) static locale __cdecl global(const locale &); 
#line 465
__declspec(dllimport) static locale __cdecl empty(); 
#line 468
private: locale(_Locimp *_Ptrimp) : _Ptr(_Ptrimp) 
#line 470
{ 
#line 471
} 
#line 473
__declspec(dllimport) static _Locimp *__cdecl _Init(); 
#line 474
__declspec(dllimport) static _Locimp *__cdecl _Getgloballocale(); 
#line 475
__declspec(dllimport) static void __cdecl _Setgloballocale(void *); 
#line 477
bool _Badname(const _Locinfo &_Lobj) 
#line 478
{ 
#line 479
return ::strcmp(_Lobj._Getname(), "*") == 0; 
#line 480
} 
#line 482
_Locimp *_Ptr; 
#line 483
}; 
#line 486
template< class _Facet> 
#line 487
struct _Facetptr { 
#line 489
static const locale::facet *_Psave; 
#line 490
}; 
#line 492
template< class _Facet> const locale::facet *
#line 494
_Facetptr< _Facet> ::_Psave = (0); 
#line 501
template < class _Facet > inline
 const _Facet & __cdecl use_facet ( const locale & _Loc )

 {
 { :: std :: _Lockit _Lock ( 0 );
  const locale :: facet * _Psave =
   _Facetptr < _Facet > :: _Psave;

  size_t _Id = _Facet :: id;
  const locale :: facet * _Pf = _Loc . _Getfacet ( _Id );

  if ( _Pf != 0 )
   ;
  else if ( _Psave != 0 )
   _Pf = _Psave;
  else if ( _Facet :: _Getcat ( & _Psave, & _Loc ) == ( size_t ) ( - 1 ) )



   throw bad_cast ( );





  else
   {
   _Pf = _Psave;
   _Facetptr < _Facet > :: _Psave = _Psave;

   locale :: facet * _Pfmod = ( _Facet * ) _Psave;
   _Pfmod -> _Incref ( );
   _Pfmod -> _Register ( );
   }

  return ( ( const _Facet & ) ( * _Pf ) );
 }
 }
#line 541 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
template < class _Elem,
 class _InIt > inline
 int __cdecl _Getloctxt ( _InIt & _First, _InIt & _Last, size_t _Numfields,
  const _Elem * _Ptr )
 {
 for ( size_t _Off = 0; _Ptr [ _Off ] != ( _Elem ) 0; ++ _Off )
  if ( _Ptr [ _Off ] == _Ptr [ 0 ] )
   ++ _Numfields;
 string _Str ( _Numfields, '\000' );

 int _Ans = - 2;
 for ( size_t _Column = 1;; ++ _Column, ++ _First, _Ans = - 1 )
  {
  bool _Prefix = false;
  size_t _Off = 0;
  size_t _Field = 0;

  for (; _Field < _Numfields; ++ _Field )
   {
   for (; _Ptr [ _Off ] != ( _Elem ) 0 && _Ptr [ _Off ] != _Ptr [ 0 ]; ++ _Off )
    ;

   if ( _Str [ _Field ] != '\000' )
    _Off += _Str [ _Field ];
   else if ( _Ptr [ _Off += _Column ] == _Ptr [ 0 ]
    || _Ptr [ _Off ] == ( _Elem ) 0 )
    {
    _Str [ _Field ] = ( char ) ( _Column < 127
     ? _Column : 127 );
    _Ans = ( int ) _Field;
    }
   else if ( _First == _Last || _Ptr [ _Off ] != * _First )
    _Str [ _Field ] = ( char ) ( _Column < 127
     ? _Column : 127 );
   else
    _Prefix = true;
   }

  if ( ! _Prefix || _First == _Last )
   break;
  }
 return ( _Ans );
 }
#line 589
template < class _Elem > inline
 char __cdecl _Maklocbyte ( _Elem _Char,
  const _Locinfo :: _Cvtvec & )
 {
 return ( ( char ) ( unsigned char ) _Char );
 }
#line 597
template<> inline char __cdecl _Maklocbyte(__wchar_t _Char, const _Locinfo::_Cvtvec &
#line 598
_Cvt) 
#line 599
{ 
#line 600
char _Byte = '\000'; 
#line 601
mbstate_t _Mbst1 = 0; 
#line 602
_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt); 
#line 603
return _Byte; 
#line 604
} 
#line 608
template<> inline char __cdecl _Maklocbyte(unsigned short _Char, const _Locinfo::_Cvtvec &
#line 609
_Cvt) 
#line 610
{ 
#line 611
char _Byte = '\000'; 
#line 612
mbstate_t _Mbst1 = 0; 
#line 613
_Wcrtomb(&_Byte, (__wchar_t)_Char, &_Mbst1, &_Cvt); 
#line 614
return _Byte; 
#line 615
} 
#line 622 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
template < class _Elem > inline
 _Elem __cdecl _Maklocchr ( char _Byte, _Elem *,
  const _Locinfo :: _Cvtvec & )
 {
 return ( ( _Elem ) ( unsigned char ) _Byte );
 }
#line 630
template<> inline __wchar_t __cdecl _Maklocchr(char _Byte, __wchar_t *, const _Locinfo::_Cvtvec &
#line 631
_Cvt) 
#line 632
{ 
#line 633
__wchar_t _Wc = L'\x0'; 
#line 634
mbstate_t _Mbst1 = 0; 
#line 635
_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt); 
#line 636
return _Wc; 
#line 637
} 
#line 641
template<> inline unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *, const _Locinfo::_Cvtvec &
#line 642
_Cvt) 
#line 643
{ 
#line 644
unsigned short _Wc = ((unsigned short)0); 
#line 645
mbstate_t _Mbst1 = 0; 
#line 646
_Mbrtowc((__wchar_t *)(&_Wc), &_Byte, 1, &_Mbst1, &_Cvt); 
#line 647
return _Wc; 
#line 648
} 
#line 655 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
template < class _Elem > inline
 _Elem * __cdecl _Maklocstr ( const char * _Ptr, _Elem *,
  const _Locinfo :: _Cvtvec & )
 {
 size_t _Count = :: strlen ( _Ptr ) + 1;
 _Elem * _Ptrdest = new _Elem [ _Count ];

 #pragma warning(push)
 #pragma warning(disable: 6011)
 for ( _Elem * _Ptrnext = _Ptrdest; 0 < _Count; -- _Count, ++ _Ptrnext, ++ _Ptr )
  * _Ptrnext = ( _Elem ) ( unsigned char ) * _Ptr;
 #pragma warning(pop)

 return ( _Ptrdest );
 }
#line 672
template<> inline __wchar_t *__cdecl _Maklocstr(const char *_Ptr, __wchar_t *, const _Locinfo::_Cvtvec &
#line 673
_Cvt) 
#line 674
{ 
#line 675
size_t _Count, _Count1; 
#line 676
size_t _Wchars; 
#line 677
const char *_Ptr1; 
#line 678
int _Bytes; 
#line 679
__wchar_t _Wc; 
#line 680
mbstate_t _Mbst1 = 0; 
#line 682
_Count1 = (::strlen(_Ptr) + (1)); 
#line 683
for (((_Count = _Count1), (_Wchars = (0))), (_Ptr1 = _Ptr); (0) < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) { 
#line 685
if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) { 
#line 686
break; }  }  
#line 687
++_Wchars; 
#line 689
__wchar_t *_Ptrdest = new __wchar_t [_Wchars]; 
#line 690
__wchar_t *_Ptrnext = _Ptrdest; 
#line 691
mbstate_t _Mbst2 = 0; 
#line 693
#pragma warning(push)
#pragma warning(disable: 6011)
for (; (0) < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) { 
#line 697
if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) { 
#line 698
break; }  }  
#line 699
(*_Ptrnext) = L'\x0'; 
#pragma warning(pop)
#line 702
return _Ptrdest; 
#line 703
} 
#line 707
template<> inline unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *, const _Locinfo::_Cvtvec &
#line 708
_Cvt) 
#line 709
{ 
#line 710
size_t _Count, _Count1; 
#line 711
size_t _Wchars; 
#line 712
const char *_Ptr1; 
#line 713
int _Bytes; 
#line 714
unsigned short _Wc; 
#line 715
mbstate_t _Mbst1 = 0; 
#line 717
_Count1 = (::strlen(_Ptr) + (1)); 
#line 718
for (((_Count = _Count1), (_Wchars = (0))), (_Ptr1 = _Ptr); (0) < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) { 
#line 720
if ((_Bytes = _Mbrtowc((__wchar_t *)(&_Wc), _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) { 
#line 722
break; }  }  
#line 723
++_Wchars; 
#line 725
__wchar_t *_Ptrdest = new __wchar_t [_Wchars]; 
#line 726
__wchar_t *_Ptrnext = _Ptrdest; 
#line 727
mbstate_t _Mbst2 = 0; 
#line 728
for (; (0) < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) { 
#line 730
if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) { 
#line 731
break; }  }  
#line 732
(*_Ptrnext) = L'\x0'; 
#line 733
return (unsigned short *)_Ptrdest; 
#line 734
} 
#line 738 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
#pragma warning(push)
#pragma warning(disable: 4275)
#line 741
class __declspec(dllimport) codecvt_base : public locale::facet { 
#line 746
public: enum { 
#line 747
ok, partial, error, noconv}; 
#line 748
typedef int result; 
#line 750
codecvt_base(size_t _Refs = 0) : locale::facet(_Refs) 
#line 752
{ 
#line 753
} 
#line 755
bool always_noconv() const throw() 
#line 756
{ 
#line 757
return this->do_always_noconv(); 
#line 758
} 
#line 760
int max_length() const throw() 
#line 761
{ 
#line 762
return this->do_max_length(); 
#line 763
} 
#line 765
int encoding() const throw() 
#line 766
{ 
#line 767
return this->do_encoding(); 
#line 768
} 
#line 770
virtual ~codecvt_base() 
#line 771
{ 
#line 772
} 
#line 775
protected: virtual bool do_always_noconv() const throw() 
#line 776
{ 
#line 777
return true; 
#line 778
} 
#line 780
virtual int do_max_length() const throw() 
#line 781
{ 
#line 782
return 1; 
#line 783
} 
#line 785
virtual int do_encoding() const throw() 
#line 786
{ 
#line 787
return 1; 
#line 788
} 
#line 789
}; 
#line 791
#pragma warning(pop)
#line 794
template < class _Elem,
 class _Byte,
 class _Statype >
 class codecvt
  : public codecvt_base
 {
public :
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in ( _Statype & _State,
  const _Byte * _First1, const _Byte * _Last1, const _Byte * & _Mid1,
  _Elem * _First2, _Elem * _Last2, _Elem * & _Mid2 ) const
  {
  return ( do_in ( _State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 ) );
  }

 result out ( _Statype & _State,
  const _Elem * _First1, const _Elem * _Last1, const _Elem * & _Mid1,
  _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const
  {
  return ( do_out ( _State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 ) );
  }

 result unshift ( _Statype & _State,
  _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const
  {
  return ( do_unshift ( _State, _First2, _Last2, _Mid2 ) );
  }

 int length ( const _Statype & _State, const _Byte * _First1,
  const _Byte * _Last1, size_t _Count ) const
  {
  return ( do_length ( _State, _First1, _Last1, _Count ) );
  }

  static locale :: id id;

 explicit codecvt ( size_t _Refs = 0 )
  : codecvt_base ( _Refs )
  {
  _Init ( _Locinfo ( ) );
  }

  codecvt ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : codecvt_base ( _Refs )
  {
  _Init ( _Lobj );
  }

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new codecvt < _Elem, _Byte, _Statype > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 2 );
  }

protected :
 virtual ~ codecvt ( )
  {
  }

 void _Init ( const _Locinfo & )
  {
  }

 virtual result do_in ( _Statype &,
  const _Byte * _First1, const _Byte *, const _Byte * & _Mid1,
  _Elem * _First2, _Elem *, _Elem * & _Mid2 ) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  return ( noconv );
  }

 virtual result do_out ( _Statype &,
  const _Elem * _First1, const _Elem *, const _Elem * & _Mid1,
  _Byte * _First2, _Byte *, _Byte * & _Mid2 ) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  return ( noconv );
  }

 virtual result do_unshift ( _Statype &,
  _Byte * _First2, _Byte *, _Byte * & _Mid2 ) const
  {
  _Mid2 = _First2;
  return ( noconv );
  }

 virtual int do_length ( const _Statype &, const _Byte * _First1,
  const _Byte * _Last1, size_t _Count ) const
  {
  return ( ( int ) ( _Count < ( size_t ) ( _Last1 - _First1 )
   ? _Count : _Last1 - _First1 ) );
  }
 };
#line 897
template< class _Elem, class 
#line 898
_Byte, class 
#line 899
_Statype> locale::id 
#line 900
codecvt< _Elem, _Byte, _Statype> ::id; 
#line 1503 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
template<> class __declspec(dllimport) codecvt< __wchar_t, char, int>  : public codecvt_base { 
#line 1507
public: typedef __wchar_t _Elem; 
#line 1508
typedef char _Byte; 
#line 1509
typedef _Mbstatet _Statype; 
#line 1510
typedef _Elem intern_type; 
#line 1511
typedef _Byte extern_type; 
#line 1512
typedef _Statype state_type; 
#line 1514
result in(_Statype &_State, const _Byte *
#line 1515
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1516
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1517
{ 
#line 1518
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1520
} 
#line 1522
result out(_Statype &_State, const _Elem *
#line 1523
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1524
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1525
{ 
#line 1526
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1528
} 
#line 1530
result unshift(_Statype &_State, _Byte *
#line 1531
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1532
{ 
#line 1533
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 1535
} 
#line 1537
int length(const _Statype &_State, const _Byte *_First1, const _Byte *
#line 1538
_Last1, size_t _Count) const 
#line 1539
{ 
#line 1540
return this->do_length(_State, _First1, _Last1, _Count); 
#line 1541
} 
#line 1543
static locale::id id; 
#line 1545
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) 
#line 1547
{ 
#line 1548
{ _Locinfo _Lobj; 
#line 1549
this->_Init(_Lobj); 
#line 1550
} 
#line 1551
} 
#line 1553
codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs) 
#line 1555
{ 
#line 1556
this->_Init(_Lobj); 
#line 1557
} 
#line 1559
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 1560
_Ploc = 0) 
#line 1561
{ 
#line 1562
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
#line 1563
(*_Ppf) = (new std::codecvt< __wchar_t, char, int> (((_Locinfo)(_Ploc->c_str())))); }  
#line 1565
return 2; 
#line 1566
} 
#line 1569
protected: virtual ~codecvt() 
#line 1570
{ 
#line 1571
} 
#line 1573
void _Init(const _Locinfo &_Lobj) 
#line 1574
{ 
#line 1575
(_Cvt) = _Lobj._Getcvt(); 
#line 1576
} 
#line 1578
virtual result do_in(_Statype &_State, const _Byte *
#line 1579
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1580
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1581
{ 
#line 1582
; 
#line 1583
; 
#line 1584
(_Mid1 = _First1), (_Mid2 = _First2); 
#line 1585
result _Ans = (_Mid1 == _Last1) ? ok : partial; 
#line 1586
int _Bytes; 
#line 1588
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1589
switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1, &_State, &(_Cvt))) 
#line 1591
{ 
#line 1592
case -2:  
#line 1593
_Mid1 = _Last1; 
#line 1594
return _Ans; 
#line 1596
case -1:  
#line 1597
return error; 
#line 1599
case 0:  
#line 1600
if ((*_Mid2) == ((_Elem)0)) { 
#line 1601
_Bytes = (((int)::strlen(_Mid1)) + 1); }  
#line 1604
default:  
#line 1605
if (_Bytes == (-3)) { 
#line 1606
_Bytes = 0; }  
#line 1607
_Mid1 += _Bytes; 
#line 1608
++_Mid2; 
#line 1609
_Ans = (ok); 
#line 1610
}  }  
#line 1611
return _Ans; 
#line 1612
} 
#line 1614
virtual result do_out(_Statype &_State, const _Elem *
#line 1615
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1616
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1617
{ 
#line 1618
; 
#line 1619
; 
#line 1620
(_Mid1 = _First1), (_Mid2 = _First2); 
#line 1621
result _Ans = (_Mid1 == _Last1) ? ok : partial; 
#line 1622
int _Bytes; 
#line 1624
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1625
if (((int)___mb_cur_max_func()) <= (_Last2 - _Mid2)) { 
#line 1626
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 1628
return error; } else { 
#line 1630
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); }  } else 
#line 1632
{ 
#line 1633
_Byte _Buf[5]; 
#line 1634
_Statype _Stsave = _State; 
#line 1636
if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 1638
return error; } else { 
#line 1639
if ((_Last2 - _Mid2) < _Bytes) 
#line 1640
{ 
#line 1641
_State = _Stsave; 
#line 1642
return _Ans; 
#line 1643
} else 
#line 1645
{ 
#line 1646
::memcpy(_Mid2, _Buf, _Bytes); 
#line 1647
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); 
#line 1648
}  }  
#line 1649
}  }  
#line 1650
return _Ans; 
#line 1651
} 
#line 1653
virtual result do_unshift(_Statype &_State, _Byte *
#line 1654
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1655
{ 
#line 1656
; 
#line 1657
_Mid2 = _First2; 
#line 1658
result _Ans = (ok); 
#line 1659
int _Bytes; 
#line 1660
_Byte _Buf[5]; 
#line 1661
_Statype _Stsave = _State; 
#line 1663
if ((_Bytes = _Wcrtomb(_Buf, L'\x0', &_State, &(_Cvt))) <= 0) { 
#line 1664
_Ans = (error); } else { 
#line 1665
if ((_Last2 - _Mid2) < (--_Bytes)) 
#line 1666
{ 
#line 1667
_State = _Stsave; 
#line 1668
_Ans = (partial); 
#line 1669
} else { 
#line 1670
if (0 < _Bytes) 
#line 1671
{ 
#line 1672
::memcpy(_Mid2, _Buf, _Bytes); 
#line 1673
_Mid2 += _Bytes; 
#line 1674
}  }  }  
#line 1675
return _Ans; 
#line 1676
} 
#line 1678
virtual int do_length(const _Statype &_State, const _Byte *_First1, const _Byte *
#line 1679
_Last1, size_t _Count) const 
#line 1680
{ 
#line 1686 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
; 
#line 1687
int _Wchars; 
#line 1688
const _Byte *_Mid1; 
#line 1689
_Statype _Mystate = _State; 
#line 1691
for ((_Wchars = 0), (_Mid1 = _First1); (((size_t)_Wchars) < _Count) && (_Mid1 != _Last1);) 
#line 1693
{ 
#line 1694
int _Bytes; 
#line 1695
_Elem _Ch; 
#line 1697
switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1, &_Mystate, &(_Cvt))) 
#line 1699
{ 
#line 1700
case -2:  
#line 1701
return _Wchars; 
#line 1703
case -1:  
#line 1704
return _Wchars; 
#line 1706
case 0:  
#line 1707
if (_Ch == ((_Elem)0)) { 
#line 1708
_Bytes = (((int)::strlen(_Mid1)) + 1); }  
#line 1711
default:  
#line 1712
if (_Bytes == (-3)) { 
#line 1713
_Bytes = 0; }  
#line 1714
_Mid1 += _Bytes; 
#line 1715
++_Wchars; 
#line 1716
}  
#line 1717
}  
#line 1718
return _Wchars; 
#line 1720 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
} 
#line 1722
virtual bool do_always_noconv() const throw() 
#line 1723
{ 
#line 1724
return false; 
#line 1725
} 
#line 1727
virtual int do_max_length() const throw() 
#line 1728
{ 
#line 1729
return 5; 
#line 1730
} 
#line 1733
private: _Locinfo::_Cvtvec _Cvt; 
#line 1734
}; 
#line 1739
template<> class __declspec(dllimport) codecvt< unsigned short, char, int>  : public codecvt_base { 
#line 1743
public: typedef unsigned short _Elem; 
#line 1744
typedef char _Byte; 
#line 1745
typedef _Mbstatet _Statype; 
#line 1746
typedef _Elem intern_type; 
#line 1747
typedef _Byte extern_type; 
#line 1748
typedef _Statype state_type; 
#line 1750
result in(_Statype &_State, const _Byte *
#line 1751
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1752
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1753
{ 
#line 1754
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1756
} 
#line 1758
result out(_Statype &_State, const _Elem *
#line 1759
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1760
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1761
{ 
#line 1762
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1764
} 
#line 1766
result unshift(_Statype &_State, _Byte *
#line 1767
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1768
{ 
#line 1769
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 1771
} 
#line 1773
int length(const _Statype &_State, const _Byte *_First1, const _Byte *
#line 1774
_Last1, size_t _Count) const 
#line 1775
{ 
#line 1776
return this->do_length(_State, _First1, _Last1, _Count); 
#line 1777
} 
#line 1779
static locale::id id; 
#line 1781
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) 
#line 1783
{ 
#line 1784
{ _Locinfo _Lobj; 
#line 1785
this->_Init(_Lobj); 
#line 1786
} 
#line 1787
} 
#line 1789
codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs) 
#line 1791
{ 
#line 1792
this->_Init(_Lobj); 
#line 1793
} 
#line 1795
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 1796
_Ploc = 0) 
#line 1797
{ 
#line 1798
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
#line 1799
(*_Ppf) = (new std::codecvt< unsigned short, char, int> (((_Locinfo)(_Ploc->c_str())))); }  
#line 1801
return 2; 
#line 1802
} 
#line 1805
protected: virtual ~codecvt() 
#line 1806
{ 
#line 1807
} 
#line 1809
void _Init(const _Locinfo &_Lobj) 
#line 1810
{ 
#line 1811
(_Cvt) = _Lobj._Getcvt(); 
#line 1812
} 
#line 1814
virtual result do_in(_Statype &_State, const _Byte *
#line 1815
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1816
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1817
{ 
#line 1818
; 
#line 1819
; 
#line 1820
(_Mid1 = _First1), (_Mid2 = _First2); 
#line 1821
result _Ans = (_Mid1 == _Last1) ? ok : partial; 
#line 1822
int _Bytes; 
#line 1824
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1825
switch (_Bytes = _Mbrtowc((__wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1, &_State, &(_Cvt))) 
#line 1827
{ 
#line 1828
case -2:  
#line 1829
_Mid1 = _Last1; 
#line 1830
return _Ans; 
#line 1832
case -1:  
#line 1833
return error; 
#line 1835
case 0:  
#line 1836
if ((*_Mid2) == ((_Elem)0)) { 
#line 1837
_Bytes = (((int)::strlen(_Mid1)) + 1); }  
#line 1840
default:  
#line 1841
if (_Bytes == (-3)) { 
#line 1842
_Bytes = 0; }  
#line 1843
_Mid1 += _Bytes; 
#line 1844
++_Mid2; 
#line 1845
_Ans = (ok); 
#line 1846
}  }  
#line 1847
return _Ans; 
#line 1848
} 
#line 1850
virtual result do_out(_Statype &_State, const _Elem *
#line 1851
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1852
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1853
{ 
#line 1854
; 
#line 1855
; 
#line 1856
(_Mid1 = _First1), (_Mid2 = _First2); 
#line 1857
result _Ans = (_Mid1 == _Last1) ? ok : partial; 
#line 1858
int _Bytes; 
#line 1860
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1861
if (((int)___mb_cur_max_func()) <= (_Last2 - _Mid2)) { 
#line 1862
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 1864
return error; } else { 
#line 1866
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); }  } else 
#line 1868
{ 
#line 1869
_Byte _Buf[5]; 
#line 1870
_Statype _Stsave = _State; 
#line 1872
if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 1874
return error; } else { 
#line 1875
if ((_Last2 - _Mid2) < _Bytes) 
#line 1876
{ 
#line 1877
_State = _Stsave; 
#line 1878
return _Ans; 
#line 1879
} else 
#line 1881
{ 
#line 1882
::memcpy(_Mid2, _Buf, _Bytes); 
#line 1883
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); 
#line 1884
}  }  
#line 1885
}  }  
#line 1886
return _Ans; 
#line 1887
} 
#line 1889
virtual result do_unshift(_Statype &_State, _Byte *
#line 1890
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1891
{ 
#line 1892
; 
#line 1893
_Mid2 = _First2; 
#line 1894
result _Ans = (ok); 
#line 1895
int _Bytes; 
#line 1896
_Byte _Buf[5]; 
#line 1897
_Statype _Stsave = _State; 
#line 1899
if ((_Bytes = _Wcrtomb(_Buf, L'\x0', &_State, &(_Cvt))) <= 0) { 
#line 1900
_Ans = (error); } else { 
#line 1901
if ((_Last2 - _Mid2) < (--_Bytes)) 
#line 1902
{ 
#line 1903
_State = _Stsave; 
#line 1904
_Ans = (partial); 
#line 1905
} else { 
#line 1906
if (0 < _Bytes) 
#line 1907
{ 
#line 1908
::memcpy(_Mid2, _Buf, _Bytes); 
#line 1909
_Mid2 += _Bytes; 
#line 1910
}  }  }  
#line 1911
return _Ans; 
#line 1912
} 
#line 1914
virtual int do_length(const _Statype &_State, const _Byte *_First1, const _Byte *
#line 1915
_Last1, size_t _Count) const 
#line 1916
{ 
#line 1917
; 
#line 1918
int _Wchars; 
#line 1919
const _Byte *_Mid1; 
#line 1920
_Statype _Mystate = _State; 
#line 1922
for ((_Wchars = 0), (_Mid1 = _First1); (((size_t)_Wchars) < _Count) && (_Mid1 != _Last1);) 
#line 1924
{ 
#line 1925
int _Bytes; 
#line 1926
_Elem _Ch; 
#line 1928
switch (_Bytes = _Mbrtowc((__wchar_t *)(&_Ch), _Mid1, _Last1 - _Mid1, &_Mystate, &(_Cvt))) 
#line 1930
{ 
#line 1931
case -2:  
#line 1932
return _Wchars; 
#line 1934
case -1:  
#line 1935
return _Wchars; 
#line 1937
case 0:  
#line 1938
if (_Ch == ((_Elem)0)) { 
#line 1939
_Bytes = (((int)::strlen(_Mid1)) + 1); }  
#line 1942
default:  
#line 1943
if (_Bytes == (-3)) { 
#line 1944
_Bytes = 0; }  
#line 1945
_Mid1 += _Bytes; 
#line 1946
++_Wchars; 
#line 1947
}  
#line 1948
}  
#line 1949
return _Wchars; 
#line 1950
} 
#line 1952
virtual bool do_always_noconv() const throw() 
#line 1953
{ 
#line 1954
return false; 
#line 1955
} 
#line 1957
virtual int do_max_length() const throw() 
#line 1958
{ 
#line 1959
return 5; 
#line 1960
} 
#line 1963
private: _Locinfo::_Cvtvec _Cvt; 
#line 1964
}; 
#line 1968 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
template < class _Elem,
 class _Byte,
 class _Statype >
 class codecvt_byname
  : public codecvt < _Elem, _Byte, _Statype >
 {
public :
 explicit codecvt_byname ( const char * _Locname, size_t _Refs = 0 )
  : codecvt < _Elem, _Byte, _Statype > ( _Locinfo ( _Locname ), _Refs )
  {
  }


 explicit codecvt_byname ( const string & _Str, size_t _Refs = 0 )
  : codecvt < _Elem, _Byte, _Statype > ( _Locinfo ( _Str . c_str ( ) ), _Refs )
  {
  }


protected :
 virtual ~ codecvt_byname ( )
  {
  }
 };
#line 1994 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
#pragma warning(push)
#pragma warning(disable: 4275)
#line 1997
struct __declspec(dllimport) ctype_base : public locale::facet { 
#line 2001
enum { 
#line 2002
alnum = 263, alpha = 259, 
#line 2003
cntrl = 32, digit = 4, graph = 279, 
#line 2004
lower = 2, print = 471, 
#line 2005
punct = 16, space = 72, upper = 1, 
#line 2006
xdigit = 128}; 
#line 2007
typedef short mask; 
#line 2009
ctype_base(size_t _Refs = 0) : locale::facet(_Refs) 
#line 2011
{ 
#line 2012
} 
#line 2014
virtual ~ctype_base() 
#line 2015
{ 
#line 2016
} 
#line 2017
}; 
#line 2019
#pragma warning(pop)
#line 2022
template < class _Elem >
 class ctype
  : public ctype_base
 {
public :
 typedef _Elem char_type;

 bool is ( mask _Maskval, _Elem _Ch ) const
  {
  return ( do_is ( _Maskval, _Ch ) );
  }

 const _Elem * is ( const _Elem * _First, const _Elem * _Last,
  mask * _Dest ) const
  {
  return ( do_is ( _First, _Last, _Dest ) );
  }

 const _Elem * scan_is ( mask _Maskval, const _Elem * _First,
  const _Elem * _Last ) const
  {
  return ( do_scan_is ( _Maskval, _First, _Last ) );
  }

 const _Elem * scan_not ( mask _Maskval, const _Elem * _First,
  const _Elem * _Last ) const
  {
  return ( do_scan_not ( _Maskval, _First, _Last ) );
  }

 _Elem tolower ( _Elem _Ch ) const
  {
  return ( do_tolower ( _Ch ) );
  }

 const _Elem * tolower ( _Elem * _First, const _Elem * _Last ) const
  {
  return ( do_tolower ( _First, _Last ) );
  }

 _Elem toupper ( _Elem _Ch ) const
  {
  return ( do_toupper ( _Ch ) );
  }

 const _Elem * toupper ( _Elem * _First, const _Elem * _Last ) const
  {
  return ( do_toupper ( _First, _Last ) );
  }

 _Elem widen ( char _Byte ) const
  {
  return ( do_widen ( _Byte ) );
  }

 const char * widen ( const char * _First, const char * _Last,
  _Elem * _Dest ) const
  {
  return ( do_widen ( _First, _Last, _Dest ) );
  }

 char narrow ( _Elem _Ch, char _Dflt = '\000' ) const
  {
  return ( do_narrow ( _Ch, _Dflt ) );
  }

 const _Elem * narrow ( const _Elem * _First, const _Elem * _Last,
  char _Dflt, char * _Dest ) const
  {
  return ( do_narrow ( _First, _Last, _Dflt, _Dest ) );
  }

  static locale :: id id;

 explicit ctype ( size_t _Refs = 0 )
  : ctype_base ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

  ctype ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : ctype_base ( _Refs )
  {
  _Init ( _Lobj );
  }

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new ctype < _Elem > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 2 );
  }

protected :
 virtual ~ ctype ( )
  {
  if ( _Ctype . _Delfl )
   free ( ( void * ) _Ctype . _Table );
  }

 void _Init ( const _Locinfo & _Lobj )
  {
  _Ctype = _Lobj . _Getctype ( );
  }

 virtual bool do_is ( mask _Maskval, _Elem _Ch ) const
  {
  return ( ( _Ctype . _Table [ ( unsigned char ) narrow ( _Ch ) ]
   & _Maskval ) != 0 );
  }

 virtual const _Elem * do_is ( const _Elem * _First, const _Elem * _Last,
  mask * _Dest ) const
  {
  ;
  ;
  for (; _First != _Last; ++ _First, ++ _Dest )
   * _Dest = _Ctype . _Table [ ( unsigned char ) narrow ( * _First ) ];
  return ( _First );
  }

 virtual const _Elem * do_scan_is ( mask _Maskval,
  const _Elem * _First, const _Elem * _Last ) const
  {
  ;
  for (; _First != _Last && ! is ( _Maskval, * _First ); ++ _First )
   ;
  return ( _First );
  }

 virtual const _Elem * do_scan_not ( mask _Maskval,
  const _Elem * _First, const _Elem * _Last ) const
  {
  ;
  for (; _First != _Last && is ( _Maskval, * _First ); ++ _First )
   ;
  return ( _First );
  }

 virtual _Elem do_tolower ( _Elem _Ch ) const
  {
  unsigned char _Byte = ( unsigned char ) narrow ( _Ch, '\000' );
  if ( _Byte == '\000' )
   return ( _Ch );
  else
   return ( widen ( ( char ) _Tolower ( _Byte, & _Ctype ) ) );
  }

 virtual const _Elem * do_tolower ( _Elem * _First,
  const _Elem * _Last ) const
  {
  ;
  for (; _First != _Last; ++ _First )
   {
   unsigned char _Byte = ( unsigned char ) narrow ( * _First, '\000' );
   if ( _Byte != '\000' )
    * _First = ( widen ( ( char ) _Tolower ( _Byte, & _Ctype ) ) );
   }
  return ( ( const _Elem * ) _First );
  }

 virtual _Elem do_toupper ( _Elem _Ch ) const
  {
  unsigned char _Byte = ( unsigned char ) narrow ( _Ch, '\000' );
  if ( _Byte == '\000' )
   return ( _Ch );
  else
   return ( widen ( ( char ) _Toupper ( _Byte, & _Ctype ) ) );
  }

 virtual const _Elem * do_toupper ( _Elem * _First,
  const _Elem * _Last ) const
  {
  ;
  for (; _First != _Last; ++ _First )
   {
   unsigned char _Byte = ( unsigned char ) narrow ( * _First, '\000' );
   if ( _Byte != '\000' )
    * _First = ( widen ( ( char ) _Toupper ( _Byte, & _Ctype ) ) );
   }
  return ( ( const _Elem * ) _First );
  }

 virtual _Elem do_widen ( char _Byte ) const
  {
  return ( _Maklocchr ( _Byte, ( _Elem * ) 0, _Cvt ) );
  }

 virtual const char * do_widen ( const char * _First,
  const char * _Last, _Elem * _Dest ) const
  {
  ;
  ;
  for (; _First != _Last; ++ _First, ++ _Dest )
   * _Dest = _Maklocchr ( * _First, ( _Elem * ) 0, _Cvt );
  return ( _First );
  }

 char _Donarrow ( _Elem _Ch, char _Dflt ) const
  {
  char _Byte;
  if ( _Ch == ( _Elem ) 0 )
   return ( '\000' );
  else if ( ( _Byte = _Maklocbyte ( ( _Elem ) _Ch, _Cvt ) ) == '\000' )
   return ( _Dflt );
  else
   return ( _Byte );
  }

 virtual char do_narrow ( _Elem _Ch, char _Dflt ) const
  {
  return ( _Donarrow ( _Ch, _Dflt ) );
  }

 virtual const _Elem * do_narrow ( const _Elem * _First,
  const _Elem * _Last, char _Dflt, char * _Dest ) const
  {
  ;
  ;
  for (; _First != _Last; ++ _First, ++ _Dest )
   * _Dest = _Donarrow ( * _First, _Dflt );
  return ( _First );
  }

private :
 _Locinfo :: _Ctypevec _Ctype;
 _Locinfo :: _Cvtvec _Cvt;
 };
#line 2256
template< class _Elem> locale::id 
#line 2257
ctype< _Elem> ::id; 
#line 2261
template<> class __declspec(dllimport) ctype< char>  : public ctype_base { 
#line 2264
typedef std::ctype< char>  _Myt; 
#line 2267
public: typedef char _Elem; 
#line 2268
typedef _Elem char_type; 
#line 2270
bool is(mask _Maskval, _Elem _Ch) const 
#line 2271
{ 
#line 2272
return ((((_Ctype)._Table)[(unsigned char)_Ch]) & _Maskval) != 0; 
#line 2273
} 
#line 2275
const _Elem *is(const _Elem *_First, const _Elem *
#line 2276
_Last, mask *_Dest) const 
#line 2277
{ 
#line 2278
; 
#line 2279
; 
#line 2280
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2281
(*_Dest) = (((_Ctype)._Table)[(unsigned char)(*_First)]); }  
#line 2282
return _First; 
#line 2283
} 
#line 2285
const _Elem *scan_is(mask _Maskval, const _Elem *
#line 2286
_First, const _Elem *_Last) const 
#line 2287
{ 
#line 2288
; 
#line 2289
for (; (_First != _Last) && (!this->is(_Maskval, *_First)); ++_First) { 
#line 2290
; }  
#line 2291
return _First; 
#line 2292
} 
#line 2294
const _Elem *scan_not(mask _Maskval, const _Elem *
#line 2295
_First, const _Elem *_Last) const 
#line 2296
{ 
#line 2297
; 
#line 2298
for (; (_First != _Last) && this->is(_Maskval, *_First); ++_First) { 
#line 2299
; }  
#line 2300
return _First; 
#line 2301
} 
#line 2303
_Elem tolower(_Elem _Ch) const 
#line 2304
{ 
#line 2305
return this->do_tolower(_Ch); 
#line 2306
} 
#line 2308
const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
#line 2309
{ 
#line 2310
return this->do_tolower(_First, _Last); 
#line 2311
} 
#line 2313
_Elem toupper(_Elem _Ch) const 
#line 2314
{ 
#line 2315
return this->do_toupper(_Ch); 
#line 2316
} 
#line 2318
const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
#line 2319
{ 
#line 2320
return this->do_toupper(_First, _Last); 
#line 2321
} 
#line 2323
_Elem widen(char _Byte) const 
#line 2324
{ 
#line 2325
return this->do_widen(_Byte); 
#line 2326
} 
#line 2328
const _Elem *widen(const char *_First, const char *_Last, _Elem *
#line 2329
_Dest) const 
#line 2330
{ 
#line 2331
return this->do_widen(_First, _Last, _Dest); 
#line 2332
} 
#line 2334
_Elem narrow(_Elem _Ch, char _Dflt = '\000') const 
#line 2335
{ 
#line 2336
return this->do_narrow(_Ch, _Dflt); 
#line 2337
} 
#line 2339
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
#line 2340
_Dflt, char *_Dest) const 
#line 2341
{ 
#line 2342
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 2343
} 
#line 2345
static locale::id id; 
#line 2347
explicit ctype(const mask *_Table = 0, bool 
#line 2348
_Deletetable = false, size_t 
#line 2349
_Refs = 0) : ctype_base(_Refs) 
#line 2351
{ 
#line 2352
{ _Locinfo _Lobj; 
#line 2353
this->_Init(_Lobj); 
#line 2354
} 
#line 2355
if (_Table != (0)) 
#line 2356
{ 
#line 2357
this->_Tidy(); 
#line 2358
((_Ctype)._Table) = _Table; 
#line 2359
((_Ctype)._Delfl) = (_Deletetable ? (-1) : 0); 
#line 2360
}  
#line 2361
} 
#line 2363
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) 
#line 2365
{ 
#line 2366
this->_Init(_Lobj); 
#line 2367
} 
#line 2369
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 2370
_Ploc = 0) 
#line 2371
{ 
#line 2372
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
#line 2373
(*_Ppf) = (new std::ctype< char> (((_Locinfo)(_Ploc->c_str())))); }  
#line 2375
return 2; 
#line 2376
} 
#line 2378
const mask *table() const throw() 
#line 2379
{ 
#line 2380
return (_Ctype)._Table; 
#line 2381
} 
#line 2383
static const mask *__cdecl classic_table() throw() 
#line 2384
{ 
#line 2385
const _Myt &_Ctype_fac = use_facet< std::ctype< char> > (locale::classic()); 
#line 2386
return _Ctype_fac.table(); 
#line 2387
} 
#line 2389
static const size_t table_size = (1 << 8); 
#line 2393
protected: virtual ~ctype() 
#line 2394
{ 
#line 2395
this->_Tidy(); 
#line 2396
} 
#line 2398
void _Init(const _Locinfo &_Lobj) 
#line 2399
{ 
#line 2400
(_Ctype) = _Lobj._Getctype(); 
#line 2401
} 
#line 2403
void _Tidy() 
#line 2404
{ 
#line 2405
if (0 < ((_Ctype)._Delfl)) { 
#line 2406
free((void *)((_Ctype)._Table)); } else { 
#line 2407
if (((_Ctype)._Delfl) < 0) { 
#line 2408
delete [] ((void *)((_Ctype)._Table)); }  }  
#line 2409
} 
#line 2411
virtual _Elem do_tolower(_Elem _Ch) const 
#line 2412
{ 
#line 2413
return (_Elem)_Tolower((unsigned char)_Ch, &(_Ctype)); 
#line 2414
} 
#line 2416
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 2417
_Last) const 
#line 2418
{ 
#line 2419
; 
#line 2420
for (; _First != _Last; ++_First) { 
#line 2421
(*_First) = ((_Elem)_Tolower((unsigned char)(*_First), &(_Ctype))); }  
#line 2422
return (const _Elem *)_First; 
#line 2423
} 
#line 2425
virtual _Elem do_toupper(_Elem _Ch) const 
#line 2426
{ 
#line 2427
return (_Elem)_Toupper((unsigned char)_Ch, &(_Ctype)); 
#line 2428
} 
#line 2430
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 2431
_Last) const 
#line 2432
{ 
#line 2433
; 
#line 2434
for (; _First != _Last; ++_First) { 
#line 2435
(*_First) = ((_Elem)_Toupper((unsigned char)(*_First), &(_Ctype))); }  
#line 2436
return (const _Elem *)_First; 
#line 2437
} 
#line 2439
virtual _Elem do_widen(char _Byte) const 
#line 2440
{ 
#line 2441
return _Byte; 
#line 2442
} 
#line 2444
virtual const _Elem *do_widen(const char *_First, const char *
#line 2445
_Last, _Elem *_Dest) const 
#line 2446
{ 
#line 2447
; 
#line 2448
; 
#line 2449
::memcpy(_Dest, _First, _Last - _First); 
#line 2450
return _Last; 
#line 2451
} 
#line 2453
virtual _Elem do_narrow(_Elem _Ch, char) const 
#line 2454
{ 
#line 2455
return _Ch; 
#line 2456
} 
#line 2458
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *
#line 2459
_Last, char, char *_Dest) const 
#line 2460
{ 
#line 2461
; 
#line 2462
; 
#line 2463
::memcpy(_Dest, _First, _Last - _First); 
#line 2464
return _Last; 
#line 2465
} 
#line 2468
private: _Locinfo::_Ctypevec _Ctype; 
#line 2469
}; 
#line 2473
template<> class __declspec(dllimport) ctype< __wchar_t>  : public ctype_base { 
#line 2476
typedef std::ctype< __wchar_t>  _Myt; 
#line 2479
public: typedef __wchar_t _Elem; 
#line 2480
typedef _Elem char_type; 
#line 2482
bool is(mask _Maskval, _Elem _Ch) const 
#line 2483
{ 
#line 2484
return this->do_is(_Maskval, _Ch); 
#line 2485
} 
#line 2487
const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
#line 2488
_Dest) const 
#line 2489
{ 
#line 2490
return this->do_is(_First, _Last, _Dest); 
#line 2491
} 
#line 2493
const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 2494
_Last) const 
#line 2495
{ 
#line 2496
return this->do_scan_is(_Maskval, _First, _Last); 
#line 2497
} 
#line 2499
const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 2500
_Last) const 
#line 2501
{ 
#line 2502
return this->do_scan_not(_Maskval, _First, _Last); 
#line 2503
} 
#line 2505
_Elem tolower(_Elem _Ch) const 
#line 2506
{ 
#line 2507
return this->do_tolower(_Ch); 
#line 2508
} 
#line 2510
const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
#line 2511
{ 
#line 2512
return this->do_tolower(_First, _Last); 
#line 2513
} 
#line 2515
_Elem toupper(_Elem _Ch) const 
#line 2516
{ 
#line 2517
return this->do_toupper(_Ch); 
#line 2518
} 
#line 2520
const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
#line 2521
{ 
#line 2522
return this->do_toupper(_First, _Last); 
#line 2523
} 
#line 2525
_Elem widen(char _Byte) const 
#line 2526
{ 
#line 2527
return this->do_widen(_Byte); 
#line 2528
} 
#line 2530
const char *widen(const char *_First, const char *_Last, _Elem *
#line 2531
_Dest) const 
#line 2532
{ 
#line 2533
return this->do_widen(_First, _Last, _Dest); 
#line 2534
} 
#line 2536
char narrow(_Elem _Ch, char _Dflt = '\000') const 
#line 2537
{ 
#line 2538
return this->do_narrow(_Ch, _Dflt); 
#line 2539
} 
#line 2541
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
#line 2542
_Dflt, char *_Dest) const 
#line 2543
{ 
#line 2544
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 2545
} 
#line 2547
static locale::id id; 
#line 2549
explicit ctype(size_t _Refs = 0) : ctype_base(_Refs) 
#line 2551
{ 
#line 2552
{ _Locinfo _Lobj; 
#line 2553
this->_Init(_Lobj); 
#line 2554
} 
#line 2555
} 
#line 2557
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) 
#line 2559
{ 
#line 2560
this->_Init(_Lobj); 
#line 2561
} 
#line 2563
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 2564
_Ploc = 0) 
#line 2565
{ 
#line 2566
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
#line 2567
(*_Ppf) = (new std::ctype< __wchar_t> (((_Locinfo)(_Ploc->c_str())))); }  
#line 2569
return 2; 
#line 2570
} 
#line 2573
protected: virtual ~ctype() 
#line 2574
{ 
#line 2575
if ((_Ctype)._Delfl) { 
#line 2576
free((void *)((_Ctype)._Table)); }  
#line 2577
} 
#line 2579
void _Init(const _Locinfo &_Lobj) 
#line 2580
{ 
#line 2581
(_Ctype) = _Lobj._Getctype(); 
#line 2582
(_Cvt) = _Lobj._Getcvt(); 
#line 2583
} 
#line 2585
virtual bool do_is(mask _Maskval, _Elem _Ch) const 
#line 2586
{ 
#line 2587
return ((::_Getwctype(_Ch, &(_Ctype))) & _Maskval) != 0; 
#line 2588
} 
#line 2590
virtual const _Elem *do_is(const _Elem *_First, const _Elem *
#line 2591
_Last, mask *_Dest) const 
#line 2592
{ 
#line 2593
; 
#line 2594
; 
#line 2595
return ::_Getwctypes(_First, _Last, _Dest, &(_Ctype)); 
#line 2596
} 
#line 2598
virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *
#line 2599
_First, const _Elem *_Last) const 
#line 2600
{ 
#line 2601
; 
#line 2602
for (; (_First != _Last) && (!this->is(_Maskval, *_First)); ++_First) { 
#line 2603
; }  
#line 2604
return _First; 
#line 2605
} 
#line 2607
virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *
#line 2608
_First, const _Elem *_Last) const 
#line 2609
{ 
#line 2610
; 
#line 2611
for (; (_First != _Last) && this->is(_Maskval, *_First); ++_First) { 
#line 2612
; }  
#line 2613
return _First; 
#line 2614
} 
#line 2616
virtual _Elem do_tolower(_Elem _Ch) const 
#line 2617
{ 
#line 2618
return _Towlower(_Ch, &(_Ctype)); 
#line 2619
} 
#line 2621
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 2622
_Last) const 
#line 2623
{ 
#line 2624
; 
#line 2625
for (; _First != _Last; ++_First) { 
#line 2626
(*_First) = _Towlower(*_First, &(_Ctype)); }  
#line 2627
return (const _Elem *)_First; 
#line 2628
} 
#line 2630
virtual _Elem do_toupper(_Elem _Ch) const 
#line 2631
{ 
#line 2632
return _Towupper(_Ch, &(_Ctype)); 
#line 2633
} 
#line 2635
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 2636
_Last) const 
#line 2637
{ 
#line 2638
; 
#line 2639
for (; _First != _Last; ++_First) { 
#line 2640
(*_First) = _Towupper(*_First, &(_Ctype)); }  
#line 2641
return (const _Elem *)_First; 
#line 2642
} 
#line 2644
_Elem _Dowiden(char _Byte) const 
#line 2645
{ 
#line 2646
mbstate_t _Mbst = 0; 
#line 2647
__wchar_t _Wc; 
#line 2648
return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &(_Cvt)) < 0) ? ((__wchar_t)((wint_t)65535)) : _Wc; 
#line 2650
} 
#line 2652
virtual _Elem do_widen(char _Byte) const 
#line 2653
{ 
#line 2654
return this->_Dowiden(_Byte); 
#line 2655
} 
#line 2657
virtual const char *do_widen(const char *_First, const char *
#line 2658
_Last, _Elem *_Dest) const 
#line 2659
{ 
#line 2660
; 
#line 2661
; 
#line 2662
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2663
(*_Dest) = this->_Dowiden(*_First); }  
#line 2664
return _First; 
#line 2665
} 
#line 2667
char _Donarrow(_Elem _Ch, char _Dflt) const 
#line 2668
{ 
#line 2669
char _Buf[5]; 
#line 2670
mbstate_t _Mbst = 0; 
#line 2671
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(_Cvt)) != 1) ? _Dflt : ((_Buf)[0]); 
#line 2673
} 
#line 2675
virtual char do_narrow(_Elem _Ch, char _Dflt) const 
#line 2676
{ 
#line 2677
return this->_Donarrow(_Ch, _Dflt); 
#line 2678
} 
#line 2680
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *
#line 2681
_Last, char _Dflt, char *_Dest) const 
#line 2682
{ 
#line 2683
; 
#line 2684
; 
#line 2685
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2686
(*_Dest) = this->_Donarrow(*_First, _Dflt); }  
#line 2687
return _First; 
#line 2688
} 
#line 2691
private: _Locinfo::_Ctypevec _Ctype; 
#line 2692
_Locinfo::_Cvtvec _Cvt; 
#line 2693
}; 
#line 2698
template<> class __declspec(dllimport) ctype< unsigned short>  : public ctype_base { 
#line 2701
typedef std::ctype< unsigned short>  _Myt; 
#line 2704
public: typedef unsigned short _Elem; 
#line 2705
typedef _Elem char_type; 
#line 2707
bool is(mask _Maskval, _Elem _Ch) const 
#line 2708
{ 
#line 2709
return this->do_is(_Maskval, _Ch); 
#line 2710
} 
#line 2712
const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
#line 2713
_Dest) const 
#line 2714
{ 
#line 2715
return this->do_is(_First, _Last, _Dest); 
#line 2716
} 
#line 2718
const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 2719
_Last) const 
#line 2720
{ 
#line 2721
return this->do_scan_is(_Maskval, _First, _Last); 
#line 2722
} 
#line 2724
const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 2725
_Last) const 
#line 2726
{ 
#line 2727
return this->do_scan_not(_Maskval, _First, _Last); 
#line 2728
} 
#line 2730
_Elem tolower(_Elem _Ch) const 
#line 2731
{ 
#line 2732
return this->do_tolower(_Ch); 
#line 2733
} 
#line 2735
const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
#line 2736
{ 
#line 2737
return this->do_tolower(_First, _Last); 
#line 2738
} 
#line 2740
_Elem toupper(_Elem _Ch) const 
#line 2741
{ 
#line 2742
return this->do_toupper(_Ch); 
#line 2743
} 
#line 2745
const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
#line 2746
{ 
#line 2747
return this->do_toupper(_First, _Last); 
#line 2748
} 
#line 2750
_Elem widen(char _Byte) const 
#line 2751
{ 
#line 2752
return this->do_widen(_Byte); 
#line 2753
} 
#line 2755
const char *widen(const char *_First, const char *_Last, _Elem *
#line 2756
_Dest) const 
#line 2757
{ 
#line 2758
return this->do_widen(_First, _Last, _Dest); 
#line 2759
} 
#line 2761
char narrow(_Elem _Ch, char _Dflt = '\000') const 
#line 2762
{ 
#line 2763
return this->do_narrow(_Ch, _Dflt); 
#line 2764
} 
#line 2766
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
#line 2767
_Dflt, char *_Dest) const 
#line 2768
{ 
#line 2769
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 2770
} 
#line 2772
static locale::id id; 
#line 2774
explicit ctype(size_t _Refs = 0) : ctype_base(_Refs) 
#line 2776
{ 
#line 2777
{ _Locinfo _Lobj; 
#line 2778
this->_Init(_Lobj); 
#line 2779
} 
#line 2780
} 
#line 2782
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) 
#line 2784
{ 
#line 2785
this->_Init(_Lobj); 
#line 2786
} 
#line 2788
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 2789
_Ploc = 0) 
#line 2790
{ 
#line 2791
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
#line 2792
(*_Ppf) = (new std::ctype< unsigned short> (((_Locinfo)(_Ploc->c_str())))); }  
#line 2794
return 2; 
#line 2795
} 
#line 2798
protected: virtual ~ctype() 
#line 2799
{ 
#line 2800
if ((_Ctype)._Delfl) { 
#line 2801
free((void *)((_Ctype)._Table)); }  
#line 2802
} 
#line 2804
void _Init(const _Locinfo &_Lobj) 
#line 2805
{ 
#line 2806
(_Ctype) = _Lobj._Getctype(); 
#line 2807
(_Cvt) = _Lobj._Getcvt(); 
#line 2808
} 
#line 2810
virtual bool do_is(mask _Maskval, _Elem _Ch) const 
#line 2811
{ 
#line 2812
return ((::_Getwctype(_Ch, &(_Ctype))) & _Maskval) != 0; 
#line 2813
} 
#line 2815
virtual const _Elem *do_is(const _Elem *_First, const _Elem *
#line 2816
_Last, mask *_Dest) const 
#line 2817
{ 
#line 2818
; 
#line 2819
; 
#line 2820
return (const _Elem *)::_Getwctypes((const __wchar_t *)_First, (const __wchar_t *)_Last, _Dest, &(_Ctype)); 
#line 2822
} 
#line 2824
virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *
#line 2825
_First, const _Elem *_Last) const 
#line 2826
{ 
#line 2827
; 
#line 2828
for (; (_First != _Last) && (!this->is(_Maskval, *_First)); ++_First) { 
#line 2829
; }  
#line 2830
return _First; 
#line 2831
} 
#line 2833
virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *
#line 2834
_First, const _Elem *_Last) const 
#line 2835
{ 
#line 2836
; 
#line 2837
for (; (_First != _Last) && this->is(_Maskval, *_First); ++_First) { 
#line 2838
; }  
#line 2839
return _First; 
#line 2840
} 
#line 2842
virtual _Elem do_tolower(_Elem _Ch) const 
#line 2843
{ 
#line 2844
return _Towlower(_Ch, &(_Ctype)); 
#line 2845
} 
#line 2847
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 2848
_Last) const 
#line 2849
{ 
#line 2850
; 
#line 2851
for (; _First != _Last; ++_First) { 
#line 2852
(*_First) = (_Towlower(*_First, &(_Ctype))); }  
#line 2853
return (const _Elem *)_First; 
#line 2854
} 
#line 2856
virtual _Elem do_toupper(_Elem _Ch) const 
#line 2857
{ 
#line 2858
return _Towupper(_Ch, &(_Ctype)); 
#line 2859
} 
#line 2861
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 2862
_Last) const 
#line 2863
{ 
#line 2864
; 
#line 2865
for (; _First != _Last; ++_First) { 
#line 2866
(*_First) = (_Towupper(*_First, &(_Ctype))); }  
#line 2867
return (const _Elem *)_First; 
#line 2868
} 
#line 2870
_Elem _Dowiden(char _Byte) const 
#line 2871
{ 
#line 2872
mbstate_t _Mbst = 0; 
#line 2873
unsigned short _Wc; 
#line 2874
return (_Mbrtowc((__wchar_t *)(&_Wc), &_Byte, 1, &_Mbst, &(_Cvt)) < 0) ? ((unsigned short)((wint_t)65535)) : _Wc; 
#line 2876
} 
#line 2878
virtual _Elem do_widen(char _Byte) const 
#line 2879
{ 
#line 2880
return this->_Dowiden(_Byte); 
#line 2881
} 
#line 2883
virtual const char *do_widen(const char *_First, const char *
#line 2884
_Last, _Elem *_Dest) const 
#line 2885
{ 
#line 2886
; 
#line 2887
; 
#line 2888
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2889
(*_Dest) = this->_Dowiden(*_First); }  
#line 2890
return _First; 
#line 2891
} 
#line 2893
char _Donarrow(_Elem _Ch, char _Dflt) const 
#line 2894
{ 
#line 2895
char _Buf[5]; 
#line 2896
mbstate_t _Mbst = 0; 
#line 2897
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(_Cvt)) != 1) ? _Dflt : ((_Buf)[0]); 
#line 2899
} 
#line 2901
virtual char do_narrow(_Elem _Ch, char _Dflt) const 
#line 2902
{ 
#line 2903
return this->_Donarrow(_Ch, _Dflt); 
#line 2904
} 
#line 2906
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *
#line 2907
_Last, char _Dflt, char *_Dest) const 
#line 2908
{ 
#line 2909
; 
#line 2910
; 
#line 2911
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2912
(*_Dest) = this->_Donarrow(*_First, _Dflt); }  
#line 2913
return _First; 
#line 2914
} 
#line 2917
private: _Locinfo::_Ctypevec _Ctype; 
#line 2918
_Locinfo::_Cvtvec _Cvt; 
#line 2919
}; 
#line 2923 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
template < class _Elem >
 class ctype_byname
 : public ctype < _Elem >
 {
public :
 explicit ctype_byname ( const char * _Locname, size_t _Refs = 0 )
  : ctype < _Elem > ( _Locinfo ( _Locname ), _Refs )
  {
  }


 explicit ctype_byname ( const string & _Str, size_t _Refs = 0 )
  : ctype < _Elem > ( _Locinfo ( _Str . c_str ( ) ), _Refs )
  {
  }


protected :
 virtual ~ ctype_byname ( )
  {
  }
 };
#line 2948 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
template<> class ctype_byname< char>  : public ctype< char>  { 
#line 2952
public: explicit ctype_byname(const char *_Locname, size_t _Refs = 0) : std::ctype< char> (((_Locinfo)(_Locname)), _Refs) 
#line 2954
{ 
#line 2955
} 
#line 2958
explicit ctype_byname(const string &_Str, size_t _Refs = 0) : std::ctype< char> (((_Locinfo)(_Str.c_str())), _Refs) 
#line 2960
{ 
#line 2961
} 
#line 2965 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
protected: virtual ~ctype_byname() 
#line 2966
{ 
#line 2967
} 
#line 2968
}; 
#line 2972
template class __declspec(dllimport) codecvt< char, char, int> ;
#line 2975 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
}
#line 2979
#pragma warning(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\system_error"
#pragma warning(push,3)
#line 2980 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocale"
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\system_error"
#pragma pack ( push, 8 )
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\system_error"
namespace std { 
#line 21
namespace errc { 
#line 22
enum errc { 
#line 23
address_family_not_supported = 102, 
#line 24
address_in_use = 100, 
#line 25
address_not_available, 
#line 26
already_connected = 113, 
#line 27
argument_list_too_long = 7, 
#line 28
argument_out_of_domain = 33, 
#line 29
bad_address = 14, 
#line 30
bad_file_descriptor = 9, 
#line 31
bad_message = 104, 
#line 32
broken_pipe = 32, 
#line 33
connection_aborted = 106, 
#line 34
connection_already_in_progress = 103, 
#line 35
connection_refused = 107, 
#line 36
connection_reset, 
#line 37
cross_device_link = 18, 
#line 38
destination_address_required = 109, 
#line 39
device_or_resource_busy = 16, 
#line 40
directory_not_empty = 41, 
#line 41
executable_format_error = 8, 
#line 42
file_exists = 17, 
#line 43
file_too_large = 27, 
#line 44
filename_too_long = 38, 
#line 45
function_not_supported = 40, 
#line 46
host_unreachable = 110, 
#line 47
identifier_removed, 
#line 48
illegal_byte_sequence = 42, 
#line 49
inappropriate_io_control_operation = 25, 
#line 50
interrupted = 4, 
#line 51
invalid_argument = 22, 
#line 52
invalid_seek = 29, 
#line 53
io_error = 5, 
#line 54
is_a_directory = 21, 
#line 55
message_size = 115, 
#line 56
network_down, 
#line 57
network_reset, 
#line 58
network_unreachable, 
#line 59
no_buffer_space, 
#line 60
no_child_process = 10, 
#line 61
no_link = 121, 
#line 62
no_lock_available = 39, 
#line 63
no_message_available = 120, 
#line 64
no_message = 122, 
#line 65
no_protocol_option, 
#line 66
no_space_on_device = 28, 
#line 67
no_stream_resources = 124, 
#line 68
no_such_device_or_address = 6, 
#line 69
no_such_device = 19, 
#line 70
no_such_file_or_directory = 2, 
#line 71
no_such_process, 
#line 72
not_a_directory = 20, 
#line 73
not_a_socket = 128, 
#line 74
not_a_stream = 125, 
#line 75
not_connected, 
#line 76
not_enough_memory = 12, 
#line 77
not_supported = 129, 
#line 78
operation_canceled = 105, 
#line 79
operation_in_progress = 112, 
#line 80
operation_not_permitted = 1, 
#line 81
operation_not_supported = 130, 
#line 82
operation_would_block = 140, 
#line 83
owner_dead = 133, 
#line 84
permission_denied = 13, 
#line 85
protocol_error = 134, 
#line 86
protocol_not_supported, 
#line 87
read_only_file_system = 30, 
#line 88
resource_deadlock_would_occur = 36, 
#line 89
resource_unavailable_try_again = 11, 
#line 90
result_out_of_range = 34, 
#line 91
state_not_recoverable = 127, 
#line 92
stream_timeout = 137, 
#line 93
text_file_busy = 139, 
#line 94
timed_out = 138, 
#line 95
too_many_files_open_in_system = 23, 
#line 96
too_many_files_open, 
#line 97
too_many_links = 31, 
#line 98
too_many_synbolic_link_levels = 114, 
#line 99
value_too_large = 132, 
#line 100
wrong_protocol_type = 136
#line 101
}; 
#line 102
}
#line 104
typedef errc::errc generic_errno; 
#line 107
template< class _Enum> 
#line 108
struct is_error_code_enum : public tr1::false_type { 
#line 111
}; 
#line 114
template< class _Enum> 
#line 115
struct is_error_condition_enum : public tr1::false_type { 
#line 118
}; 
#line 121
template<> struct is_error_condition_enum< errc::errc>  : public tr1::true_type { 
#line 124
}; 
#line 127
namespace io_errc { 
#line 128
enum io_errc { 
#line 129
stream = 1
#line 130
}; 
#line 131
}
#line 133
typedef io_errc::io_errc _Io_errc; 
#line 136
class error_code; 
#line 137
class error_condition; 
#line 138
class error_category; 
#line 140
__declspec(dllimport) const error_category &__cdecl generic_category(); 
#line 141
__declspec(dllimport) const error_category &__cdecl iostream_category(); 
#line 142
__declspec(dllimport) const error_category &__cdecl system_category(); 
#line 144
class error_category { 
#line 147
public: typedef int value_type; 
#line 149
error_category() 
#line 150
{ 
#line 151
} 
#line 153
virtual ~error_category() 
#line 154
{ 
#line 155
} 
#line 157
virtual const char *name() const = 0; 
#line 159
virtual string message(value_type ) const = 0; 
#line 161
inline virtual error_condition default_error_condition(value_type ) const; 
#line 163
inline virtual bool equivalent(value_type , const error_condition & ) const; 
#line 166
inline virtual bool equivalent(const error_code & , value_type ) const; 
#line 169
bool operator==(const error_category &_Right) const 
#line 170
{ 
#line 171
return this == (&_Right); 
#line 172
} 
#line 174
bool operator!=(const error_category &_Right) const 
#line 175
{ 
#line 176
return !((*this) == _Right); 
#line 177
} 
#line 179
bool operator<(const error_category &_Right) const 
#line 180
{ 
#line 181
return this < (&_Right); 
#line 182
} 
#line 185
private: error_category(const error_category &); 
#line 187
error_category &operator=(const error_category &); 
#line 188
}; 
#line 191
class error_code { 
#line 194
public: typedef int value_type; 
#line 196
error_code() : _Myval(0), _Mycat(&system_category()) 
#line 199
{ 
#line 200
} 
#line 202
error_code(value_type _Val, const error_category &_Cat) : _Myval(_Val), _Mycat(&_Cat) 
#line 204
{ 
#line 205
} 
#line 207
template < class _Enum >
  error_code ( _Enum _Errcode,
   typename tr1 :: enable_if < is_error_code_enum < _Enum > :: value,
    error_code > :: type * = 0 )
  : _Myval ( 0 ), _Mycat ( 0 )
  {
  * this = make_error_code ( _Errcode );
  }
#line 216
void assign(value_type _Val, const error_category &_Cat) 
#line 217
{ 
#line 218
(_Myval) = _Val; 
#line 219
(_Mycat) = (&_Cat); 
#line 220
} 
#line 222
template < class _Enum >
  typename tr1 :: enable_if < is_error_code_enum < _Enum > :: value,
   error_code > :: type & operator = ( _Enum _Errcode )
  {
  * this = make_error_code ( _Errcode );
  return ( * this );
  }
#line 230
void clear() 
#line 231
{ 
#line 232
(_Myval) = 0; 
#line 233
(_Mycat) = (&system_category()); 
#line 234
} 
#line 236
value_type value() const 
#line 237
{ 
#line 238
return _Myval; 
#line 239
} 
#line 241
const error_category &category() const 
#line 242
{ 
#line 243
return *(_Mycat); 
#line 244
} 
#line 246
inline error_condition default_error_condition() const; 
#line 248
string message() const 
#line 249
{ 
#line 250
return this->category().message(this->value()); 
#line 251
} 
#line 253
operator _Bool_type() const 
#line 254
{ 
#line 255
return (this->value() != 0) ? (&::std::_Bool_struct::_Member) : (0); 
#line 256
} 
#line 258
bool operator!() const 
#line 259
{ 
#line 260
return this->value() == 0; 
#line 261
} 
#line 263
bool operator==(const error_code &_Right) const 
#line 264
{ 
#line 265
return ((this->category()) == (_Right.category())) && (this->value() == _Right.value()); 
#line 267
} 
#line 269
bool operator!=(const error_code &_Right) const 
#line 270
{ 
#line 271
return !((*this) == _Right); 
#line 272
} 
#line 274
bool operator<(const error_code &_Right) const 
#line 275
{ 
#line 276
return ((this->category()) < (_Right.category())) || (((this->category()) == (_Right.category())) && (this->value() < _Right.value())); 
#line 279
} 
#line 282
private: value_type _Myval; 
#line 283
const error_category *_Mycat; 
#line 284
}; 
#line 287
class error_condition { 
#line 290
public: typedef int value_type; 
#line 292
error_condition() : _Myval(0), _Mycat(&generic_category()) 
#line 295
{ 
#line 296
} 
#line 298
error_condition(value_type _Val, const error_category &_Cat) : _Myval(_Val), _Mycat(&_Cat) 
#line 300
{ 
#line 301
} 
#line 303
template < class _Enum >
  error_condition ( _Enum _Errcode,
   typename tr1 :: enable_if < is_error_condition_enum < _Enum > :: value,
    error_condition > :: type * = 0 )
  : _Myval ( 0 ), _Mycat ( 0 )
  {
  * this = make_error_condition ( _Errcode );
  }
#line 312
void assign(value_type _Val, const error_category &_Cat) 
#line 313
{ 
#line 314
(_Myval) = _Val; 
#line 315
(_Mycat) = (&_Cat); 
#line 316
} 
#line 318
template < class _Enum >
  typename tr1 :: enable_if < is_error_condition_enum < _Enum > :: value,
   error_condition > :: type & operator = ( _Enum _Errcode )
  {
  * this = make_error_condition ( _Errcode );
  return ( * this );
  }
#line 326
void clear() 
#line 327
{ 
#line 328
(_Myval) = 0; 
#line 329
(_Mycat) = (&generic_category()); 
#line 330
} 
#line 332
value_type value() const 
#line 333
{ 
#line 334
return _Myval; 
#line 335
} 
#line 337
const error_category &category() const 
#line 338
{ 
#line 339
return *(_Mycat); 
#line 340
} 
#line 342
string message() const 
#line 343
{ 
#line 344
return this->category().message(this->value()); 
#line 345
} 
#line 347
operator _Bool_type() const 
#line 348
{ 
#line 349
return (this->value() != 0) ? (&::std::_Bool_struct::_Member) : (0); 
#line 350
} 
#line 352
bool operator!() const 
#line 353
{ 
#line 354
return this->value() == 0; 
#line 355
} 
#line 357
bool operator==(const error_condition &_Right) const 
#line 358
{ 
#line 359
return ((this->category()) == (_Right.category())) && (this->value() == _Right.value()); 
#line 361
} 
#line 363
bool operator!=(const error_condition &_Right) const 
#line 364
{ 
#line 365
return !((*this) == _Right); 
#line 366
} 
#line 368
bool operator<(const error_condition &_Right) const 
#line 369
{ 
#line 370
return ((this->category()) < (_Right.category())) || (((this->category()) == (_Right.category())) && (this->value() < _Right.value())); 
#line 373
} 
#line 376
private: value_type _Myval; 
#line 377
const error_category *_Mycat; 
#line 378
}; 
#line 382
inline error_condition error_category::default_error_condition(value_type _Errval) const 
#line 383
{ 
#line 384
return error_condition(_Errval, *this); 
#line 385
} 
#line 388
inline bool error_category::equivalent(value_type _Errval, const error_condition &
#line 389
_Cond) const 
#line 390
{ 
#line 391
return ((this->default_error_condition(_Errval)) == _Cond); 
#line 392
} 
#line 395
inline bool error_category::equivalent(const error_code &_Code, value_type 
#line 396
_Errval) const 
#line 397
{ 
#line 398
return ((*this) == (_Code.category())) && (_Code.value() == _Errval); 
#line 399
} 
#line 402
inline error_condition error_code::default_error_condition() const 
#line 403
{ 
#line 404
return this->category().default_error_condition(this->value()); 
#line 405
} 
#line 408
inline bool operator==(const error_code &
#line 409
_Left, const error_condition &
#line 410
_Right) 
#line 411
{ 
#line 412
return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value()); 
#line 414
} 
#line 416
inline bool operator==(const error_condition &
#line 417
_Left, const error_code &
#line 418
_Right) 
#line 419
{ 
#line 420
return _Right.category().equivalent(_Right.value(), _Left) || _Left.category().equivalent(_Right, _Left.value()); 
#line 422
} 
#line 425
inline bool operator!=(const error_code &
#line 426
_Left, const error_condition &
#line 427
_Right) 
#line 428
{ 
#line 429
return !((_Left == _Right)); 
#line 430
} 
#line 432
inline bool operator!=(const error_condition &
#line 433
_Left, const error_code &
#line 434
_Right) 
#line 435
{ 
#line 436
return !((_Left == _Right)); 
#line 437
} 
#line 440
inline error_code make_error_code(generic_errno _Errno) 
#line 441
{ 
#line 442
return error_code(_Errno, generic_category()); 
#line 443
} 
#line 445
inline error_code make_error_code(_Io_errc _Errno) 
#line 446
{ 
#line 447
return error_code(_Errno, iostream_category()); 
#line 448
} 
#line 451
inline error_condition make_error_condition(generic_errno _Errno) 
#line 452
{ 
#line 453
return error_condition(_Errno, generic_category()); 
#line 454
} 
#line 456
inline error_condition make_error_condition(_Io_errc _Errno) 
#line 457
{ 
#line 458
return error_condition(_Errno, iostream_category()); 
#line 459
} 
#line 462
template < class _Kty >
 class hash;
#line 466
template<> class hash< error_code>  : public unary_function< error_code, unsigned __int64>  { 
#line 470
public: typedef error_code _Kty; 
#line 472
size_t operator()(const _Kty &_Keyval) const 
#line 473
{ 
#line 474
ldiv_t _Qrem = ::ldiv((long)((size_t)_Keyval.value()), 127773); 
#line 476
(_Qrem.rem) = (((16807) * (_Qrem.rem)) - ((2836) * (_Qrem.quot))); 
#line 477
if ((_Qrem.rem) < (0)) { 
#line 478
(_Qrem.rem) += (2147483647); }  
#line 479
return (size_t)(_Qrem.rem); 
#line 480
} 
#line 481
}; 
#line 484
template<> class hash< error_condition>  : public unary_function< error_condition, unsigned __int64>  { 
#line 488
public: typedef error_condition _Kty; 
#line 490
size_t operator()(const _Kty &_Keyval) const 
#line 491
{ 
#line 492
ldiv_t _Qrem = ::ldiv((long)((size_t)_Keyval.value()), 127773); 
#line 494
(_Qrem.rem) = (((16807) * (_Qrem.rem)) - ((2836) * (_Qrem.quot))); 
#line 495
if ((_Qrem.rem) < (0)) { 
#line 496
(_Qrem.rem) += (2147483647); }  
#line 497
return (size_t)(_Qrem.rem); 
#line 498
} 
#line 499
}; 
#line 502
class system_error : public runtime_error { 
#line 506
public: explicit system_error(error_code _Errcode, const string &
#line 507
_Message = "") : runtime_error(_Message), _Mycode(_Errcode) 
#line 509
{ 
#line 510
this->_Makestr(); 
#line 511
} 
#line 513
system_error(error_code _Errcode, const char *
#line 514
_Message) : runtime_error(_Message), _Mycode(_Errcode) 
#line 516
{ 
#line 517
this->_Makestr(); 
#line 518
} 
#line 520
system_error(error_code::value_type _Errval, const error_category &
#line 521
_Errcat, const string &
#line 522
_Message = "") : runtime_error(_Message), _Mycode(_Errval, _Errcat) 
#line 524
{ 
#line 525
this->_Makestr(); 
#line 526
} 
#line 528
system_error(error_code::value_type _Errval, const error_category &
#line 529
_Errcat, const char *
#line 530
_Message) : runtime_error(_Message), _Mycode(_Errval, _Errcat) 
#line 532
{ 
#line 533
this->_Makestr(); 
#line 534
} 
#line 545
const error_code &code() const throw() 
#line 546
{ 
#line 547
return _Mycode; 
#line 548
} 
#line 561 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\system_error"
private: void _Makestr() 
#line 562
{ 
#line 567
} 
#line 569
error_code _Mycode; 
#line 571
}; 
#line 572
}
#pragma warning(pop)
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xiosbase"
#pragma warning(push,3)
#line 17
#pragma warning(disable: 4412)
#line 574 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\system_error"
#pragma pack ( pop )
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xiosbase"
#pragma pack ( push, 8 )
#line 24
namespace std { 
#line 50
template< class _Dummy> 
#line 51
class _Iosb { 
#line 54
public: enum _Dummy_enum { _Dummy_enum_val = 1}; 
#line 55
enum _Fmtflags { 
#line 57
_Fmtmask = 65535, _Fmtzero = 0}; 
#line 59
static const _Fmtflags skipws = ((_Fmtflags)1); 
#line 60
static const _Fmtflags unitbuf = ((_Fmtflags)2); 
#line 61
static const _Fmtflags uppercase = ((_Fmtflags)4); 
#line 62
static const _Fmtflags showbase = ((_Fmtflags)8); 
#line 63
static const _Fmtflags showpoint = ((_Fmtflags)16); 
#line 64
static const _Fmtflags showpos = ((_Fmtflags)32); 
#line 65
static const _Fmtflags left = ((_Fmtflags)64); 
#line 66
static const _Fmtflags right = ((_Fmtflags)128); 
#line 67
static const _Fmtflags internal = ((_Fmtflags)256); 
#line 68
static const _Fmtflags dec = ((_Fmtflags)512); 
#line 69
static const _Fmtflags oct = ((_Fmtflags)1024); 
#line 70
static const _Fmtflags hex = ((_Fmtflags)2048); 
#line 71
static const _Fmtflags scientific = ((_Fmtflags)4096); 
#line 72
static const _Fmtflags fixed = ((_Fmtflags)8192); 
#line 74
static const _Fmtflags hexfloat = ((_Fmtflags)12288); 
#line 77
static const _Fmtflags boolalpha = ((_Fmtflags)16384); 
#line 78
static const _Fmtflags _Stdio = ((_Fmtflags)32768); 
#line 79
static const _Fmtflags adjustfield = ((_Fmtflags)((64 | 128) | 256)); 
#line 81
static const _Fmtflags basefield = ((_Fmtflags)((512 | 1024) | 2048)); 
#line 83
static const _Fmtflags floatfield = ((_Fmtflags)(4096 | 8192)); 
#line 86
enum _Iostate { 
#line 88
_Statmask = 23}; 
#line 90
static const _Iostate goodbit = ((_Iostate)0); 
#line 91
static const _Iostate eofbit = ((_Iostate)1); 
#line 92
static const _Iostate failbit = ((_Iostate)2); 
#line 93
static const _Iostate badbit = ((_Iostate)4); 
#line 94
static const _Iostate _Hardfail = ((_Iostate)16); 
#line 96
enum _Openmode { 
#line 98
_Openmask = 255}; 
#line 100
static const _Openmode in = ((_Openmode)1); 
#line 101
static const _Openmode out = ((_Openmode)2); 
#line 102
static const _Openmode ate = ((_Openmode)4); 
#line 103
static const _Openmode app = ((_Openmode)8); 
#line 104
static const _Openmode trunc = ((_Openmode)16); 
#line 105
static const _Openmode _Nocreate = ((_Openmode)64); 
#line 106
static const _Openmode _Noreplace = ((_Openmode)128); 
#line 107
static const _Openmode binary = ((_Openmode)32); 
#line 109
enum _Seekdir { 
#line 111
_Seekmask = 3}; 
#line 113
static const _Seekdir beg = ((_Seekdir)0); 
#line 114
static const _Seekdir cur = ((_Seekdir)1); 
#line 115
static const _Seekdir end = ((_Seekdir)2); 
#line 118
enum { 
#line 119
_Openprot = 64}; 
#line 120
}; 
#line 122
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 123
_Iosb< _Dummy> ::skipws; 
#line 124
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 125
_Iosb< _Dummy> ::unitbuf; 
#line 126
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 127
_Iosb< _Dummy> ::uppercase; 
#line 128
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 129
_Iosb< _Dummy> ::showbase; 
#line 130
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 131
_Iosb< _Dummy> ::showpoint; 
#line 132
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 133
_Iosb< _Dummy> ::showpos; 
#line 134
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 135
_Iosb< _Dummy> ::left; 
#line 136
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 137
_Iosb< _Dummy> ::right; 
#line 138
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 139
_Iosb< _Dummy> ::internal; 
#line 140
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 141
_Iosb< _Dummy> ::dec; 
#line 142
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 143
_Iosb< _Dummy> ::oct; 
#line 144
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 145
_Iosb< _Dummy> ::hex; 
#line 146
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 147
_Iosb< _Dummy> ::scientific; 
#line 148
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 149
_Iosb< _Dummy> ::fixed; 
#line 151
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 153
_Iosb< _Dummy> ::hexfloat; 
#line 155
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 156
_Iosb< _Dummy> ::boolalpha; 
#line 157
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 158
_Iosb< _Dummy> ::_Stdio; 
#line 159
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 160
_Iosb< _Dummy> ::adjustfield; 
#line 161
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 162
_Iosb< _Dummy> ::basefield; 
#line 163
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 164
_Iosb< _Dummy> ::floatfield; 
#line 166
template< class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
#line 167
_Iosb< _Dummy> ::goodbit; 
#line 168
template< class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
#line 169
_Iosb< _Dummy> ::eofbit; 
#line 170
template< class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
#line 171
_Iosb< _Dummy> ::failbit; 
#line 172
template< class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
#line 173
_Iosb< _Dummy> ::badbit; 
#line 174
template< class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
#line 175
_Iosb< _Dummy> ::_Hardfail; 
#line 177
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 178
_Iosb< _Dummy> ::in; 
#line 179
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 180
_Iosb< _Dummy> ::out; 
#line 181
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 182
_Iosb< _Dummy> ::ate; 
#line 183
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 184
_Iosb< _Dummy> ::app; 
#line 185
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 186
_Iosb< _Dummy> ::trunc; 
#line 187
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 188
_Iosb< _Dummy> ::_Nocreate; 
#line 189
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 190
_Iosb< _Dummy> ::_Noreplace; 
#line 191
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 192
_Iosb< _Dummy> ::binary; 
#line 194
template< class _Dummy> const typename _Iosb< _Dummy> ::_Seekdir 
#line 195
_Iosb< _Dummy> ::beg; 
#line 196
template< class _Dummy> const typename _Iosb< _Dummy> ::_Seekdir 
#line 197
_Iosb< _Dummy> ::cur; 
#line 198
template< class _Dummy> const typename _Iosb< _Dummy> ::_Seekdir 
#line 199
_Iosb< _Dummy> ::end; 
#line 202
class __declspec(dllimport) ios_base : public _Iosb< int>  { 
#line 206
public: typedef int fmtflags; 
#line 207
typedef int iostate; 
#line 208
typedef int openmode; 
#line 209
typedef int seekdir; 
#line 211
typedef std::streamoff streamoff; 
#line 212
typedef std::streampos streampos; 
#line 214
enum event { 
#line 216
erase_event, imbue_event, copyfmt_event}; 
#line 218
typedef void (__cdecl *event_callback)(event, ios_base &, int); 
#line 219
typedef unsigned io_state, open_mode, seek_dir; 
#line 222
class failure : public system_error { 
#line 228
public: explicit failure(const string &_Message, const error_code &
#line 229
_Errcode = make_error_code(io_errc::stream)) : system_error(_Errcode, _Message) 
#line 231
{ 
#line 232
} 
#line 234
explicit failure(const char *_Message, const error_code &
#line 235
_Errcode = make_error_code(io_errc::stream)) : system_error(_Errcode, _Message) 
#line 237
{ 
#line 238
} 
#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xiosbase"
}; 
#line 267
class __declspec(dllimport) Init { 
#line 270
public: Init() 
#line 271
{ 
#line 272
_Init_ctor(this); 
#line 273
} 
#line 275
~Init() 
#line 276
{ 
#line 277
_Init_dtor(this); 
#line 278
} 
#line 281
private: static void __cdecl _Init_ctor(Init *); 
#line 282
static void __cdecl _Init_dtor(Init *); 
#line 284
static int _Init_cnt; 
#line 286
static int &__cdecl _Init_cnt_func(); 
#line 287
}; 
#line 289
ios_base &operator=(const ios_base &_Right) 
#line 290
{ 
#line 291
if (this != (&_Right)) 
#line 292
{ 
#line 293
(_Mystate) = (_Right._Mystate); 
#line 294
this->copyfmt(_Right); 
#line 295
}  
#line 296
return *this; 
#line 297
} 
#line 299
operator void *() const 
#line 300
{ 
#line 301
return this->fail() ? (0) : ((void *)this); 
#line 302
} 
#line 304
bool operator!() const 
#line 305
{ 
#line 306
return this->fail(); 
#line 307
} 
#line 309
void clear(iostate _State, bool _Reraise) 
#line 310
{ 
#line 311
(_Mystate) = ((iostate)(_State & (_Statmask))); 
#line 312
if (((_Mystate) & (_Except)) == 0) { 
#line 313
; } else { 
#line 314
if (_Reraise) { 
#line 315
throw; } else { 
#line 316
if (((_Mystate) & (_Except)) & badbit) { 
#line 317
throw ((failure)("ios_base::badbit set")); } else { 
#line 318
if (((_Mystate) & (_Except)) & failbit) { 
#line 319
throw ((failure)("ios_base::failbit set")); } else { 
#line 321
throw ((failure)("ios_base::eofbit set")); }  }  }  }  
#line 322
} 
#line 324
void clear(iostate _State = goodbit) 
#line 325
{ 
#line 326
this->clear(_State, false); 
#line 327
} 
#line 329
void clear(io_state _State) 
#line 330
{ 
#line 331
this->clear((iostate)_State); 
#line 332
} 
#line 334
iostate rdstate() const 
#line 335
{ 
#line 336
return _Mystate; 
#line 337
} 
#line 339
void setstate(iostate _State, bool _Exreraise) 
#line 340
{ 
#line 341
if (_State != goodbit) { 
#line 342
this->clear((iostate)(((int)this->rdstate()) | _State), _Exreraise); }  
#line 343
} 
#line 345
void setstate(iostate _State) 
#line 346
{ 
#line 347
if (_State != goodbit) { 
#line 348
this->clear((iostate)(((int)this->rdstate()) | _State), false); }  
#line 349
} 
#line 351
void setstate(io_state _State) 
#line 352
{ 
#line 353
this->setstate((iostate)_State); 
#line 354
} 
#line 356
bool good() const 
#line 357
{ 
#line 358
return this->rdstate() == goodbit; 
#line 359
} 
#line 361
bool eof() const 
#line 362
{ 
#line 363
return ((int)this->rdstate()) & ((int)eofbit); 
#line 364
} 
#line 366
bool fail() const 
#line 367
{ 
#line 368
return (((int)this->rdstate()) & (((int)badbit) | ((int)failbit))) != 0; 
#line 370
} 
#line 372
bool bad() const 
#line 373
{ 
#line 374
return (((int)this->rdstate()) & ((int)badbit)) != 0; 
#line 375
} 
#line 377
iostate exceptions() const 
#line 378
{ 
#line 379
return _Except; 
#line 380
} 
#line 382
void exceptions(iostate _Newexcept) 
#line 383
{ 
#line 384
(_Except) = ((iostate)(_Newexcept & ((int)_Statmask))); 
#line 385
this->clear(_Mystate); 
#line 386
} 
#line 388
void exceptions(io_state _State) 
#line 389
{ 
#line 390
this->exceptions((iostate)_State); 
#line 391
} 
#line 393
fmtflags flags() const 
#line 394
{ 
#line 395
return _Fmtfl; 
#line 396
} 
#line 398
fmtflags flags(fmtflags _Newfmtflags) 
#line 399
{ 
#line 400
fmtflags _Oldfmtflags = _Fmtfl; 
#line 401
(_Fmtfl) = ((fmtflags)(_Newfmtflags & ((int)_Fmtmask))); 
#line 402
return _Oldfmtflags; 
#line 403
} 
#line 405
fmtflags setf(fmtflags _Newfmtflags) 
#line 406
{ 
#line 407
fmtflags _Oldfmtflags = _Fmtfl; 
#line 408
(_Fmtfl) = ((fmtflags)((_Fmtfl) | (_Newfmtflags & ((int)_Fmtmask)))); 
#line 410
return _Oldfmtflags; 
#line 411
} 
#line 413
fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask) 
#line 414
{ 
#line 415
fmtflags _Oldfmtflags = _Fmtfl; 
#line 416
(_Fmtfl) = ((fmtflags)(((_Fmtfl) & ((int)(~_Mask))) | ((_Newfmtflags & _Mask) & ((int)_Fmtmask)))); 
#line 418
return _Oldfmtflags; 
#line 419
} 
#line 421
void unsetf(fmtflags _Mask) 
#line 422
{ 
#line 423
(_Fmtfl) = ((fmtflags)((_Fmtfl) & ((int)(~_Mask)))); 
#line 424
} 
#line 426
streamsize precision() const 
#line 427
{ 
#line 428
return _Prec; 
#line 429
} 
#line 431
streamsize precision(streamsize _Newprecision) 
#line 432
{ 
#line 433
streamsize _Oldprecision = _Prec; 
#line 434
(_Prec) = _Newprecision; 
#line 435
return _Oldprecision; 
#line 436
} 
#line 438
streamsize width() const 
#line 439
{ 
#line 440
return _Wide; 
#line 441
} 
#line 443
streamsize width(streamsize _Newwidth) 
#line 444
{ 
#line 445
streamsize _Oldwidth = _Wide; 
#line 446
(_Wide) = _Newwidth; 
#line 447
return _Oldwidth; 
#line 448
} 
#line 450
locale getloc() const 
#line 451
{ 
#line 452
return *(_Ploc); 
#line 453
} 
#line 455
locale imbue(const locale &_Loc) 
#line 456
{ 
#line 457
locale _Oldlocale = *(_Ploc); 
#line 458
((*(_Ploc)) = _Loc); 
#line 459
this->_Callfns(imbue_event); 
#line 460
return _Oldlocale; 
#line 461
} 
#line 463
static int __cdecl xalloc() 
#line 464
{ 
#line 465
{ _Lockit _Lock(2); 
#line 466
return _Index++; 
#line 467
} 
#line 468
} 
#line 470
long &iword(int _Idx) 
#line 471
{ 
#line 472
return this->_Findarr(_Idx)._Lo; 
#line 473
} 
#line 475
void *&pword(int _Idx) 
#line 476
{ 
#line 477
return this->_Findarr(_Idx)._Vp; 
#line 478
} 
#line 480
void register_callback(event_callback _Pfn, int 
#line 481
_Idx) 
#line 482
{ 
#line 483
(_Calls) = (new _Fnarray(_Idx, _Pfn, _Calls)); 
#line 484
} 
#line 486
ios_base &copyfmt(const ios_base &_Other) 
#line 487
{ 
#line 488
if (this != (&_Other)) 
#line 489
{ 
#line 490
this->_Tidy(); 
#line 491
((*(_Ploc)) = (*(_Other._Ploc))); 
#line 492
(_Fmtfl) = (_Other._Fmtfl); 
#line 493
(_Prec) = (_Other._Prec); 
#line 494
(_Wide) = (_Other._Wide); 
#line 495
_Iosarray *_Ptr = _Other._Arr; 
#line 497
for ((_Arr) = (0); _Ptr != (0); _Ptr = (_Ptr->_Next)) { 
#line 498
if (((_Ptr->_Lo) != (0)) || ((_Ptr->_Vp) != (0))) 
#line 499
{ 
#line 500
this->iword(_Ptr->_Index) = (_Ptr->_Lo); 
#line 501
this->pword(_Ptr->_Index) = (_Ptr->_Vp); 
#line 502
}  }  
#line 504
for (_Fnarray *_Pfa = _Other._Calls; _Pfa != (0); _Pfa = (_Pfa->_Next)) { 
#line 506
this->register_callback(_Pfa->_Pfn, _Pfa->_Index); }  
#line 508
this->_Callfns(copyfmt_event); 
#line 509
this->exceptions(_Other._Except); 
#line 510
}  
#line 511
return *this; 
#line 512
} 
#line 514
static bool __cdecl sync_with_stdio(bool _Newsync = true) 
#line 515
{ 
#line 516
{ _Lockit _Lock(2); 
#line 517
const bool _Oldsync = _Sync; 
#line 518
_Sync = _Newsync; 
#line 519
return _Oldsync; 
#line 520
} 
#line 521
} 
#line 523
void swap(ios_base &_Right) 
#line 524
{ 
#line 525
if (this != (&_Right)) 
#line 526
{ 
#line 527
::std::swap(_Mystate, _Right._Mystate); 
#line 528
::std::swap(_Except, _Right._Except); 
#line 529
::std::swap(_Fmtfl, _Right._Fmtfl); 
#line 530
::std::swap(_Prec, _Right._Prec); 
#line 531
::std::swap(_Wide, _Right._Wide); 
#line 533
::std::swap(_Arr, _Right._Arr); 
#line 534
::std::swap(_Calls, _Right._Calls); 
#line 535
::std::swap(_Ploc, _Right._Ploc); 
#line 536
}  
#line 537
} 
#line 539
virtual ~ios_base() 
#line 540
{ 
#line 541
_Ios_base_dtor(this); 
#line 542
} 
#line 544
static void __cdecl _Addstd(ios_base *); 
#line 546
size_t _Stdstr; 
#line 549
protected: ios_base() 
#line 550
{ 
#line 551
} 
#line 553
void _Init() 
#line 554
{ 
#line 555
(_Ploc) = (0); 
#line 556
(_Stdstr) = (0); 
#line 557
(_Except) = goodbit; 
#line 558
(_Fmtfl) = ((fmtflags)(skipws | dec)); 
#line 559
(_Prec) = (6); 
#line 560
(_Wide) = (0); 
#line 561
(_Arr) = (0); 
#line 562
(_Calls) = (0); 
#line 563
this->clear(goodbit); 
#line 564
(_Ploc) = (new locale); 
#line 565
} 
#line 569
private: struct _Iosarray { 
#line 572
_Iosarray(int _Idx, _Iosarray *_Link) : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0) 
#line 574
{ 
#line 575
} 
#line 577
_Iosarray *_Next; 
#line 578
int _Index; 
#line 579
long _Lo; 
#line 580
void *_Vp; 
#line 581
}; 
#line 584
struct _Fnarray { 
#line 586
_Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link) : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) 
#line 588
{ 
#line 589
} 
#line 591
_Fnarray *_Next; 
#line 592
int _Index; 
#line 593
event_callback _Pfn; 
#line 594
}; 
#line 596
void _Callfns(event _Ev) 
#line 597
{ 
#line 598
for (_Fnarray *_Pfa = _Calls; _Pfa != (0); _Pfa = (_Pfa->_Next)) { 
#line 599
(*(_Pfa->_Pfn))(_Ev, *this, _Pfa->_Index); }  
#line 600
} 
#line 602
_Iosarray &_Findarr(int _Idx) 
#line 603
{ 
#line 604
_Iosarray *_Ptr1, *_Ptr2; 
#line 606
for ((_Ptr1 = (_Arr)), (_Ptr2 = (0)); _Ptr1 != (0); _Ptr1 = (_Ptr1->_Next)) { 
#line 607
if ((_Ptr1->_Index) == _Idx) { 
#line 608
return *_Ptr1; } else { 
#line 609
if (((_Ptr2 == (0)) && ((_Ptr1->_Lo) == (0))) && ((_Ptr1->_Vp) == (0))) { 
#line 610
_Ptr2 = _Ptr1; }  }  }  
#line 612
if (_Ptr2 != (0)) 
#line 613
{ 
#line 614
(_Ptr2->_Index) = _Idx; 
#line 615
return *_Ptr2; 
#line 616
}  
#line 618
(_Arr) = (new _Iosarray(_Idx, _Arr)); 
#line 619
return *(_Arr); 
#line 620
} 
#line 622
void _Tidy() 
#line 623
{ 
#line 624
this->_Callfns(erase_event); 
#line 625
_Iosarray *_Ptr1, *_Ptr2; 
#line 627
for (_Ptr1 = (_Arr); _Ptr1 != (0); _Ptr1 = _Ptr2) 
#line 628
{ 
#line 629
_Ptr2 = (_Ptr1->_Next); 
#line 630
delete _Ptr1; 
#line 631
}  
#line 632
(_Arr) = (0); 
#line 634
_Fnarray *_Pfa1, *_Pfa2; 
#line 635
for (_Pfa1 = (_Calls); _Pfa1 != (0); _Pfa1 = _Pfa2) 
#line 636
{ 
#line 637
_Pfa2 = (_Pfa1->_Next); 
#line 638
delete _Pfa1; 
#line 639
}  
#line 640
(_Calls) = (0); 
#line 641
} 
#line 643
iostate _Mystate; 
#line 644
iostate _Except; 
#line 645
fmtflags _Fmtfl; 
#line 646
streamsize _Prec; 
#line 647
streamsize _Wide; 
#line 648
_Iosarray *_Arr; 
#line 649
_Fnarray *_Calls; 
#line 650
locale *_Ploc; 
#line 652
static int _Index; 
#line 653
static bool _Sync; 
#line 655
static void __cdecl _Ios_base_dtor(ios_base *); 
#line 656
}; 
#line 662
}
#line 666
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\streambuf"
#pragma warning(push,3)
#line 667 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xiosbase"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\streambuf"
#pragma pack ( push, 8 )
#line 14
namespace std { 
#line 16
template < class _Elem,
 class _Traits >
 class basic_streambuf
 {
 typedef basic_streambuf < _Elem, _Traits > _Myt;

protected :
  basic_streambuf ( )
  : _Plocale ( new locale )
  {
  _Init ( );
  }

  basic_streambuf ( _Uninitialized )
  : _Mylock ( _Noinit )
  {
  }

  basic_streambuf ( const _Myt & _Right )
  : _Plocale ( new locale ( _Right . getloc ( ) ) )
  {
  _Init ( );
  setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
  setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  if ( this != & _Right )
   {
   setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
   setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
   pubimbue ( _Right . getloc ( ) );
   }
  return ( * this );
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Elem * _Tfirst = pbase ( );
   _Elem * _Tnext = pptr ( );
   _Elem * _Tend = epptr ( );
   setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
   _Right . setp ( _Tfirst, _Tnext, _Tend );

   _Tfirst = eback ( );
   _Tnext = gptr ( );
   _Tend = egptr ( );
   setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
   _Right . setg ( _Tfirst, _Tnext, _Tend );

   locale _Oldlocale = pubimbue ( _Right . getloc ( ) );
   _Right . pubimbue ( _Oldlocale );
   }
  }

public :
 typedef _Elem char_type;
 typedef _Traits traits_type;

 virtual ~ basic_streambuf ( )
  {
  delete ( _Plocale );
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 pos_type pubseekoff ( off_type _Off,
  ios_base :: seekdir _Way,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  {
  return ( seekoff ( _Off, _Way, _Mode ) );
  }

 pos_type pubseekoff ( off_type _Off,
  ios_base :: seek_dir _Way,
  ios_base :: open_mode _Mode )
  {
  return ( pubseekoff ( _Off, ( ios_base :: seekdir ) _Way,
   ( ios_base :: openmode ) _Mode ) );
  }

 pos_type pubseekpos ( pos_type _Pos,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  {
  return ( seekpos ( _Pos, _Mode ) );
  }

 pos_type pubseekpos ( pos_type _Pos,
  ios_base :: open_mode _Mode )
  {
  return ( seekpos ( _Pos, ( ios_base :: openmode ) _Mode ) );
  }

 _Myt * pubsetbuf ( _Elem * _Buffer,
  streamsize _Count )
  {
  return ( setbuf ( _Buffer, _Count ) );
  }

 locale pubimbue ( const locale & _Newlocale )
  {
  locale _Oldlocale = * _Plocale;
  imbue ( _Newlocale );
  * _Plocale = _Newlocale;
  return ( _Oldlocale );
  }

 locale getloc ( ) const
  {
  return ( * _Plocale );
  }

 streamsize in_avail ( )
  {
  streamsize _Res = _Gnavail ( );
  return ( 0 < _Res ? _Res : showmanyc ( ) );
  }

 int pubsync ( )
  {
  return ( sync ( ) );
  }

 int_type sbumpc ( )
  {
  return ( 0 < _Gnavail ( )
   ? _Traits :: to_int_type ( * _Gninc ( ) ) : uflow ( ) );
  }

 int_type sgetc ( )
  {
  return ( 0 < _Gnavail ( )
   ? _Traits :: to_int_type ( * gptr ( ) ) : underflow ( ) );
  }

 streamsize sgetn ( _Elem * _Ptr,
  streamsize _Count )
  {
  return ( xsgetn ( _Ptr, _Count ) );
  }

 int_type snextc ( )
  {
  return ( 1 < _Gnavail ( )
   ? _Traits :: to_int_type ( * _Gnpreinc ( ) )
   : _Traits :: eq_int_type ( _Traits :: eof ( ), sbumpc ( ) )
    ? _Traits :: eof ( ) : sgetc ( ) );
  }

 int_type sputbackc ( _Elem _Ch )
  {
  return ( gptr ( ) != 0 && eback ( ) < gptr ( )
   && _Traits :: eq ( _Ch, gptr ( ) [ - 1 ] )
   ? _Traits :: to_int_type ( * _Gndec ( ) )
   : pbackfail ( _Traits :: to_int_type ( _Ch ) ) );
  }

 void stossc ( )
  {
  if ( 0 < _Gnavail ( ) )
   _Gninc ( );
  else
   uflow ( );
  }

 int_type sungetc ( )
  {
  return ( gptr ( ) != 0 && eback ( ) < gptr ( )
   ? _Traits :: to_int_type ( * _Gndec ( ) ) : pbackfail ( ) );
  }

 int_type sputc ( _Elem _Ch )
  {
  return ( 0 < _Pnavail ( )
   ? _Traits :: to_int_type ( * _Pninc ( ) = _Ch )
   : overflow ( _Traits :: to_int_type ( _Ch ) ) );
  }

 streamsize sputn ( const _Elem * _Ptr,
  streamsize _Count )
  {
  return ( xsputn ( _Ptr, _Count ) );
  }

 virtual void _Lock ( )
  {
  _Mylock . _Lock ( );
  }

 virtual void _Unlock ( )
  {
  _Mylock . _Unlock ( );
  }

protected :
 _Elem * eback ( ) const
  {
  return ( * _IGfirst );
  }

 _Elem * gptr ( ) const
  {
  return ( * _IGnext );
  }

 _Elem * pbase ( ) const
  {
  return ( * _IPfirst );
  }

 _Elem * pptr ( ) const
  {
  return ( * _IPnext );
  }

 _Elem * egptr ( ) const
  {
  return ( * _IGnext + * _IGcount );
  }

 void gbump ( int _Off )
  {
  * _IGcount -= _Off;
  * _IGnext += _Off;
  }

 void setg ( _Elem * _First, _Elem * _Next, _Elem * _Last )
  {
  * _IGfirst = _First;
  * _IGnext = _Next;
  * _IGcount = ( int ) ( _Last - _Next );
  }

 _Elem * epptr ( ) const
  {
  return ( * _IPnext + * _IPcount );
  }

 _Elem * _Gndec ( )
  {
  ++ * _IGcount;
  return ( -- * _IGnext );
  }

 _Elem * _Gninc ( )
  {
  -- * _IGcount;
  return ( ( * _IGnext ) ++ );
  }

 _Elem * _Gnpreinc ( )
  {
  -- * _IGcount;
  return ( ++ ( * _IGnext ) );
  }

 streamsize _Gnavail ( ) const
  {
  return ( * _IGnext != 0 ? * _IGcount : 0 );
  }

 void pbump ( int _Off )
  {
  * _IPcount -= _Off;
  * _IPnext += _Off;
  }

 void setp ( _Elem * _First, _Elem * _Last )
  {
  * _IPfirst = _First;
  * _IPnext = _First;
  * _IPcount = ( int ) ( _Last - _First );
  }

 void setp ( _Elem * _First, _Elem * _Next, _Elem * _Last )
  {
  * _IPfirst = _First;
  * _IPnext = _Next;
  * _IPcount = ( int ) ( _Last - _Next );
  }

 _Elem * _Pninc ( )
  {
  -- * _IPcount;
  return ( ( * _IPnext ) ++ );
  }

 streamsize _Pnavail ( ) const
  {
  return ( * _IPnext != 0 ? * _IPcount : 0 );
  }

 void _Init ( )
  {
  _IGfirst = & _Gfirst;
  _IPfirst = & _Pfirst;
  _IGnext = & _Gnext;
  _IPnext = & _Pnext;
  _IGcount = & _Gcount;
  _IPcount = & _Pcount;
  setp ( 0, 0 );
  setg ( 0, 0, 0 );
  }

 void _Init ( _Elem * * _Gf, _Elem * * _Gn, int * _Gc,
  _Elem * * _Pf, _Elem * * _Pn, int * _Pc )
  {
  _IGfirst = _Gf;
  _IPfirst = _Pf;
  _IGnext = _Gn;
  _IPnext = _Pn;
  _IGcount = _Gc;
  _IPcount = _Pc;
  }

 virtual int_type overflow ( int_type = _Traits :: eof ( ) )
  {
  return ( _Traits :: eof ( ) );
  }

 virtual int_type pbackfail ( int_type = _Traits :: eof ( ) )
  {
  return ( _Traits :: eof ( ) );
  }

 virtual streamsize showmanyc ( )
  {
  return ( 0 );
  }

 virtual int_type underflow ( )
  {
  return ( _Traits :: eof ( ) );
  }

 virtual int_type uflow ( )
  {
  return ( _Traits :: eq_int_type ( _Traits :: eof ( ), underflow ( ) )
   ? _Traits :: eof ( ) : _Traits :: to_int_type ( * _Gninc ( ) ) );
  }

 virtual streamsize xsgetn ( _Elem * _Ptr,
  streamsize _Count )
  {
  int_type _Meta;
  streamsize _Size, _Copied;

  for ( _Copied = 0; 0 < _Count; )
   if ( 0 < ( _Size = _Gnavail ( ) ) )
    {
    if ( _Count < _Size )
     _Size = _Count;
    _Traits :: copy ( _Ptr, gptr ( ), ( size_t ) _Size );
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    gbump ( ( int ) _Size );
    }
   else if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta = uflow ( ) ) )
    break;
   else
    {
    * _Ptr ++ = _Traits :: to_char_type ( _Meta );
    ++ _Copied;
    -- _Count;
    }

  return ( _Copied );
  }

 virtual streamsize xsputn ( const _Elem * _Ptr,
  streamsize _Count )
  {
  streamsize _Size, _Copied;

  for ( _Copied = 0; 0 < _Count; )
   if ( 0 < ( _Size = _Pnavail ( ) ) )
    {
    if ( _Count < _Size )
     _Size = _Count;
    _Traits :: copy ( pptr ( ), _Ptr, ( size_t ) _Size );
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    pbump ( ( int ) _Size );
    }
   else if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    overflow ( _Traits :: to_int_type ( * _Ptr ) ) ) )
    break;
   else
    {
    ++ _Ptr;
    ++ _Copied;
    -- _Count;
    }

  return ( _Copied );
  }

 virtual pos_type seekoff ( off_type,
  ios_base :: seekdir,
  ios_base :: openmode = ios_base :: in | ios_base :: out )
  {
  return ( streampos ( _BADOFF ) );
  }

 virtual pos_type seekpos ( pos_type,
  ios_base :: openmode = ios_base :: in | ios_base :: out )
  {
  return ( streampos ( _BADOFF ) );
  }

 virtual _Myt * setbuf ( _Elem *, streamsize )
  {
  return ( this );
  }

 virtual int sync ( )
  {
  return ( 0 );
  }

 virtual void imbue ( const locale & )
  {
  }

private :
 _Mutex _Mylock;
 _Elem * _Gfirst;
 _Elem * _Pfirst;
 _Elem * * _IGfirst;
 _Elem * * _IPfirst;
 _Elem * _Gnext;
 _Elem * _Pnext;
 _Elem * * _IGnext;
 _Elem * * _IPnext;

 int _Gcount;
 int _Pcount;
 int * _IGcount;
 int * _IPcount;

 locale * _Plocale;
 };
#line 468
template class __declspec(dllimport) basic_streambuf< char, char_traits< char> > ;
#line 469
template class __declspec(dllimport) basic_streambuf< __wchar_t, char_traits< __wchar_t> > ;
#line 475 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\streambuf"
template < class _Elem,
 class _Traits >
 class istreambuf_iterator
  : public iterator < input_iterator_tag,
   _Elem, typename _Traits :: off_type, _Elem *, _Elem & >
 {
 typedef istreambuf_iterator < _Elem, _Traits > _Myt;
public :
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf < _Elem, _Traits > streambuf_type;
 typedef basic_istream < _Elem, _Traits > istream_type;

 typedef typename traits_type :: int_type int_type;

 istreambuf_iterator ( streambuf_type * _Sb = 0 ) throw ( )
  : _Strbuf ( _Sb ), _Got ( _Sb == 0 )
  {
  }

 istreambuf_iterator ( istream_type & _Istr ) throw ( )
  : _Strbuf ( _Istr . rdbuf ( ) ), _Got ( _Istr . rdbuf ( ) == 0 )
  {
  }

 _Elem operator * ( ) const
  {
  if ( ! _Got )
   _Peek ( );






  return ( _Val );
  }

 _Myt & operator ++ ( )
  {





  _Inc ( );
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  if ( ! _Got )
   _Peek ( );
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 bool equal ( const _Myt & _Right ) const
  {
  if ( ! _Got )
   _Peek ( );
  if ( ! _Right . _Got )
   _Right . _Peek ( );
  return ( _Strbuf == 0 && _Right . _Strbuf == 0
   || _Strbuf != 0 && _Right . _Strbuf != 0 );
  }

private :
 void _Inc ( )
  {
  if ( _Strbuf == 0
   || traits_type :: eq_int_type ( traits_type :: eof ( ),
    _Strbuf -> sbumpc ( ) ) )
   _Strbuf = 0, _Got = true;
  else
   _Got = false;
  }

 _Elem _Peek ( ) const
  {
  int_type _Meta;
  if ( _Strbuf == 0
   || traits_type :: eq_int_type ( traits_type :: eof ( ),
    _Meta = _Strbuf -> sgetc ( ) ) )
   _Strbuf = 0;
  else
   _Val = traits_type :: to_char_type ( _Meta );
  _Got = true;
  return ( _Val );
  }

 mutable streambuf_type * _Strbuf;
 mutable bool _Got;
 mutable _Elem _Val;
 };
#line 572 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\streambuf"
template< class _Elem, class 
#line 573
_Traits> 
#pragma pack(8)
#line 574
struct _Is_checked_helper< istreambuf_iterator< _Elem, _Traits> >  : public tr1::true_type { 
#line 577
}; 
#pragma pack()
#line 580
template < class _Elem,
 class _Traits > inline
 bool operator == (
  const istreambuf_iterator < _Elem, _Traits > & _Left,
  const istreambuf_iterator < _Elem, _Traits > & _Right )
 {
 return ( _Left . equal ( _Right ) );
 }
#line 589
template < class _Elem,
 class _Traits > inline
 bool operator != (
  const istreambuf_iterator < _Elem, _Traits > & _Left,
  const istreambuf_iterator < _Elem, _Traits > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 599
template < class _Elem,
 class _Traits >
 class ostreambuf_iterator
  : public _Outit
 {
 typedef ostreambuf_iterator < _Elem, _Traits > _Myt;
public :
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf < _Elem, _Traits > streambuf_type;
 typedef basic_ostream < _Elem, _Traits > ostream_type;

 ostreambuf_iterator ( streambuf_type * _Sb ) throw ( )
  : _Failed ( false ), _Strbuf ( _Sb )
  {
  }

 ostreambuf_iterator ( ostream_type & _Ostr ) throw ( )
  : _Failed ( false ), _Strbuf ( _Ostr . rdbuf ( ) )
  {
  }

 _Myt & operator = ( _Elem _Right )
  {
  if ( _Strbuf == 0
   || traits_type :: eq_int_type ( _Traits :: eof ( ),
    _Strbuf -> sputc ( _Right ) ) )
   _Failed = true;
  return ( * this );
  }

 _Myt & operator * ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( int )
  {
  return ( * this );
  }

 bool failed ( ) const throw ( )
  {
  return ( _Failed );
  }

private :
 bool _Failed;
 streambuf_type * _Strbuf;
 };
#line 655
template< class _Elem, class 
#line 656
_Traits> 
#pragma pack(8)
#line 657
struct _Is_checked_helper< ostreambuf_iterator< _Elem, _Traits> >  : public tr1::true_type { 
#line 660
}; 
#pragma pack()
#line 661
}
#line 665
#pragma warning(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum"
#pragma warning(push,3)
#line 18
#pragma warning(disable: 4189 4275)
#line 666 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\streambuf"
#pragma pack ( pop )
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum"
#pragma pack ( push, 8 )
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum"
extern "C" { __declspec(dllimport) extern float __cdecl _Stofx(const char *, char **, long, int *); } 
#line 30
extern "C" { __declspec(dllimport) extern double __cdecl _Stodx(const char *, char **, long, int *); } 
#line 33
extern "C" { __declspec(dllimport) extern long double __cdecl _Stoldx(const char *, char **, long, int *); } 
#line 36
extern "C" { __declspec(dllimport) extern long __cdecl _Stolx(const char *, char **, int, int *); } 
#line 39
extern "C" { __declspec(dllimport) extern unsigned long __cdecl _Stoulx(const char *, char **, int, int *); } 
#line 42
extern "C" { __declspec(dllimport) extern __int64 __cdecl _Stollx(const char *, char **, int, int *); } 
#line 45
extern "C" { __declspec(dllimport) extern unsigned __int64 __cdecl _Stoullx(const char *, char **, int, int *); } 
#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum"
namespace std { 
#line 56
template < class _Elem >
 class numpunct
  : public locale :: facet
 {
public :
 typedef basic_string < _Elem, char_traits < _Elem >, allocator < _Elem > >
  string_type;
 typedef _Elem char_type;

  __declspec ( dllimport ) static locale :: id id;

 _Elem decimal_point ( ) const
  {
  return ( do_decimal_point ( ) );
  }

 _Elem thousands_sep ( ) const
  {
  return ( do_thousands_sep ( ) );
  }

 string grouping ( ) const
  {
  return ( do_grouping ( ) );
  }

 string_type falsename ( ) const
  {
  return ( do_falsename ( ) );
  }

 string_type truename ( ) const
  {
  return ( do_truename ( ) );
  }

 explicit numpunct ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
   if ( _Kseparator == 0 )
    _Kseparator =
     _Maklocchr ( ',', ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
  }
  }

 numpunct ( const _Locinfo & _Lobj, size_t _Refs = 0, bool _Isdef = false )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj, _Isdef );
  }

 static size_t _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new numpunct < _Elem > (
    _Locinfo ( _Ploc -> c_str ( ) ), 0, true );
  return ( 4 );
  }

protected :
 virtual ~ numpunct ( )
  {
  _Tidy ( );
  }

 numpunct ( const char * _Locname, size_t _Refs = 0, bool _Isdef = false )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj ( _Locname );
   _Init ( _Lobj, _Isdef );
  }
  }

 void _Init ( const _Locinfo & _Lobj, bool _Isdef = false )
  {
  const lconv * _Ptr = _Lobj . _Getlconv ( );

  _Grouping = 0;
  _Falsename = 0;
  _Truename = 0;

  try {
  _Grouping = _Maklocstr ( _Isdef ? "" : _Ptr -> grouping, ( char * ) 0, _Lobj . _Getcvt ( ) );

  _Falsename = _Maklocstr ( _Lobj . _Getfalse ( ), ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
  _Truename = _Maklocstr ( _Lobj . _Gettrue ( ), ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
  } catch ( ... ) {
  _Tidy ( );
  throw;
  }

  _Dp = _Maklocchr ( _Ptr -> decimal_point [ 0 ], ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
  _Kseparator =
   _Maklocchr ( _Ptr -> thousands_sep [ 0 ], ( _Elem * ) 0, _Lobj . _Getcvt ( ) );

  if ( _Isdef )
   {

   _Dp = _Maklocchr ( '.', ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
   _Kseparator = _Maklocchr ( ',', ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
   }
  }

 virtual _Elem do_decimal_point ( ) const
  {
  return ( _Dp );
  }

 virtual _Elem do_thousands_sep ( ) const
  {
  return ( _Kseparator );
  }

 virtual string do_grouping ( ) const
  {
  return ( string ( _Grouping ) );
  }

 virtual string_type do_falsename ( ) const
  {
  return ( string_type ( _Falsename ) );
  }

 virtual string_type do_truename ( ) const
  {
  return ( string_type ( _Truename ) );
  }

private :
 void _Tidy ( )
  {
  delete [ ] ( ( void * ) _Grouping );
  delete [ ] ( ( void * ) _Falsename );
  delete [ ] ( ( void * ) _Truename );
  }

 const char * _Grouping;
 _Elem _Dp;
 _Elem _Kseparator;
 const _Elem * _Falsename;
 const _Elem * _Truename;
 };
#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum"
template < class _Elem >
 class numpunct_byname
  : public numpunct < _Elem >
 {
public :
 explicit numpunct_byname ( const char * _Locname, size_t _Refs = 0 )
  : numpunct < _Elem > ( _Locname, _Refs )
  {
  }


 explicit numpunct_byname ( const string & _Str, size_t _Refs = 0 )
  : numpunct < _Elem > ( _Str . c_str ( ), _Refs )
  {
  }


protected :
 virtual ~ numpunct_byname ( )
  {
  }
 };
#line 227 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum"
template< class _Elem> locale::id 
#line 228
numpunct< _Elem> ::id; 
#line 231
template < class _Elem,
 class _InIt = istreambuf_iterator < _Elem, char_traits < _Elem > > >
 class num_get
  : public locale :: facet
 {
public :
 typedef numpunct < _Elem > _Mypunct;
 typedef basic_string < _Elem, char_traits < _Elem >, allocator < _Elem > >
  _Mystr;

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new num_get < _Elem, _InIt > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 4 );
  }

  static locale :: id id;

protected :
 virtual ~ num_get ( )
  {
  }

 void _Init ( const _Locinfo & _Lobj )
  {
  _Cvt = _Lobj . _Getcvt ( );
  }

 _Locinfo :: _Cvtvec _Cvt;

public :
 explicit num_get ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

  num_get ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj );
  }

 typedef _Elem char_type;
 typedef _InIt iter_type;

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   _Bool & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned short & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned int & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned long & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }


 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   __int64 & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned __int64 & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }


 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   float & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   double & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long double & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   void * & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

protected :
 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   _Bool & _Val ) const
  {
  ;
  int _Ans = - 1;

  if ( _Iosbase . flags ( ) & ios_base :: boolalpha )
   {
   typedef typename _Mystr :: size_type _Mystrsize;
   const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
   _Mystr _Str ( ( _Mystrsize ) 1, ( char_type ) 0 );
   _Str += _Punct_fac . falsename ( );
   _Str += ( char_type ) 0;
   _Str += _Punct_fac . truename ( );
   _Ans = _Getloctxt ( _First, _Last, ( size_t ) 2, _Str . c_str ( ) );
   }
  else
   {
   char _Ac [ 32 ], * _Ep;
   int _Errno = 0;
   const unsigned long _Ulo = :: _Stoulx ( _Ac, & _Ep,
    _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
     _Iosbase . getloc ( ) ), & _Errno );
   if ( _Ep != _Ac && _Errno == 0 && _Ulo <= 1 )
    _Ans = _Ulo;
   }

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ans < 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans != 0;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned short & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
   _Iosbase . getloc ( ) );
  char * _Ptr = _Ac [ 0 ] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx ( _Ptr, & _Ep, _Base, & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ptr || _Errno != 0 || 65535 < _Ans )
   _State |= ios_base :: failbit;
  else
   _Val = ( unsigned short ) ( _Ac [ 0 ] == '-'
    ? 0 - _Ans : _Ans );
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned int & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
   _Iosbase . getloc ( ) );
  char * _Ptr = _Ac [ 0 ] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx ( _Ptr, & _Ep, _Base, & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ptr || _Errno != 0 || 4294967295U < _Ans )
   _State |= ios_base :: failbit;
  else
   _Val = _Ac [ 0 ] == '-' ? 0 - _Ans : _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const long _Ans = :: _Stolx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned long & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const unsigned long _Ans = :: _Stoulx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }


 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   __int64 & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const __int64 _Ans = :: _Stollx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned __int64 & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const unsigned __int64 _Ans = :: _Stoullx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }


 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   float & _Val ) const
  {
  ;
  char _Ac [ 8 + 36 + 16 ], * _Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  float _Ans = :: _Stofx ( _Ac, & _Ep,
   _Getffld ( _Ac, _First, _Last,
    _Iosbase, & _Hexexp ), & _Errno );

  if ( _Hexexp != 0 )
   _Ans = :: ldexpf ( _Ans, 4 * _Hexexp );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   double & _Val ) const
  {
  ;
  char _Ac [ 8 + 36 + 16 ], * _Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  double _Ans = :: _Stodx ( _Ac, & _Ep,
   _Getffld ( _Ac, _First, _Last,
    _Iosbase, & _Hexexp ), & _Errno );

  if ( _Hexexp != 0 )
   _Ans = :: ldexp ( _Ans, 4 * _Hexexp );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long double & _Val ) const
  {
  ;
  char _Ac [ 8 + 36 + 16 ], * _Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  long double _Ans = :: _Stoldx ( _Ac, & _Ep,
   _Getffld ( _Ac, _First, _Last,
    _Iosbase, & _Hexexp ), & _Errno );

  if ( _Hexexp != 0 )
   _Ans = :: ldexpl ( _Ans, 4 * _Hexexp );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   void * & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;


  int _Base = _Getifld ( _Ac, _First, _Last, ios_base :: hex,
   _Iosbase . getloc ( ) );
  const unsigned __int64 _Ans =
   ( sizeof ( void * ) == sizeof ( unsigned long ) )
    ? ( unsigned __int64 ) :: _Stoulx ( _Ac, & _Ep, _Base, & _Errno )
    : :: _Stoullx ( _Ac, & _Ep, _Base, & _Errno );







  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = ( void * ) ( ( char * ) 0 + _Ans );
  return ( _First );
  }

private :
 int __cdecl _Getifld ( char * _Ac,
  _InIt & _First, _InIt & _Last, ios_base :: fmtflags _Basefield,
   const locale & _Loc ) const
  {
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Loc );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _Kseparator = _Grouping . size ( ) == 0
   ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );
  const _Elem _E0 = _Maklocchr ( '0', ( _Elem * ) 0, _Cvt );
  char * _Ptr = _Ac;

  if ( _First == _Last )
   ;
  else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '+', ++ _First;
  else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '-', ++ _First;

  _Basefield &= ios_base :: basefield;
  int _Base = _Basefield == ios_base :: oct ? 8
   : _Basefield == ios_base :: hex ? 16
   : _Basefield == ios_base :: _Fmtzero ? 0 : 10;

  bool _Seendigit = false;
  bool _Nonzero = false;

  if ( _First != _Last && * _First == _E0 )
   {
   _Seendigit = true, ++ _First;
   if ( _First != _Last && ( * _First == _Maklocchr ( 'x', ( _Elem * ) 0, _Cvt )
     || * _First == _Maklocchr ( 'X', ( _Elem * ) 0, _Cvt ) )
    && ( _Base == 0 || _Base == 16 ) )
    _Base = 16, _Seendigit = false, ++ _First;
   else if ( _Base == 0 )
    _Base = 8;
   }

  int _Dlen = _Base == 0 || _Base == 10 ? 10
   : _Base == 8 ? 8 : 16 + 6;
  string _Groups ( ( size_t ) 1, ( char ) _Seendigit );
  size_t _Group = 0;

  for ( char * const _Pe = & _Ac [ 32 - 1 ];
   _First != _Last; ++ _First )
   if ( :: memchr ( ( const char * ) "0123456789abcdefABCDEF",
    * _Ptr = _Maklocbyte ( ( _Elem ) * _First, _Cvt ), _Dlen ) != 0 )
    {
    if ( ( _Nonzero || * _Ptr != '0' ) && _Ptr < _Pe )
     ++ _Ptr, _Nonzero = true;
    _Seendigit = true;
    if ( _Groups [ _Group ] != 127 )
     ++ _Groups [ _Group ];
    }
   else if ( _Groups [ _Group ] == '\000'
    || _Kseparator == ( _Elem ) 0
    || * _First != _Kseparator )
    break;
   else
    {
    _Groups . append ( ( string :: size_type ) 1, '\000' );
    ++ _Group;
    }

  if ( _Group == 0 )
   ;
  else if ( '\000' < _Groups [ _Group ] )
   ++ _Group;
  else
   _Seendigit = false;

  for ( const char * _Pg = _Grouping . c_str ( ); _Seendigit && 0 < _Group; )
   if ( * _Pg == 127 )
    break;
   else if ( 0 < -- _Group && * _Pg != _Groups [ _Group ]
    || 0 == _Group && * _Pg < _Groups [ _Group ] )
    _Seendigit = false;
   else if ( '\000' < _Pg [ 1 ] )
    ++ _Pg;

  if ( _Seendigit && ! _Nonzero )
   * _Ptr ++ = '0';
  else if ( ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  return ( _Base );
  }

 int __cdecl _Getffld ( char * _Ac,
  _InIt & _First, _InIt & _Last,
  ios_base & _Iosbase, int * _Phexexp ) const
  {
  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) == ios_base :: hexfloat )
   return ( _Getffldx ( _Ac, _First, _Last,
    _Iosbase, _Phexexp ) );

  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _E0 = _Maklocchr ( '0', ( _Elem * ) 0, _Cvt );
  char * _Ptr = _Ac;
  bool _Bad = false;

  if ( _First == _Last )
   ;
  else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '+', ++ _First;
  else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '-', ++ _First;

  bool _Seendigit = false;
  int _Significant = 0;
  int _Pten = 0;

  if ( * _Grouping . c_str ( ) == 127 || * _Grouping . c_str ( ) <= '\000' )
   for (; _First != _Last
    && _E0 <= * _First && * _First <= _E0 + 9;
     _Seendigit = true, ++ _First )
    if ( 36 <= _Significant )
     ++ _Pten;
    else if ( * _First == _E0 && _Significant == 0 )
     ;
    else
     {
     * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
     ++ _Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping . size ( ) == 0
    ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );
   string _Groups ( ( size_t ) 1, '\000' );
   size_t _Group = 0;

   for (; _First != _Last; ++ _First )
    if ( _E0 <= * _First && * _First <= _E0 + 9 )
     {
     _Seendigit = true;
     if ( 36 <= _Significant )
      ++ _Pten;
     else if ( * _First == _E0 && _Significant == 0 )
      ;
     else
      {
      * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
      ++ _Significant;
      }
     if ( _Groups [ _Group ] != 127 )
      ++ _Groups [ _Group ];
     }
    else if ( _Groups [ _Group ] == '\000'
     || _Kseparator == ( _Elem ) 0
     || * _First != _Kseparator )
     break;
    else
     {
     _Groups . append ( ( size_t ) 1, '\000' );
     ++ _Group;
     }
   if ( _Group == 0 )
    ;
   else if ( '\000' < _Groups [ _Group ] )
    ++ _Group;
   else
    _Bad = true;

   for ( const char * _Pg = _Grouping . c_str ( );
    ! _Bad && 0 < _Group; )
    if ( * _Pg == 127 )
     break;
    else if ( 0 < -- _Group && * _Pg != _Groups [ _Group ]
     || 0 == _Group && * _Pg < _Groups [ _Group ] )
     _Bad = true;
    else if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
   }

  if ( _Seendigit && _Significant == 0 )
   * _Ptr ++ = '0';

  if ( _First != _Last && * _First == _Punct_fac . decimal_point ( ) )
   * _Ptr ++ = localeconv ( ) -> decimal_point [ 0 ], ++ _First;

  if ( _Significant == 0 )
   {
   for (; _First != _Last && * _First == _E0;
    _Seendigit = true, ++ _First )
    -- _Pten;
   if ( _Pten < 0 )
    * _Ptr ++ = '0', ++ _Pten;
   }

  for (; _First != _Last
    && _E0 <= * _First && * _First <= _E0 + 9;
    _Seendigit = true, ++ _First )
   if ( _Significant < 36 )
    {
    * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
    ++ _Significant;
    }

  if ( _Seendigit && _First != _Last
   && ( * _First == _Maklocchr ( 'e', ( _Elem * ) 0, _Cvt )
    || * _First == _Maklocchr ( 'E', ( _Elem * ) 0, _Cvt ) ) )
   {
   * _Ptr ++ = 'e', ++ _First;
   _Seendigit = false, _Significant = 0;

   if ( _First == _Last )
    ;
   else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
    * _Ptr ++ = '+', ++ _First;
   else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
    * _Ptr ++ = '-', ++ _First;
   for (; _First != _Last && * _First == _E0; )
    _Seendigit = true, ++ _First;
   if ( _Seendigit )
    * _Ptr ++ = '0';
   for (; _First != _Last
    && _E0 <= * _First && * _First <= _E0 + 9;
    _Seendigit = true, ++ _First )
    if ( _Significant < 8 )
     {
     * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
     ++ _Significant;
     }
   }

  if ( _Bad || ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  return ( _Pten );
  }

 int __cdecl _Hexdig ( const _Elem _Dig, const _Elem _E0,
  const _Elem _Al, const _Elem _Au ) const
  {
  if ( _E0 <= _Dig && _Dig <= _E0 + 9 )
   return ( _Dig - _E0 );
  else if ( _Al <= _Dig && _Dig <= _Al + 5 )
   return ( _Dig - _Al + 10 );
  else if ( _Au <= _Dig && _Dig <= _Au + 5 )
   return ( _Dig - _Au + 10 );
  else
   return ( - 1 );
  }

 int __cdecl _Getffldx ( char * _Ac,
  _InIt & _First, _InIt & _Last,
  ios_base & _Iosbase, int * _Phexexp ) const
  {
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _E0 = _Maklocchr ( '0', ( _Elem * ) 0, _Cvt );
  const _Elem _Al = _Maklocchr ( 'a', ( _Elem * ) 0, _Cvt );
  const _Elem _Au = _Maklocchr ( 'A', ( _Elem * ) 0, _Cvt );
  char * _Ptr = _Ac;
  bool _Bad = false;
  int _Dig;

  if ( _First == _Last )
   ;
  else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '+', ++ _First;
  else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '-', ++ _First;

  * _Ptr ++ = '0';
  * _Ptr ++ = 'x';

  bool _Seendigit = false;
  int _Significant = 0;
  int _Phex = 0;

  if ( _First == _Last || * _First != _E0 )
   ;
  else if ( ++ _First != _Last
   && ( * _First == _Maklocchr ( 'x', ( _Elem * ) 0, _Cvt )
     || * _First == _Maklocchr ( 'X', ( _Elem * ) 0, _Cvt ) ) )
   ++ _First;
  else
   _Seendigit = true;

  if ( * _Grouping . c_str ( ) == 127 || * _Grouping . c_str ( ) <= '\000' )
   for (; _First != _Last
    && 0 <= ( _Dig = _Hexdig ( * _First, _E0, _Al, _Au ) );
     _Seendigit = true, ++ _First )
    if ( 36 <= _Significant )
     ++ _Phex;
    else if ( * _First == _E0 && _Significant == 0 )
     ;
    else
     {
     * _Ptr ++ = "0123456789abcdef" [ _Dig ];
     ++ _Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping . size ( ) == 0
    ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );
   string _Groups ( ( size_t ) 1, '\000' );
   size_t _Group = 0;

   for (; _First != _Last; ++ _First )
    if ( 0 <= ( _Dig = _Hexdig ( * _First, _E0, _Al, _Au ) ) )
     {
     _Seendigit = true;
     if ( 36 <= _Significant )
      ++ _Phex;
     else if ( * _First == _E0 && _Significant == 0 )
      ;
     else
      {
      * _Ptr ++ = "0123456789abcdef" [ _Dig ];
      ++ _Significant;
      }
     if ( _Groups [ _Group ] != 127 )
      ++ _Groups [ _Group ];
     }
    else if ( _Groups [ _Group ] == '\000'
     || _Kseparator == ( _Elem ) 0
     || * _First != _Kseparator )
     break;
    else
     {
     _Groups . append ( ( size_t ) 1, '\000' );
     ++ _Group;
     }
   if ( _Group == 0 )
    ;
   else if ( '\000' < _Groups [ _Group ] )
    ++ _Group;
   else
    _Bad = true;

   for ( const char * _Pg = _Grouping . c_str ( );
    ! _Bad && 0 < _Group; )
    if ( * _Pg == 127 )
     break;
    else if ( 0 < -- _Group && * _Pg != _Groups [ _Group ]
     || 0 == _Group && * _Pg < _Groups [ _Group ] )
     _Bad = true;
    else if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
   }

  if ( _Seendigit && _Significant == 0 )
   * _Ptr ++ = '0';

  if ( _First != _Last && * _First == _Punct_fac . decimal_point ( ) )
   * _Ptr ++ = localeconv ( ) -> decimal_point [ 0 ], ++ _First;

  if ( _Significant == 0 )
   {
   for (; _First != _Last && * _First == _E0;
    _Seendigit = true, ++ _First )
    -- _Phex;
   if ( _Phex < 0 )
    * _Ptr ++ = '0', ++ _Phex;
   }

  for (; _First != _Last
    && 0 <= ( _Dig = _Hexdig ( * _First, _E0, _Al, _Au ) );
    _Seendigit = true, ++ _First )
   if ( _Significant < 36 )
    {
    * _Ptr ++ = "0123456789abcdef" [ _Dig ];
    ++ _Significant;
    }

  if ( _Seendigit && _First != _Last
   && ( * _First == _Maklocchr ( 'p', ( _Elem * ) 0, _Cvt )
    || * _First == _Maklocchr ( 'P', ( _Elem * ) 0, _Cvt ) ) )
   {
   * _Ptr ++ = 'p', ++ _First;
   _Seendigit = false, _Significant = 0;

   if ( _First == _Last )
    ;
   else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
    * _Ptr ++ = '+', ++ _First;
   else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
    * _Ptr ++ = '-', ++ _First;
   for (; _First != _Last && * _First == _E0; )
    _Seendigit = true, ++ _First;
   if ( _Seendigit )
    * _Ptr ++ = '0';
   for (; _First != _Last
    && _E0 <= * _First && * _First <= _E0 + 9;
    _Seendigit = true, ++ _First )
    if ( _Significant < 8 )
     {
     * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
     ++ _Significant;
     }
   }

  if ( _Bad || ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  * _Phexexp = _Phex;
  return ( 0 );
  }
 };
#line 1034 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum"
template< class _Elem, class 
#line 1035
_InIt> locale::id 
#line 1036
num_get< _Elem, _InIt> ::id; 
#line 1039
template < class _Elem,
 class _OutIt = ostreambuf_iterator < _Elem, char_traits < _Elem > > >
 class num_put
  : public locale :: facet
 {
public :
 typedef numpunct < _Elem > _Mypunct;
 typedef basic_string < _Elem, char_traits < _Elem >, allocator < _Elem > >
  _Mystr;

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new num_put < _Elem, _OutIt > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 4 );
  }

  static locale :: id id;

protected :
 virtual ~ num_put ( )
  {
  }

 void _Init ( const _Locinfo & _Lobj )
  {
  _Cvt = _Lobj . _Getcvt ( );
  }

 _Locinfo :: _Cvtvec _Cvt;

public :
 explicit num_put ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

  num_put ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj );
  }

 typedef _Elem char_type;
 typedef _OutIt iter_type;

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, _Bool _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned long _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }


 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, __int64 _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned __int64 _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }


 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, double _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long double _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

protected :
 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, _Bool _Val ) const
  {
  ;
  if ( ! ( _Iosbase . flags ( ) & ios_base :: boolalpha ) )
   return ( do_put ( _Dest, _Iosbase, _Fill, ( long ) _Val ) );
  else
   {
   const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
   _Mystr _Str;
   if ( _Val )
    _Str . assign ( _Punct_fac . truename ( ) );
   else
    _Str . assign ( _Punct_fac . falsename ( ) );

   size_t _Fillcount = _Iosbase . width ( ) <= 0
    || ( size_t ) _Iosbase . width ( ) <= _Str . size ( )
     ? 0 : ( size_t ) _Iosbase . width ( ) - _Str . size ( );

   if ( ( _Iosbase . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
    {
    _Dest = _Rep ( _Dest, _Fill, _Fillcount );
    _Fillcount = 0;
    }
   _Dest = _Put ( _Dest, _Str . c_str ( ), _Str . size ( ) );
   _Iosbase . width ( 0 );
   return ( _Rep ( _Dest, _Fill, _Fillcount ) );
   }
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long _Val ) const
  {
  char _Buf [ 2 * 32 ], _Fmt [ 6 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "ld",
    _Iosbase . flags ( ) ), _Val ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned long _Val ) const
  {
  char _Buf [ 2 * 32 ], _Fmt [ 6 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "lu",
    _Iosbase . flags ( ) ), _Val ) ) );
  }


 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, __int64 _Val ) const
  {
  char _Buf [ 2 * 32 ], _Fmt [ 8 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "Ld",
    _Iosbase . flags ( ) ), _Val ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned __int64 _Val ) const
  {
  char _Buf [ 2 * 32 ], _Fmt [ 8 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "Lu",
    _Iosbase . flags ( ) ), _Val ) ) );
  }


 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, double _Val ) const
  {
  char _Buf [ 8 + 36 + 64 ], _Fmt [ 8 ];
  streamsize _Precision = _Iosbase . precision ( ) <= 0
   && ! ( _Iosbase . flags ( ) & ios_base :: fixed )
    ? 6 : _Iosbase . precision ( );
  int _Significance = 36 < _Precision
   ? 36 : ( int ) _Precision;
  _Precision -= _Significance;
  size_t _Beforepoint = 0;
  size_t _Afterpoint = 0;

  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) == ios_base :: fixed
   && _Val * (0.5) != _Val )
   {
   bool _Signed = _Val < 0;
   if ( _Signed )
    _Val = - _Val;

   for (; (9.9999999999999997e+034) <= _Val && _Beforepoint < 5000; _Beforepoint += 10 )
    _Val /= (10000000000.0);

   if ( 0 < _Val )
    for (; 10 <= _Precision && _Val <= (1e-035)
     && _Afterpoint < 5000; _Afterpoint += 10 )
     {
     _Val *= (10000000000.0);
     _Precision -= 10;
     }

   if ( _Signed )
    _Val = - _Val;
   }

  return ( _Fput ( _Dest, _Iosbase, _Fill, _Buf,
   _Beforepoint, _Afterpoint, ( size_t ) _Precision,
    :: sprintf_s ( _Buf, sizeof ( _Buf ),
     _Ffmt ( _Fmt, 0, _Iosbase . flags ( ) ),
     _Significance, _Val ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long double _Val ) const
  {
  char _Buf [ 8 + 36 + 64 ], _Fmt [ 8 ];
  streamsize _Precision = _Iosbase . precision ( ) <= 0
   && ! ( _Iosbase . flags ( ) & ios_base :: fixed )
    ? 6 : _Iosbase . precision ( );
  int _Significance = 36 < _Precision
   ? 36 : ( int ) _Precision;
  _Precision -= _Significance;
  size_t _Beforepoint = 0;
  size_t _Afterpoint = 0;

  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) == ios_base :: fixed )
   {
   bool _Signed = _Val < 0;
   if ( _Signed )
    _Val = - _Val;

   for (; (9.9999999999999997e+034) <= _Val && _Beforepoint < 5000; _Beforepoint += 10 )
    _Val /= (10000000000.0);

   if ( 0 < _Val )
    for (; 10 <= _Precision && _Val <= (1e-035)
     && _Afterpoint < 5000; _Afterpoint += 10 )
     {
     _Val *= (10000000000.0);
     _Precision -= 10;
     }

   if ( _Signed )
    _Val = - _Val;
   }

  return ( _Fput ( _Dest, _Iosbase, _Fill, _Buf,
   _Beforepoint, _Afterpoint, ( size_t ) _Precision,
    :: sprintf_s ( _Buf, sizeof ( _Buf ),
     _Ffmt ( _Fmt, 'L', _Iosbase . flags ( ) ),
     _Significance, _Val ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const
  {
  char _Buf [ 2 * 32 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), "%p", _Val ) ) );
  }

private :
 char * __cdecl _Ffmt ( char * _Fmt,
  char _Spec, ios_base :: fmtflags _Flags ) const
  {
  char * _Ptr = _Fmt;
  * _Ptr ++ = '%';

  if ( _Flags & ios_base :: showpos )
   * _Ptr ++ = '+';
  if ( _Flags & ios_base :: showpoint )
   * _Ptr ++ = '#';
  * _Ptr ++ = '.';
  * _Ptr ++ = '*';
  if ( _Spec != '\000' )
   * _Ptr ++ = _Spec;

  ios_base :: fmtflags _Ffl = _Flags & ios_base :: floatfield;
  * _Ptr ++ = _Ffl == ios_base :: fixed ? 'f'
   : _Ffl == ios_base :: hexfloat ? 'a'
   : _Ffl == ios_base :: scientific ? 'e' : 'g';
  * _Ptr = '\000';
  return ( _Fmt );
  }

 _OutIt __cdecl _Fput ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const char * _Buf,
   size_t _Beforepoint, size_t _Afterpoint,
    size_t _Trailing, size_t _Count ) const
  {
  ;
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _Kseparator = _Punct_fac . thousands_sep ( );
  string _Groupstring;
  const _Elem _E0 = _Maklocchr ( '0', ( _Elem * ) 0, _Cvt );
  size_t _Prefix = _Buf [ 0 ] == '+' || _Buf [ 0 ] == '-' ? 1 : 0;

  char _Enders [ 3 ];
  _Enders [ 0 ] = :: localeconv ( ) -> decimal_point [ 0 ];
  _Enders [ 1 ] = 'e';
  _Enders [ 2 ] = '\000';

  const char * _Eptr = ( const char * ) :: memchr ( _Buf,
   'e', _Count );
  const char * _Pointptr = ( const char * ) :: memchr ( _Buf,
   _Enders [ 0 ], _Count );
  if ( _Pointptr == 0 )
   _Trailing = 0;

  if ( * _Grouping . c_str ( ) != 127 && '\000' < * _Grouping . c_str ( ) )
   {
   _Groupstring . append ( _Buf, _Count );
   if ( _Eptr == 0 )
    _Groupstring . append ( _Trailing, '0' );
   else
    {
    if ( _Pointptr == 0 )
     {
     _Groupstring . append ( _Beforepoint, '0' );
     _Beforepoint = 0;
     }
    _Groupstring . insert ( _Eptr - _Buf, _Trailing, '0' );
    }
   _Trailing = 0;

   if ( _Pointptr == 0 )
    _Groupstring . append ( _Beforepoint, '0' );
   else
    {
    _Groupstring . insert ( _Pointptr - _Buf + 1, _Afterpoint, '0' );
    _Groupstring . insert ( _Pointptr - _Buf, _Beforepoint, '0' );
    _Afterpoint = 0;
    }
   _Beforepoint = 0;

   const char * _Pg = _Grouping . c_str ( );
   size_t _Off = :: strcspn ( & _Groupstring [ 0 ], & _Enders [ 0 ] );
   while ( * _Pg != 127 && '\000' < * _Pg
    && ( size_t ) * _Pg < _Off - _Prefix )
    {
    _Groupstring . insert ( _Off -= * _Pg, ( size_t ) 1, '\000' );
    if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
    }

   _Buf = & _Groupstring [ 0 ];
   _Trailing = 0;
   _Count = _Groupstring . size ( );
   }

  size_t _Fillcount = _Beforepoint + _Afterpoint + _Trailing + _Count;
  _Fillcount = _Iosbase . width ( ) <= 0
   || ( size_t ) _Iosbase . width ( ) <= _Fillcount
    ? 0 : ( size_t ) _Iosbase . width ( ) - _Fillcount;
  ios_base :: fmtflags _Adjustfield =
   _Iosbase . flags ( ) & ios_base :: adjustfield;
  if ( _Adjustfield != ios_base :: left
   && _Adjustfield != ios_base :: internal )
   {
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   }
  else if ( _Adjustfield == ios_base :: internal )
   {
   if ( 0 < _Prefix )
    {
    _Dest = _Putc ( _Dest, _Buf, 1 );
    ++ _Buf, -- _Count;
    }
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   }

  _Pointptr = ( const char * ) :: memchr ( _Buf,
   _Enders [ 0 ], _Count );
  if ( _Pointptr != 0 )
   {
   size_t _Fracoffset = _Pointptr - _Buf + 1;
   _Dest = _Putgrouped ( _Dest, _Buf, _Fracoffset - 1, _Kseparator );
   _Dest = _Rep ( _Dest, _E0, _Beforepoint );
   _Dest = _Rep ( _Dest, _Punct_fac . decimal_point ( ), 1 );
   _Dest = _Rep ( _Dest, _E0, _Afterpoint );
   _Buf += _Fracoffset, _Count -= _Fracoffset;
   }

  _Eptr = ( const char * ) :: memchr ( _Buf,
   'e', _Count );
  if ( _Eptr != 0 )
   {
   size_t _Expoffset = _Eptr - _Buf + 1;
   _Dest = _Putgrouped ( _Dest, _Buf, _Expoffset - 1, _Kseparator );
   _Dest = _Rep ( _Dest, _E0, _Trailing ), _Trailing = 0;
   _Dest = _Putc ( _Dest, _Iosbase . flags ( ) & ios_base :: uppercase
    ? "E" : "e", 1 );
   _Buf += _Expoffset, _Count -= _Expoffset;
   }

  _Dest = _Putgrouped ( _Dest, _Buf, _Count,
   _Kseparator );
  _Dest = _Rep ( _Dest, _E0, _Trailing );
  _Iosbase . width ( 0 );
  return ( _Rep ( _Dest, _Fill, _Fillcount ) );
  }

 char * __cdecl _Ifmt ( char * _Fmt,
  const char * _Spec, ios_base :: fmtflags _Flags ) const
  {
  char * _Ptr = _Fmt;
  * _Ptr ++ = '%';

  if ( _Flags & ios_base :: showpos )
   * _Ptr ++ = '+';
  if ( _Flags & ios_base :: showbase )
   * _Ptr ++ = '#';
  if ( _Spec [ 0 ] != 'L' )
   * _Ptr ++ = _Spec [ 0 ];
  else

   {
   * _Ptr ++ = 'I';
   * _Ptr ++ = '6';
   * _Ptr ++ = '4';
   }

  ios_base :: fmtflags _Basefield = _Flags & ios_base :: basefield;
  * _Ptr ++ = _Basefield == ios_base :: oct ? 'o'
   : _Basefield != ios_base :: hex ? _Spec [ 1 ]
   : _Flags & ios_base :: uppercase ? 'X' : 'x';
  * _Ptr = '\000';
  return ( _Fmt );
  }

 _OutIt __cdecl _Iput ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, char * _Buf, size_t _Count ) const
  {
  ;
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const size_t _Prefix = * _Buf == '+' || * _Buf == '-' ? 1
   : * _Buf == '0' && ( _Buf [ 1 ] == 'x' || _Buf [ 1 ] == 'X' ) ? 2
   : 0;

  if ( * _Grouping . c_str ( ) != 127 && '\000' < * _Grouping . c_str ( ) )
   {
   const char * _Pg = _Grouping . c_str ( );
   size_t _Off = _Count;
   while ( * _Pg != 127 && '\000' < * _Pg
    && ( size_t ) * _Pg < _Off - _Prefix )
    {
    _Off -= * _Pg;

    ;
    :: memmove_s ( ( & _Buf [ _Off + 1 ] ), ( _Count + 1 - _Off ), ( & _Buf [ _Off ] ), ( _Count + 1 - _Off ) );


    _Buf [ _Off ] = '\000', ++ _Count;
    if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
    }
   }

  size_t _Fillcount = _Iosbase . width ( ) <= 0
   || ( size_t ) _Iosbase . width ( ) <= _Count
    ? 0 : ( size_t ) _Iosbase . width ( ) - _Count;

  ios_base :: fmtflags _Adjustfield =
   _Iosbase . flags ( ) & ios_base :: adjustfield;
  if ( _Adjustfield != ios_base :: left
   && _Adjustfield != ios_base :: internal )
   {
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   }
  else if ( _Adjustfield == ios_base :: internal )
   {
   _Dest = _Putc ( _Dest, _Buf, _Prefix );
   _Buf += _Prefix, _Count -= _Prefix;
   _Dest = _Rep ( _Dest, _Fill, _Fillcount ), _Fillcount = 0;
   }

  _Dest = _Putgrouped ( _Dest, _Buf, _Count,
   _Punct_fac . thousands_sep ( ) );
  _Iosbase . width ( 0 );
  return ( _Rep ( _Dest, _Fill, _Fillcount ) );
  }

 _OutIt __cdecl _Put ( _OutIt _Dest,
  const _Elem * _Ptr, size_t _Count ) const
  {
  for (; 0 < _Count; -- _Count, ++ _Dest, ++ _Ptr )
   * _Dest = * _Ptr;
  return ( _Dest );
  }

 _OutIt __cdecl _Putc ( _OutIt _Dest,
  const char * _Ptr, size_t _Count ) const
  {
  for (; 0 < _Count; -- _Count, ++ _Dest, ++ _Ptr )
   * _Dest = _Maklocchr ( * _Ptr, ( _Elem * ) 0, _Cvt );
  return ( _Dest );
  }

 _OutIt __cdecl _Putgrouped ( _OutIt _Dest,
  const char * _Ptr, size_t _Count, _Elem _Kseparator ) const
  {
  for (;; ++ _Ptr, -- _Count )
   {
   const char * _Pend =
    ( const char * ) :: memchr ( _Ptr, '\000', _Count );
   size_t _Groupsize = _Pend != 0 ? _Pend - _Ptr : _Count;

   _Dest = _Putc ( _Dest, _Ptr, _Groupsize );
   _Ptr += _Groupsize, _Count -= _Groupsize;
   if ( _Count == 0 )
    break;
   if ( _Kseparator != ( _Elem ) 0 )
    _Dest = _Rep ( _Dest, _Kseparator, 1 );
   }
  return ( _Dest );
  }

 _OutIt __cdecl _Rep ( _OutIt _Dest,
  _Elem _Ch, size_t _Count ) const
  {
  for (; 0 < _Count; -- _Count, ++ _Dest )
   * _Dest = _Ch;
  return ( _Dest );
  }
 };
#line 1576 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum"
template< class _Elem, class 
#line 1577
_OutIt> locale::id 
#line 1578
num_put< _Elem, _OutIt> ::id; 
#line 1583
template locale::id numpunct< char> ::id;
#line 1585
template class __declspec(dllimport) num_get< char, istreambuf_iterator< char, char_traits< char> > > ;
#line 1587
template class __declspec(dllimport) num_put< char, ostreambuf_iterator< char, char_traits< char> > > ;
#line 1590
template locale::id numpunct< __wchar_t> ::id;
#line 1592
template class __declspec(dllimport) num_get< __wchar_t, istreambuf_iterator< __wchar_t, char_traits< __wchar_t> > > ;
#line 1594
template class __declspec(dllimport) num_put< __wchar_t, ostreambuf_iterator< __wchar_t, char_traits< __wchar_t> > > ;
#line 1599 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum"
}
#line 1603
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ios"
#pragma warning(push,3)
#line 11
#pragma warning(disable: 4189)
#line 1604 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xlocnum"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ios"
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 15
template < class _Elem,
 class _Traits >
 class basic_ios
  : public ios_base
 {
public :
 typedef basic_ios < _Elem, _Traits > _Myt;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef ctype < _Elem > _Ctype;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 explicit basic_ios ( _Mysb * _Strbuf )
  {
  init ( _Strbuf );
  }

 virtual ~ basic_ios ( )
  {
  }

 void clear ( iostate _State = goodbit,
  bool _Reraise = false )
  {
  ios_base :: clear ( ( iostate ) ( _Mystrbuf == 0
   ? ( int ) _State | ( int ) badbit : ( int ) _State ), _Reraise );
  }

 void clear ( io_state _State )
  {
  clear ( ( iostate ) _State );
  }

 void setstate ( iostate _State,
  bool _Reraise = false )
  {
  if ( _State != goodbit )
   clear ( ( iostate ) ( ( int ) rdstate ( ) | ( int ) _State ), _Reraise );
  }

 void setstate ( io_state _State )
  {
  setstate ( ( iostate ) _State );
  }

 _Myt & copyfmt ( const _Myt & _Right )
  {
  _Tiestr = _Right . tie ( );
  _Fillch = _Right . fill ( );
  ios_base :: copyfmt ( _Right );
  return ( * this );
  }

 _Myos * tie ( ) const
  {
  return ( _Tiestr );
  }

 _Myos * tie ( _Myos * _Newtie )
  {
  _Myos * _Oldtie = _Tiestr;
  _Tiestr = _Newtie;
  return ( _Oldtie );
  }

 _Mysb * rdbuf ( ) const
  {
  return ( _Mystrbuf );
  }

 _Mysb * rdbuf ( _Mysb * _Strbuf )
  {
  _Mysb * _Oldstrbuf = _Mystrbuf;
  _Mystrbuf = _Strbuf;
  clear ( );
  return ( _Oldstrbuf );
  }

 locale imbue ( const locale & _Loc )
  {
  locale _Oldlocale = ios_base :: imbue ( _Loc );
  if ( rdbuf ( ) != 0 )
   rdbuf ( ) -> pubimbue ( _Loc );
  return ( _Oldlocale );
  }

 _Elem fill ( ) const
  {
  return ( _Fillch );
  }

 _Elem fill ( _Elem _Newfill )
  {
  _Elem _Oldfill = _Fillch;
  _Fillch = _Newfill;
  return ( _Oldfill );
  }

 char narrow ( _Elem _Ch, char _Dflt = '\000' ) const
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( getloc ( ) );
  return ( _Ctype_fac . narrow ( _Ch, _Dflt ) );
  }

 _Elem widen ( char _Byte ) const
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( getloc ( ) );
  return ( _Ctype_fac . widen ( _Byte ) );
  }

 void move ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   _Mystrbuf = 0;
   _Tiestr = 0;
   this -> swap ( _Right );
   }
  }

 void swap ( _Myt & _Right )
  {
  ios_base :: swap ( _Right );
  :: std :: swap ( _Fillch, _Right . _Fillch );
  :: std :: swap ( _Tiestr, _Right . _Tiestr );
  }

 void set_rdbuf ( _Mysb * _Strbuf )
  {
  _Mystrbuf = _Strbuf;
  }

protected :
 void init ( _Mysb * _Strbuf = 0,
  bool _Isstd = false )
  {
  _Init ( );
  _Mystrbuf = _Strbuf;
  _Tiestr = 0;
  _Fillch = widen ( ' ' );

  if ( _Mystrbuf == 0 )
   setstate ( badbit );

  if ( _Isstd )
   _Addstd ( this );
  }

  basic_ios ( )
  {
  }

private :
 _Mysb * _Mystrbuf;
 _Myos * _Tiestr;
 _Elem _Fillch;

  basic_ios ( const _Myt & );
 _Myt & operator = ( const _Myt & );
 };
#line 182
template class __declspec(dllimport) basic_ios< char, char_traits< char> > ;
#line 184
template class __declspec(dllimport) basic_ios< __wchar_t, char_traits< __wchar_t> > ;
#line 192 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ios"
inline ios_base &__cdecl boolalpha(ios_base &_Iosbase) 
#line 193
{ 
#line 194
_Iosbase.setf(_Iosb< int> ::boolalpha); 
#line 195
return _Iosbase; 
#line 196
} 
#line 198
inline ios_base &__cdecl dec(ios_base &_Iosbase) 
#line 199
{ 
#line 200
_Iosbase.setf(_Iosb< int> ::dec, _Iosb< int> ::basefield); 
#line 201
return _Iosbase; 
#line 202
} 
#line 205
inline ios_base &__cdecl defaultfloat(ios_base &_Iosbase) 
#line 206
{ 
#line 207
_Iosbase.unsetf(_Iosb< int> ::floatfield); 
#line 208
return _Iosbase; 
#line 209
} 
#line 212 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ios"
inline ios_base &__cdecl fixed(ios_base &_Iosbase) 
#line 213
{ 
#line 214
_Iosbase.setf(_Iosb< int> ::fixed, _Iosb< int> ::floatfield); 
#line 215
return _Iosbase; 
#line 216
} 
#line 218
inline ios_base &__cdecl hex(ios_base &_Iosbase) 
#line 219
{ 
#line 220
_Iosbase.setf(_Iosb< int> ::hex, _Iosb< int> ::basefield); 
#line 221
return _Iosbase; 
#line 222
} 
#line 225
namespace tr1 { 
#line 226
inline ios_base &__cdecl hexfloat(ios_base &_Iosbase) 
#line 227
{ 
#line 228
_Iosbase.setf(_Iosb< int> ::hexfloat, _Iosb< int> ::floatfield); 
#line 229
return _Iosbase; 
#line 230
} 
#line 231
}
#line 236 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ios"
using tr1::hexfloat;
#line 240 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ios"
inline ios_base &__cdecl internal(ios_base &_Iosbase) 
#line 241
{ 
#line 242
_Iosbase.setf(_Iosb< int> ::internal, _Iosb< int> ::adjustfield); 
#line 243
return _Iosbase; 
#line 244
} 
#line 246
inline ios_base &__cdecl left(ios_base &_Iosbase) 
#line 247
{ 
#line 248
_Iosbase.setf(_Iosb< int> ::left, _Iosb< int> ::adjustfield); 
#line 249
return _Iosbase; 
#line 250
} 
#line 252
inline ios_base &__cdecl noboolalpha(ios_base &_Iosbase) 
#line 253
{ 
#line 254
_Iosbase.unsetf(_Iosb< int> ::boolalpha); 
#line 255
return _Iosbase; 
#line 256
} 
#line 258
inline ios_base &__cdecl noshowbase(ios_base &_Iosbase) 
#line 259
{ 
#line 260
_Iosbase.unsetf(_Iosb< int> ::showbase); 
#line 261
return _Iosbase; 
#line 262
} 
#line 264
inline ios_base &__cdecl noshowpoint(ios_base &_Iosbase) 
#line 265
{ 
#line 266
_Iosbase.unsetf(_Iosb< int> ::showpoint); 
#line 267
return _Iosbase; 
#line 268
} 
#line 270
inline ios_base &__cdecl noshowpos(ios_base &_Iosbase) 
#line 271
{ 
#line 272
_Iosbase.unsetf(_Iosb< int> ::showpos); 
#line 273
return _Iosbase; 
#line 274
} 
#line 276
inline ios_base &__cdecl noskipws(ios_base &_Iosbase) 
#line 277
{ 
#line 278
_Iosbase.unsetf(_Iosb< int> ::skipws); 
#line 279
return _Iosbase; 
#line 280
} 
#line 282
inline ios_base &__cdecl nounitbuf(ios_base &_Iosbase) 
#line 283
{ 
#line 284
_Iosbase.unsetf(_Iosb< int> ::unitbuf); 
#line 285
return _Iosbase; 
#line 286
} 
#line 288
inline ios_base &__cdecl nouppercase(ios_base &_Iosbase) 
#line 289
{ 
#line 290
_Iosbase.unsetf(_Iosb< int> ::uppercase); 
#line 291
return _Iosbase; 
#line 292
} 
#line 294
inline ios_base &__cdecl oct(ios_base &_Iosbase) 
#line 295
{ 
#line 296
_Iosbase.setf(_Iosb< int> ::oct, _Iosb< int> ::basefield); 
#line 297
return _Iosbase; 
#line 298
} 
#line 300
inline ios_base &__cdecl right(ios_base &_Iosbase) 
#line 301
{ 
#line 302
_Iosbase.setf(_Iosb< int> ::right, _Iosb< int> ::adjustfield); 
#line 303
return _Iosbase; 
#line 304
} 
#line 306
inline ios_base &__cdecl scientific(ios_base &_Iosbase) 
#line 307
{ 
#line 308
_Iosbase.setf(_Iosb< int> ::scientific, _Iosb< int> ::floatfield); 
#line 309
return _Iosbase; 
#line 310
} 
#line 312
inline ios_base &__cdecl showbase(ios_base &_Iosbase) 
#line 313
{ 
#line 314
_Iosbase.setf(_Iosb< int> ::showbase); 
#line 315
return _Iosbase; 
#line 316
} 
#line 318
inline ios_base &__cdecl showpoint(ios_base &_Iosbase) 
#line 319
{ 
#line 320
_Iosbase.setf(_Iosb< int> ::showpoint); 
#line 321
return _Iosbase; 
#line 322
} 
#line 324
inline ios_base &__cdecl showpos(ios_base &_Iosbase) 
#line 325
{ 
#line 326
_Iosbase.setf(_Iosb< int> ::showpos); 
#line 327
return _Iosbase; 
#line 328
} 
#line 330
inline ios_base &__cdecl skipws(ios_base &_Iosbase) 
#line 331
{ 
#line 332
_Iosbase.setf(_Iosb< int> ::skipws); 
#line 333
return _Iosbase; 
#line 334
} 
#line 336
inline ios_base &__cdecl unitbuf(ios_base &_Iosbase) 
#line 337
{ 
#line 338
_Iosbase.setf(_Iosb< int> ::unitbuf); 
#line 339
return _Iosbase; 
#line 340
} 
#line 342
inline ios_base &__cdecl uppercase(ios_base &_Iosbase) 
#line 343
{ 
#line 344
_Iosbase.setf(_Iosb< int> ::uppercase); 
#line 345
return _Iosbase; 
#line 346
} 
#line 347
}
#line 349
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ostream"
#pragma warning(push,3)
#line 11
#pragma warning(disable: 4189 4390)
#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ios"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ostream"
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ostream"
template < class _Elem,
 class _Traits >
 class basic_ostream
  : virtual public basic_ios < _Elem, _Traits >
 {
public :
 typedef basic_ostream < _Elem, _Traits > _Myt;
 typedef basic_ios < _Elem, _Traits > _Myios;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef ostreambuf_iterator < _Elem, _Traits > _Iter;
 typedef num_put < _Elem, _Iter > _Nput;

 explicit basic_ostream (
  basic_streambuf < _Elem, _Traits > * _Strbuf,

  bool _Isstd = false )
  {
  _Myios :: init ( _Strbuf, _Isstd );
  }

  basic_ostream ( _Uninitialized, bool _Addit = true )
  {
  if ( _Addit )
   ios_base :: _Addstd ( this );
  }

  basic_ostream ( _Myt && _Right )
  {
  _Myios :: init ( );
  _Myios :: move ( :: std :: move ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  this -> swap ( _Right );
  return ( * this );
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   _Myios :: swap ( _Right );
  }

 virtual ~ basic_ostream ( )
  {
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 class _Sentry_base
  {
 public :
   _Sentry_base ( _Myt & _Ostr )
   : _Myostr ( _Ostr )
   {
   if ( _Myostr . rdbuf ( ) != 0 )
    _Myostr . rdbuf ( ) -> _Lock ( );
   }

   ~ _Sentry_base ( )
   {
   if ( _Myostr . rdbuf ( ) != 0 )
    _Myostr . rdbuf ( ) -> _Unlock ( );
   }

  _Myt & _Myostr;

 private :
  _Sentry_base & operator = ( const _Sentry_base & );
  };

 class sentry
  : public _Sentry_base
  {
 public :
  explicit sentry ( _Myt & _Ostr )
   : _Sentry_base ( _Ostr )
   {
   if ( _Ostr . good ( ) && _Ostr . tie ( ) != 0 )
    _Ostr . tie ( ) -> flush ( );
   _Ok = _Ostr . good ( );
   }

   ~ sentry ( )
   {

   if ( ! uncaught_exception ( ) )
    this -> _Myostr . _Osfx ( );




   }

   operator :: std :: _Bool_type ( ) const
   {
   return ( _Ok ? ( & :: std :: _Bool_struct :: _Member ) : 0 );
   }

 private :
  bool _Ok;

   sentry ( const sentry & );
  sentry & operator = ( const sentry & );
  };

 bool opfx ( )
  {
  if ( ios_base :: good ( ) && _Myios :: tie ( ) != 0 )
   _Myios :: tie ( ) -> flush ( );
  return ( ios_base :: good ( ) );
  }

 void osfx ( )
  {
  _Osfx ( );
  }

 void _Osfx ( )
  {
  try {
  if ( ios_base :: flags ( ) & ios_base :: unitbuf )
   flush ( );
  } catch ( ... ) {
  }
  }























 _Myt & operator << ( _Myt & ( __cdecl * _Pfn ) ( _Myt & ) )
  {
  ;
  return ( ( * _Pfn ) ( * this ) );
  }

 _Myt & operator << ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) )
  {
  ;
  ( * _Pfn ) ( * ( _Myios * ) this );
  return ( * this );
  }

 _Myt & operator << ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) )
  {
  ;
  ( * _Pfn ) ( * ( ios_base * ) this );
  return ( * this );
  }

 _Myt & operator << ( _Bool _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( short _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );
   ios_base :: fmtflags _Bfl =
    ios_base :: flags ( ) & ios_base :: basefield;
   long _Tmp = ( _Bfl == ios_base :: oct
    || _Bfl == ios_base :: hex )
    ? ( long ) ( unsigned short ) _Val : ( long ) _Val;

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Tmp ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }










 _Myt & operator << ( unsigned short _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( unsigned long ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( int _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );
   ios_base :: fmtflags _Bfl =
    ios_base :: flags ( ) & ios_base :: basefield;
   long _Tmp = ( _Bfl == ios_base :: oct
    || _Bfl == ios_base :: hex )
    ? ( long ) ( unsigned int ) _Val : ( long ) _Val;

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Tmp ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( unsigned int _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( unsigned long ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( long _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( unsigned long _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


 _Myt & operator << ( __int64 _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( unsigned __int64 _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


 _Myt & operator << ( float _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( double ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( double _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( long double _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( const void * _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( _Mysb * _Strbuf )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  bool _Copied = false;
  const sentry _Ok ( * this );

  if ( _Ok && _Strbuf != 0 )
   for ( int_type _Meta = _Traits :: eof ( );; _Copied = true )
    {
    try {
    _Meta = _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta )
     ? _Strbuf -> sgetc ( ) : _Strbuf -> snextc ( );
    } catch ( ... ) {
     _Myios :: setstate ( ios_base :: failbit );
     throw;
    }

    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     break;

    try {
     if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
      _Myios :: rdbuf ( ) -> sputc (
       _Traits :: to_char_type ( _Meta ) ) ) )
      {
      _State |= ios_base :: badbit;
      break;
      }
    } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
    }

  ios_base :: width ( 0 );
  _Myios :: setstate ( _Strbuf == 0 ? ios_base :: badbit
   : ! _Copied ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

 _Myt & put ( _Elem _Ch )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( ! _Ok )
   _State |= ios_base :: badbit;
  else
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sputc ( _Ch ) ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & write ( const _Elem * _Str,
  streamsize _Count )
  {





  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( ! _Ok )
   _State |= ios_base :: badbit;
  else
   {
   try {
   if ( _Myios :: rdbuf ( ) -> sputn ( _Str, _Count ) != _Count )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & flush ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  if ( ! ios_base :: fail ( ) && _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 )
   _State |= ios_base :: badbit;
  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & seekp ( pos_type _Pos )
  {
  if ( ! ios_base :: fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekpos ( _Pos,
    ios_base :: out ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

 _Myt & seekp ( off_type _Off, ios_base :: seekdir _Way )
  {
  if ( ! ios_base :: fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way,
    ios_base :: out ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

 pos_type tellp ( )
  {
  if ( ! ios_base :: fail ( ) )
   return ( _Myios :: rdbuf ( ) -> pubseekoff ( 0,
    ios_base :: cur, ios_base :: out ) );
  else
   return ( pos_type ( _BADOFF ) );
  }
 };
#line 607 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ostream"
template < class _Elem,
 class _Traits > inline
 void swap ( basic_ostream < _Elem, _Traits > & _Left,
  basic_ostream < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 667
template class __declspec(dllimport) basic_ostream< char, char_traits< char> > ;
#line 669
template class __declspec(dllimport) basic_ostream< __wchar_t, char_traits< __wchar_t> > ;
#line 677 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ostream"
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, const char * _Val )
 {
 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) :: strlen ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  const ctype < _Elem > & _Ctype_fac = use_facet < ctype < _Elem > > ( _Ostr . getloc ( ) );
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  for (; _State == ios_base :: goodbit && 0 < _Count; -- _Count, ++ _Val )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( * _Val ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 724
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, char _Ch )
 {
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  const ctype < _Elem > & _Ctype_fac = use_facet < ctype < _Elem > > ( _Ostr . getloc ( ) );
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( _Ch ) ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 763
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr,
  const char * _Val )
 {
 typedef char _Elem;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) _Traits :: length ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  if ( _State == ios_base :: goodbit
   && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count )
   _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 810
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, char _Ch )
 {
 typedef char _Elem;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 849
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, const _Elem * _Val )
 {
 typedef basic_ostream < _Elem, _Traits > _Myos;

 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) _Traits :: length ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  if ( _State == ios_base :: goodbit
   && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count )
   _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 896
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, _Elem _Ch )
 {
 typedef basic_ostream < _Elem, _Traits > _Myos;

 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 936
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, const signed char * _Val )
 {
 return ( _Ostr << ( const char * ) _Val );
 }
#line 943
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, signed char _Ch )
 {
 return ( _Ostr << ( char ) _Ch );
 }
#line 950
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, const unsigned char * _Val )
 {
 return ( _Ostr << ( const char * ) _Val );
 }
#line 957
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, unsigned char _Ch )
 {
 return ( _Ostr << ( char ) _Ch );
 }
#line 964
template < class _Elem,
 class _Traits,
 class _Ty > inline
 basic_ostream < _Elem, _Traits > &
  operator << ( basic_ostream < _Elem, _Traits > && _Ostr, _Ty _Val )
 {
 return ( _Ostr << _Val );
 }
#line 974
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl endl ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . put ( _Ostr . widen ( '\n' ) );
 _Ostr . flush ( );
 return ( _Ostr );
 }
#line 984
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl ends ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . put ( _Elem ( ) );
 return ( _Ostr );
 }
#line 993
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl flush ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . flush ( );
 return ( _Ostr );
 }
#line 1002
__declspec(dllimport) inline basic_ostream< char, char_traits< char> >  &__cdecl 
#line 1003
endl(basic_ostream< char, char_traits< char> >  &_Ostr) 
#line 1004
{ 
#line 1005
_Ostr.put('\n'); 
#line 1006
_Ostr.flush(); 
#line 1007
return _Ostr; 
#line 1008
} 
#line 1010
__declspec(dllimport) inline basic_ostream< __wchar_t, char_traits< __wchar_t> >  &__cdecl 
#line 1011
endl(basic_ostream< __wchar_t, char_traits< __wchar_t> >  &
#line 1012
_Ostr) 
#line 1013
{ 
#line 1014
_Ostr.put('\n'); 
#line 1015
_Ostr.flush(); 
#line 1016
return _Ostr; 
#line 1017
} 
#line 1020
__declspec(dllimport) inline basic_ostream< unsigned short, char_traits< unsigned short> >  &__cdecl 
#line 1021
endl(basic_ostream< unsigned short, char_traits< unsigned short> >  &
#line 1022
_Ostr) 
#line 1023
{ 
#line 1024
_Ostr.put('\n'); 
#line 1025
_Ostr.flush(); 
#line 1026
return _Ostr; 
#line 1027
} 
#line 1030 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ostream"
__declspec(dllimport) inline basic_ostream< char, char_traits< char> >  &__cdecl 
#line 1031
ends(basic_ostream< char, char_traits< char> >  &_Ostr) 
#line 1032
{ 
#line 1033
_Ostr.put('\000'); 
#line 1034
return _Ostr; 
#line 1035
} 
#line 1037
__declspec(dllimport) inline basic_ostream< __wchar_t, char_traits< __wchar_t> >  &__cdecl 
#line 1038
ends(basic_ostream< __wchar_t, char_traits< __wchar_t> >  &
#line 1039
_Ostr) 
#line 1040
{ 
#line 1041
_Ostr.put('\000'); 
#line 1042
return _Ostr; 
#line 1043
} 
#line 1046
__declspec(dllimport) inline basic_ostream< unsigned short, char_traits< unsigned short> >  &__cdecl 
#line 1047
ends(basic_ostream< unsigned short, char_traits< unsigned short> >  &
#line 1048
_Ostr) 
#line 1049
{ 
#line 1050
_Ostr.put('\000'); 
#line 1051
return _Ostr; 
#line 1052
} 
#line 1055 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ostream"
__declspec(dllimport) inline basic_ostream< char, char_traits< char> >  &__cdecl 
#line 1056
flush(basic_ostream< char, char_traits< char> >  &_Ostr) 
#line 1057
{ 
#line 1058
_Ostr.flush(); 
#line 1059
return _Ostr; 
#line 1060
} 
#line 1062
__declspec(dllimport) inline basic_ostream< __wchar_t, char_traits< __wchar_t> >  &__cdecl 
#line 1063
flush(basic_ostream< __wchar_t, char_traits< __wchar_t> >  &
#line 1064
_Ostr) 
#line 1065
{ 
#line 1066
_Ostr.flush(); 
#line 1067
return _Ostr; 
#line 1068
} 
#line 1071
__declspec(dllimport) inline basic_ostream< unsigned short, char_traits< unsigned short> >  &__cdecl 
#line 1072
flush(basic_ostream< unsigned short, char_traits< unsigned short> >  &
#line 1073
_Ostr) 
#line 1074
{ 
#line 1075
_Ostr.flush(); 
#line 1076
return _Ostr; 
#line 1077
} 
#line 1082 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ostream"
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
   const error_code & _Errcode )
 {
 return ( _Ostr << _Errcode . category ( ) . name ( ) << ':' << _Errcode . value ( ) );
 }
#line 1091 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ostream"
}
#line 1093
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\istream"
#pragma warning(push,3)
#line 11
#pragma warning(disable: 4189)
#line 1094 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ostream"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\istream"
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 15
template < class _Elem,
 class _Traits >
 class basic_istream
  : virtual public basic_ios < _Elem, _Traits >
 {
public :
 typedef basic_istream < _Elem, _Traits > _Myt;
 typedef basic_ios < _Elem, _Traits > _Myios;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef istreambuf_iterator < _Elem, _Traits > _Iter;
 typedef ctype < _Elem > _Ctype;
 typedef num_get < _Elem, _Iter > _Nget;


 explicit basic_istream ( _Mysb * _Strbuf,
  bool _Isstd = false )

  : _Chcount ( 0 )
  {
  _Myios :: init ( _Strbuf, _Isstd );
  }

  basic_istream ( _Uninitialized )
  {
  ios_base :: _Addstd ( this );
  }

  basic_istream ( _Myt && _Right )
  : _Chcount ( _Right . _Chcount )
  {
  _Myios :: init ( );
  _Myios :: move ( :: std :: move ( _Right ) );
  _Right . _Chcount = 0;
  }

 _Myt & operator = ( _Myt && _Right )
  {
  this -> swap ( _Right );
  return ( * this );
  }

 void swap ( _Myt & _Right )
  {
  _Myios :: swap ( _Right );
  :: std :: swap ( _Chcount, _Right . _Chcount );
  }

 virtual ~ basic_istream ( )
  {
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;


 class _Sentry_base
  {
 public :
   _Sentry_base ( _Myt & _Istr )
   : _Myistr ( _Istr )
   {
   if ( _Myistr . rdbuf ( ) != 0 )
    _Myistr . rdbuf ( ) -> _Lock ( );
   }

   ~ _Sentry_base ( )
   {
   if ( _Myistr . rdbuf ( ) != 0 )
    _Myistr . rdbuf ( ) -> _Unlock ( );
   }

  _Myt & _Myistr;

 private :
  _Sentry_base & operator = ( const _Sentry_base & );
  };

 class sentry
  : public _Sentry_base
  {
 public :
  explicit sentry ( _Myt & _Istr, bool _Noskip = false )
   : _Sentry_base ( _Istr )
   {
   _Ok = this -> _Myistr . _Ipfx ( _Noskip );
   }

   operator :: std :: _Bool_type ( ) const
   {
   return ( _Ok ? ( & :: std :: _Bool_struct :: _Member ) : 0 );
   }

 private :
  bool _Ok;

   sentry ( const sentry & );
  sentry & operator = ( const sentry & );
  };

 bool _Ipfx ( bool _Noskip = false )
  {
  if ( ios_base :: good ( ) )
   {
   if ( _Myios :: tie ( ) != 0 )
    _Myios :: tie ( ) -> flush ( );

   if ( ! _Noskip && ios_base :: flags ( ) & ios_base :: skipws )
    {
    const _Ctype & _Ctype_fac = use_facet < _Ctype > ( ios_base :: getloc ( ) );

    try {
    int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

    for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
     if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
      {
      _Myios :: setstate ( ios_base :: eofbit );
      break;
      }
     else if ( ! _Ctype_fac . is ( _Ctype :: space,
      _Traits :: to_char_type ( _Meta ) ) )
      break;
    } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
    }

   if ( ios_base :: good ( ) )
    return ( true );
   }
  _Myios :: setstate ( ios_base :: failbit );
  return ( false );
  }

 bool ipfx ( bool _Noskip = false )
  {
  return ( _Ipfx ( _Noskip ) );
  }

 void isfx ( )
  {
  }























 _Myt & operator >> ( _Myt & ( __cdecl * _Pfn ) ( _Myt & ) )
  {
  ;
  return ( ( * _Pfn ) ( * this ) );
  }

 _Myt & operator >> ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) )
  {
  ;
  ( * _Pfn ) ( * ( _Myios * ) this );
  return ( * this );
  }

 _Myt & operator >> ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) )
  {
  ;
  ( * _Pfn ) ( * ( ios_base * ) this );
  return ( * this );
  }

 _Myt & operator >> ( _Bool & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( short & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   long _Tmp = 0;
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Tmp );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }

   if ( _State & ios_base :: failbit
    || _Tmp < ( - 32768 ) || 32767 < _Tmp )
    _State |= ios_base :: failbit;
   else
    _Val = ( short ) _Tmp;
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }










 _Myt & operator >> ( unsigned short & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( int & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   long _Tmp = 0;
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Tmp );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }

   if ( _State & ios_base :: failbit
    || _Tmp < ( - 2147483647 - 1 ) || 2147483647 < _Tmp )
    _State |= ios_base :: failbit;
   else
    _Val = _Tmp;
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( unsigned int & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );
  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( long & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );
   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( unsigned long & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


 _Myt & operator >> ( __int64 & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( unsigned __int64 & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );
  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


 _Myt & operator >> ( float & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( double & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );
  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( long double & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );
   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( void * & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( _Mysb * _Strbuf )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  bool _Copied = false;
  const sentry _Ok ( * this );

  if ( _Ok && _Strbuf != 0 )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     try {
      if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
       _Strbuf -> sputc ( _Traits :: to_char_type ( _Meta ) ) ) )
       break;
     } catch ( ... ) {
      break;
     }
     _Copied = true;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( ! _Copied ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

 int_type get ( )
  {
  int_type _Meta = 0;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( ! _Ok )
   _Meta = _Traits :: eof ( );
  else
   {
   try {
   _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    _State |= ios_base :: eofbit | ios_base :: failbit;
   else
    {
    _Myios :: rdbuf ( ) -> sbumpc ( );
    ++ _Chcount;
    }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( _Meta );
  }

 _Myt & get ( _Elem * _Str, streamsize _Count )
  {
  return ( get ( _Str, _Count, _Myios :: widen ( '\n' ) ) );
  }

 _Myt & get ( _Elem * _Str,
  streamsize _Count, _Elem _Delim )
  {
  ;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (; 0 < -- _Count; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( _Traits :: to_char_type ( _Meta ) == _Delim )
     break;
    else
     {
     * _Str ++ = _Traits :: to_char_type ( _Meta );
     ++ _Chcount;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _Chcount == 0
   ? _State | ios_base :: failbit : _State );
  * _Str = _Elem ( );
  return ( * this );
  }

 _Myt & get ( _Elem & _Ch )
  {
  int_type _Meta = get ( );
  if ( ! _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   _Ch = _Traits :: to_char_type ( _Meta );
  return ( * this );
  }

 _Myt & get ( _Mysb & _Strbuf )
  {
  return ( get ( _Strbuf, _Myios :: widen ( '\n' ) ) );
  }

 _Myt & get ( _Mysb & _Strbuf, _Elem _Delim )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     try {
      _Elem _Ch = _Traits :: to_char_type ( _Meta );
      if ( _Ch == _Delim
       || _Traits :: eq_int_type ( _Traits :: eof ( ),
        _Strbuf . sputc ( _Ch ) ) )
       break;
     } catch ( ... ) {
      break;
     }
     ++ _Chcount;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  if ( _Chcount == 0 )
   _State |= ios_base :: failbit;
  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & getline ( _Elem * _Str, streamsize _Count )
  {
  return ( getline ( _Str, _Count, _Myios :: widen ( '\n' ) ) );
  }

 _Myt & getline ( _Elem * _Str,
  streamsize _Count, _Elem _Delim )
  {
  ;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   int_type _Metadelim = _Traits :: to_int_type ( _Delim );

   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( _Meta == _Metadelim )
     {
     ++ _Chcount;
     _Myios :: rdbuf ( ) -> sbumpc ( );
     break;
     }
    else if ( -- _Count <= 0 )
     {
     _State |= ios_base :: failbit;
     break;
     }
    else
     {
     ++ _Chcount;
     * _Str ++ = _Traits :: to_char_type ( _Meta );
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  * _Str = _Elem ( );
  _Myios :: setstate ( _Chcount == 0 ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

 _Myt & ignore ( streamsize _Count = 1,
  int_type _Metadelim = _Traits :: eof ( ) )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   try {
   for (;; )
    {
    int_type _Meta;
    if ( _Count != 2147483647 && -- _Count < 0 )
     break;
    else if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Meta = _Myios :: rdbuf ( ) -> sbumpc ( ) ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     ++ _Chcount;
     if ( _Meta == _Metadelim )
      break;
     }
    }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & read ( _Elem * _Str, streamsize _Count )
  {
  ;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   const streamsize _Num = _Myios :: rdbuf ( ) -> sgetn ( _Str, _Count );
   _Chcount += _Num;
   if ( _Num != _Count )
    _State |= ios_base :: eofbit | ios_base :: failbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 streamsize readsome ( _Elem * _Str,
  streamsize _Count )
  {
  ;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );
  streamsize _Num;

  if ( ! _Ok )
   _State |= ios_base :: failbit;
  else if ( ( _Num = _Myios :: rdbuf ( ) -> in_avail ( ) ) < 0 )
   _State |= ios_base :: eofbit;
  else if ( 0 < _Num )
   read ( _Str, _Num < _Count ? _Num : _Count );

  _Myios :: setstate ( _State );
  return ( gcount ( ) );
  }

 int_type peek ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  int_type _Meta = 0;
  const sentry _Ok ( * this, true );

  if ( ! _Ok )
   _Meta = _Traits :: eof ( );
  else
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Meta = _Myios :: rdbuf ( ) -> sgetc ( ) ) )
    _State |= ios_base :: eofbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( _Meta );
  }

 _Myt & putback ( _Elem _Ch )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sputbackc ( _Ch ) ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & unget ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sungetc ( ) ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 streamsize gcount ( ) const
  {
  return ( _Chcount );
  }

 int sync ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  int _Ans;

  if ( _Myios :: rdbuf ( ) == 0 )
   _Ans = - 1;
  else if ( _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 )
   {
   _State |= ios_base :: badbit;
   _Ans = - 1;
   }
  else
   _Ans = 0;

  _Myios :: setstate ( _State );
  return ( _Ans );
  }

 _Myt & seekg ( pos_type _Pos )
  {
  if ( ! ios_base :: fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekpos ( _Pos,
    ios_base :: in ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

 _Myt & seekg ( off_type _Off, ios_base :: seekdir _Way )
  {
  if ( ! ios_base :: fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way,
    ios_base :: in ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

 pos_type tellg ( )
  {
  if ( ! ios_base :: fail ( ) )
   return ( _Myios :: rdbuf ( ) -> pubseekoff ( 0,
    ios_base :: cur, ios_base :: in ) );
  else
   return ( pos_type ( _BADOFF ) );
  }

private :
 streamsize _Chcount;
 };
#line 863 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\istream"
template < class _Elem,
 class _Traits > inline
 void swap ( basic_istream < _Elem, _Traits > & _Left,
  basic_istream < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 910
template class __declspec(dllimport) basic_istream< char, char_traits< char> > ;
#line 912
template class __declspec(dllimport) basic_istream< __wchar_t, char_traits< __wchar_t> > ;
#line 919 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\istream"
template < class _Elem,
 class _Traits >
 class basic_iostream
 : public basic_istream < _Elem, _Traits >,
  public basic_ostream < _Elem, _Traits >
 {
public :
 typedef basic_iostream < _Elem, _Traits > _Myt;
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 typedef basic_ios < _Elem, _Traits > _Myios;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 explicit basic_iostream ( basic_streambuf < _Elem, _Traits > * _Strbuf )
  : _Myis ( _Strbuf, false ),
   _Myos ( _Noinit, false )
  {
  }

  basic_iostream ( _Myt && _Right )
  : _Myis ( _Right . rdbuf ( ), false ),
   _Myos ( _Noinit, false )
  {
  _Myios :: init ( );
  _Myios :: move ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  this -> swap ( _Right );
  return ( * this );
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   _Myios :: swap ( _Right );
  }

 virtual ~ basic_iostream ( )
  {
  }
 };
#line 968
template < class _Elem,
 class _Traits > inline
 void swap ( basic_iostream < _Elem, _Traits > & _Left,
  basic_iostream < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 978
template class __declspec(dllimport) basic_iostream< char, char_traits< char> > ;
#line 979
template class __declspec(dllimport) basic_iostream< __wchar_t, char_traits< __wchar_t> > ;
#line 985 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\istream"
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > && _Istr, _Elem * _Str )
 {
 ;
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef ctype < _Elem > _Ctype;
 ios_base :: iostate _State = ios_base :: goodbit;
 _Elem * _Str0 = _Str;
 const typename _Myis :: sentry _Ok ( _Istr );

 if ( _Ok )
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( _Istr . getloc ( ) );

  try {
  streamsize _Count = 0 < _Istr . width ( ) ? _Istr . width ( ) : 2147483647;
  typename _Myis :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );
  _Elem _Ch;
  for (; 0 < -- _Count; _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    {
    _State |= ios_base :: eofbit;
    break;
    }
   else if ( _Ctype_fac . is ( _Ctype :: space,
    _Ch = _Traits :: to_char_type ( _Meta ) )
     || _Ch == _Elem ( ) )
    break;
   else
    * _Str ++ = _Traits :: to_char_type ( _Meta );
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 * _Str = _Elem ( );
 _Istr . width ( 0 );
 _Istr . setstate ( _Str == _Str0 ? _State | ios_base :: failbit : _State );
 return ( _Istr );
 }
#line 1026
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > && _Istr, _Elem & _Ch )
 {
 typedef basic_istream < _Elem, _Traits > _Myis;

 typename _Myis :: int_type _Meta;
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myis :: sentry _Ok ( _Istr );

 if ( _Ok )
  {
  try {
  _Meta = _Istr . rdbuf ( ) -> sbumpc ( );
  if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   _State |= ios_base :: eofbit | ios_base :: failbit;
  else
   _Ch = _Traits :: to_char_type ( _Meta );
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Istr . setstate ( _State );
 return ( _Istr );
 }
#line 1052
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > && _Istr, signed char * _Str )
 {
 return ( _Istr >> ( char * ) _Str );
 }
#line 1059
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > && _Istr, signed char & _Ch )
 {
 return ( _Istr >> ( char & ) _Ch );
 }
#line 1066
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > && _Istr, unsigned char * _Str )
 {
 return ( _Istr >> ( char * ) _Str );
 }
#line 1073
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > && _Istr, unsigned char & _Ch )
 {
 return ( _Istr >> ( char & ) _Ch );
 }
#line 1080
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > & _Istr, _Elem * _Str )
 {
 return ( :: std :: move ( _Istr ) >> _Str );
 }
#line 1088
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > & _Istr, _Elem & _Ch )
 {
 return ( :: std :: move ( _Istr ) >> _Ch );
 }
#line 1096
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, signed char * _Str )
 {
 return ( :: std :: move ( _Istr ) >> ( char * ) _Str );
 }
#line 1103
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, signed char & _Ch )
 {
 return ( :: std :: move ( _Istr ) >> ( char & ) _Ch );
 }
#line 1110
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, unsigned char * _Str )
 {
 return ( :: std :: move ( _Istr ) >> ( char * ) _Str );
 }
#line 1117
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, unsigned char & _Ch )
 {
 return ( :: std :: move ( _Istr ) >> ( char & ) _Ch );
 }
#line 1124
template < class _Elem,
 class _Traits,
 class _Ty > inline
 basic_istream < _Elem, _Traits > &
  operator >> ( basic_istream < _Elem, _Traits > && _Istr, _Ty & _Val )
 {
 return ( _Istr >> _Val );
 }
#line 1134
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > &
  __cdecl ws ( basic_istream < _Elem, _Traits > & _Istr )
 {
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef ctype < _Elem > _Ctype;

 if ( ! _Istr . eof ( ) )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const typename _Myis :: sentry _Ok ( _Istr, true );

  if ( _Ok )
   {
   const _Ctype & _Ctype_fac = use_facet < _Ctype > ( _Istr . getloc ( ) );

   try {
   for ( typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );;
    _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( ! _Ctype_fac . is ( _Ctype :: space,
     _Traits :: to_char_type ( _Meta ) ) )
     break;
   } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
   }

  _Istr . setstate ( _State );
  }
 return ( _Istr );
 }
#line 1170
__declspec(dllimport) inline basic_istream< char, char_traits< char> >  &__cdecl 
#line 1171
ws(basic_istream< char, char_traits< char> >  &_Istr) 
#line 1172
{ 
#line 1173
typedef char _Elem; 
#line 1174
typedef char_traits< char>  _Traits; 
#line 1176
if (!_Istr.eof()) 
#line 1177
{ 
#line 1178
ios_base::iostate _State = (_Iosb< int> ::goodbit); 
#line 1179
const basic_istream< char, char_traits< char> > ::sentry _Ok(_Istr, true); 
#line 1181
if (_Ok) 
#line 1182
{ 
#line 1183
const ctype< char>  &_Ctype_fac = use_facet< ctype< char> > (_Istr.getloc()); 
#line 1186
try { 
#line 1187
for (char_traits< char> ::int_type _Meta = _Istr.rdbuf()->sgetc(); ; _Meta = _Istr.rdbuf()->snextc()) { 
#line 1189
if (_Traits::eq_int_type(_Traits::eof(), _Meta)) 
#line 1190
{ 
#line 1191
_State |= _Iosb< int> ::eofbit; 
#line 1192
break; 
#line 1193
} else { 
#line 1194
if (!_Ctype_fac.is(ctype< char> ::space, _Traits::to_char_type(_Meta))) { 
#line 1196
break; }  }  }  
#line 1197
} catch (...) { _Istr.setstate(_Iosb< int> ::badbit, true); }  
#line 1198
}  
#line 1200
_Istr.setstate(_State); 
#line 1201
}  
#line 1202
return _Istr; 
#line 1203
} 
#line 1205
__declspec(dllimport) inline basic_istream< __wchar_t, char_traits< __wchar_t> >  &__cdecl 
#line 1206
ws(basic_istream< __wchar_t, char_traits< __wchar_t> >  &_Istr) 
#line 1207
{ 
#line 1208
typedef __wchar_t _Elem; 
#line 1209
typedef char_traits< __wchar_t>  _Traits; 
#line 1211
if (!_Istr.eof()) 
#line 1212
{ 
#line 1213
ios_base::iostate _State = (_Iosb< int> ::goodbit); 
#line 1214
const basic_istream< __wchar_t, char_traits< __wchar_t> > ::sentry _Ok(_Istr, true); 
#line 1216
if (_Ok) 
#line 1217
{ 
#line 1218
const ctype< __wchar_t>  &_Ctype_fac = use_facet< ctype< __wchar_t> > (_Istr.getloc()); 
#line 1221
try { 
#line 1222
for (char_traits< __wchar_t> ::int_type _Meta = _Istr.rdbuf()->sgetc(); ; _Meta = _Istr.rdbuf()->snextc()) { 
#line 1224
if (_Traits::eq_int_type(_Traits::eof(), _Meta)) 
#line 1225
{ 
#line 1226
_State |= _Iosb< int> ::eofbit; 
#line 1227
break; 
#line 1228
} else { 
#line 1229
if (!_Ctype_fac.is(ctype< __wchar_t> ::space, _Traits::to_char_type(_Meta))) { 
#line 1231
break; }  }  }  
#line 1232
} catch (...) { _Istr.setstate(_Iosb< int> ::badbit, true); }  
#line 1233
}  
#line 1235
_Istr.setstate(_State); 
#line 1236
}  
#line 1237
return _Istr; 
#line 1238
} 
#line 1241
__declspec(dllimport) inline basic_istream< unsigned short, char_traits< unsigned short> >  &__cdecl 
#line 1242
ws(basic_istream< unsigned short, char_traits< unsigned short> >  &_Istr) 
#line 1243
{ 
#line 1244
typedef unsigned short _Elem; 
#line 1245
typedef char_traits< unsigned short>  _Traits; 
#line 1247
if (!_Istr.eof()) 
#line 1248
{ 
#line 1249
ios_base::iostate _State = (_Iosb< int> ::goodbit); 
#line 1250
const basic_istream< unsigned short, char_traits< unsigned short> > ::sentry _Ok(_Istr, true); 
#line 1252
if (_Ok) 
#line 1253
{ 
#line 1254
const ctype< unsigned short>  &_Ctype_fac = use_facet< ctype< unsigned short> > (_Istr.getloc()); 
#line 1257
try { 
#line 1258
for (char_traits< unsigned short> ::int_type _Meta = _Istr.rdbuf()->sgetc(); ; _Meta = _Istr.rdbuf()->snextc()) { 
#line 1260
if (_Traits::eq_int_type(_Traits::eof(), _Meta)) 
#line 1261
{ 
#line 1262
_State |= _Iosb< int> ::eofbit; 
#line 1263
break; 
#line 1264
} else { 
#line 1265
if (!_Ctype_fac.is(ctype< unsigned short> ::space, _Traits::to_char_type(_Meta))) { 
#line 1267
break; }  }  }  
#line 1268
} catch (...) { _Istr.setstate(_Iosb< int> ::badbit, true); }  
#line 1269
}  
#line 1271
_Istr.setstate(_State); 
#line 1272
}  
#line 1273
return _Istr; 
#line 1274
} 
#line 1276 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\istream"
}
#line 1278
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iterator"
#pragma warning(push,3)
#line 1279 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\istream"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iterator"
#pragma pack ( push, 8 )
#line 12
namespace std { 
#line 14
template < class _Container >
 class back_insert_iterator
  : public _Outit
 {
public :
 typedef back_insert_iterator < _Container > _Myt;
 typedef _Container container_type;
 typedef typename _Container :: const_reference const_reference;
 typedef typename _Container :: value_type _Valty;

 explicit back_insert_iterator ( _Container & _Cont )
  : container ( & _Cont )
  {
  }

 _Myt & operator = ( const _Valty & _Val )
  {
  container -> push_back ( _Val );
  return ( * this );
  }

 _Myt & operator = ( _Valty && _Val )
  {
  container -> push_back ( :: std :: forward < _Valty > ( _Val ) );
  return ( * this );
  }

 _Myt & operator * ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( )
  {
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  return ( * this );
  }

protected :
 _Container * container;
 };
#line 60
template< class _Container> 
#line 61
struct _Is_checked_helper< back_insert_iterator< _Container> >  : public tr1::true_type { 
#line 64
}; 
#line 67
template < class _Container > inline
 back_insert_iterator < _Container > back_inserter ( _Container & _Cont )
 {
 return ( :: std :: back_insert_iterator < _Container > ( _Cont ) );
 }
#line 74
template < class _Container >
 class front_insert_iterator
  : public _Outit
 {
public :
 typedef front_insert_iterator < _Container > _Myt;
 typedef _Container container_type;
 typedef typename _Container :: const_reference const_reference;
 typedef typename _Container :: value_type _Valty;

 explicit front_insert_iterator ( _Container & _Cont )
  : container ( & _Cont )
  {
  }

 _Myt & operator = ( const _Valty & _Val )
  {
  container -> push_front ( _Val );
  return ( * this );
  }

 _Myt & operator = ( _Valty && _Val )
  {
  container -> push_front ( :: std :: forward < _Valty > ( _Val ) );
  return ( * this );
  }

 _Myt & operator * ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( )
  {
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  return ( * this );
  }

protected :
 _Container * container;
 };
#line 120
template< class _Container> 
#line 121
struct _Is_checked_helper< front_insert_iterator< _Container> >  : public tr1::true_type { 
#line 124
}; 
#line 127
template < class _Container > inline
 front_insert_iterator < _Container > front_inserter ( _Container & _Cont )
 {
 return ( :: std :: front_insert_iterator < _Container > ( _Cont ) );
 }
#line 134
template < class _Container >
 class insert_iterator
  : public _Outit
 {
public :
 typedef insert_iterator < _Container > _Myt;
 typedef _Container container_type;
 typedef typename _Container :: const_reference const_reference;
 typedef typename _Container :: value_type _Valty;

 insert_iterator ( _Container & _Cont, typename _Container :: iterator _Where )
  : container ( & _Cont ), iter ( _Where )
  {
  }

 _Myt & operator = ( const _Valty & _Val )
  {
  iter = container -> insert ( iter, _Val );
  ++ iter;
  return ( * this );
  }

 _Myt & operator = ( _Valty && _Val )
  {
  iter = container -> insert ( iter, :: std :: forward < _Valty > ( _Val ) );
  ++ iter;
  return ( * this );
  }

 _Myt & operator * ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( int )
  {
  return ( * this );
  }

protected :
 _Container * container;
 typename _Container :: iterator iter;
 };
#line 183
template< class _Container> 
#line 184
struct _Is_checked_helper< insert_iterator< _Container> >  : public tr1::true_type { 
#line 187
}; 
#line 190
template < class _Container > inline
 insert_iterator < _Container > inserter ( _Container & _Cont,
  typename _Container :: iterator _Where )
 {
 return ( :: std :: insert_iterator < _Container > ( _Cont, _Where ) );
 }
#line 198
template < class _RanIt >
 class move_iterator
 {
public :
 typedef move_iterator < _RanIt > _Myt;
  typedef typename iterator_traits < _RanIt > :: iterator_category
  iterator_category;
  typedef typename iterator_traits < _RanIt > :: value_type
  value_type;
  typedef typename iterator_traits < _RanIt > :: difference_type
  difference_type;
 typedef _RanIt pointer;
 typedef value_type && reference;
 typedef _RanIt iterator_type;

 move_iterator ( )
  {
  }

 explicit move_iterator ( iterator_type _Right )
  : current ( _Right )
  {
  }

 template < class _RanIt2 >
  move_iterator ( const move_iterator < _RanIt2 > & _Right )
  : current ( _Right . base ( ) )
  {
  }

 template < class _RanIt2 >
  _Myt & operator = ( const move_iterator < _RanIt2 > & _Right )
  {
  current = _Right . base ( );
  return ( * this );
  }

 _RanIt base ( ) const
  {
  return ( current );
  }

 reference operator * ( ) const
  {
  return ( move ( * current ) );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myt & operator ++ ( )
  {
  ++ current;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  -- current;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

 template < class _RanIt2 >
  bool _Equal ( const move_iterator < _RanIt2 > & _Right ) const
  {
  return ( current == _Right . base ( ) );
  }



 _Myt & operator += ( difference_type _Off )
  {
  current += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  return ( _Myt ( current + _Off ) );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  current -= _Off;
  return ( * this );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  return ( _Myt ( current - _Off ) );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( move ( current [ _Off ] ) );
  }

 template < class _RanIt2 >
  bool _Less ( const move_iterator < _RanIt2 > & _Right ) const
  {
  return ( current < _Right . base ( ) );
  }

 difference_type operator - ( const _Myt & _Right ) const
  {
  return ( current - _Right . base ( ) );
  }

protected :
 iterator_type current;
 };
#line 326
template< class _RanIt> 
#line 327
struct _Is_checked_helper< move_iterator< _RanIt> >  : public _Is_checked_helper< _RanIt>  { 
#line 330
}; 
#line 333
template < class _RanIt,
 class _Diff > inline
 move_iterator < _RanIt >
  operator + ( _Diff _Off,
  const move_iterator < _RanIt > & _Right )
 {
 return ( _Right + _Off );
 }
#line 342
template < class _RanIt1,
 class _RanIt2 > inline
 typename _RanIt1 :: difference_type operator - (
  move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . base ( ) - _Right . base ( ) );
 }
#line 351
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator == (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }
#line 360
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator != (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 369
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator < (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Less ( _Right ) );
 }
#line 378
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator > (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 387
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator <= (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 396
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator >= (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 406
template < class _RanIt > inline
 move_iterator < _RanIt > make_move_iterator ( const _RanIt _Iter )
 {
 return ( move_iterator < _RanIt > ( _Iter ) );
 }
#line 414
template < class _Ty,
 class _Elem = char,
 class _Traits = char_traits < _Elem >,
 class _Diff = ptrdiff_t >
 class istream_iterator
  : public iterator < input_iterator_tag, _Ty, _Diff,
   const _Ty *, const _Ty & >
 {
 typedef istream_iterator < _Ty, _Elem, _Traits, _Diff > _Myt;
public :
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_istream < _Elem, _Traits > istream_type;

 istream_iterator ( )
  : _Myistr ( 0 )
  {
  }

 istream_iterator ( istream_type & _Istr )
  : _Myistr ( & _Istr )
  {
  _Getval ( );
  }

 const _Ty & operator * ( ) const
  {
  return ( _Myval );
  }

 const _Ty * operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myt & operator ++ ( )
  {
  _Getval ( );
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 bool _Equal ( const _Myt & _Right ) const
  {
  return ( _Myistr == _Right . _Myistr );
  }

protected :
 void _Getval ( )
  {
  if ( _Myistr != 0 && ! ( * _Myistr >> _Myval ) )
   _Myistr = 0;
  }

 istream_type * _Myistr;
 _Ty _Myval;
 };
#line 478
template< class _Ty, class 
#line 479
_Elem, class 
#line 480
_Traits, class 
#line 481
_Diff> 
#line 482
struct _Is_checked_helper< istream_iterator< _Ty, _Elem, _Traits, _Diff> >  : public tr1::true_type { 
#line 485
}; 
#line 488
template < class _Ty,
 class _Elem,
 class _Traits,
 class _Diff > inline
 bool operator == (
  const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Left,
  const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }
#line 499
template < class _Ty,
 class _Elem,
 class _Traits,
 class _Diff > inline
 bool operator != (
  const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Left,
  const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 512
template < class _Ty,
 class _Elem = char,
 class _Traits = char_traits < _Elem > >
 class ostream_iterator
  : public _Outit
 {
public :
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_ostream < _Elem, _Traits > ostream_type;

 ostream_iterator ( ostream_type & _Ostr,
  const _Elem * _Delim = 0 )
  : _Myostr ( & _Ostr ), _Mydelim ( _Delim )
  {
  }

 ostream_iterator < _Ty, _Elem, _Traits > & operator = ( const _Ty & _Val )
  {
  * _Myostr << _Val;
  if ( _Mydelim != 0 )
   * _Myostr << _Mydelim;
  return ( * this );
  }

 ostream_iterator < _Ty, _Elem, _Traits > & operator * ( )
  {
  return ( * this );
  }

 ostream_iterator < _Ty, _Elem, _Traits > & operator ++ ( )
  {
  return ( * this );
  }

 ostream_iterator < _Ty, _Elem, _Traits > operator ++ ( int )
  {
  return ( * this );
  }

protected :
 const _Elem * _Mydelim;
 ostream_type * _Myostr;
 };
#line 557
template< class _Ty, class 
#line 558
_Elem, class 
#line 559
_Traits> 
#line 560
struct _Is_checked_helper< ostream_iterator< _Ty, _Elem, _Traits> >  : public tr1::true_type { 
#line 563
}; 
#line 564
}
#line 566
namespace stdext { 
#line 568
template < class _Iterator >
 class checked_array_iterator
 {
public :
 typedef checked_array_iterator < _Iterator > _Myt;

 typedef typename :: std :: iterator_traits < _Iterator > :: iterator_category iterator_category;
 typedef typename :: std :: iterator_traits < _Iterator > :: value_type value_type;
 typedef typename :: std :: iterator_traits < _Iterator > :: difference_type difference_type;
 typedef typename :: std :: iterator_traits < _Iterator > :: difference_type distance_type;
 typedef typename :: std :: iterator_traits < _Iterator > :: pointer pointer;
 typedef typename :: std :: iterator_traits < _Iterator > :: reference reference;

 checked_array_iterator ( )
  : _Myarray ( ), _Mysize ( 0 ), _Myindex ( 0 )
  {
  }

 checked_array_iterator ( _Iterator _Array, :: std :: size_t _Size, :: std :: size_t _Index = 0 )
  : _Myarray ( _Array ), _Mysize ( _Size ), _Myindex ( _Index )
  {
  { if ( ! ( _Index <= _Size ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };
  }

 _Iterator base ( ) const
  {
  return ( _Myarray + _Myindex );
  }


 typedef _Iterator _Unchecked_type;

 _Myt & _Rechecked ( _Unchecked_type _Right )
  {
  _Myindex = _Right - _Myarray;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( base ( ) );
  }


 reference operator * ( ) const
  {
  { if ( ! ( _Myarray != 0 && _Myindex < _Mysize ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };
  return ( _Myarray [ _Myindex ] );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myt & operator ++ ( )
  {
  { if ( ! ( _Myarray != 0 && _Myindex < _Mysize ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };
  ++ _Myindex;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  { if ( ! ( _Myarray != 0 && _Myindex > 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };
  -- _Myindex;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myt & operator += ( difference_type _Off )
  {
  { if ( ! ( _Myarray != 0 && _Myindex + _Off <= _Mysize ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };
  _Myindex += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myt & _Right ) const
  {
  { if ( ! ( _Myarray == _Right . _Myarray ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };
  return ( _Myindex - _Right . _Myindex );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myt & _Right ) const
  {
  { if ( ! ( _Myarray == _Right . _Myarray ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };
  return ( _Myindex == _Right . _Myindex );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myt & _Right ) const
  {
  { if ( ! ( _Myarray == _Right . _Myarray ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };
  return ( _Myindex < _Right . _Myindex );
  }

 bool operator > ( const _Myt & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myt & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myt & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }

private :
 _Iterator _Myarray;
 :: std :: size_t _Mysize;
 :: std :: size_t _Myindex;
 };
#line 724
template < class _Iterator > inline
 typename checked_array_iterator < _Iterator > :: _Unchecked_type
  _Unchecked ( checked_array_iterator < _Iterator > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 731
template < class _Iterator > inline
 checked_array_iterator < _Iterator > &
  _Rechecked ( checked_array_iterator < _Iterator > & _Iter,
   typename checked_array_iterator < _Iterator >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 740
template < class _Iterator > inline
 checked_array_iterator < _Iterator > operator + (
  typename checked_array_iterator < _Iterator > :: difference_type _Off,
  checked_array_iterator < _Iterator > _Next )
 {
 return ( _Next += _Off );
 }
#line 748
template < class _Iterator > inline
 checked_array_iterator < _Iterator > make_checked_array_iterator (
  _Iterator _Array, :: std :: size_t _Size, :: std :: size_t _Index = 0 )
 {
 return ( checked_array_iterator < _Iterator > ( _Array, _Size, _Index ) );
 }
#line 756
template < class _Iterator >
 class unchecked_array_iterator
 {
public :
 typedef unchecked_array_iterator < _Iterator > _Myt;

 typedef typename :: std :: iterator_traits < _Iterator > :: iterator_category iterator_category;
 typedef typename :: std :: iterator_traits < _Iterator > :: value_type value_type;
 typedef typename :: std :: iterator_traits < _Iterator > :: difference_type difference_type;
 typedef typename :: std :: iterator_traits < _Iterator > :: difference_type distance_type;
 typedef typename :: std :: iterator_traits < _Iterator > :: pointer pointer;
 typedef typename :: std :: iterator_traits < _Iterator > :: reference reference;

 unchecked_array_iterator ( )
  : _Myptr ( )
  {
  }

 explicit unchecked_array_iterator ( _Iterator _Ptr )
  : _Myptr ( _Ptr )
  {
  }

 _Iterator base ( ) const
  {
  return ( _Myptr );
  }


 typedef _Iterator _Unchecked_type;

 _Myt & _Rechecked ( _Unchecked_type _Right )
  {
  _Myptr = _Right;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( base ( ) );
  }


 reference operator * ( ) const
  {
  return ( * _Myptr );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myt & operator ++ ( )
  {
  ++ _Myptr;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  -- _Myptr;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myt & operator += ( difference_type _Off )
  {
  _Myptr += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myt & _Right ) const
  {
  return ( _Myptr - _Right . _Myptr );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myt & _Right ) const
  {
  return ( _Myptr == _Right . _Myptr );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myt & _Right ) const
  {
  return ( _Myptr < _Right . _Myptr );
  }

 bool operator > ( const _Myt & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myt & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myt & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }

private :
 _Iterator _Myptr;
 };
#line 902
template < class _Iterator > inline
 typename unchecked_array_iterator < _Iterator > :: _Unchecked_type
  _Unchecked ( unchecked_array_iterator < _Iterator > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 909
template < class _Iterator > inline
 unchecked_array_iterator < _Iterator > &
  _Rechecked ( unchecked_array_iterator < _Iterator > & _Iter,
   typename unchecked_array_iterator < _Iterator >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 918
template < class _Iterator > inline
 unchecked_array_iterator < _Iterator > operator + (
  typename unchecked_array_iterator < _Iterator > :: difference_type _Off,
  unchecked_array_iterator < _Iterator > _Next )
 {
 return ( _Next += _Off );
 }
#line 926
template < class _Iterator > inline
 unchecked_array_iterator < _Iterator > make_unchecked_array_iterator (
  _Iterator _Ptr )
 {
 return ( unchecked_array_iterator < _Iterator > ( _Ptr ) );
 }
#line 932
}
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\array"
#pragma warning(push,3)
#line 934 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iterator"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\array"
#pragma pack ( push, 8 )
#line 12
namespace std { 
#line 13
namespace tr1 { 
#line 15
template < class _Ty,
 size_t _Size >
 class array
 {
public :
 enum { _EEN_SIZE = _Size };
 typedef array < _Ty, _Size > _Myt;
 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef _Ty * pointer;
 typedef const _Ty * const_pointer;
 typedef _Ty & reference;
 typedef const _Ty & const_reference;

 typedef _Array_iterator < _Ty, _Size > iterator;
 typedef _Array_const_iterator < _Ty, _Size > const_iterator;

 typedef :: std :: reverse_iterator < iterator > reverse_iterator;
 typedef :: std :: reverse_iterator < const_iterator > const_reverse_iterator;

 void assign ( const _Ty & _Value )
  {
  :: std :: fill_n ( _Elems, _Size, _Value );
  }

 void fill ( const _Ty & _Value )
  {
  :: std :: fill_n ( _Elems, _Size, _Value );
  }

 void swap ( _Myt & _Other )
  {
  _Swap_ranges ( :: std :: addressof ( _Elems [ 0 ] ), :: std :: addressof ( _Elems [ 0 ] ) + _Size, :: std :: addressof ( _Other . _Elems [ 0 ] ) );
  }

 void swap ( _Myt && _Other )
  {
  _Move ( _Other . begin ( ), _Other . end ( ), begin ( ) );
  }

 iterator begin ( )
  {
  return ( iterator ( :: std :: addressof ( _Elems [ 0 ] ), 0 ) );
  }

 const_iterator begin ( ) const
  {
  return ( const_iterator ( :: std :: addressof ( _Elems [ 0 ] ), 0 ) );
  }

 iterator end ( )
  {
  return ( iterator ( :: std :: addressof ( _Elems [ 0 ] ), _Size ) );
  }

 const_iterator end ( ) const
  {
  return ( const_iterator ( :: std :: addressof ( _Elems [ 0 ] ), _Size ) );
  }

 reverse_iterator rbegin ( )
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( )
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }


 const_iterator cbegin ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> begin ( ) );
  }

 const_iterator cend ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> end ( ) );
  }

 const_reverse_iterator crbegin ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> rbegin ( ) );
  }

 const_reverse_iterator crend ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> rend ( ) );
  }


 size_type size ( ) const
  {
  return ( _Size );
  }

 size_type max_size ( ) const
  {
  return ( _Size );
  }

 bool empty ( ) const
  {
  return ( _Size == 0 );
  }

 reference at ( size_type _Pos )
  {
  if ( _Size <= _Pos )
   _Xran ( );
  return ( _Elems [ _Pos ] );
  }

 const_reference at ( size_type _Pos ) const
  {
  if ( _Size <= _Pos )
   _Xran ( );
  return ( _Elems [ _Pos ] );
  }

 reference operator [ ] ( size_type _Pos )
  {








  ;

  return ( _Elems [ _Pos ] );
  }

 const_reference operator [ ] ( size_type _Pos ) const
  {








  ;

  return ( _Elems [ _Pos ] );
  }

 reference front ( )
  {
  return ( _Elems [ 0 ] );
  }

 const_reference front ( ) const
  {
  return ( _Elems [ 0 ] );
  }

 reference back ( )
  {
  return ( _Elems [ _Size - 1 ] );
  }

 const_reference back ( ) const
  {
  return ( _Elems [ _Size - 1 ] );
  }

 _Ty * data ( )
  {
  return ( _Elems );
  }

 const _Ty * data ( ) const
  {
  return ( _Elems );
  }

 __declspec ( noreturn ) void _Xran ( ) const
  {
  :: std :: _Xout_of_range ( "invalid array<T, N> subscript" );
  }

 _Ty _Elems [ _Size == 0 ? 1 : _Size ];
 };
#line 215 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\array"
template < class _Ty >
 class array < _Ty, 0 >
 {
public :
 enum { _EEN_SIZE = 0 };
 typedef array < _Ty, 0 > _Myt;
 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef _Ty * pointer;
 typedef const _Ty * const_pointer;
 typedef _Ty & reference;
 typedef const _Ty & const_reference;

 typedef _Array_iterator < _Ty, 0 > iterator;
 typedef _Array_const_iterator < _Ty, 0 > const_iterator;
 typedef :: std :: reverse_iterator < iterator > reverse_iterator;
 typedef :: std :: reverse_iterator < const_iterator > const_reverse_iterator;

 void assign ( const _Ty & )
  {
  }

 void fill ( const _Ty & )
  {
  }

 void swap ( _Myt & )
  {
  }

 iterator begin ( )
  {
  return ( iterator ( 0, 0 ) );
  }

 const_iterator begin ( ) const
  {
  return ( iterator ( 0, 0 ) );
  }

 iterator end ( )
  {
  return ( iterator ( 0, 0 ) );
  }

 const_iterator end ( ) const
  {
  return ( iterator ( 0, 0 ) );
  }

 reverse_iterator rbegin ( )
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( )
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }


 const_iterator cbegin ( ) const
  {
  return ( iterator ( 0, 0 ) );
  }

 const_iterator cend ( ) const
  {
  return ( iterator ( 0, 0 ) );
  }

 const_reverse_iterator crbegin ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> rbegin ( ) );
  }

 const_reverse_iterator crend ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> rend ( ) );
  }


 size_type size ( ) const
  {
  return ( 0 );
  }

 size_type max_size ( ) const
  {
  return ( 0 );
  }

 bool empty ( ) const
  {
  return ( true );
  }

 reference at ( size_type )
  {
  static int _Zero = 0;

  if ( _Zero == 0 )
   _Xran ( );
  return ( _Elems [ 0 ] );
  }

 const_reference at ( size_type ) const
  {
  static int _Zero = 0;

  if ( _Zero == 0 )
   _Xran ( );
  return ( _Elems [ 0 ] );
  }

 reference operator [ ] ( size_type )
  {







  return ( _Elems [ 0 ] );
  }

 const_reference operator [ ] ( size_type ) const
  {







  return ( _Elems [ 0 ] );
  }

 reference front ( )
  {







  return ( _Elems [ 0 ] );
  }

 const_reference front ( ) const
  {







  return ( _Elems [ 0 ] );
  }

 reference back ( )
  {







  return ( _Elems [ 0 ] );
  }

 const_reference back ( ) const
  {







  return ( _Elems [ 0 ] );
  }

 _Ty * data ( )
  {
  return ( _Elems );
  }

 const _Ty * data ( ) const
  {
  return ( _Elems );
  }

 __declspec ( noreturn ) void _Xran ( ) const
  {
  :: std :: _Xout_of_range ( "invalid array<T, 0> subscript" );
  }

 _Ty _Elems [ 1 ];
 };
#line 431 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\array"
template < class _Ty,
 size_t _Size >
 void swap ( array < _Ty, _Size > & _Left,
  array < _Ty, _Size > & _Right )
 {
 return ( _Left . swap ( _Right ) );
 }
#line 439
template < class _Ty,
 size_t _Size >
 void swap ( array < _Ty, _Size > & _Left,
  array < _Ty, _Size > && _Right )
 {
 typedef array < _Ty, _Size > _Myt;
 _Left . swap ( :: std :: forward < _Myt > ( _Right ) );
 }
#line 448
template < class _Ty,
 size_t _Size >
 void swap ( array < _Ty, _Size > && _Left,
  array < _Ty, _Size > & _Right )
 {
 typedef array < _Ty, _Size > _Myt;
 _Right . swap ( :: std :: forward < _Myt > ( _Left ) );
 }
#line 457
template < class _Ty,
 size_t _Size >
 bool operator == ( const array < _Ty, _Size > & _Left,
  const array < _Ty, _Size > & _Right )
 {
 return ( :: std :: equal ( _Left . begin ( ), _Left . end ( ), _Right . begin ( ) ) );
 }
#line 465
template < class _Ty,
 size_t _Size >
 bool operator != ( const array < _Ty, _Size > & _Left,
  const array < _Ty, _Size > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 473
template < class _Ty,
 size_t _Size >
 bool operator < ( const array < _Ty, _Size > & _Left,
  const array < _Ty, _Size > & _Right )
 {
 return ( :: std :: lexicographical_compare ( _Left . begin ( ), _Left . end ( ),
  _Right . begin ( ), _Right . end ( ) ) );
 }
#line 482
template < class _Ty,
 size_t _Size >
 bool operator > ( const array < _Ty, _Size > & _Left,
  const array < _Ty, _Size > & _Right )
 {
 return ( _Right < _Left );
 }
#line 490
template < class _Ty,
 size_t _Size >
 bool operator <= ( const array < _Ty, _Size > & _Left,
 const array < _Ty, _Size > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 498
template < class _Ty,
 size_t _Size >
 bool operator >= ( const array < _Ty, _Size > & _Left,
 const array < _Ty, _Size > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 508
template< class _Tuple> struct tuple_size; 
#line 511
template< size_t _Idx, class 
#line 512
_Tuple> struct tuple_element; 
#line 515
template< class _Ty, size_t 
#line 516
_Size> 
#line 517
struct tuple_size< array< _Ty, _Size> >  { 
#line 519
static const int value = (_Size); 
#line 520
}; 
#line 522
template< size_t _Idx, class 
#line 523
_Ty, size_t 
#line 524
_Size> 
#line 525
struct tuple_element< _Idx, array< _Ty, _Size> >  { 
#line 527
typedef _Ty type; 
#line 528
}; 
#line 530
template < int _Idx,
 class _Ty,
 size_t _Size >
 _Ty & get ( array < _Ty, _Size > & _Arr )
 {
 static_assert ( 0 <= _Idx && _Idx < _Size, "array index out of bounds" );
 return ( _Arr [ _Idx ] );
 }
#line 539
template < int _Idx,
 class _Ty,
 size_t _Size >
 const _Ty & get ( const array < _Ty, _Size > & _Arr )
 {
 static_assert ( 0 <= _Idx && _Idx < _Size, "array index out of bounds" );
 return ( _Arr [ _Idx ] );
 }
#line 548 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\array"
}
#line 551
using tr1::array;
#line 552
using tr1::get;
#line 556 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\array"
}
#line 558
#pragma warning(pop)
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\cstdarg"
namespace std { 
#line 10
using ::va_list;
#line 11
}
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\ctime"
namespace std { 
#line 18
using ::clock_t;
#line 19
using ::time_t;
#line 20
using ::asctime;using ::clock;using ::ctime;
#line 21
using ::difftime;using ::gmtime;using ::localtime;
#line 22
using ::mktime;using ::strftime;using ::time;
#line 23
}
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\fstream"
#pragma warning(push,3)
#line 8
#pragma pack ( push, 8 )
#line 11
namespace std { 
#pragma warning(disable: 4127)
#line 14
__declspec(dllimport) extern _iobuf *__cdecl _Fiopen(const char *, ios_base::openmode, int); 
#line 17
__declspec(dllimport) extern _iobuf *__cdecl _Fiopen(const __wchar_t *, ios_base::openmode, int); 
#line 22
__declspec(dllimport) extern _iobuf *__cdecl _Fiopen(const unsigned short *, ios_base::openmode, int); 
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\fstream"
template < class _Elem > inline
 bool _Fgetc ( _Elem & _Ch, _iobuf * _File )
 {
 return ( fread ( & _Ch, sizeof ( _Elem ), 1, _File ) == 1 );
 }
#line 34
template<> inline bool _Fgetc(char &_Byte, _iobuf *_File) 
#line 35
{ 
#line 36
int _Meta; 
#line 37
if ((_Meta = fgetc(_File)) == (-1)) { 
#line 38
return false; } else 
#line 40
{ 
#line 41
_Byte = ((char)_Meta); 
#line 42
return true; 
#line 43
}  
#line 44
} 
#line 46
template<> inline bool _Fgetc(__wchar_t &_Wchar, _iobuf *_File) 
#line 47
{ 
#line 48
wint_t _Meta; 
#line 49
if ((_Meta = ::fgetwc(_File)) == ((wint_t)65535)) { 
#line 50
return false; } else 
#line 52
{ 
#line 53
_Wchar = ((__wchar_t)_Meta); 
#line 54
return true; 
#line 55
}  
#line 56
} 
#line 59
template<> inline bool _Fgetc(unsigned short &_Wchar, _iobuf *_File) 
#line 60
{ 
#line 61
wint_t _Meta; 
#line 62
if ((_Meta = ::fgetwc(_File)) == ((wint_t)65535)) { 
#line 63
return false; } else 
#line 65
{ 
#line 66
_Wchar = _Meta; 
#line 67
return true; 
#line 68
}  
#line 69
} 
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\fstream"
template < class _Elem > inline
 bool _Fputc ( _Elem _Ch, _iobuf * _File )
 {
 return ( fwrite ( & _Ch, 1, sizeof ( _Elem ), _File ) == sizeof ( _Elem ) );
 }
#line 79
template<> inline bool _Fputc(char _Byte, _iobuf *_File) 
#line 80
{ 
#line 81
return fputc(_Byte, _File) != (-1); 
#line 82
} 
#line 84
template<> inline bool _Fputc(__wchar_t _Wchar, _iobuf *_File) 
#line 85
{ 
#line 86
return (::fputwc(_Wchar, _File)) != ((wint_t)65535); 
#line 87
} 
#line 90
template<> inline bool _Fputc(unsigned short _Wchar, _iobuf *_File) 
#line 91
{ 
#line 92
return (::fputwc(_Wchar, _File)) != ((wint_t)65535); 
#line 93
} 
#line 97 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\fstream"
template < class _Elem > inline
 bool _Ungetc ( const _Elem & _Ch, _iobuf * _File )
 {
 return ( false );
 }
#line 103
template<> inline bool _Ungetc(const char &_Byte, _iobuf *_File) 
#line 104
{ 
#line 105
return ungetc((unsigned char)_Byte, _File) != (-1); 
#line 106
} 
#line 108
template<> inline bool _Ungetc(const signed char &_Byte, _iobuf *_File) 
#line 109
{ 
#line 110
return ungetc((unsigned char)_Byte, _File) != (-1); 
#line 111
} 
#line 113
template<> inline bool _Ungetc(const unsigned char &_Byte, _iobuf *_File) 
#line 114
{ 
#line 115
return ungetc(_Byte, _File) != (-1); 
#line 116
} 
#line 118
template<> inline bool _Ungetc(const __wchar_t &_Wchar, _iobuf *_File) 
#line 119
{ 
#line 120
return (::ungetwc(_Wchar, _File)) != ((wint_t)65535); 
#line 121
} 
#line 124
template<> inline bool _Ungetc(const unsigned short &_Wchar, _iobuf *_File) 
#line 125
{ 
#line 126
return (::ungetwc(_Wchar, _File)) != ((wint_t)65535); 
#line 127
} 
#line 131 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\fstream"
template < class _Elem,
 class _Traits >
 class basic_filebuf
  : public basic_streambuf < _Elem, _Traits >
 {
public :
 typedef basic_filebuf < _Elem, _Traits > _Myt;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef typename _Traits :: state_type _Myst;
 typedef codecvt < _Elem, char, typename _Traits :: state_type > _Cvt;

 virtual ~ basic_filebuf ( )
  {
  if ( _Myfile != 0 )
   _Reset_back ( );
  if ( _Closef )
   close ( );
  }

 basic_filebuf ( _iobuf * _File = 0 )
  : _Mysb ( )
  {
  _Init ( _File, _Newfl );
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 basic_filebuf ( _Uninitialized )
  : _Mysb ( _Noinit )
  {
  }

 basic_filebuf ( _Myt && _Right )
  {
  _Init ( _Right . _Myfile, _Newfl );
  _Init ( ( _iobuf * ) 0, _Closefl );
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   close ( );
   this -> swap ( _Right );
   }
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Mysb :: swap ( _Right );
   :: std :: swap ( _Pcvt, _Right . _Pcvt );
   :: std :: swap ( _Mychar, _Right . _Mychar );
   :: std :: swap ( _Wrotesome, _Right . _Wrotesome );
   :: std :: swap ( _State, _Right . _State );
   :: std :: swap ( _Closef, _Right . _Closef );
   :: std :: swap ( _Myfile, _Right . _Myfile );
   }
  }

 void swap ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 enum _Initfl
  {
  _Newfl, _Openfl, _Closefl };

 bool is_open ( ) const
  {
  return ( _Myfile != 0 );
  }

 _Myt * open ( const char * _Filename,
  ios_base :: openmode _Mode,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  _iobuf * _File;
  if ( _Myfile != 0 || ( _File = _Fiopen ( _Filename, _Mode, _Prot ) ) == 0 )
   return ( 0 );

  _Init ( _File, _Openfl );
  _Initcvt ( & use_facet < _Cvt > ( _Mysb :: getloc ( ) ) );
  return ( this );
  }


 _Myt * open ( const string & _Str,
  ios_base :: openmode _Mode,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  return ( open ( _Str . c_str ( ), _Mode, _Prot ) );
  }


 _Myt * open ( const char * _Filename, ios_base :: open_mode _Mode )
  {
  return ( open ( _Filename, ( ios_base :: openmode ) _Mode ) );
  }

 _Myt * open ( const wchar_t * _Filename,
  ios_base :: openmode _Mode,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  _iobuf * _File;
  if ( _Myfile != 0 || ( _File = _Fiopen ( _Filename, _Mode, _Prot ) ) == 0 )
   return ( 0 );

  _Init ( _File, _Openfl );
  _Initcvt ( & use_facet < _Cvt > ( _Mysb :: getloc ( ) ) );
  return ( this );
  }


 _Myt * open ( const wstring & _Str,
  ios_base :: openmode _Mode,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  return ( open ( _Str . c_str ( ), _Mode, _Prot ) );
  }


 _Myt * open ( const wchar_t * _Filename,
  ios_base :: open_mode _Mode )
  {
  return ( open ( _Filename, ( ios_base :: openmode ) _Mode ) );
  }


 _Myt * open ( const unsigned short * _Filename,
  ios_base :: openmode _Mode,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  _iobuf * _File;
  if ( _Myfile != 0 || ( _File = _Fiopen ( _Filename, _Mode, _Prot ) ) == 0 )
   return ( 0 );

  _Init ( _File, _Openfl );
  _Initcvt ( & use_facet < _Cvt > ( _Mysb :: getloc ( ) ) );
  return ( this );
  }

 _Myt * open ( const unsigned short * _Filename,
  ios_base :: open_mode _Mode )
  {
  return ( open ( _Filename, ( ios_base :: openmode ) _Mode ) );
  }


 _Myt * close ( )
  {
  _Myt * _Ans = this;
  if ( _Myfile == 0 )
   _Ans = 0;
  else
   {
   if ( ! _Endwrite ( ) )
    _Ans = 0;
   if ( fclose ( _Myfile ) != 0 )
    _Ans = 0;
   }
  _Init ( 0, _Closefl );
  return ( _Ans );
  }

 virtual void _Lock ( )
  {
  if ( _Myfile )
   :: _lock_file ( _Myfile );
  }

 virtual void _Unlock ( )
  {
  if ( _Myfile )
   :: _unlock_file ( _Myfile );
  }

protected :
 virtual int_type overflow ( int_type _Meta =
  _Traits :: eof ( ) )
  {
  if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   return ( _Traits :: not_eof ( _Meta ) );
  else if ( _Mysb :: pptr ( ) != 0
   && _Mysb :: pptr ( ) < _Mysb :: epptr ( ) )
   {
   * _Mysb :: _Pninc ( ) = _Traits :: to_char_type ( _Meta );
   return ( _Meta );
   }
  else if ( _Myfile == 0 )
   return ( _Traits :: eof ( ) );
  _Reset_back ( );
  if ( _Pcvt == 0 )
   return ( _Fputc ( _Traits :: to_char_type ( _Meta ), _Myfile )
    ? _Meta : _Traits :: eof ( ) );
  else
   {
   const int _STRING_INC = 8;
   const _Elem _Ch = _Traits :: to_char_type ( _Meta );
   const _Elem * _Src;
   char * _Dest;

   string _Str ( _STRING_INC, '\000' );
   for (;; )
    switch ( _Pcvt -> out ( _State,
     & _Ch, & _Ch + 1, _Src,
     & * _Str . begin ( ), & * _Str . begin ( ) + _Str . size ( ), _Dest ) )
    {
    case codecvt_base :: partial :
    case codecvt_base :: ok :
     {
     size_t _Count = _Dest - & * _Str . begin ( );
     if ( 0 < _Count && _Count !=
      fwrite ( & * _Str . begin ( ), 1, _Count, _Myfile ) )
      return ( _Traits :: eof ( ) );

     _Wrotesome = true;
     if ( _Src != & _Ch )
      return ( _Meta );

     if ( 0 < _Count )
      ;
     else if ( _Str . size ( ) < 4 * _STRING_INC )
      _Str . append ( _STRING_INC, '\000' );
     else
      return ( _Traits :: eof ( ) );
     break;
     }

    case codecvt_base :: noconv :
     return ( _Fputc ( _Ch, _Myfile ) ? _Meta
      : _Traits :: eof ( ) );

    default :
     return ( _Traits :: eof ( ) );
    }
   }
  }

 virtual int_type pbackfail ( int_type _Meta =
  _Traits :: eof ( ) )
  {
  if ( _Mysb :: gptr ( ) != 0
   && _Mysb :: eback ( ) < _Mysb :: gptr ( )
   && ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta )
   || _Traits :: eq_int_type ( _Traits :: to_int_type ( _Mysb :: gptr ( ) [ - 1 ] ),
    _Meta ) ) )
   {
   _Mysb :: _Gndec ( );
   return ( _Traits :: not_eof ( _Meta ) );
   }
  else if ( _Myfile == 0 || _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   return ( _Traits :: eof ( ) );
  else if ( _Pcvt == 0 && _Ungetc ( _Traits :: to_char_type ( _Meta ), _Myfile ) )
   return ( _Meta );
  else if ( _Mysb :: gptr ( ) != & _Mychar )
   {
   _Mychar = _Traits :: to_char_type ( _Meta );
   _Set_back ( );
   return ( _Meta );
   }
  else
   return ( _Traits :: eof ( ) );
  }

 virtual int_type underflow ( )
  {
  int_type _Meta;
  if ( _Mysb :: gptr ( ) != 0
   && _Mysb :: gptr ( ) < _Mysb :: egptr ( ) )
   return ( _Traits :: to_int_type ( * _Mysb :: gptr ( ) ) );
  else if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta = uflow ( ) ) )
   return ( _Meta );
  else
   {
   pbackfail ( _Meta );
   return ( _Meta );
   }
  }

 virtual int_type uflow ( )
  {
  if ( _Mysb :: gptr ( ) != 0
   && _Mysb :: gptr ( ) < _Mysb :: egptr ( ) )
   return ( _Traits :: to_int_type (
    * _Mysb :: _Gninc ( ) ) );
  else if ( _Myfile == 0 )
   return ( _Traits :: eof ( ) );
  _Reset_back ( );
  if ( _Pcvt == 0 )
   {
   _Elem _Ch = 0;
   return ( _Fgetc ( _Ch, _Myfile ) ? _Traits :: to_int_type ( _Ch )
    : _Traits :: eof ( ) );
   }
  else
   {
   string _Str;

   for (;; )
    {
    _Elem _Ch, * _Dest;
    const char * _Src;
    int _Nleft;
    int _Meta = fgetc ( _Myfile );

    if ( _Meta == ( - 1 ) )
     return ( _Traits :: eof ( ) );

    _Str . append ( 1, ( char ) _Meta );
    switch ( _Pcvt -> in ( _State,
     & * _Str . begin ( ), & * _Str . begin ( ) + _Str . size ( ), _Src,
     & _Ch, & _Ch + 1, _Dest ) )
     {
    case codecvt_base :: partial :
    case codecvt_base :: ok :
     if ( _Dest != & _Ch )
      {
      _Nleft = ( int ) ( & * _Str . begin ( ) + _Str . size ( ) - _Src );
      for (; 0 < _Nleft; )
       ungetc ( _Src [ -- _Nleft ], _Myfile );
      return ( _Traits :: to_int_type ( _Ch ) );
      }
     else
      _Str . erase ( ( size_t ) 0,
       ( size_t ) ( _Src - & * _Str . begin ( ) ) );
     break;

    case codecvt_base :: noconv :
     if ( _Str . size ( ) < sizeof ( _Elem ) )
      break;

     :: memcpy_s ( ( & _Ch ), ( sizeof ( _Elem ) ), ( & * _Str . begin ( ) ), ( sizeof ( _Elem ) ) );


     return ( _Traits :: to_int_type ( _Ch ) );

    default :
     return ( _Traits :: eof ( ) );
     }
    }
   }
  }

 virtual pos_type seekoff ( off_type _Off,
  ios_base :: seekdir _Way,
  ios_base :: openmode =
   ( ios_base :: openmode ) ( ios_base :: in | ios_base :: out ) )
  {
  fpos_t _Fileposition;

  if ( _Mysb :: gptr ( ) == & _Mychar
   && _Way == ios_base :: cur
   && _Pcvt == 0 )
   _Off -= ( off_type ) sizeof ( _Elem );

  if ( _Myfile == 0 || ! _Endwrite ( )
   || ( _Off != 0 || _Way != ios_base :: cur )
    && _fseeki64 ( _Myfile, _Off, _Way ) != 0
   || fgetpos ( _Myfile, & _Fileposition ) != 0 )
   return ( pos_type ( _BADOFF ) );

  _Reset_back ( );
  return ( pos_type ( _State, _Fileposition ) );

  }

 virtual pos_type seekpos ( pos_type _Pos,
  ios_base :: openmode =
   ( ios_base :: openmode ) ( ios_base :: in | ios_base :: out ) )
  {
  fpos_t _Fileposition = _Pos . seekpos ( );
  off_type _Off = ( off_type ) _Pos - ( off_type ) ( ( long ) ( _Fileposition ) );

  if ( _Myfile == 0 || ! _Endwrite ( )
   || fsetpos ( _Myfile, & _Fileposition ) != 0
   || _Off != 0 && _fseeki64 ( _Myfile, _Off, 1 ) != 0
   || fgetpos ( _Myfile, & _Fileposition ) != 0 )
   return ( pos_type ( _BADOFF ) );

  _State = _Pos . state ( );

  _Reset_back ( );
  return ( pos_type ( _State, _Fileposition ) );

  }

 virtual _Mysb * setbuf ( _Elem * _Buffer, streamsize _Count )
  {
  if ( _Myfile == 0 || setvbuf ( _Myfile, ( char * ) _Buffer,
   _Buffer == 0 && _Count == 0 ? 4 : 0,
   ( size_t ) _Count * sizeof ( _Elem ) ) != 0 )
   return ( 0 );
  else
   {
   _Init ( _Myfile, _Openfl );
   return ( this );
   }
  }

 virtual int sync ( )
  {
  return ( _Myfile == 0
   || _Traits :: eq_int_type ( _Traits :: eof ( ), overflow ( ) )
   || 0 <= fflush ( _Myfile ) ? 0 : - 1 );
  }

 virtual void imbue ( const locale & _Loc )
  {
  _Initcvt ( & use_facet < _Cvt > ( _Loc ) );
  }

 void _Init ( _iobuf * _File, _Initfl _Which )
  {
   static _Myst _Stinit;

  _Closef = _Which == _Openfl;
  _Wrotesome = false;

  _Mysb :: _Init ( );






  #pragma warning(push)
  #pragma warning(disable: 6240)
  if ( _File != 0 && sizeof ( _Elem ) == 1 )
  #pragma warning(pop)

   {
   _Elem * * _Pb = ( _Elem * * ) & _File -> _base;
   _Elem * * _Pn = ( _Elem * * ) & _File -> _ptr;
   int * _Nr = ( int * ) & _File -> _cnt;
   int * _Nw = ( int * ) & _File -> _cnt;
   _Mysb :: _Init ( _Pb, _Pn, _Nr, _Pb, _Pn, _Nw );
   }

  _Myfile = _File;
  _State = _Stinit;
  _Pcvt = 0;
  }

 bool _Endwrite ( )
  {
  if ( _Pcvt == 0 || ! _Wrotesome )
   return ( true );
  else
   {
   const int _STRING_INC = 8;
   char * _Dest;
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), overflow ( ) ) )
    return ( false );

   string _Str ( _STRING_INC, '\000' );
   for (;; )
    switch ( _Pcvt -> unshift ( _State,
     & * _Str . begin ( ), & * _Str . begin ( ) + _Str . size ( ), _Dest ) )
    {
    case codecvt_base :: ok :
     _Wrotesome = false;

    case codecvt_base :: partial :
     {
     size_t _Count = _Dest - & * _Str . begin ( );
     if ( 0 < _Count && _Count !=
      fwrite ( & * _Str . begin ( ), 1, _Count, _Myfile ) )
      return ( false );
     if ( ! _Wrotesome )
      return ( true );
     if ( _Count == 0 )
      _Str . append ( _STRING_INC, '\000' );
     break;
     }

    case codecvt_base :: noconv :
     return ( true );

    default :
     return ( false );
    }
   }
  }

 void _Initcvt ( const _Cvt * _Newpcvt )
  {
  if ( _Newpcvt -> always_noconv ( ) )
   _Pcvt = 0;
  else
   {
   _Pcvt = _Newpcvt;
   _Mysb :: _Init ( );
   }
  }

private :
 void _Reset_back ( )
  {
  if ( _Mysb :: eback ( ) == & _Mychar )
   _Mysb :: setg ( _Set_eback, _Set_egptr, _Set_egptr );
  }

 void _Set_back ( )
  {
  if ( _Mysb :: eback ( ) != & _Mychar )
   {
   _Set_eback = _Mysb :: eback ( );
   _Set_egptr = _Mysb :: egptr ( );
   }
  _Mysb :: setg ( & _Mychar, & _Mychar, & _Mychar + 1 );
  }

 _Elem * _Set_eback;
 _Elem * _Set_egptr;

 const _Cvt * _Pcvt;
 _Elem _Mychar;
 bool _Wrotesome;
 typename _Traits :: state_type _State;
 bool _Closef;
 _iobuf * _Myfile;
 };
#line 667 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\fstream"
template < class _Elem,
 class _Traits > inline
 void swap ( basic_filebuf < _Elem, _Traits > & _Left,
  basic_filebuf < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 675
template < class _Elem,
 class _Traits > inline
 void swap ( basic_filebuf < _Elem, _Traits > & _Left,
  basic_filebuf < _Elem, _Traits > && _Right )
 {
 typedef basic_filebuf < _Elem, _Traits > _Myt;
 _Left . swap ( :: std :: forward < _Myt > ( _Right ) );
 }
#line 684
template < class _Elem,
 class _Traits > inline
 void swap ( basic_filebuf < _Elem, _Traits > && _Left,
  basic_filebuf < _Elem, _Traits > & _Right )
 {
 typedef basic_filebuf < _Elem, _Traits > _Myt;
 _Right . swap ( :: std :: forward < _Myt > ( _Left ) );
 }
#line 694
template < class _Elem,
 class _Traits >
 class basic_ifstream
  : public basic_istream < _Elem, _Traits >
 {
public :
 typedef basic_ifstream < _Elem, _Traits > _Myt;
 typedef basic_istream < _Elem, _Traits > _Mybase;
 typedef basic_filebuf < _Elem, _Traits > _Myfb;
 typedef basic_ios < _Elem, _Traits > _Myios;

 basic_ifstream ( )
  : _Mybase ( & _Filebuffer )
  {
  }

 explicit basic_ifstream ( const char * _Filename,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: in, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_ifstream ( const string & _Str,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Str . c_str ( ), _Mode | ios_base :: in, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_ifstream ( const wchar_t * _Filename,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: in, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_ifstream ( const wstring & _Str,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Str . c_str ( ), _Mode | ios_base :: in, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }



 explicit basic_ifstream ( const unsigned short * _Filename,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: in, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_ifstream ( _iobuf * _File )
  : _Mybase ( & _Filebuffer ),
   _Filebuffer ( _File )
  {
  }

 basic_ifstream ( _Myt && _Right )
  : _Mybase ( & _Filebuffer )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   _Filebuffer . close ( );
   this -> swap ( _Right );
   }
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Mybase :: swap ( _Right );
   _Filebuffer . swap ( _Right . _Filebuffer );
   }
  }

 void swap ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 void open ( const wchar_t * _Filename,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: in, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }


 void open ( const wstring & _Str,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Str . c_str ( ), _Mode, _Prot );
  }


 void open ( const wchar_t * _Filename, ios_base :: open_mode _Mode )
  {
  open ( _Filename, ( ios_base :: openmode ) _Mode );
  }


 void open ( const unsigned short * _Filename,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: in, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }

 void open ( const unsigned short * _Filename,
  ios_base :: open_mode _Mode )
  {
  open ( _Filename, ( ios_base :: openmode ) _Mode );
  }


 virtual ~ basic_ifstream ( )
  {
  }

 _Myfb * rdbuf ( ) const
  {
  return ( ( _Myfb * ) & _Filebuffer );
  }

 bool is_open ( ) const
  {
  return ( _Filebuffer . is_open ( ) );
  }

 void open ( const char * _Filename,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: in, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }


 void open ( const string & _Str,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Str . c_str ( ), _Mode, _Prot );
  }


 void open ( const char * _Filename, ios_base :: open_mode _Mode )
  {
  open ( _Filename, ( ios_base :: openmode ) _Mode );
  }

 void close ( )
  {
  if ( _Filebuffer . close ( ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }

private :
 _Myfb _Filebuffer;
 };
#line 893 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\fstream"
template < class _Elem,
 class _Traits > inline
 void swap ( basic_ifstream < _Elem, _Traits > & _Left,
  basic_ifstream < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 901
template < class _Elem,
 class _Traits > inline
 void swap ( basic_ifstream < _Elem, _Traits > & _Left,
  basic_ifstream < _Elem, _Traits > && _Right )
 {
 typedef basic_ifstream < _Elem, _Traits > _Myt;
 _Left . swap ( :: std :: forward < _Myt > ( _Right ) );
 }
#line 910
template < class _Elem,
 class _Traits > inline
 void swap ( basic_ifstream < _Elem, _Traits > && _Left,
  basic_ifstream < _Elem, _Traits > & _Right )
 {
 typedef basic_ifstream < _Elem, _Traits > _Myt;
 _Right . swap ( :: std :: forward < _Myt > ( _Left ) );
 }
#line 920
template < class _Elem,
 class _Traits >
 class basic_ofstream
  : public basic_ostream < _Elem, _Traits >
 {
public :
 typedef basic_ofstream < _Elem, _Traits > _Myt;
 typedef basic_ostream < _Elem, _Traits > _Mybase;
 typedef basic_filebuf < _Elem, _Traits > _Myfb;
 typedef basic_ios < _Elem, _Traits > _Myios;

 basic_ofstream ( )
  : _Mybase ( & _Filebuffer )
  {
  }

 explicit basic_ofstream ( const char * _Filename,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: out, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_ofstream ( const string & _Str,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Str . c_str ( ), _Mode | ios_base :: out, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_ofstream ( const wchar_t * _Filename,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: out, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_ofstream ( const wstring & _Str,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Str . c_str ( ), _Mode | ios_base :: out, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }



 explicit basic_ofstream ( const unsigned short * _Filename,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: out, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_ofstream ( _iobuf * _File )
  : _Mybase ( & _Filebuffer ),
   _Filebuffer ( _File )
  {
  }

 basic_ofstream ( _Myt && _Right )
  : _Mybase ( & _Filebuffer )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   _Filebuffer . close ( );
   this -> swap ( _Right );
   }
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Mybase :: swap ( _Right );
   _Filebuffer . swap ( _Right . _Filebuffer );
   }
  }

 void swap ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 void open ( const wchar_t * _Filename,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: out, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }


 void open ( const wstring & _Str,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Str . c_str ( ), _Mode, _Prot );
  }


 void open ( const wchar_t * _Filename, ios_base :: open_mode _Mode )
  {
  open ( _Filename, ( ios_base :: openmode ) _Mode );
  }


 void open ( const unsigned short * _Filename,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: out, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }

 void open ( const unsigned short * _Filename,
  ios_base :: open_mode _Mode )
  {
  open ( _Filename, ( ios_base :: openmode ) _Mode );
  }


 virtual ~ basic_ofstream ( )
  {
  }

 _Myfb * rdbuf ( ) const
  {
  return ( ( _Myfb * ) & _Filebuffer );
  }

 bool is_open ( ) const
  {
  return ( _Filebuffer . is_open ( ) );
  }

 void open ( const char * _Filename,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: out, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }


 void open ( const string & _Str,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Str . c_str ( ), _Mode, _Prot );
  }


 void open ( const char * _Filename, ios_base :: open_mode _Mode )
  {
  open ( _Filename, ( ios_base :: openmode ) _Mode );
  }

 void close ( )
  {
  if ( _Filebuffer . close ( ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }

private :
 _Myfb _Filebuffer;
 };
#line 1119 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\fstream"
template < class _Elem,
 class _Traits > inline
 void swap ( basic_ofstream < _Elem, _Traits > & _Left,
  basic_ofstream < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 1127
template < class _Elem,
 class _Traits > inline
 void swap ( basic_ofstream < _Elem, _Traits > & _Left,
  basic_ofstream < _Elem, _Traits > && _Right )
 {
 typedef basic_ofstream < _Elem, _Traits > _Myt;
 _Left . swap ( :: std :: forward < _Myt > ( _Right ) );
 }
#line 1136
template < class _Elem,
 class _Traits > inline
 void swap ( basic_ofstream < _Elem, _Traits > && _Left,
  basic_ofstream < _Elem, _Traits > & _Right )
 {
 typedef basic_ofstream < _Elem, _Traits > _Myt;
 _Right . swap ( :: std :: forward < _Myt > ( _Left ) );
 }
#line 1146
template < class _Elem,
 class _Traits >
 class basic_fstream
  : public basic_iostream < _Elem, _Traits >
 {
public :
 typedef basic_fstream < _Elem, _Traits > _Myt;
 typedef basic_iostream < _Elem, _Traits > _Mybase;
 typedef basic_filebuf < _Elem, _Traits > _Myfb;
 typedef basic_ios < _Elem, _Traits > _Myios;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 basic_fstream ( )
  : _Mybase ( & _Filebuffer )
  {
  }

 explicit basic_fstream ( const char * _Filename,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_fstream ( const string & _Str,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Str . c_str ( ), _Mode, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_fstream ( const wchar_t * _Filename,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_fstream ( const wstring & _Str,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Str . c_str ( ), _Mode, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }



 explicit basic_fstream ( const unsigned short * _Filename,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_fstream ( _iobuf * _File )
  : _Mybase ( & _Filebuffer ),
   _Filebuffer ( _File )
  {
  }

 basic_fstream ( _Myt && _Right )
  : _Mybase ( & _Filebuffer )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   _Filebuffer . close ( );
   this -> swap ( _Right );
   }
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Mybase :: swap ( _Right );
   _Filebuffer . swap ( _Right . _Filebuffer );
   }
  }

 void swap ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 void open ( const wchar_t * _Filename,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }


 void open ( const wstring & _Str,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Str . c_str ( ), _Mode, _Prot );
  }


 void open ( const wchar_t * _Filename, ios_base :: open_mode _Mode )
  {
  open ( _Filename, ( ios_base :: openmode ) _Mode );
  }


 void open ( const unsigned short * _Filename,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }

 void open ( const unsigned short * _Filename,
  ios_base :: open_mode _Mode )
  {
  open ( _Filename, ( ios_base :: openmode ) _Mode );
  }


 virtual ~ basic_fstream ( )
  {
  }

 _Myfb * rdbuf ( ) const
  {
  return ( ( _Myfb * ) & _Filebuffer );
  }

 bool is_open ( ) const
  {
  return ( _Filebuffer . is_open ( ) );
  }

 void open ( const char * _Filename,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }


 void open ( const string & _Str,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Str . c_str ( ), _Mode, _Prot );
  }


 void open ( const char * _Filename, ios_base :: open_mode _Mode )
  {
  open ( _Filename, ( ios_base :: openmode ) _Mode );
  }

 void close ( )
  {
  if ( _Filebuffer . close ( ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }

private :
 _Myfb _Filebuffer;
 };
#line 1350 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\fstream"
template < class _Elem,
 class _Traits > inline
 void swap ( basic_fstream < _Elem, _Traits > & _Left,
  basic_fstream < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 1358
template < class _Elem,
 class _Traits > inline
 void swap ( basic_fstream < _Elem, _Traits > & _Left,
  basic_fstream < _Elem, _Traits > && _Right )
 {
 typedef basic_fstream < _Elem, _Traits > _Myt;
 _Left . swap ( :: std :: forward < _Myt > ( _Right ) );
 }
#line 1367
template < class _Elem,
 class _Traits > inline
 void swap ( basic_fstream < _Elem, _Traits > && _Left,
  basic_fstream < _Elem, _Traits > & _Right )
 {
 typedef basic_fstream < _Elem, _Traits > _Myt;
 _Right . swap ( :: std :: forward < _Myt > ( _Left ) );
 }
#line 1375
}
#line 1377
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xfunctional"
#pragma warning(push,3)
#line 12
#pragma warning(disable: 4100 4180 4244)
#line 1378 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\fstream"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xfunctional"
#pragma pack ( push, 8 )
#line 18
namespace std { 
#line 20
template < class _Ty >
 struct plus
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left + _Right );
  }
 };
#line 31
template < class _Ty >
 struct minus
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left - _Right );
  }
 };
#line 42
template < class _Ty >
 struct multiplies
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left * _Right );
  }
 };
#line 53
template < class _Ty >
 struct divides
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left / _Right );
  }
 };
#line 64
template < class _Ty >
 struct modulus
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left % _Right );
  }
 };
#line 75
template < class _Ty >
 struct negate
  : public unary_function < _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left ) const
  {
  return ( - _Left );
  }
 };
#line 86
template < class _Ty >
 struct equal_to
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left == _Right );
  }
 };
#line 97
template < class _Ty >
 struct not_equal_to
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left != _Right );
  }
 };
#line 108
template < class _Ty >
 struct greater
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left > _Right );
  }
 };
#line 119
template < class _Ty >
 struct less
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left < _Right );
  }
 };
#line 130
template < class _Ty >
 struct greater_equal
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left >= _Right );
  }
 };
#line 141
template < class _Ty >
 struct less_equal
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left <= _Right );
  }
 };
#line 152
template < class _Ty >
 struct logical_and
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left && _Right );
  }
 };
#line 163
template < class _Ty >
 struct logical_or
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left || _Right );
  }
 };
#line 174
template < class _Ty >
 struct logical_not
  : public unary_function < _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left ) const
  {
  return ( ! _Left );
  }
 };
#line 186
template < class _Ty >
 struct bit_and
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left & _Right );
  }
 };
#line 197
template < class _Ty >
 struct bit_or
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left | _Right );
  }
 };
#line 208
template < class _Ty >
 struct bit_xor
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left ^ _Right );
  }
 };
#line 220 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xfunctional"
template < class _Fn1 >
 class unary_negate
 : public unary_function < typename _Fn1 :: argument_type, bool >
 {
public :
 explicit unary_negate ( const _Fn1 & _Func )
  : _Functor ( _Func )
  {
  }

 bool operator ( ) ( const typename _Fn1 :: argument_type & _Left ) const
  {
  return ( ! _Functor ( _Left ) );
  }

protected :
 _Fn1 _Functor;
 };
#line 240
template < class _Fn1 > inline
 unary_negate < _Fn1 > not1 ( const _Fn1 & _Func )
 {
 return ( :: std :: unary_negate < _Fn1 > ( _Func ) );
 }
#line 247
template < class _Fn2 >
 class binary_negate
  : public binary_function < typename _Fn2 :: first_argument_type,
   typename _Fn2 :: second_argument_type, bool >
 {
public :
 explicit binary_negate ( const _Fn2 & _Func )
  : _Functor ( _Func )
  {
  }

 bool operator ( ) ( const typename _Fn2 :: first_argument_type & _Left,
  const typename _Fn2 :: second_argument_type & _Right ) const
  {
  return ( ! _Functor ( _Left, _Right ) );
  }

protected :
 _Fn2 _Functor;
 };
#line 269
template < class _Fn2 > inline
 binary_negate < _Fn2 > not2 ( const _Fn2 & _Func )
 {
 return ( :: std :: binary_negate < _Fn2 > ( _Func ) );
 }
#line 276
template < class _Fn2 >
 class binder1st
  : public unary_function < typename _Fn2 :: second_argument_type,
   typename _Fn2 :: result_type >
 {
public :
 typedef unary_function < typename _Fn2 :: second_argument_type,
  typename _Fn2 :: result_type > _Base;
 typedef typename _Base :: argument_type argument_type;
 typedef typename _Base :: result_type result_type;

 binder1st ( const _Fn2 & _Func,
  const typename _Fn2 :: first_argument_type & _Left )
  : op ( _Func ), value ( _Left )
  {
  }

 result_type operator ( ) ( const argument_type & _Right ) const
  {
  return ( op ( value, _Right ) );
  }

 result_type operator ( ) ( argument_type & _Right ) const
  {
  return ( op ( value, _Right ) );
  }

protected :
 _Fn2 op;
 typename _Fn2 :: first_argument_type value;
 };
#line 309
template < class _Fn2,
 class _Ty > inline
 binder1st < _Fn2 > bind1st ( const _Fn2 & _Func, const _Ty & _Left )
  {
  typename _Fn2 :: first_argument_type _Val ( _Left );
  return ( :: std :: binder1st < _Fn2 > ( _Func, _Val ) );
  }
#line 318
template < class _Fn2 >
 class binder2nd
  : public unary_function < typename _Fn2 :: first_argument_type,
   typename _Fn2 :: result_type >
 {
public :
 typedef unary_function < typename _Fn2 :: first_argument_type,
  typename _Fn2 :: result_type > _Base;
 typedef typename _Base :: argument_type argument_type;
 typedef typename _Base :: result_type result_type;

 binder2nd ( const _Fn2 & _Func,
  const typename _Fn2 :: second_argument_type & _Right )
  : op ( _Func ), value ( _Right )
  {
  }

 result_type operator ( ) ( const argument_type & _Left ) const
  {
  return ( op ( _Left, value ) );
  }

 result_type operator ( ) ( argument_type & _Left ) const
  {
  return ( op ( _Left, value ) );
  }

protected :
 _Fn2 op;
 typename _Fn2 :: second_argument_type value;
 };
#line 351
template < class _Fn2,
 class _Ty > inline
 binder2nd < _Fn2 > bind2nd ( const _Fn2 & _Func, const _Ty & _Right )
 {
 typename _Fn2 :: second_argument_type _Val ( _Right );
 return ( :: std :: binder2nd < _Fn2 > ( _Func, _Val ) );
 }
#line 360
template < class _Arg,
 class _Result,
 class _Fn = _Result ( * ) ( _Arg ) >
 class pointer_to_unary_function
  : public unary_function < _Arg, _Result >
 {
public :
 explicit pointer_to_unary_function ( _Fn _Left )
  : _Pfun ( _Left )
  {
  }

 _Result operator ( ) ( _Arg _Left ) const
  {
  return ( _Pfun ( _Left ) );
  }

protected :
 _Fn _Pfun;
 };
#line 382
template < class _Arg1,
 class _Arg2,
 class _Result,
 class _Fn = _Result ( * ) ( _Arg1, _Arg2 ) >
 class pointer_to_binary_function
  : public binary_function < _Arg1, _Arg2, _Result >
 {
public :
 explicit pointer_to_binary_function ( _Fn _Left )
  : _Pfun ( _Left )
  {
  }

 _Result operator ( ) ( _Arg1 _Left, _Arg2 _Right ) const
  {
  return ( _Pfun ( _Left, _Right ) );
  }

protected :
 _Fn _Pfun;
 };
#line 405
template < class _Arg,
 class _Result > inline
 pointer_to_unary_function < _Arg, _Result,
  _Result ( __cdecl * ) ( _Arg ) >
  ptr_fun ( _Result ( __cdecl * _Left ) ( _Arg ) )
 {
 return ( pointer_to_unary_function < _Arg, _Result,
  _Result ( __cdecl * ) ( _Arg ) > ( _Left ) );
 }
#line 452
template < class _Arg1,
 class _Arg2,
 class _Result > inline
 pointer_to_binary_function < _Arg1, _Arg2, _Result,
  _Result ( __cdecl * ) ( _Arg1, _Arg2 ) >
  ptr_fun ( _Result ( __cdecl * _Left ) ( _Arg1, _Arg2 ) )
 {
 return ( pointer_to_binary_function < _Arg1, _Arg2, _Result,
  _Result ( __cdecl * ) ( _Arg1, _Arg2 ) > ( _Left ) );
 }
#line 504
template < class _Result,
 class _Ty >
 class mem_fun_t
  : public unary_function < _Ty *, _Result >
 {
public :
 explicit mem_fun_t ( _Result ( _Ty :: * _Pm ) ( ) )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( _Ty * _Pleft ) const
  {
  return ( ( _Pleft ->* _Pmemfun ) ( ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( );
 };
#line 525
template < class _Result,
 class _Ty,
 class _Arg >
 class mem_fun1_t
  : public binary_function < _Ty *, _Arg, _Result >
 {
public :
 explicit mem_fun1_t ( _Result ( _Ty :: * _Pm ) ( _Arg ) )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( _Ty * _Pleft, _Arg _Right ) const
  {
  return ( ( _Pleft ->* _Pmemfun ) ( _Right ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( _Arg );
 };
#line 547
template < class _Result,
 class _Ty >
 class const_mem_fun_t
  : public unary_function < const _Ty *, _Result >
 {
public :
 explicit const_mem_fun_t ( _Result ( _Ty :: * _Pm ) ( ) const )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( const _Ty * _Pleft ) const
  {
  return ( ( _Pleft ->* _Pmemfun ) ( ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( ) const;
 };
#line 568
template < class _Result,
 class _Ty,
 class _Arg >
 class const_mem_fun1_t
  : public binary_function < const _Ty *, _Arg, _Result >
 {
public :
 explicit const_mem_fun1_t ( _Result ( _Ty :: * _Pm ) ( _Arg ) const )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( const _Ty * _Pleft, _Arg _Right ) const
  {
  return ( ( _Pleft ->* _Pmemfun ) ( _Right ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( _Arg ) const;
 };
#line 590
template < class _Result,
 class _Ty > inline
 mem_fun_t < _Result, _Ty > mem_fun ( _Result ( _Ty :: * _Pm ) ( ) )
 {
 return ( mem_fun_t < _Result, _Ty > ( _Pm ) );
 }
#line 597
template < class _Result,
 class _Ty,
 class _Arg > inline
 mem_fun1_t < _Result, _Ty, _Arg > mem_fun ( _Result ( _Ty :: * _Pm ) ( _Arg ) )
 {
 return ( mem_fun1_t < _Result, _Ty, _Arg > ( _Pm ) );
 }
#line 605
template < class _Result,
 class _Ty > inline
 const_mem_fun_t < _Result, _Ty >
  mem_fun ( _Result ( _Ty :: * _Pm ) ( ) const )
 {
 return ( const_mem_fun_t < _Result, _Ty > ( _Pm ) );
 }
#line 613
template < class _Result,
 class _Ty,
 class _Arg > inline
 const_mem_fun1_t < _Result, _Ty, _Arg >
  mem_fun ( _Result ( _Ty :: * _Pm ) ( _Arg ) const )
 {
 return ( const_mem_fun1_t < _Result, _Ty, _Arg > ( _Pm ) );
 }
#line 623
template < class _Result,
 class _Ty,
 class _Arg > inline
 mem_fun1_t < _Result, _Ty, _Arg > mem_fun1 ( _Result ( _Ty :: * _Pm ) ( _Arg ) )
 {
 return ( mem_fun1_t < _Result, _Ty, _Arg > ( _Pm ) );
 }
#line 632
template < class _Result,
 class _Ty >
 class mem_fun_ref_t
  : public unary_function < _Ty, _Result >
 {
public :
 explicit mem_fun_ref_t ( _Result ( _Ty :: * _Pm ) ( ) )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( _Ty & _Left ) const
  {
  return ( ( _Left .* _Pmemfun ) ( ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( );
 };
#line 653
template < class _Result,
 class _Ty,
 class _Arg >
 class mem_fun1_ref_t
  : public binary_function < _Ty, _Arg, _Result >
 {
public :
 explicit mem_fun1_ref_t ( _Result ( _Ty :: * _Pm ) ( _Arg ) )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( _Ty & _Left, _Arg _Right ) const
  {
  return ( ( _Left .* _Pmemfun ) ( _Right ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( _Arg );
 };
#line 675
template < class _Result,
 class _Ty >
 class const_mem_fun_ref_t
  : public unary_function < _Ty, _Result >
 {
public :
 explicit const_mem_fun_ref_t ( _Result ( _Ty :: * _Pm ) ( ) const )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( const _Ty & _Left ) const
  {
  return ( ( _Left .* _Pmemfun ) ( ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( ) const;
 };
#line 696
template < class _Result,
 class _Ty,
 class _Arg >
 class const_mem_fun1_ref_t
  : public binary_function < _Ty, _Arg, _Result >
 {
public :
 explicit const_mem_fun1_ref_t ( _Result ( _Ty :: * _Pm ) ( _Arg ) const )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( const _Ty & _Left, _Arg _Right ) const
  {
  return ( ( _Left .* _Pmemfun ) ( _Right ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( _Arg ) const;
 };
#line 718
template < class _Result,
 class _Ty > inline
 mem_fun_ref_t < _Result, _Ty > mem_fun_ref ( _Result ( _Ty :: * _Pm ) ( ) )
 {
 return ( mem_fun_ref_t < _Result, _Ty > ( _Pm ) );
 }
#line 725
template < class _Result,
 class _Ty,
 class _Arg > inline
 mem_fun1_ref_t < _Result, _Ty, _Arg >
  mem_fun_ref ( _Result ( _Ty :: * _Pm ) ( _Arg ) )
 {
 return ( mem_fun1_ref_t < _Result, _Ty, _Arg > ( _Pm ) );
 }
#line 734
template < class _Result,
 class _Ty > inline
 const_mem_fun_ref_t < _Result, _Ty >
  mem_fun_ref ( _Result ( _Ty :: * _Pm ) ( ) const )
 {
 return ( const_mem_fun_ref_t < _Result, _Ty > ( _Pm ) );
 }
#line 742
template < class _Result,
 class _Ty,
 class _Arg > inline
 const_mem_fun1_ref_t < _Result, _Ty, _Arg >
  mem_fun_ref ( _Result ( _Ty :: * _Pm ) ( _Arg ) const )
 {
 return ( const_mem_fun1_ref_t < _Result, _Ty, _Arg > ( _Pm ) );
 }
#line 752
template < class _Result,
 class _Ty,
 class _Arg > inline
 mem_fun1_ref_t < _Result, _Ty, _Arg > mem_fun1_ref ( _Result ( _Ty :: * _Pm ) ( _Arg ) )
 {
 return ( mem_fun1_ref_t < _Result, _Ty, _Arg > ( _Pm ) );
 }
#line 761
template < class _Kty >
 class hash
  : public unary_function < _Kty, size_t >
 {
public :
 size_t operator ( ) ( const _Kty & _Keyval ) const
  {
  ldiv_t _Qrem = :: ldiv ( ( long ) ( size_t ) _Keyval, 127773 );

  _Qrem . rem = 16807 * _Qrem . rem - 2836 * _Qrem . quot;
  if ( _Qrem . rem < 0 )
   _Qrem . rem += 2147483647;
  return ( ( size_t ) _Qrem . rem );
  }
 };
#line 778
#pragma pack(8)
template<> 
#line 778
class hash< unsigned __int64>  : public unary_function< unsigned __int64, unsigned __int64>  { 
#line 782
public: typedef _ULonglong _Kty; 
#line 783
typedef _Uint32t _Inttype; 
#line 785
size_t operator()(const _Kty &_Keyval) const 
#line 786
{ 
#line 787
return std::hash< unsigned long> ()((_Inttype)(_Keyval & (4294967295UL))) ^ std::hash< unsigned long> ()((_Inttype)(_Keyval >> 32)); 
#line 789
} 
#line 790
}; 
#pragma pack()
#line 793
#pragma pack(8)
template<> 
#line 793
class hash< __int64>  : public unary_function< __int64, unsigned __int64>  { 
#line 797
public: typedef _Longlong _Kty; 
#line 798
typedef _Uint32t _Inttype; 
#line 800
size_t operator()(const _Kty &_Keyval) const 
#line 801
{ 
#line 802
return std::hash< unsigned __int64> ()((_ULonglong)_Keyval); 
#line 803
} 
#line 804
}; 
#pragma pack()
template < class _Ty >
 class hash < _Ty * >
  : public unary_function < _Ty *, size_t >
 {
public :
 typedef _Ty * _Kty;
 typedef _Uint32t _Inttype;

 size_t operator ( ) ( _Kty _Keyval ) const
  {
  typedef typename :: std :: _If < sizeof ( _Ty * ) <= sizeof ( _Inttype ),
   _Inttype, _ULonglong > :: _Type _Integer;
  return ( hash < _Integer > ( ) ( ( _Integer ) _Keyval ) );
  }
 };
#line 823
template<> class hash< float>  : public unary_function< float, unsigned __int64>  { 
#line 827
public: typedef float _Kty; 
#line 828
typedef _Uint32t _Inttype; 
#line 830
size_t operator()(const _Kty &_Keyval) const 
#line 831
{ 
#line 832
_Inttype _Bits = *((_Inttype *)(&_Keyval)); 
#line 833
return std::hash< unsigned long> ()((_Bits == (2147483648U)) ? (0) : _Bits); 
#line 834
} 
#line 835
}; 
#line 838
template<> class hash< double>  : public unary_function< double, unsigned __int64>  { 
#line 842
public: typedef double _Kty; 
#line 843
typedef _ULonglong _Inttype; 
#line 845
size_t operator()(const _Kty &_Keyval) const 
#line 846
{ 
#line 847
_Inttype _Bits = *((_Inttype *)(&_Keyval)); 
#line 848
return std::hash< unsigned __int64> ()(((_Bits & (18446744073709551615Ui64 >> 1)) == (0)) ? (0) : _Bits); 
#line 850
} 
#line 851
}; 
#line 854
template<> class hash< long double>  : public unary_function< long double, unsigned __int64>  { 
#line 858
public: typedef long double _Kty; 
#line 859
typedef _ULonglong _Inttype; 
#line 861
size_t operator()(const _Kty &_Keyval) const 
#line 862
{ 
#line 863
_Inttype _Bits = *((_Inttype *)(&_Keyval)); 
#line 864
return std::hash< unsigned __int64> ()(((_Bits & (18446744073709551615Ui64 >> 1)) == (0)) ? (0) : _Bits); 
#line 866
} 
#line 867
}; 
#line 870
template<> class hash< basic_string< char, char_traits< char> , allocator< char> > >  : public unary_function< basic_string< char, char_traits< char> , allocator< char> > , unsigned __int64>  { 
#line 874
public: typedef string _Kty; 
#line 876
size_t operator()(const _Kty &_Keyval) const 
#line 877
{ 
#line 878
size_t _Val = (2166136261U); 
#line 879
size_t _First = (0); 
#line 880
size_t _Last = _Keyval.size(); 
#line 881
size_t _Stride = (1) + (_Last / (10)); 
#line 883
for (; _First < _Last; _First += _Stride) { 
#line 884
_Val = (((16777619U) * _Val) ^ ((size_t)_Keyval[_First])); }  
#line 885
return _Val; 
#line 886
} 
#line 887
}; 
#line 890
template<> class hash< basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > >  : public unary_function< basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > , unsigned __int64>  { 
#line 894
public: typedef wstring _Kty; 
#line 896
size_t operator()(const _Kty &_Keyval) const 
#line 897
{ 
#line 898
size_t _Val = (2166136261U); 
#line 899
size_t _First = (0); 
#line 900
size_t _Last = _Keyval.size(); 
#line 901
size_t _Stride = (1) + (_Last / (10)); 
#line 903
for (; _First < _Last; _First += _Stride) { 
#line 904
_Val = (((16777619U) * _Val) ^ ((size_t)_Keyval[_First])); }  
#line 905
return _Val; 
#line 906
} 
#line 907
}; 
#line 909
namespace tr1 { 
#line 910
using std::hash;
#line 911
}
#line 912
}
#line 914
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\functional"
#pragma warning(push,3)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xrefwrap"
#pragma warning(push,3)
#line 11
#pragma warning(disable: 4180)
#line 915 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xfunctional"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\functional"
#pragma pack ( push, 8 )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xrefwrap"
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 14
namespace tr1 { 
#line 18
template< class _Ty> struct _Result_of; 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< bool __T3, class 
#line 9
_Fty> struct _Result_type0; 
#line 13
template< class _Fty> 
#line 15
struct _Result_type0< true, _Fty>  { 
#line 17
typedef typename _Fty::result_type _Type; 
#line 18
}; 
#line 20
template< class _Fty> 
#line 22
struct _Result_type0< false, _Fty>  { 
#line 25
typedef void _Type; 
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
}; 
#line 33
template< class _Fty> 
#line 35
struct _Result_of0 { 
#line 37
static const bool _Value = (sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2])); 
#line 40
typedef typename _Result_type0< sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2]), _Fty> ::_Type _Type; 
#line 41
}; 
#line 44
template< class _Ret> 
#line 47
struct _Result_of0< _Ret (__cdecl &)(void)>  { 
#line 49
typedef _Ret _Type; 
#line 50
}; 
#line 52
template< class _Ret> 
#line 55
struct _Result_of0< _Ret (__cdecl *)(void)>  { 
#line 57
typedef _Ret _Type; 
#line 58
}; 
#line 60
template< class _Ret> 
#line 63
struct _Result_of0< _Ret (__cdecl *const)(void)>  { 
#line 65
typedef _Ret _Type; 
#line 66
}; 
#line 593 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Fty> 
#line 595
struct _Result_of< _Fty __cdecl (void)>  { 
#line 597
typedef typename _Result_of0< _Fty> ::_Type _Type; 
#line 598
}; 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< bool __T4, class 
#line 9
_Fty, class 
#line 10
_Arg0> struct _Result_type1; 
#line 13
template< class _Fty, class 
#line 14
_Arg0> 
#line 15
struct _Result_type1< true, _Fty, _Arg0>  { 
#line 17
typedef typename _Fty::result_type _Type; 
#line 18
}; 
#line 20
template< class _Fty, class 
#line 21
_Arg0> 
#line 22
struct _Result_type1< false, _Fty, _Arg0>  { 
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0)> ::type _Type; 
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
}; 
#line 33
template< class _Fty, class 
#line 34
_Farg0> 
#line 35
struct _Result_of1 { 
#line 37
static const bool _Value = (sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2])); 
#line 40
typedef typename _Result_type1< sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2]), _Fty, _Farg0> ::_Type _Type; 
#line 41
}; 
#line 44
template< class _Ret, class 
#line 45
_Arg0, class 
#line 46
_Farg0> 
#line 47
struct _Result_of1< _Ret (__cdecl &)(_Arg0), _Farg0>  { 
#line 49
typedef _Ret _Type; 
#line 50
}; 
#line 52
template< class _Ret, class 
#line 53
_Arg0, class 
#line 54
_Farg0> 
#line 55
struct _Result_of1< _Ret (__cdecl *)(_Arg0), _Farg0>  { 
#line 57
typedef _Ret _Type; 
#line 58
}; 
#line 60
template< class _Ret, class 
#line 61
_Arg0, class 
#line 62
_Farg0> 
#line 63
struct _Result_of1< _Ret (__cdecl *const)(_Arg0), _Farg0>  { 
#line 65
typedef _Ret _Type; 
#line 66
}; 
#line 148
template< class _Rx, class 
#line 149
_Arg0, class 
#line 150
_Farg0> 
#line 151
struct _Result_of1< _Rx _Arg0::*, _Farg0>  { 
#line 153
typedef typename _Copy_cv< _Rx, _Farg0> ::_Type _Type; 
#line 154
}; 
#line 156
template< class _Rx, class 
#line 157
_Arg0, class 
#line 158
_Farg0> 
#line 159
struct _Result_of1< _Rx _Arg0::*const, _Farg0>  { 
#line 161
typedef typename _Copy_cv< _Rx, _Farg0> ::_Type _Type; 
#line 162
}; 
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Rx, class 
#line 168
_Arg0, class 
#line 169
_Farg0> 
#line 170
struct _Result_of1< _Rx (__thiscall _Arg0::*)(void), _Farg0 &>  { 
#line 173
typedef _Rx _Type; 
#line 174
}; 
#line 220
template< class _Rx, class 
#line 221
_Arg0, class 
#line 222
_Farg0> 
#line 223
struct _Result_of1< _Rx (__thiscall _Arg0::*)(void) const, _Farg0 &>  { 
#line 226
typedef _Rx _Type; 
#line 227
}; 
#line 273
template< class _Rx, class 
#line 274
_Arg0, class 
#line 275
_Farg0> 
#line 276
struct _Result_of1< _Rx (__thiscall _Arg0::*)(void) volatile, _Farg0 &>  { 
#line 279
typedef _Rx _Type; 
#line 280
}; 
#line 326
template< class _Rx, class 
#line 327
_Arg0, class 
#line 328
_Farg0> 
#line 329
struct _Result_of1< _Rx (__thiscall _Arg0::*)(void) const volatile, _Farg0 &>  { 
#line 332
typedef _Rx _Type; 
#line 333
}; 
#line 379
template< class _Rx, class 
#line 380
_Arg0, class 
#line 381
_Farg0> 
#line 382
struct _Result_of1< _Rx (__thiscall _Arg0::*const)(void), _Farg0 &>  { 
#line 385
typedef _Rx _Type; 
#line 386
}; 
#line 432
template< class _Rx, class 
#line 433
_Arg0, class 
#line 434
_Farg0> 
#line 435
struct _Result_of1< _Rx (__thiscall _Arg0::*const)(void) const, _Farg0 &>  { 
#line 438
typedef _Rx _Type; 
#line 439
}; 
#line 485
template< class _Rx, class 
#line 486
_Arg0, class 
#line 487
_Farg0> 
#line 488
struct _Result_of1< _Rx (__thiscall _Arg0::*const)(void) volatile, _Farg0 &>  { 
#line 491
typedef _Rx _Type; 
#line 492
}; 
#line 538
template< class _Rx, class 
#line 539
_Arg0, class 
#line 540
_Farg0> 
#line 541
struct _Result_of1< _Rx (__thiscall _Arg0::*const)(void) const volatile, _Farg0 &>  { 
#line 544
typedef _Rx _Type; 
#line 545
}; 
#line 593 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Fty, class 
#line 594
_Arg0> 
#line 595
struct _Result_of< _Fty __cdecl (_Arg0)>  { 
#line 597
typedef typename _Result_of1< _Fty, typename _Remove_reference< _Arg0> ::_Type &> ::_Type _Type; 
#line 598
}; 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< bool __T5, class 
#line 9
_Fty, class 
#line 10
_Arg0, class _Arg1> struct _Result_type2; 
#line 13
template< class _Fty, class 
#line 14
_Arg0, class _Arg1> 
#line 15
struct _Result_type2< true, _Fty, _Arg0, _Arg1>  { 
#line 17
typedef typename _Fty::result_type _Type; 
#line 18
}; 
#line 20
template< class _Fty, class 
#line 21
_Arg0, class _Arg1> 
#line 22
struct _Result_type2< false, _Fty, _Arg0, _Arg1>  { 
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1)> ::type _Type; 
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
}; 
#line 33
template< class _Fty, class 
#line 34
_Farg0, class _Farg1> 
#line 35
struct _Result_of2 { 
#line 37
static const bool _Value = (sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2])); 
#line 40
typedef typename _Result_type2< sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2]), _Fty, _Farg0, _Farg1> ::_Type _Type; 
#line 41
}; 
#line 44
template< class _Ret, class 
#line 45
_Arg0, class _Arg1, class 
#line 46
_Farg0, class _Farg1> 
#line 47
struct _Result_of2< _Ret (__cdecl &)(_Arg0, _Arg1), _Farg0, _Farg1>  { 
#line 49
typedef _Ret _Type; 
#line 50
}; 
#line 52
template< class _Ret, class 
#line 53
_Arg0, class _Arg1, class 
#line 54
_Farg0, class _Farg1> 
#line 55
struct _Result_of2< _Ret (__cdecl *)(_Arg0, _Arg1), _Farg0, _Farg1>  { 
#line 57
typedef _Ret _Type; 
#line 58
}; 
#line 60
template< class _Ret, class 
#line 61
_Arg0, class _Arg1, class 
#line 62
_Farg0, class _Farg1> 
#line 63
struct _Result_of2< _Ret (__cdecl *const)(_Arg0, _Arg1), _Farg0, _Farg1>  { 
#line 65
typedef _Ret _Type; 
#line 66
}; 
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Rx, class 
#line 168
_Arg0, class _Arg1, class 
#line 169
_Farg0, class _Farg1> 
#line 170
struct _Result_of2< _Rx (__thiscall _Arg0::*)(_Arg1), _Farg0 &, _Farg1>  { 
#line 173
typedef _Rx _Type; 
#line 174
}; 
#line 220
template< class _Rx, class 
#line 221
_Arg0, class _Arg1, class 
#line 222
_Farg0, class _Farg1> 
#line 223
struct _Result_of2< _Rx (__thiscall _Arg0::*)(_Arg1) const, _Farg0 &, _Farg1>  { 
#line 226
typedef _Rx _Type; 
#line 227
}; 
#line 273
template< class _Rx, class 
#line 274
_Arg0, class _Arg1, class 
#line 275
_Farg0, class _Farg1> 
#line 276
struct _Result_of2< _Rx (__thiscall _Arg0::*)(_Arg1) volatile, _Farg0 &, _Farg1>  { 
#line 279
typedef _Rx _Type; 
#line 280
}; 
#line 326
template< class _Rx, class 
#line 327
_Arg0, class _Arg1, class 
#line 328
_Farg0, class _Farg1> 
#line 329
struct _Result_of2< _Rx (__thiscall _Arg0::*)(_Arg1) const volatile, _Farg0 &, _Farg1>  { 
#line 332
typedef _Rx _Type; 
#line 333
}; 
#line 379
template< class _Rx, class 
#line 380
_Arg0, class _Arg1, class 
#line 381
_Farg0, class _Farg1> 
#line 382
struct _Result_of2< _Rx (__thiscall _Arg0::*const)(_Arg1), _Farg0 &, _Farg1>  { 
#line 385
typedef _Rx _Type; 
#line 386
}; 
#line 432
template< class _Rx, class 
#line 433
_Arg0, class _Arg1, class 
#line 434
_Farg0, class _Farg1> 
#line 435
struct _Result_of2< _Rx (__thiscall _Arg0::*const)(_Arg1) const, _Farg0 &, _Farg1>  { 
#line 438
typedef _Rx _Type; 
#line 439
}; 
#line 485
template< class _Rx, class 
#line 486
_Arg0, class _Arg1, class 
#line 487
_Farg0, class _Farg1> 
#line 488
struct _Result_of2< _Rx (__thiscall _Arg0::*const)(_Arg1) volatile, _Farg0 &, _Farg1>  { 
#line 491
typedef _Rx _Type; 
#line 492
}; 
#line 538
template< class _Rx, class 
#line 539
_Arg0, class _Arg1, class 
#line 540
_Farg0, class _Farg1> 
#line 541
struct _Result_of2< _Rx (__thiscall _Arg0::*const)(_Arg1) const volatile, _Farg0 &, _Farg1>  { 
#line 544
typedef _Rx _Type; 
#line 545
}; 
#line 593 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Fty, class 
#line 594
_Arg0, class _Arg1> 
#line 595
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1)>  { 
#line 597
typedef typename _Result_of2< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &> ::_Type _Type; 
#line 598
}; 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< bool __T6, class 
#line 9
_Fty, class 
#line 10
_Arg0, class _Arg1, class _Arg2> struct _Result_type3; 
#line 13
template< class _Fty, class 
#line 14
_Arg0, class _Arg1, class _Arg2> 
#line 15
struct _Result_type3< true, _Fty, _Arg0, _Arg1, _Arg2>  { 
#line 17
typedef typename _Fty::result_type _Type; 
#line 18
}; 
#line 20
template< class _Fty, class 
#line 21
_Arg0, class _Arg1, class _Arg2> 
#line 22
struct _Result_type3< false, _Fty, _Arg0, _Arg1, _Arg2>  { 
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2)> ::type _Type; 
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
}; 
#line 33
template< class _Fty, class 
#line 34
_Farg0, class _Farg1, class _Farg2> 
#line 35
struct _Result_of3 { 
#line 37
static const bool _Value = (sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2])); 
#line 40
typedef typename _Result_type3< sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2]), _Fty, _Farg0, _Farg1, _Farg2> ::_Type _Type; 
#line 41
}; 
#line 44
template< class _Ret, class 
#line 45
_Arg0, class _Arg1, class _Arg2, class 
#line 46
_Farg0, class _Farg1, class _Farg2> 
#line 47
struct _Result_of3< _Ret (__cdecl &)(_Arg0, _Arg1, _Arg2), _Farg0, _Farg1, _Farg2>  { 
#line 49
typedef _Ret _Type; 
#line 50
}; 
#line 52
template< class _Ret, class 
#line 53
_Arg0, class _Arg1, class _Arg2, class 
#line 54
_Farg0, class _Farg1, class _Farg2> 
#line 55
struct _Result_of3< _Ret (__cdecl *)(_Arg0, _Arg1, _Arg2), _Farg0, _Farg1, _Farg2>  { 
#line 57
typedef _Ret _Type; 
#line 58
}; 
#line 60
template< class _Ret, class 
#line 61
_Arg0, class _Arg1, class _Arg2, class 
#line 62
_Farg0, class _Farg1, class _Farg2> 
#line 63
struct _Result_of3< _Ret (__cdecl *const)(_Arg0, _Arg1, _Arg2), _Farg0, _Farg1, _Farg2>  { 
#line 65
typedef _Ret _Type; 
#line 66
}; 
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Rx, class 
#line 168
_Arg0, class _Arg1, class _Arg2, class 
#line 169
_Farg0, class _Farg1, class _Farg2> 
#line 170
struct _Result_of3< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2), _Farg0 &, _Farg1, _Farg2>  { 
#line 173
typedef _Rx _Type; 
#line 174
}; 
#line 220
template< class _Rx, class 
#line 221
_Arg0, class _Arg1, class _Arg2, class 
#line 222
_Farg0, class _Farg1, class _Farg2> 
#line 223
struct _Result_of3< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2) const, _Farg0 &, _Farg1, _Farg2>  { 
#line 226
typedef _Rx _Type; 
#line 227
}; 
#line 273
template< class _Rx, class 
#line 274
_Arg0, class _Arg1, class _Arg2, class 
#line 275
_Farg0, class _Farg1, class _Farg2> 
#line 276
struct _Result_of3< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2) volatile, _Farg0 &, _Farg1, _Farg2>  { 
#line 279
typedef _Rx _Type; 
#line 280
}; 
#line 326
template< class _Rx, class 
#line 327
_Arg0, class _Arg1, class _Arg2, class 
#line 328
_Farg0, class _Farg1, class _Farg2> 
#line 329
struct _Result_of3< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2) const volatile, _Farg0 &, _Farg1, _Farg2>  { 
#line 332
typedef _Rx _Type; 
#line 333
}; 
#line 379
template< class _Rx, class 
#line 380
_Arg0, class _Arg1, class _Arg2, class 
#line 381
_Farg0, class _Farg1, class _Farg2> 
#line 382
struct _Result_of3< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2), _Farg0 &, _Farg1, _Farg2>  { 
#line 385
typedef _Rx _Type; 
#line 386
}; 
#line 432
template< class _Rx, class 
#line 433
_Arg0, class _Arg1, class _Arg2, class 
#line 434
_Farg0, class _Farg1, class _Farg2> 
#line 435
struct _Result_of3< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2) const, _Farg0 &, _Farg1, _Farg2>  { 
#line 438
typedef _Rx _Type; 
#line 439
}; 
#line 485
template< class _Rx, class 
#line 486
_Arg0, class _Arg1, class _Arg2, class 
#line 487
_Farg0, class _Farg1, class _Farg2> 
#line 488
struct _Result_of3< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2) volatile, _Farg0 &, _Farg1, _Farg2>  { 
#line 491
typedef _Rx _Type; 
#line 492
}; 
#line 538
template< class _Rx, class 
#line 539
_Arg0, class _Arg1, class _Arg2, class 
#line 540
_Farg0, class _Farg1, class _Farg2> 
#line 541
struct _Result_of3< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2) const volatile, _Farg0 &, _Farg1, _Farg2>  { 
#line 544
typedef _Rx _Type; 
#line 545
}; 
#line 593 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Fty, class 
#line 594
_Arg0, class _Arg1, class _Arg2> 
#line 595
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2)>  { 
#line 597
typedef typename _Result_of3< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &> ::_Type _Type; 
#line 598
}; 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< bool __T7, class 
#line 9
_Fty, class 
#line 10
_Arg0, class _Arg1, class _Arg2, class _Arg3> struct _Result_type4; 
#line 13
template< class _Fty, class 
#line 14
_Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 15
struct _Result_type4< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3>  { 
#line 17
typedef typename _Fty::result_type _Type; 
#line 18
}; 
#line 20
template< class _Fty, class 
#line 21
_Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 22
struct _Result_type4< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3>  { 
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3)> ::type _Type; 
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
}; 
#line 33
template< class _Fty, class 
#line 34
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
#line 35
struct _Result_of4 { 
#line 37
static const bool _Value = (sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2])); 
#line 40
typedef typename _Result_type4< sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2]), _Fty, _Farg0, _Farg1, _Farg2, _Farg3> ::_Type _Type; 
#line 41
}; 
#line 44
template< class _Ret, class 
#line 45
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
#line 46
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
#line 47
struct _Result_of4< _Ret (__cdecl &)(_Arg0, _Arg1, _Arg2, _Arg3), _Farg0, _Farg1, _Farg2, _Farg3>  { 
#line 49
typedef _Ret _Type; 
#line 50
}; 
#line 52
template< class _Ret, class 
#line 53
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
#line 54
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
#line 55
struct _Result_of4< _Ret (__cdecl *)(_Arg0, _Arg1, _Arg2, _Arg3), _Farg0, _Farg1, _Farg2, _Farg3>  { 
#line 57
typedef _Ret _Type; 
#line 58
}; 
#line 60
template< class _Ret, class 
#line 61
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
#line 62
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
#line 63
struct _Result_of4< _Ret (__cdecl *const)(_Arg0, _Arg1, _Arg2, _Arg3), _Farg0, _Farg1, _Farg2, _Farg3>  { 
#line 65
typedef _Ret _Type; 
#line 66
}; 
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Rx, class 
#line 168
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
#line 169
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
#line 170
struct _Result_of4< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3), _Farg0 &, _Farg1, _Farg2, _Farg3>  { 
#line 173
typedef _Rx _Type; 
#line 174
}; 
#line 220
template< class _Rx, class 
#line 221
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
#line 222
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
#line 223
struct _Result_of4< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3) const, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 
#line 226
typedef _Rx _Type; 
#line 227
}; 
#line 273
template< class _Rx, class 
#line 274
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
#line 275
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
#line 276
struct _Result_of4< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 
#line 279
typedef _Rx _Type; 
#line 280
}; 
#line 326
template< class _Rx, class 
#line 327
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
#line 328
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
#line 329
struct _Result_of4< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 
#line 332
typedef _Rx _Type; 
#line 333
}; 
#line 379
template< class _Rx, class 
#line 380
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
#line 381
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
#line 382
struct _Result_of4< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3), _Farg0 &, _Farg1, _Farg2, _Farg3>  { 
#line 385
typedef _Rx _Type; 
#line 386
}; 
#line 432
template< class _Rx, class 
#line 433
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
#line 434
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
#line 435
struct _Result_of4< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3) const, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 
#line 438
typedef _Rx _Type; 
#line 439
}; 
#line 485
template< class _Rx, class 
#line 486
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
#line 487
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
#line 488
struct _Result_of4< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 
#line 491
typedef _Rx _Type; 
#line 492
}; 
#line 538
template< class _Rx, class 
#line 539
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
#line 540
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
#line 541
struct _Result_of4< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 
#line 544
typedef _Rx _Type; 
#line 545
}; 
#line 593 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Fty, class 
#line 594
_Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 595
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3)>  { 
#line 597
typedef typename _Result_of4< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &> ::_Type _Type; 
#line 598
}; 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< bool __T8, class 
#line 9
_Fty, class 
#line 10
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> struct _Result_type5; 
#line 13
template< class _Fty, class 
#line 14
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 15
struct _Result_type5< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4>  { 
#line 17
typedef typename _Fty::result_type _Type; 
#line 18
}; 
#line 20
template< class _Fty, class 
#line 21
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 22
struct _Result_type5< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4>  { 
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4)> ::type _Type; 
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
}; 
#line 33
template< class _Fty, class 
#line 34
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
#line 35
struct _Result_of5 { 
#line 37
static const bool _Value = (sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2])); 
#line 40
typedef typename _Result_type5< sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2]), _Fty, _Farg0, _Farg1, _Farg2, _Farg3, _Farg4> ::_Type _Type; 
#line 41
}; 
#line 44
template< class _Ret, class 
#line 45
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
#line 46
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
#line 47
struct _Result_of5< _Ret (__cdecl &)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4>  { 
#line 49
typedef _Ret _Type; 
#line 50
}; 
#line 52
template< class _Ret, class 
#line 53
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
#line 54
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
#line 55
struct _Result_of5< _Ret (__cdecl *)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4>  { 
#line 57
typedef _Ret _Type; 
#line 58
}; 
#line 60
template< class _Ret, class 
#line 61
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
#line 62
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
#line 63
struct _Result_of5< _Ret (__cdecl *const)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4>  { 
#line 65
typedef _Ret _Type; 
#line 66
}; 
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Rx, class 
#line 168
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
#line 169
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
#line 170
struct _Result_of5< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 
#line 173
typedef _Rx _Type; 
#line 174
}; 
#line 220
template< class _Rx, class 
#line 221
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
#line 222
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
#line 223
struct _Result_of5< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 
#line 226
typedef _Rx _Type; 
#line 227
}; 
#line 273
template< class _Rx, class 
#line 274
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
#line 275
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
#line 276
struct _Result_of5< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 
#line 279
typedef _Rx _Type; 
#line 280
}; 
#line 326
template< class _Rx, class 
#line 327
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
#line 328
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
#line 329
struct _Result_of5< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 
#line 332
typedef _Rx _Type; 
#line 333
}; 
#line 379
template< class _Rx, class 
#line 380
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
#line 381
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
#line 382
struct _Result_of5< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 
#line 385
typedef _Rx _Type; 
#line 386
}; 
#line 432
template< class _Rx, class 
#line 433
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
#line 434
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
#line 435
struct _Result_of5< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 
#line 438
typedef _Rx _Type; 
#line 439
}; 
#line 485
template< class _Rx, class 
#line 486
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
#line 487
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
#line 488
struct _Result_of5< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 
#line 491
typedef _Rx _Type; 
#line 492
}; 
#line 538
template< class _Rx, class 
#line 539
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
#line 540
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
#line 541
struct _Result_of5< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 
#line 544
typedef _Rx _Type; 
#line 545
}; 
#line 593 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Fty, class 
#line 594
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 595
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4)>  { 
#line 597
typedef typename _Result_of5< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &, typename _Remove_reference< _Arg4> ::_Type &> ::_Type _Type; 
#line 598
}; 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< bool __T9, class 
#line 9
_Fty, class 
#line 10
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> struct _Result_type6; 
#line 13
template< class _Fty, class 
#line 14
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 15
struct _Result_type6< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5>  { 
#line 17
typedef typename _Fty::result_type _Type; 
#line 18
}; 
#line 20
template< class _Fty, class 
#line 21
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 22
struct _Result_type6< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5>  { 
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5)> ::type _Type; 
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
}; 
#line 33
template< class _Fty, class 
#line 34
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
#line 35
struct _Result_of6 { 
#line 37
static const bool _Value = (sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2])); 
#line 40
typedef typename _Result_type6< sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2]), _Fty, _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5> ::_Type _Type; 
#line 41
}; 
#line 44
template< class _Ret, class 
#line 45
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
#line 46
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
#line 47
struct _Result_of6< _Ret (__cdecl &)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 
#line 49
typedef _Ret _Type; 
#line 50
}; 
#line 52
template< class _Ret, class 
#line 53
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
#line 54
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
#line 55
struct _Result_of6< _Ret (__cdecl *)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 
#line 57
typedef _Ret _Type; 
#line 58
}; 
#line 60
template< class _Ret, class 
#line 61
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
#line 62
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
#line 63
struct _Result_of6< _Ret (__cdecl *const)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 
#line 65
typedef _Ret _Type; 
#line 66
}; 
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Rx, class 
#line 168
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
#line 169
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
#line 170
struct _Result_of6< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 
#line 173
typedef _Rx _Type; 
#line 174
}; 
#line 220
template< class _Rx, class 
#line 221
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
#line 222
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
#line 223
struct _Result_of6< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 
#line 226
typedef _Rx _Type; 
#line 227
}; 
#line 273
template< class _Rx, class 
#line 274
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
#line 275
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
#line 276
struct _Result_of6< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 
#line 279
typedef _Rx _Type; 
#line 280
}; 
#line 326
template< class _Rx, class 
#line 327
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
#line 328
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
#line 329
struct _Result_of6< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 
#line 332
typedef _Rx _Type; 
#line 333
}; 
#line 379
template< class _Rx, class 
#line 380
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
#line 381
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
#line 382
struct _Result_of6< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 
#line 385
typedef _Rx _Type; 
#line 386
}; 
#line 432
template< class _Rx, class 
#line 433
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
#line 434
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
#line 435
struct _Result_of6< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 
#line 438
typedef _Rx _Type; 
#line 439
}; 
#line 485
template< class _Rx, class 
#line 486
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
#line 487
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
#line 488
struct _Result_of6< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 
#line 491
typedef _Rx _Type; 
#line 492
}; 
#line 538
template< class _Rx, class 
#line 539
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
#line 540
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
#line 541
struct _Result_of6< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 
#line 544
typedef _Rx _Type; 
#line 545
}; 
#line 593 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Fty, class 
#line 594
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 595
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5)>  { 
#line 597
typedef typename _Result_of6< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &, typename _Remove_reference< _Arg4> ::_Type &, typename _Remove_reference< _Arg5> ::_Type &> ::_Type _Type; 
#line 598
}; 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< bool __T10, class 
#line 9
_Fty, class 
#line 10
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> struct _Result_type7; 
#line 13
template< class _Fty, class 
#line 14
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 15
struct _Result_type7< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6>  { 
#line 17
typedef typename _Fty::result_type _Type; 
#line 18
}; 
#line 20
template< class _Fty, class 
#line 21
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 22
struct _Result_type7< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6>  { 
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6)> ::type _Type; 
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
}; 
#line 33
template< class _Fty, class 
#line 34
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
#line 35
struct _Result_of7 { 
#line 37
static const bool _Value = (sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2])); 
#line 40
typedef typename _Result_type7< sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2]), _Fty, _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6> ::_Type _Type; 
#line 41
}; 
#line 44
template< class _Ret, class 
#line 45
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
#line 46
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
#line 47
struct _Result_of7< _Ret (__cdecl &)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 
#line 49
typedef _Ret _Type; 
#line 50
}; 
#line 52
template< class _Ret, class 
#line 53
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
#line 54
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
#line 55
struct _Result_of7< _Ret (__cdecl *)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 
#line 57
typedef _Ret _Type; 
#line 58
}; 
#line 60
template< class _Ret, class 
#line 61
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
#line 62
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
#line 63
struct _Result_of7< _Ret (__cdecl *const)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 
#line 65
typedef _Ret _Type; 
#line 66
}; 
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Rx, class 
#line 168
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
#line 169
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
#line 170
struct _Result_of7< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 
#line 173
typedef _Rx _Type; 
#line 174
}; 
#line 220
template< class _Rx, class 
#line 221
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
#line 222
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
#line 223
struct _Result_of7< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 
#line 226
typedef _Rx _Type; 
#line 227
}; 
#line 273
template< class _Rx, class 
#line 274
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
#line 275
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
#line 276
struct _Result_of7< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 
#line 279
typedef _Rx _Type; 
#line 280
}; 
#line 326
template< class _Rx, class 
#line 327
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
#line 328
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
#line 329
struct _Result_of7< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 
#line 332
typedef _Rx _Type; 
#line 333
}; 
#line 379
template< class _Rx, class 
#line 380
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
#line 381
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
#line 382
struct _Result_of7< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 
#line 385
typedef _Rx _Type; 
#line 386
}; 
#line 432
template< class _Rx, class 
#line 433
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
#line 434
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
#line 435
struct _Result_of7< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 
#line 438
typedef _Rx _Type; 
#line 439
}; 
#line 485
template< class _Rx, class 
#line 486
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
#line 487
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
#line 488
struct _Result_of7< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 
#line 491
typedef _Rx _Type; 
#line 492
}; 
#line 538
template< class _Rx, class 
#line 539
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
#line 540
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
#line 541
struct _Result_of7< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 
#line 544
typedef _Rx _Type; 
#line 545
}; 
#line 593 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Fty, class 
#line 594
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 595
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6)>  { 
#line 597
typedef typename _Result_of7< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &, typename _Remove_reference< _Arg4> ::_Type &, typename _Remove_reference< _Arg5> ::_Type &, typename _Remove_reference< _Arg6> ::_Type &> ::_Type _Type; 
#line 598
}; 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< bool __T11, class 
#line 9
_Fty, class 
#line 10
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> struct _Result_type8; 
#line 13
template< class _Fty, class 
#line 14
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 15
struct _Result_type8< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7>  { 
#line 17
typedef typename _Fty::result_type _Type; 
#line 18
}; 
#line 20
template< class _Fty, class 
#line 21
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 22
struct _Result_type8< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7>  { 
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7)> ::type _Type; 
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
}; 
#line 33
template< class _Fty, class 
#line 34
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
#line 35
struct _Result_of8 { 
#line 37
static const bool _Value = (sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2])); 
#line 40
typedef typename _Result_type8< sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2]), _Fty, _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7> ::_Type _Type; 
#line 41
}; 
#line 44
template< class _Ret, class 
#line 45
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
#line 46
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
#line 47
struct _Result_of8< _Ret (__cdecl &)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 
#line 49
typedef _Ret _Type; 
#line 50
}; 
#line 52
template< class _Ret, class 
#line 53
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
#line 54
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
#line 55
struct _Result_of8< _Ret (__cdecl *)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 
#line 57
typedef _Ret _Type; 
#line 58
}; 
#line 60
template< class _Ret, class 
#line 61
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
#line 62
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
#line 63
struct _Result_of8< _Ret (__cdecl *const)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 
#line 65
typedef _Ret _Type; 
#line 66
}; 
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Rx, class 
#line 168
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
#line 169
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
#line 170
struct _Result_of8< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 
#line 173
typedef _Rx _Type; 
#line 174
}; 
#line 220
template< class _Rx, class 
#line 221
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
#line 222
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
#line 223
struct _Result_of8< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 
#line 226
typedef _Rx _Type; 
#line 227
}; 
#line 273
template< class _Rx, class 
#line 274
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
#line 275
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
#line 276
struct _Result_of8< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 
#line 279
typedef _Rx _Type; 
#line 280
}; 
#line 326
template< class _Rx, class 
#line 327
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
#line 328
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
#line 329
struct _Result_of8< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 
#line 332
typedef _Rx _Type; 
#line 333
}; 
#line 379
template< class _Rx, class 
#line 380
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
#line 381
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
#line 382
struct _Result_of8< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 
#line 385
typedef _Rx _Type; 
#line 386
}; 
#line 432
template< class _Rx, class 
#line 433
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
#line 434
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
#line 435
struct _Result_of8< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 
#line 438
typedef _Rx _Type; 
#line 439
}; 
#line 485
template< class _Rx, class 
#line 486
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
#line 487
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
#line 488
struct _Result_of8< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 
#line 491
typedef _Rx _Type; 
#line 492
}; 
#line 538
template< class _Rx, class 
#line 539
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
#line 540
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
#line 541
struct _Result_of8< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 
#line 544
typedef _Rx _Type; 
#line 545
}; 
#line 593 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Fty, class 
#line 594
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 595
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7)>  { 
#line 597
typedef typename _Result_of8< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &, typename _Remove_reference< _Arg4> ::_Type &, typename _Remove_reference< _Arg5> ::_Type &, typename _Remove_reference< _Arg6> ::_Type &, typename _Remove_reference< _Arg7> ::_Type &> ::_Type _Type; 
#line 598
}; 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< bool __T12, class 
#line 9
_Fty, class 
#line 10
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> struct _Result_type9; 
#line 13
template< class _Fty, class 
#line 14
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 15
struct _Result_type9< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8>  { 
#line 17
typedef typename _Fty::result_type _Type; 
#line 18
}; 
#line 20
template< class _Fty, class 
#line 21
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 22
struct _Result_type9< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8>  { 
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8)> ::type _Type; 
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
}; 
#line 33
template< class _Fty, class 
#line 34
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
#line 35
struct _Result_of9 { 
#line 37
static const bool _Value = (sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2])); 
#line 40
typedef typename _Result_type9< sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2]), _Fty, _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8> ::_Type _Type; 
#line 41
}; 
#line 44
template< class _Ret, class 
#line 45
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
#line 46
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
#line 47
struct _Result_of9< _Ret (__cdecl &)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 
#line 49
typedef _Ret _Type; 
#line 50
}; 
#line 52
template< class _Ret, class 
#line 53
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
#line 54
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
#line 55
struct _Result_of9< _Ret (__cdecl *)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 
#line 57
typedef _Ret _Type; 
#line 58
}; 
#line 60
template< class _Ret, class 
#line 61
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
#line 62
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
#line 63
struct _Result_of9< _Ret (__cdecl *const)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 
#line 65
typedef _Ret _Type; 
#line 66
}; 
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Rx, class 
#line 168
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
#line 169
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
#line 170
struct _Result_of9< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 
#line 173
typedef _Rx _Type; 
#line 174
}; 
#line 220
template< class _Rx, class 
#line 221
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
#line 222
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
#line 223
struct _Result_of9< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 
#line 226
typedef _Rx _Type; 
#line 227
}; 
#line 273
template< class _Rx, class 
#line 274
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
#line 275
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
#line 276
struct _Result_of9< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 
#line 279
typedef _Rx _Type; 
#line 280
}; 
#line 326
template< class _Rx, class 
#line 327
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
#line 328
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
#line 329
struct _Result_of9< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 
#line 332
typedef _Rx _Type; 
#line 333
}; 
#line 379
template< class _Rx, class 
#line 380
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
#line 381
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
#line 382
struct _Result_of9< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 
#line 385
typedef _Rx _Type; 
#line 386
}; 
#line 432
template< class _Rx, class 
#line 433
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
#line 434
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
#line 435
struct _Result_of9< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 
#line 438
typedef _Rx _Type; 
#line 439
}; 
#line 485
template< class _Rx, class 
#line 486
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
#line 487
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
#line 488
struct _Result_of9< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 
#line 491
typedef _Rx _Type; 
#line 492
}; 
#line 538
template< class _Rx, class 
#line 539
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
#line 540
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
#line 541
struct _Result_of9< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 
#line 544
typedef _Rx _Type; 
#line 545
}; 
#line 593 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Fty, class 
#line 594
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 595
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8)>  { 
#line 597
typedef typename _Result_of9< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &, typename _Remove_reference< _Arg4> ::_Type &, typename _Remove_reference< _Arg5> ::_Type &, typename _Remove_reference< _Arg6> ::_Type &, typename _Remove_reference< _Arg7> ::_Type &, typename _Remove_reference< _Arg8> ::_Type &> ::_Type _Type; 
#line 598
}; 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< bool __T13, class 
#line 9
_Fty, class 
#line 10
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> struct _Result_type10; 
#line 13
template< class _Fty, class 
#line 14
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 15
struct _Result_type10< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9>  { 
#line 17
typedef typename _Fty::result_type _Type; 
#line 18
}; 
#line 20
template< class _Fty, class 
#line 21
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 22
struct _Result_type10< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9>  { 
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9)> ::type _Type; 
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
}; 
#line 33
template< class _Fty, class 
#line 34
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
#line 35
struct _Result_of10 { 
#line 37
static const bool _Value = (sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2])); 
#line 40
typedef typename _Result_type10< sizeof(tr1::_Has_result_type((_Fty *)0)) == sizeof(char [2]), _Fty, _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9> ::_Type _Type; 
#line 41
}; 
#line 44
template< class _Ret, class 
#line 45
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
#line 46
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
#line 47
struct _Result_of10< _Ret (__cdecl &)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 
#line 49
typedef _Ret _Type; 
#line 50
}; 
#line 52
template< class _Ret, class 
#line 53
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
#line 54
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
#line 55
struct _Result_of10< _Ret (__cdecl *)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 
#line 57
typedef _Ret _Type; 
#line 58
}; 
#line 60
template< class _Ret, class 
#line 61
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
#line 62
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
#line 63
struct _Result_of10< _Ret (__cdecl *const)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 
#line 65
typedef _Ret _Type; 
#line 66
}; 
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Rx, class 
#line 168
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
#line 169
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
#line 170
struct _Result_of10< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 
#line 173
typedef _Rx _Type; 
#line 174
}; 
#line 220
template< class _Rx, class 
#line 221
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
#line 222
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
#line 223
struct _Result_of10< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 
#line 226
typedef _Rx _Type; 
#line 227
}; 
#line 273
template< class _Rx, class 
#line 274
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
#line 275
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
#line 276
struct _Result_of10< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 
#line 279
typedef _Rx _Type; 
#line 280
}; 
#line 326
template< class _Rx, class 
#line 327
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
#line 328
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
#line 329
struct _Result_of10< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 
#line 332
typedef _Rx _Type; 
#line 333
}; 
#line 379
template< class _Rx, class 
#line 380
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
#line 381
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
#line 382
struct _Result_of10< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 
#line 385
typedef _Rx _Type; 
#line 386
}; 
#line 432
template< class _Rx, class 
#line 433
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
#line 434
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
#line 435
struct _Result_of10< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 
#line 438
typedef _Rx _Type; 
#line 439
}; 
#line 485
template< class _Rx, class 
#line 486
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
#line 487
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
#line 488
struct _Result_of10< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 
#line 491
typedef _Rx _Type; 
#line 492
}; 
#line 538
template< class _Rx, class 
#line 539
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
#line 540
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
#line 541
struct _Result_of10< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 
#line 544
typedef _Rx _Type; 
#line 545
}; 
#line 593 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxresult"
template< class _Fty, class 
#line 594
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 595
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9)>  { 
#line 597
typedef typename _Result_of10< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &, typename _Remove_reference< _Arg4> ::_Type &, typename _Remove_reference< _Arg5> ::_Type &, typename _Remove_reference< _Arg6> ::_Type &, typename _Remove_reference< _Arg7> ::_Type &, typename _Remove_reference< _Arg8> ::_Type &, typename _Remove_reference< _Arg9> ::_Type &> ::_Type _Type; 
#line 598
}; 
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xrefwrap"
template< class _Fty> 
#line 26
struct result_of { 
#line 28
typedef typename _Result_of< _Fty> ::_Type type; 
#line 29
}; 
#line 34
template< class _Ret, class 
#line 35
_Arg0> 
#line 36
struct _Pmd_caller { 
#line 38
template < class _Pmd,
  class _Farg0 >
  static _Ret _Call_pmd ( const volatile _Arg0 *, _Pmd _Pm, _Farg0 _F0 )
  {
  return ( ( _Ret ) ( _F0 .* _Pm ) );
  }
#line 45
template < class _Pmd,
  class _Farg0 >
  static _Ret _Call_pmd ( const volatile void *, _Pmd _Pm, _Farg0 _F0 )
  {
  return ( ( * _F0 ) .* _Pm );
  }
#line 52
template < class _Pmd,
  class _Farg0 >
  static _Ret _Apply_pmd ( _Pmd _Pm, _Farg0 & _F0 )
  {
  return ( _Call_pmd < _Pmd, _Farg0 & > ( & _F0, _Pm, _F0 ) );
  }
#line 58
}; 
#line 61
template< class _Ty, bool 
#line 62
_Indirect> struct _Callable_base; 
#line 65
template < class _Ty >
 struct _Callable_base < _Ty, false >
 {
 enum { _EEN_INDIRECT = 0 };
 typedef _Ty _MyTy;
 typedef const _Ty & _MyCnstTy;

 _Callable_base ( _Ty & _Val )
  : _Object ( _Val )
  {
  }

 const _Ty & _Get ( ) const
  {
  return ( _Object );
  }

 _Ty & _Get ( )
  {
  return ( _Object );
  }

private :
 _Callable_base & operator = ( const _Callable_base & );

 _Ty _Object;
};
#line 93
template < class _Ty >
 struct _Callable_base < _Ty, true >
 {

 enum { _EEN_INDIRECT = 1 };
 typedef _Ty _MyTy;
 typedef _Ty & _MyCnstTy;

 _Callable_base ( _Ty & _Val )
  : _Ptr ( & _Val )
  {
  }

 _MyCnstTy _Get ( ) const
  {
  return ( * _Ptr );
  }

 _Ty & _Get ( )
  {
  return ( * _Ptr );
  }

 void _Reset ( _Ty & _Val )
  {
  _Ptr = & _Val;
  }

private :
 _Ty * _Ptr;
};
#line 126
template < class _Ty,
 class _Memty,
 bool _Indirect = false >
 struct _Callable_pmd
  : _Callable_base < _Ty, _Indirect >
 {
 _Callable_pmd ( _Ty & _Val )
  : _Callable_base < _Ty, _Indirect > ( _Val )
  {
  }

 template < class _Ret,
  class _Arg0 >
  _Ret _ApplyX ( _Arg0 & _A0 ) const
  {
  return ( _Pmd_caller < _Ret, _Memty > :: _Apply_pmd ( this -> _Get ( ), _A0 ) );
  }
 };
#line 146
template < class _Ty,
 bool _Indirect = false >
 struct _Callable_obj
  : _Callable_base < _Ty, _Indirect >
 {
 _Callable_obj ( _Ty & _Val )
  : _Callable_base < _Ty, _Indirect > ( _Val )
  {
  }






















































































































































































































































































template < class _Ret >
 _Ret _ApplyX ( ) const
 {
 return ( this -> _Get ( ) ( ) );
 }

template < class _Ret >
 _Ret _ApplyX ( )
 {
 return ( this -> _Get ( ) ( ) );
 }





















































































































































































































































































































































































































template < class _Ret, class _Arg0 >
 _Ret _ApplyX ( _Arg0 && _Ax0 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ) ) );
 }

template < class _Ret, class _Arg0 >
 _Ret _ApplyX ( _Arg0 && _Ax0 )
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ) ) );
 }

template < class _Ret, class _Arg0, class _Arg1 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1 )
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ) ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2 )
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ) ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3 )
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ) ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4 )
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ) ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5 )
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ) ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6 )
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ) ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7 )
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ) ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8 )
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8, _Arg9 && _Ax9 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ), :: std :: forward < _Arg9 > ( _Ax9 ) ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8, _Arg9 && _Ax9 )
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ), :: std :: forward < _Arg9 > ( _Ax9 ) ) );
 }

































































































































































 };
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxpmfcaller"
template< class _Ty> class reference_wrapper; 
#line 10
template< class _Ret, class 
#line 11
_Arg0> 
#line 12
struct _Pmf_caller1 { 
#line 14
template < class _Ty >
  static _Ty & _Unwrap ( _Ty & _Val )
  {
  return ( _Val );
  }
#line 20
template < class _Ty >
  static _Ty & _Unwrap ( reference_wrapper < _Ty > & _Val )
  {
  return ( _Val . get ( ) );
  }
#line 27
template < class _Pmf,
  class _Farg0 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
   _Pmf _Pm, _Farg0 & _Fx0 )
  {
  return ( ( _Fx0 .* _Pm ) ( ) );
  }
#line 36
template < class _Pmf,
  class _Farg0 >
  static _Ret _Call_pmf (
   const volatile void *,
   _Pmf _Pm, _Farg0 & _Fx0 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( ) );
  }
#line 47
template < class _Pmf,
  class _Farg0 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0 )
  {
  return ( _Call_pmf < _Pmf > (
   & _Unwrap ( _Fx0 ), _Pm, _Unwrap ( _Fx0 ) ) );
  }
#line 54
}; 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxpmfcaller"
template< class _Ty> class reference_wrapper; 
#line 10
template< class _Ret, class 
#line 11
_Arg0> 
#line 12
struct _Pmf_caller2 { 
#line 14
template < class _Ty >
  static _Ty & _Unwrap ( _Ty & _Val )
  {
  return ( _Val );
  }
#line 20
template < class _Ty >
  static _Ty & _Unwrap ( reference_wrapper < _Ty > & _Val )
  {
  return ( _Val . get ( ) );
  }
#line 27
template < class _Pmf,
  class _Farg0, class _Farg1 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1 ) );
  }
#line 36
template < class _Pmf,
  class _Farg0, class _Farg1 >
  static _Ret _Call_pmf (
   const volatile void *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1 ) );
  }
#line 47
template < class _Pmf,
  class _Farg0, class _Farg1 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1 )
  {
  return ( _Call_pmf < _Pmf > (
   & _Unwrap ( _Fx0 ), _Pm, _Unwrap ( _Fx0 ), _Fx1 ) );
  }
#line 54
}; 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxpmfcaller"
template< class _Ty> class reference_wrapper; 
#line 10
template< class _Ret, class 
#line 11
_Arg0> 
#line 12
struct _Pmf_caller3 { 
#line 14
template < class _Ty >
  static _Ty & _Unwrap ( _Ty & _Val )
  {
  return ( _Val );
  }
#line 20
template < class _Ty >
  static _Ty & _Unwrap ( reference_wrapper < _Ty > & _Val )
  {
  return ( _Val . get ( ) );
  }
#line 27
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2 ) );
  }
#line 36
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2 >
  static _Ret _Call_pmf (
   const volatile void *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2 ) );
  }
#line 47
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2 )
  {
  return ( _Call_pmf < _Pmf > (
   & _Unwrap ( _Fx0 ), _Pm, _Unwrap ( _Fx0 ), _Fx1, _Fx2 ) );
  }
#line 54
}; 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxpmfcaller"
template< class _Ty> class reference_wrapper; 
#line 10
template< class _Ret, class 
#line 11
_Arg0> 
#line 12
struct _Pmf_caller4 { 
#line 14
template < class _Ty >
  static _Ty & _Unwrap ( _Ty & _Val )
  {
  return ( _Val );
  }
#line 20
template < class _Ty >
  static _Ty & _Unwrap ( reference_wrapper < _Ty > & _Val )
  {
  return ( _Val . get ( ) );
  }
#line 27
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3 ) );
  }
#line 36
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  static _Ret _Call_pmf (
   const volatile void *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3 ) );
  }
#line 47
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3 )
  {
  return ( _Call_pmf < _Pmf > (
   & _Unwrap ( _Fx0 ), _Pm, _Unwrap ( _Fx0 ), _Fx1, _Fx2, _Fx3 ) );
  }
#line 54
}; 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxpmfcaller"
template< class _Ty> class reference_wrapper; 
#line 10
template< class _Ret, class 
#line 11
_Arg0> 
#line 12
struct _Pmf_caller5 { 
#line 14
template < class _Ty >
  static _Ty & _Unwrap ( _Ty & _Val )
  {
  return ( _Val );
  }
#line 20
template < class _Ty >
  static _Ty & _Unwrap ( reference_wrapper < _Ty > & _Val )
  {
  return ( _Val . get ( ) );
  }
#line 27
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4 ) );
  }
#line 36
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  static _Ret _Call_pmf (
   const volatile void *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4 ) );
  }
#line 47
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4 )
  {
  return ( _Call_pmf < _Pmf > (
   & _Unwrap ( _Fx0 ), _Pm, _Unwrap ( _Fx0 ), _Fx1, _Fx2, _Fx3, _Fx4 ) );
  }
#line 54
}; 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxpmfcaller"
template< class _Ty> class reference_wrapper; 
#line 10
template< class _Ret, class 
#line 11
_Arg0> 
#line 12
struct _Pmf_caller6 { 
#line 14
template < class _Ty >
  static _Ty & _Unwrap ( _Ty & _Val )
  {
  return ( _Val );
  }
#line 20
template < class _Ty >
  static _Ty & _Unwrap ( reference_wrapper < _Ty > & _Val )
  {
  return ( _Val . get ( ) );
  }
#line 27
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5 ) );
  }
#line 36
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  static _Ret _Call_pmf (
   const volatile void *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5 ) );
  }
#line 47
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5 )
  {
  return ( _Call_pmf < _Pmf > (
   & _Unwrap ( _Fx0 ), _Pm, _Unwrap ( _Fx0 ), _Fx1, _Fx2, _Fx3, _Fx4, _Fx5 ) );
  }
#line 54
}; 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxpmfcaller"
template< class _Ty> class reference_wrapper; 
#line 10
template< class _Ret, class 
#line 11
_Arg0> 
#line 12
struct _Pmf_caller7 { 
#line 14
template < class _Ty >
  static _Ty & _Unwrap ( _Ty & _Val )
  {
  return ( _Val );
  }
#line 20
template < class _Ty >
  static _Ty & _Unwrap ( reference_wrapper < _Ty > & _Val )
  {
  return ( _Val . get ( ) );
  }
#line 27
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6 ) );
  }
#line 36
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  static _Ret _Call_pmf (
   const volatile void *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6 ) );
  }
#line 47
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6 )
  {
  return ( _Call_pmf < _Pmf > (
   & _Unwrap ( _Fx0 ), _Pm, _Unwrap ( _Fx0 ), _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6 ) );
  }
#line 54
}; 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxpmfcaller"
template< class _Ty> class reference_wrapper; 
#line 10
template< class _Ret, class 
#line 11
_Arg0> 
#line 12
struct _Pmf_caller8 { 
#line 14
template < class _Ty >
  static _Ty & _Unwrap ( _Ty & _Val )
  {
  return ( _Val );
  }
#line 20
template < class _Ty >
  static _Ty & _Unwrap ( reference_wrapper < _Ty > & _Val )
  {
  return ( _Val . get ( ) );
  }
#line 27
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7 ) );
  }
#line 36
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  static _Ret _Call_pmf (
   const volatile void *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7 ) );
  }
#line 47
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7 )
  {
  return ( _Call_pmf < _Pmf > (
   & _Unwrap ( _Fx0 ), _Pm, _Unwrap ( _Fx0 ), _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7 ) );
  }
#line 54
}; 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxpmfcaller"
template< class _Ty> class reference_wrapper; 
#line 10
template< class _Ret, class 
#line 11
_Arg0> 
#line 12
struct _Pmf_caller9 { 
#line 14
template < class _Ty >
  static _Ty & _Unwrap ( _Ty & _Val )
  {
  return ( _Val );
  }
#line 20
template < class _Ty >
  static _Ty & _Unwrap ( reference_wrapper < _Ty > & _Val )
  {
  return ( _Val . get ( ) );
  }
#line 27
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7, _Farg8 & _Fx8 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8 ) );
  }
#line 36
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  static _Ret _Call_pmf (
   const volatile void *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7, _Farg8 & _Fx8 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8 ) );
  }
#line 47
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7, _Farg8 & _Fx8 )
  {
  return ( _Call_pmf < _Pmf > (
   & _Unwrap ( _Fx0 ), _Pm, _Unwrap ( _Fx0 ), _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8 ) );
  }
#line 54
}; 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxpmfcaller"
template< class _Ty> class reference_wrapper; 
#line 10
template< class _Ret, class 
#line 11
_Arg0> 
#line 12
struct _Pmf_caller10 { 
#line 14
template < class _Ty >
  static _Ty & _Unwrap ( _Ty & _Val )
  {
  return ( _Val );
  }
#line 20
template < class _Ty >
  static _Ty & _Unwrap ( reference_wrapper < _Ty > & _Val )
  {
  return ( _Val . get ( ) );
  }
#line 27
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7, _Farg8 & _Fx8, _Farg9 & _Fx9 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8, _Fx9 ) );
  }
#line 36
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  static _Ret _Call_pmf (
   const volatile void *,
   _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7, _Farg8 & _Fx8, _Farg9 & _Fx9 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8, _Fx9 ) );
  }
#line 47
template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7, _Farg8 & _Fx8, _Farg9 & _Fx9 )
  {
  return ( _Call_pmf < _Pmf > (
   & _Unwrap ( _Fx0 ), _Pm, _Unwrap ( _Fx0 ), _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8, _Fx9 ) );
  }
#line 54
}; 
#line 166 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xrefwrap"
template < class _Ty,
 class _Memty,
 bool _Indirect = false >
 struct _Callable_pmf
  : _Callable_base < _Ty, _Indirect >
 {
 _Callable_pmf ( _Ty & _Val )
  : _Callable_base < _Ty, _Indirect > ( _Val )
  {
  }






















































































































































































































































































































































































































































































































































































































































































































template < class _Ret, class _Arg0 >
 _Ret _ApplyX ( _Arg0 && _Ax0 ) const
 {
 return ( _Pmf_caller1 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0 ) );
 }






















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1 ) const
 {
 return ( _Pmf_caller2 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1 ) );
 }






















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2 ) const
 {
 return ( _Pmf_caller3 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2 ) );
 }






















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3 ) const
 {
 return ( _Pmf_caller4 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3 ) );
 }






















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4 ) const
 {
 return ( _Pmf_caller5 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) );
 }






















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5 ) const
 {
 return ( _Pmf_caller6 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) );
 }






















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6 ) const
 {
 return ( _Pmf_caller7 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) );
 }






















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7 ) const
 {
 return ( _Pmf_caller8 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) );
 }






















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8 ) const
 {
 return ( _Pmf_caller9 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) );
 }






















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8, _Arg9 && _Ax9 ) const
 {
 return ( _Pmf_caller10 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) );
 }
































































































































































 };
#line 182 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xrefwrap"
template < class _Ty,
 bool _Indirect = false >
 struct _Callable_fun
  : _Callable_base < _Ty, _Indirect >
 {
 _Callable_fun ( _Ty & _Val )
  : _Callable_base < _Ty, _Indirect > ( _Val )
  {
  }




















































































































































































































































































template < class _Ret >
 _Ret _ApplyX ( ) const
 {
 return ( this -> _Get ( ) ( ) );
 }





















































































































































































































































































































































































































template < class _Ret, class _Arg0 >
 _Ret _ApplyX ( _Arg0 && _Ax0 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ) ) );
 }




















































































































































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Ret _ApplyX ( _Arg0 && _Ax0, _Arg1 && _Ax1, _Arg2 && _Ax2, _Arg3 && _Ax3, _Arg4 && _Ax4, _Arg5 && _Ax5, _Arg6 && _Ax6, _Arg7 && _Ax7, _Arg8 && _Ax8, _Arg9 && _Ax9 ) const
 {
 return ( this -> _Get ( ) ( :: std :: forward < _Arg0 > ( _Ax0 ), :: std :: forward < _Arg1 > ( _Ax1 ), :: std :: forward < _Arg2 > ( _Ax2 ), :: std :: forward < _Arg3 > ( _Ax3 ), :: std :: forward < _Arg4 > ( _Ax4 ), :: std :: forward < _Arg5 > ( _Ax5 ), :: std :: forward < _Arg6 > ( _Ax6 ), :: std :: forward < _Arg7 > ( _Ax7 ), :: std :: forward < _Arg8 > ( _Ax8 ), :: std :: forward < _Arg9 > ( _Ax9 ) ) );
 }



































































































































































 };
#line 197 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xrefwrap"
template < class _Callable >
 struct _Call_wrapper_base
 {
 typedef typename _Callable :: _MyTy _MyTy;
 typedef typename _Callable :: _MyCnstTy _MyCnstTy;

 _Call_wrapper_base ( _MyTy & _Val )
  : _Callee ( _Val )
  {
  }

 void _Reset ( _MyTy & _Val )
  {
  _Callee . _Reset ( _Val );
  }

 _MyCnstTy _Get ( ) const
  {
  return ( _Callee . _Get ( ) );
  }

 _MyCnstTy _Get ( )
  {
  return ( _Callee . _Get ( ) );
  }

 _Callable _Callee;
 };
#line 227
template < class _Callable >
 struct _Call_wrapper
 : _Call_wrapper_base < _Callable >
 {
 typedef _Call_wrapper_base < _Callable > _Mybase;

 _Call_wrapper ( typename _Call_wrapper_base < _Callable > :: _MyTy & _Val )
  : _Call_wrapper_base < _Callable > ( _Val )
  {
  }

































 typename _Result_of < typename _Callable :: _MyTy ( ) > :: _Type
  operator ( ) ( ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( ) );
 }





























template < class _Carg0 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 ) > :: _Type
  operator ( ) ( _Carg0 && _CA0 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( :: std :: forward < _Carg0 > ( _CA0 ) ) );
 }





























template < class _Carg0, class _Carg1 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0, _Carg1 ) > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0, _Carg1 ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ) ) );
 }






























template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2 ) > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2 ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ) ) );
 }

































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3 ) > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3 ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ) ) );
 }



































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3, _Carg4 ) > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3, _Carg4 ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ) ) );
 }




































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5 ) > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5 ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ) ) );
 }





































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6 ) > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5, _Carg6 && _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6 ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), :: std :: forward < _Carg6 > ( _CA6 ) ) );
 }








































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7 ) > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5, _Carg6 && _CA6, _Carg7 && _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7 ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), :: std :: forward < _Carg6 > ( _CA6 ), :: std :: forward < _Carg7 > ( _CA7 ) ) );
 }










































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Carg8 ) > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5, _Carg6 && _CA6, _Carg7 && _CA7, _Carg8 && _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Carg8 ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), :: std :: forward < _Carg6 > ( _CA6 ), :: std :: forward < _Carg7 > ( _CA7 ), :: std :: forward < _Carg8 > ( _CA8 ) ) );
 }











































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Carg8, _Carg9 ) > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5, _Carg6 && _CA6, _Carg7 && _CA7, _Carg8 && _CA8, _Carg9 && _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Carg8, _Carg9 ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), :: std :: forward < _Carg6 > ( _CA6 ), :: std :: forward < _Carg7 > ( _CA7 ), :: std :: forward < _Carg8 > ( _CA8 ), :: std :: forward < _Carg9 > ( _CA9 ) ) );
 }






















 };
#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xrefwrap"
template< class _Ty> _No _Has_result_and_arg_type(const volatile void *); 
#line 246
template< class _Ty> _Yes _Has_result_and_arg_type(_Ty *, typename _Ty::argument_type * = 0, typename _Ty::result_type * = 0); 
#line 254
template< class _Ty> _No _Has_result_and_2arg_type(const volatile void *); 
#line 257
template< class _Ty> _Yes _Has_result_and_2arg_type(_Ty *, typename _Ty::first_argument_type * = 0, typename _Ty::second_argument_type * = 0, typename _Ty::result_type * = 0); 
#line 267
template< class _T1, class 
#line 268
_Ret> _No 
#line 267
_Has_unary_base(const volatile void *); 
#line 271
template< class _T1, class 
#line 272
_Ret> _Yes 
#line 271
_Has_unary_base(const volatile unary_function< _T1, _Ret>  *); 
#line 280
template< class _T1, class 
#line 281
_T2, class 
#line 282
_Ret> _No 
#line 280
_Has_binary_base(const volatile void *); 
#line 285
template< class _T1, class 
#line 286
_T2, class 
#line 287
_Ret> _Yes 
#line 285
_Has_binary_base(const volatile binary_function< _T1, _T2, _Ret>  *); 
#line 296
template< class _Ty, bool 
#line 297
__T14> 
#line 298
struct _Refwrap_result0 { 
#line 300
typedef typename _Ty::result_type result_type; 
#line 301
}; 
#line 303
template< class _Ty> 
#line 304
struct _Refwrap_result0< _Ty, false>  { 
#line 306
}; 
#line 309
template< class _Ty, bool 
#line 310
__T15> 
#line 311
struct _Refwrap_result1_helper : public _Refwrap_result0< _Ty, sizeof(tr1::_Has_result_type((_Ty *)0)) == sizeof(char [2])>  { 
#line 314
}; 
#line 316
template< class _Ty> 
#line 317
struct _Refwrap_result1_helper< _Ty, true>  : public unary_function< typename _Ty::argument_type, typename _Ty::result_type>  { 
#line 321
}; 
#line 324
template< class _Ty, bool 
#line 325
__T16> 
#line 326
struct _Refwrap_result1 : public _Refwrap_result0< _Ty, sizeof(tr1::_Has_result_type((_Ty *)0)) == sizeof(char [2])>  { 
#line 329
}; 
#line 331
template< class _Ty> 
#line 332
struct _Refwrap_result1< _Ty, true>  : public _Refwrap_result1_helper< _Ty, sizeof(_Has_unary_base< typename _Ty::argument_type, typename _Ty::result_type> ((_Ty *)0)) == sizeof(char [2])>  { 
#line 335
}; 
#line 338
template< class _Ty, bool 
#line 339
__T17> 
#line 340
struct _Refwrap_result2_helper : public _Refwrap_result1< _Ty, sizeof(tr1::_Has_result_and_arg_type< _Ty> ((_Ty *)0)) == sizeof(char [2])>  { 
#line 343
}; 
#line 345
template< class _Ty> 
#line 346
struct _Refwrap_result2_helper< _Ty, true>  : public binary_function< typename _Ty::first_argument_type, typename _Ty::second_argument_type, typename _Ty::result_type> , public _Refwrap_result1< _Ty, sizeof(tr1::_Has_result_and_arg_type< _Ty> ((_Ty *)0)) == sizeof(char [2])>  { 
#line 352
}; 
#line 355
template< class _Ty, bool 
#line 356
__T18> 
#line 357
struct _Refwrap_result2 : public _Refwrap_result1< _Ty, sizeof(tr1::_Has_result_and_arg_type< _Ty> ((_Ty *)0)) == sizeof(char [2])>  { 
#line 360
}; 
#line 362
template< class _Ty> 
#line 363
struct _Refwrap_result2< _Ty, true>  : public _Refwrap_result2_helper< _Ty, sizeof(_Has_binary_base< typename _Ty::first_argument_type, typename _Ty::second_argument_type, typename _Ty::result_type> ((_Ty *)0)) == sizeof(char [2])>  { 
#line 366
}; 
#line 369
template < class _Ty >
 struct _Refwrap_impl
  : _Call_wrapper < _Callable_obj < _Ty, true > >,
   _Refwrap_result2 < _Ty, ( sizeof ( :: std :: tr1 :: _Has_result_and_2arg_type < _Ty > ( ( _Ty * ) 0 ) ) == sizeof ( :: std :: tr1 :: _Yes ) ) >
 {
 _Refwrap_impl ( _Ty & _Val )
  : _Call_wrapper < _Callable_obj < _Ty, true > > ( _Val )
  {
  }
 };
#line 380
template < class _Rx,
 class _Arg0 >
 struct _Refwrap_impl < _Rx _Arg0 :: * >
  : _Call_wrapper < _Callable_pmd < _Rx _Arg0 :: * const, _Arg0, false > >
 {
 typedef _Rx _Arg0 :: * const _Fty;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_pmd < _Fty, _Arg0, false > > ( _Val )
  {
  }
 };
#line 394
template < class _Rx,
 class _Arg0 >
 struct _Refwrap_impl < _Rx _Arg0 :: * const >
  : _Call_wrapper < _Callable_pmd < _Rx _Arg0 :: *, _Arg0, false > >
 {
 typedef _Rx _Arg0 :: * _Fty;
 typedef _Rx result_type;
 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_pmd < _Fty, _Arg0, false > > ( _Val )
  {
  }
 };
#line 5 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
      >
 struct _Refwrap_impl < _Rx __cdecl ( ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( ), false > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
      >
 struct _Refwrap_impl < _Rx ( __cdecl * ) ( ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( ), true > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
      >
 struct _Refwrap_impl < _Rx ( __cdecl * const ) ( ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * const ) ( ), true > >








 {
 typedef _Rx ( __cdecl * const _Fty ) ( );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 5 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx __cdecl ( _Arg0 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0 ), false > >


   , unary_function < _Arg0, _Rx >





 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( __cdecl * ) ( _Arg0 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0 ), true > >


   , unary_function < _Arg0, _Rx >





 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( __cdecl * const ) ( _Arg0 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * const ) ( _Arg0 ), true > >


   , unary_function < _Arg0, _Rx >





 {
 typedef _Rx ( __cdecl * const _Fty ) ( _Arg0 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( ), _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( ) const, _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( ) volatile, _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 368 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( ) const volatile, _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( ), _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( ) const, _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( ) volatile, _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( ) const volatile, _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx __cdecl ( _Arg0, _Arg1 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1 ), false > >





   , binary_function < _Arg0, _Arg1, _Rx >


 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( __cdecl * ) ( _Arg0, _Arg1 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1 ), true > >





   , binary_function < _Arg0, _Arg1, _Rx >


 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( __cdecl * const ) ( _Arg0, _Arg1 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * const ) ( _Arg0, _Arg1 ), true > >





   , binary_function < _Arg0, _Arg1, _Rx >


 {
 typedef _Rx ( __cdecl * const _Fty ) ( _Arg0, _Arg1 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1 ), _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1 ) const, _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1 ) volatile, _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 368 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1 ) const volatile, _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ), _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) const, _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) volatile, _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) const volatile, _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx __cdecl ( _Arg0, _Arg1, _Arg2 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2 ), false > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2 ), true > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2 ), true > >








 {
 typedef _Rx ( __cdecl * const _Fty ) ( _Arg0, _Arg1, _Arg2 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 368 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx __cdecl ( _Arg0, _Arg1, _Arg2, _Arg3 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3 ), false > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3 ), true > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3 ), true > >








 {
 typedef _Rx ( __cdecl * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 368 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx __cdecl ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ), false > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ), true > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ), true > >








 {
 typedef _Rx ( __cdecl * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 368 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx __cdecl ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), false > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), true > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), true > >








 {
 typedef _Rx ( __cdecl * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 368 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx __cdecl ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), false > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), true > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), true > >








 {
 typedef _Rx ( __cdecl * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 368 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx __cdecl ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), false > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), true > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), true > >








 {
 typedef _Rx ( __cdecl * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 368 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx __cdecl ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), false > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), true > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), true > >








 {
 typedef _Rx ( __cdecl * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 368 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx __cdecl ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), false > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), true > >








 {
 typedef _Rx ( __cdecl * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( __cdecl * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), true > >








 {
 typedef _Rx ( __cdecl * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 368 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 413 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xrefwrap"
template < class _Ty >
 class reference_wrapper
 : public _Refwrap_impl < _Ty >
 {
public :
 typedef _Refwrap_impl < _Ty > _MyBase;
 typedef _Ty type;

 reference_wrapper ( _Ty & _Val )
  : _MyBase ( _Val )
  {
  }

 operator _Ty & ( ) const
  {
  return ( this -> _Get ( ) );
  }

 _Ty & get ( ) const
  {
  return ( this -> _Get ( ) );
  }
 };
#line 438
template < class _Ty >
 reference_wrapper < _Ty > ref ( _Ty & _Val )
 {
 return ( reference_wrapper < _Ty > ( _Val ) );
 }
#line 444
template< class _Ty> void ref(const _Ty && ); 
#line 447
template < class _Ty >
 reference_wrapper < _Ty > ref ( reference_wrapper < _Ty > _Val )
 {
 return ( _Val );
 }
#line 453
template < class _Ty >
 reference_wrapper < const _Ty > cref ( const _Ty & _Val )
 {
 return ( reference_wrapper < const _Ty > ( _Val ) );
 }
#line 462
template < class _Ty >
 reference_wrapper < const _Ty > cref ( reference_wrapper < const _Ty > _Val )
 {
 return ( _Val );
 }
#line 467
}
#line 468
}
#line 470
#pragma warning(pop)
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\functional"
#pragma warning(disable: 4100 4180 4244)
#line 471 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xrefwrap"
#pragma pack ( pop )
#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\functional"
namespace std { 
#line 22
namespace tr1 { 
#line 25
template < class _Rx,
 class _Arg0 >
 _Call_wrapper < _Callable_pmd < _Rx _Arg0 :: * const, _Arg0 > >
  mem_fn ( _Rx _Arg0 :: * const _Pmd )
 {
 return ( _Call_wrapper < _Callable_pmd < _Rx _Arg0 :: * const, _Arg0 > > ( _Pmd ) );
 }
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0 >
 class _Mem_fn1
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >

   , public :: std :: unary_function < _Arg0 *, _Rx >





 {
public :
 typedef _Rx result_type;

 _Mem_fn1 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ), _Arg0 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( ) )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ),
  _Arg0 > ( _Pm ) );
 }
#line 82
template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ) const,
  const _Arg0 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( ) const )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ) const,
  const _Arg0 > ( _Pm ) );
 }
#line 140
template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ) volatile,
  volatile _Arg0 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( ) volatile )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ) volatile,
  volatile _Arg0 > ( _Pm ) );
 }
#line 198
template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ) const volatile,
  const volatile _Arg0 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( ) const volatile )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ) const volatile,
  const volatile _Arg0 > ( _Pm ) );
 }
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1 >
 class _Mem_fn2
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >




   , public :: std :: binary_function < _Arg0 *, _Arg1, _Rx >


 {
public :
 typedef _Rx result_type;

 _Mem_fn2 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ), _Arg0, _Arg1 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1 ) )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ),
  _Arg0, _Arg1 > ( _Pm ) );
 }
#line 82
template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) const,
  const _Arg0, _Arg1 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1 ) const )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) const,
  const _Arg0, _Arg1 > ( _Pm ) );
 }
#line 140
template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) volatile,
  volatile _Arg0, _Arg1 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1 ) volatile )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) volatile,
  volatile _Arg0, _Arg1 > ( _Pm ) );
 }
#line 198
template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) const volatile,
  const volatile _Arg0, _Arg1 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1 ) const volatile )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) const volatile,
  const volatile _Arg0, _Arg1 > ( _Pm ) );
 }
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2 >
 class _Mem_fn3
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >







 {
public :
 typedef _Rx result_type;

 _Mem_fn3 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ), _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ),
  _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }
#line 82
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) const,
  const _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) const )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) const,
  const _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }
#line 140
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile,
  volatile _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) volatile )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile,
  volatile _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }
#line 198
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) const volatile )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 class _Mem_fn4
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >







 {
public :
 typedef _Rx result_type;

 _Mem_fn4 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ), _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ),
  _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }
#line 82
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) const )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }
#line 140
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) volatile )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }
#line 198
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) const volatile )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 class _Mem_fn5
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >







 {
public :
 typedef _Rx result_type;

 _Mem_fn5 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }
#line 82
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }
#line 140
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }
#line 198
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 class _Mem_fn6
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >







 {
public :
 typedef _Rx result_type;

 _Mem_fn6 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }
#line 82
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }
#line 140
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }
#line 198
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 class _Mem_fn7
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >







 {
public :
 typedef _Rx result_type;

 _Mem_fn7 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }
#line 82
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }
#line 140
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }
#line 198
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 class _Mem_fn8
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >







 {
public :
 typedef _Rx result_type;

 _Mem_fn8 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }
#line 82
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }
#line 140
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }
#line 198
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 class _Mem_fn9
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >







 {
public :
 typedef _Rx result_type;

 _Mem_fn9 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }
#line 82
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }
#line 140
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }
#line 198
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 class _Mem_fn10
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >







 {
public :
 typedef _Rx result_type;

 _Mem_fn10 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }
#line 82
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }
#line 140
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }
#line 198
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }
#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\functional"
typedef nullptr_t _Unutterable; 
#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\functional"
class bad_function_call : public exception { 
#line 73
public: explicit bad_function_call(const char * = 0) 
#line 74
{ 
#line 75
} 
#line 77
virtual const char *what() const throw() 
#line 78
{ 
#line 79
return "bad function call"; 
#line 80
} 
#line 81
}; 
#line 83
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xfunc(); 
#line 85
template< class _Tx> struct _Get_function_impl; 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template < class _Rx >
 class _Impl_base0
 {
public :
 virtual _Impl_base0 * _Copy ( void * ) = 0;
 virtual _Rx _Do_call ( ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base0 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };
#line 33
template < class _Callable,
 class _Rx >
 class _Impl_no_alloc0
  : public _Impl_base0 < _Rx >
 {
public :
 typedef _Impl_no_alloc0 _Myty;
 typedef :: std :: allocator < _Myty > _Myalty;

 _Impl_no_alloc0 ( typename _Callable :: _MyTy & _Val,
  _Myalty = _Myalty ( ) )
  : _Callee ( _Val )
  {
  }

 virtual ~ _Impl_no_alloc0 ( )
  {
  }

 virtual _Impl_base0 < _Rx > * _Copy ( void * _Where )
 {
 if ( _Where == 0 )
  {
  _Myalty _Al;
  _Where = _Al . allocate ( 1 );
  }
 new ( _Where ) _Impl_no_alloc0 ( * this );
 return ( ( _Impl_base0 < _Rx > * ) _Where );
 }

 _Rx _Do_call ( )
  {
  return ( _Callee . template _ApplyX < _Rx > ( ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 };
#line 91
template < class _Callable,
 class _Rx,
 class _Alloc >
 class _Impl0
  : public _Impl_no_alloc0 < _Callable, _Rx >
 {
public :
 typedef _Impl0 _Myty;
 typedef _Impl_no_alloc0 < _Callable, _Rx >
  _Mybase;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl0 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Mybase ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl0 ( )
  {
  }

 virtual _Impl_base0 < _Rx > * _Copy ( void * _Where )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl0 ( * this );
  return ( ( _Impl_base0 < _Rx > * ) _Where );
  }

private :
 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Myalty _Myal;
 };
#line 134
template < class _Ret >
 class _Function_impl0







 {
 typedef _Function_impl0 < _Ret > _Myty;
 typedef _Impl_base0 < _Ret > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( 0 ) );
  }

 void _Resetm ( _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   {
   _Set ( _Right . _Impl );
   _Right . _Set ( 0 );
   }
  }

 template < class _Fret >
  void _Reset ( _Fret ( __cdecl * const _Val ) ( ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( ) > _MyWrapper;
  typedef _Impl_no_alloc0 < _MyWrapper, _Ret >
   _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __cdecl * const _Val ) ( ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( ) > _MyWrapper;
  typedef _Impl0 < _MyWrapper, _Ret, _Alloc > _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret,
  class _Alloc >
  void _Reset0f ( _Fret ( __cdecl * const _Val ) ( ), _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



































































































































 template < class _Fty >
  void _Reset ( _Fty _Val )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl_no_alloc0 < _MyWrapper, _Ret >
   _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fty,
  class _Alloc >
  void _Reset_alloc ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl0 < _MyWrapper, _Ret, _Alloc > _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fty,
  class _Alloc >
  void _Reset0o ( _Fty _Val, _Alloc _Ax )
  {
  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myty & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( _Local ( ) )
   if ( _Right . _Local ( ) )
    {
    _Myty _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
  else
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    :: std :: swap ( _Impl, _Right . _Impl );
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 typedef void ( * _Pfnty ) ( );
 union _Space_union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  char _Alias [ 3 * sizeof ( void * ) ];
  } _Space;

 _Ptrt * _Impl;
 };
#line 1453 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template< class _Ret> 
#line 1454
struct _Get_function_impl< _Ret (void)>  { 
#line 1456
typedef _Function_impl0< _Ret>  _Type; 
#line 1457
}; 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template < class _Rx, class _Arg0 >
 class _Impl_base1
 {
public :
 virtual _Impl_base1 * _Copy ( void * ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base1 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };
#line 33
template < class _Callable,
 class _Rx, class _Arg0 >
 class _Impl_no_alloc1
  : public _Impl_base1 < _Rx, _Arg0 >
 {
public :
 typedef _Impl_no_alloc1 _Myty;
 typedef :: std :: allocator < _Myty > _Myalty;

 _Impl_no_alloc1 ( typename _Callable :: _MyTy & _Val,
  _Myalty = _Myalty ( ) )
  : _Callee ( _Val )
  {
  }

 virtual ~ _Impl_no_alloc1 ( )
  {
  }

 virtual _Impl_base1 < _Rx, _Arg0 > * _Copy ( void * _Where )
 {
 if ( _Where == 0 )
  {
  _Myalty _Al;
  _Where = _Al . allocate ( 1 );
  }
 new ( _Where ) _Impl_no_alloc1 ( * this );
 return ( ( _Impl_base1 < _Rx, _Arg0 > * ) _Where );
 }

 _Rx _Do_call ( _Arg0 _Ax0 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 };
#line 91
template < class _Callable,
 class _Rx, class _Arg0,
 class _Alloc >
 class _Impl1
  : public _Impl_no_alloc1 < _Callable, _Rx, _Arg0 >
 {
public :
 typedef _Impl1 _Myty;
 typedef _Impl_no_alloc1 < _Callable, _Rx, _Arg0 >
  _Mybase;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl1 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Mybase ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl1 ( )
  {
  }

 virtual _Impl_base1 < _Rx, _Arg0 > * _Copy ( void * _Where )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl1 ( * this );
  return ( ( _Impl_base1 < _Rx, _Arg0 > * ) _Where );
  }

private :
 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Myalty _Myal;
 };
#line 134
template < class _Ret, class _Arg0 >
 class _Function_impl1


  : public :: std :: unary_function < _Arg0, _Ret >




 {
 typedef _Function_impl1 < _Ret, _Arg0 > _Myty;
 typedef _Impl_base1 < _Ret, _Arg0 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( 0 ) );
  }

 void _Resetm ( _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   {
   _Set ( _Right . _Impl );
   _Right . _Set ( 0 );
   }
  }

 template < class _Fret, class _Farg0 >
  void _Reset ( _Fret ( __cdecl * const _Val ) ( _Farg0 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0 ) > _MyWrapper;
  typedef _Impl_no_alloc1 < _MyWrapper, _Ret, _Arg0 >
   _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __cdecl * const _Val ) ( _Farg0 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0 ) > _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0,
  class _Alloc >
  void _Reset0f ( _Fret ( __cdecl * const _Val ) ( _Farg0 ), _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



































































































































 template < class _Fty >
  void _Reset ( _Fty _Val )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl_no_alloc1 < _MyWrapper, _Ret, _Arg0 >
   _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fty,
  class _Alloc >
  void _Reset_alloc ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fty,
  class _Alloc >
  void _Reset0o ( _Fty _Val, _Alloc _Ax )
  {
  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }


 template < class _Fret,
  class _Farg0 >
  void _Reset ( _Fret _Farg0 :: * const _Val )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmd < _Fret _Farg0 :: * const, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc1 < _MyWrapper, _Ret, _Arg0 >
   _Myimpl;
  _Reset0pmd < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret,
  class _Farg0,
  class _Alloc >
  void _Reset_alloc ( _Fret _Farg0 :: * const _Val, _Alloc _Ax )
  {
  typedef _Callable_pmd < _Fret _Farg0 :: * const, _Farg0 > _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;
  _Reset0pmd < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret,
  class _Farg0,
  class _Alloc >
  void _Reset0pmd ( _Fret _Farg0 :: * const _Val, _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



 template < class _Fret, class _Farg0 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( ), _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc1 < _MyWrapper, _Ret, _Arg0 >
   _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( ),
   _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( ), _Farg0 >
   _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0,
  class _Alloc >
  void _Reset0pmf ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( ),
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( ) const )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( ) const, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc1 < _MyWrapper, _Ret, _Arg0 >
   _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( ) const, _Farg0 > _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0,
  class _Alloc >
  void _Reset0pmfc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( ) const,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( ) volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc1 < _MyWrapper, _Ret, _Arg0 >
   _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0,
  class _Alloc >
  void _Reset0pmfv ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( ) volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( ) const volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc1 < _MyWrapper, _Ret, _Arg0 >
   _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0,
  class _Alloc >
  void _Reset_alloc (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0,
  class _Alloc >
  void _Reset0pmfcv (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( ) const volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }










































































































































































































































































































































































































































































































































































































































































































































































 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myty & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( _Local ( ) )
   if ( _Right . _Local ( ) )
    {
    _Myty _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
  else
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    :: std :: swap ( _Impl, _Right . _Impl );
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 typedef void ( * _Pfnty ) ( );
 union _Space_union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  char _Alias [ 3 * sizeof ( void * ) ];
  } _Space;

 _Ptrt * _Impl;
 };
#line 1453 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template< class _Ret, class _Arg0> 
#line 1454
struct _Get_function_impl< _Ret (_Arg0)>  { 
#line 1456
typedef _Function_impl1< _Ret, _Arg0>  _Type; 
#line 1457
}; 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1 >
 class _Impl_base2
 {
public :
 virtual _Impl_base2 * _Copy ( void * ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base2 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };
#line 33
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1 >
 class _Impl_no_alloc2
  : public _Impl_base2 < _Rx, _Arg0, _Arg1 >
 {
public :
 typedef _Impl_no_alloc2 _Myty;
 typedef :: std :: allocator < _Myty > _Myalty;

 _Impl_no_alloc2 ( typename _Callable :: _MyTy & _Val,
  _Myalty = _Myalty ( ) )
  : _Callee ( _Val )
  {
  }

 virtual ~ _Impl_no_alloc2 ( )
  {
  }

 virtual _Impl_base2 < _Rx, _Arg0, _Arg1 > * _Copy ( void * _Where )
 {
 if ( _Where == 0 )
  {
  _Myalty _Al;
  _Where = _Al . allocate ( 1 );
  }
 new ( _Where ) _Impl_no_alloc2 ( * this );
 return ( ( _Impl_base2 < _Rx, _Arg0, _Arg1 > * ) _Where );
 }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 };
#line 91
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1,
 class _Alloc >
 class _Impl2
  : public _Impl_no_alloc2 < _Callable, _Rx, _Arg0, _Arg1 >
 {
public :
 typedef _Impl2 _Myty;
 typedef _Impl_no_alloc2 < _Callable, _Rx, _Arg0, _Arg1 >
  _Mybase;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl2 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Mybase ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl2 ( )
  {
  }

 virtual _Impl_base2 < _Rx, _Arg0, _Arg1 > * _Copy ( void * _Where )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl2 ( * this );
  return ( ( _Impl_base2 < _Rx, _Arg0, _Arg1 > * ) _Where );
  }

private :
 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Myalty _Myal;
 };
#line 134
template < class _Ret, class _Arg0, class _Arg1 >
 class _Function_impl2




  : public :: std :: binary_function < _Arg0, _Arg1, _Ret >


 {
 typedef _Function_impl2 < _Ret, _Arg0, _Arg1 > _Myty;
 typedef _Impl_base2 < _Ret, _Arg0, _Arg1 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( 0 ) );
  }

 void _Resetm ( _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   {
   _Set ( _Right . _Impl );
   _Right . _Set ( 0 );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1 >
  void _Reset ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1 ) > _MyWrapper;
  typedef _Impl_no_alloc2 < _MyWrapper, _Ret, _Arg0, _Arg1 >
   _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1 ) > _MyWrapper;
  typedef _Impl2 < _MyWrapper, _Ret, _Arg0, _Arg1, _Alloc > _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset0f ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1 ), _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



































































































































 template < class _Fty >
  void _Reset ( _Fty _Val )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl_no_alloc2 < _MyWrapper, _Ret, _Arg0, _Arg1 >
   _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fty,
  class _Alloc >
  void _Reset_alloc ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl2 < _MyWrapper, _Ret, _Arg0, _Arg1, _Alloc > _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fty,
  class _Alloc >
  void _Reset0o ( _Fty _Val, _Alloc _Ax )
  {
  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }
















































 template < class _Fret, class _Farg0, class _Farg1 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1 ), _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc2 < _MyWrapper, _Ret, _Arg0, _Arg1 >
   _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ),
   _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1 ), _Farg0 >
   _MyWrapper;
  typedef _Impl2 < _MyWrapper, _Ret, _Arg0, _Arg1, _Alloc > _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset0pmf ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ),
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) const )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1 ) const, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc2 < _MyWrapper, _Ret, _Arg0, _Arg1 >
   _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1 ) const, _Farg0 > _MyWrapper;
  typedef _Impl2 < _MyWrapper, _Ret, _Arg0, _Arg1, _Alloc > _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset0pmfc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) const,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc2 < _MyWrapper, _Ret, _Arg0, _Arg1 >
   _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl2 < _MyWrapper, _Ret, _Arg0, _Arg1, _Alloc > _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset0pmfv ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) const volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc2 < _MyWrapper, _Ret, _Arg0, _Arg1 >
   _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset_alloc (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl2 < _MyWrapper, _Ret, _Arg0, _Arg1, _Alloc > _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset0pmfcv (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) const volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }










































































































































































































































































































































































































































































































































































































































































































































































 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myty & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( _Local ( ) )
   if ( _Right . _Local ( ) )
    {
    _Myty _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
  else
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    :: std :: swap ( _Impl, _Right . _Impl );
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 typedef void ( * _Pfnty ) ( );
 union _Space_union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  char _Alias [ 3 * sizeof ( void * ) ];
  } _Space;

 _Ptrt * _Impl;
 };
#line 1453 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template< class _Ret, class _Arg0, class _Arg1> 
#line 1454
struct _Get_function_impl< _Ret (_Arg0, _Arg1)>  { 
#line 1456
typedef _Function_impl2< _Ret, _Arg0, _Arg1>  _Type; 
#line 1457
}; 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2 >
 class _Impl_base3
 {
public :
 virtual _Impl_base3 * _Copy ( void * ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base3 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };
#line 33
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2 >
 class _Impl_no_alloc3
  : public _Impl_base3 < _Rx, _Arg0, _Arg1, _Arg2 >
 {
public :
 typedef _Impl_no_alloc3 _Myty;
 typedef :: std :: allocator < _Myty > _Myalty;

 _Impl_no_alloc3 ( typename _Callable :: _MyTy & _Val,
  _Myalty = _Myalty ( ) )
  : _Callee ( _Val )
  {
  }

 virtual ~ _Impl_no_alloc3 ( )
  {
  }

 virtual _Impl_base3 < _Rx, _Arg0, _Arg1, _Arg2 > * _Copy ( void * _Where )
 {
 if ( _Where == 0 )
  {
  _Myalty _Al;
  _Where = _Al . allocate ( 1 );
  }
 new ( _Where ) _Impl_no_alloc3 ( * this );
 return ( ( _Impl_base3 < _Rx, _Arg0, _Arg1, _Arg2 > * ) _Where );
 }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 };
#line 91
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2,
 class _Alloc >
 class _Impl3
  : public _Impl_no_alloc3 < _Callable, _Rx, _Arg0, _Arg1, _Arg2 >
 {
public :
 typedef _Impl3 _Myty;
 typedef _Impl_no_alloc3 < _Callable, _Rx, _Arg0, _Arg1, _Arg2 >
  _Mybase;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl3 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Mybase ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl3 ( )
  {
  }

 virtual _Impl_base3 < _Rx, _Arg0, _Arg1, _Arg2 > * _Copy ( void * _Where )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl3 ( * this );
  return ( ( _Impl_base3 < _Rx, _Arg0, _Arg1, _Arg2 > * ) _Where );
  }

private :
 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Myalty _Myal;
 };
#line 134
template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 class _Function_impl3







 {
 typedef _Function_impl3 < _Ret, _Arg0, _Arg1, _Arg2 > _Myty;
 typedef _Impl_base3 < _Ret, _Arg0, _Arg1, _Arg2 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( 0 ) );
  }

 void _Resetm ( _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   {
   _Set ( _Right . _Impl );
   _Right . _Set ( 0 );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2 >
  void _Reset ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2 ) > _MyWrapper;
  typedef _Impl_no_alloc3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2 >
   _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2 ) > _MyWrapper;
  typedef _Impl3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Alloc > _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset0f ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2 ), _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



































































































































 template < class _Fty >
  void _Reset ( _Fty _Val )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl_no_alloc3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2 >
   _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fty,
  class _Alloc >
  void _Reset_alloc ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Alloc > _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fty,
  class _Alloc >
  void _Reset0o ( _Fty _Val, _Alloc _Ax )
  {
  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }
















































 template < class _Fret, class _Farg0, class _Farg1, class _Farg2 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ), _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2 >
   _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ),
   _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ), _Farg0 >
   _MyWrapper;
  typedef _Impl3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Alloc > _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset0pmf ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ),
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) const )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) const, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2 >
   _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) const, _Farg0 > _MyWrapper;
  typedef _Impl3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Alloc > _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset0pmfc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) const,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2 >
   _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Alloc > _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset0pmfv ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) const volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2 >
   _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset_alloc (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Alloc > _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset0pmfcv (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) const volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }










































































































































































































































































































































































































































































































































































































































































































































































 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myty & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( _Local ( ) )
   if ( _Right . _Local ( ) )
    {
    _Myty _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
  else
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    :: std :: swap ( _Impl, _Right . _Impl );
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 typedef void ( * _Pfnty ) ( );
 union _Space_union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  char _Alias [ 3 * sizeof ( void * ) ];
  } _Space;

 _Ptrt * _Impl;
 };
#line 1453 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2> 
#line 1454
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2)>  { 
#line 1456
typedef _Function_impl3< _Ret, _Arg0, _Arg1, _Arg2>  _Type; 
#line 1457
}; 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 class _Impl_base4
 {
public :
 virtual _Impl_base4 * _Copy ( void * ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base4 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };
#line 33
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 class _Impl_no_alloc4
  : public _Impl_base4 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3 >
 {
public :
 typedef _Impl_no_alloc4 _Myty;
 typedef :: std :: allocator < _Myty > _Myalty;

 _Impl_no_alloc4 ( typename _Callable :: _MyTy & _Val,
  _Myalty = _Myalty ( ) )
  : _Callee ( _Val )
  {
  }

 virtual ~ _Impl_no_alloc4 ( )
  {
  }

 virtual _Impl_base4 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3 > * _Copy ( void * _Where )
 {
 if ( _Where == 0 )
  {
  _Myalty _Al;
  _Where = _Al . allocate ( 1 );
  }
 new ( _Where ) _Impl_no_alloc4 ( * this );
 return ( ( _Impl_base4 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3 > * ) _Where );
 }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 };
#line 91
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3,
 class _Alloc >
 class _Impl4
  : public _Impl_no_alloc4 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3 >
 {
public :
 typedef _Impl4 _Myty;
 typedef _Impl_no_alloc4 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3 >
  _Mybase;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl4 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Mybase ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl4 ( )
  {
  }

 virtual _Impl_base4 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3 > * _Copy ( void * _Where )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl4 ( * this );
  return ( ( _Impl_base4 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3 > * ) _Where );
  }

private :
 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Myalty _Myal;
 };
#line 134
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 class _Function_impl4







 {
 typedef _Function_impl4 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3 > _Myty;
 typedef _Impl_base4 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( 0 ) );
  }

 void _Resetm ( _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   {
   _Set ( _Right . _Impl );
   _Right . _Set ( 0 );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  void _Reset ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3 ) > _MyWrapper;
  typedef _Impl_no_alloc4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3 >
   _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3 ) > _MyWrapper;
  typedef _Impl4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Alloc > _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset0f ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3 ), _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



































































































































 template < class _Fty >
  void _Reset ( _Fty _Val )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl_no_alloc4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3 >
   _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fty,
  class _Alloc >
  void _Reset_alloc ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Alloc > _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fty,
  class _Alloc >
  void _Reset0o ( _Fty _Val, _Alloc _Ax )
  {
  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }
















































 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ), _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3 >
   _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ),
   _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ), _Farg0 >
   _MyWrapper;
  typedef _Impl4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Alloc > _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset0pmf ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ),
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) const )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3 >
   _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const, _Farg0 > _MyWrapper;
  typedef _Impl4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Alloc > _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset0pmfc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) const,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3 >
   _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Alloc > _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset0pmfv ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) const volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3 >
   _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset_alloc (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Alloc > _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset0pmfcv (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) const volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }










































































































































































































































































































































































































































































































































































































































































































































































 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myty & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( _Local ( ) )
   if ( _Right . _Local ( ) )
    {
    _Myty _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
  else
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    :: std :: swap ( _Impl, _Right . _Impl );
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 typedef void ( * _Pfnty ) ( );
 union _Space_union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  char _Alias [ 3 * sizeof ( void * ) ];
  } _Space;

 _Ptrt * _Impl;
 };
#line 1453 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 1454
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3)>  { 
#line 1456
typedef _Function_impl4< _Ret, _Arg0, _Arg1, _Arg2, _Arg3>  _Type; 
#line 1457
}; 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 class _Impl_base5
 {
public :
 virtual _Impl_base5 * _Copy ( void * ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base5 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };
#line 33
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 class _Impl_no_alloc5
  : public _Impl_base5 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
 {
public :
 typedef _Impl_no_alloc5 _Myty;
 typedef :: std :: allocator < _Myty > _Myalty;

 _Impl_no_alloc5 ( typename _Callable :: _MyTy & _Val,
  _Myalty = _Myalty ( ) )
  : _Callee ( _Val )
  {
  }

 virtual ~ _Impl_no_alloc5 ( )
  {
  }

 virtual _Impl_base5 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > * _Copy ( void * _Where )
 {
 if ( _Where == 0 )
  {
  _Myalty _Al;
  _Where = _Al . allocate ( 1 );
  }
 new ( _Where ) _Impl_no_alloc5 ( * this );
 return ( ( _Impl_base5 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > * ) _Where );
 }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 };
#line 91
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4,
 class _Alloc >
 class _Impl5
  : public _Impl_no_alloc5 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
 {
public :
 typedef _Impl5 _Myty;
 typedef _Impl_no_alloc5 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  _Mybase;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl5 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Mybase ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl5 ( )
  {
  }

 virtual _Impl_base5 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > * _Copy ( void * _Where )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl5 ( * this );
  return ( ( _Impl_base5 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > * ) _Where );
  }

private :
 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Myalty _Myal;
 };
#line 134
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 class _Function_impl5







 {
 typedef _Function_impl5 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _Myty;
 typedef _Impl_base5 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( 0 ) );
  }

 void _Resetm ( _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   {
   _Set ( _Right . _Impl );
   _Right . _Set ( 0 );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  void _Reset ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ) > _MyWrapper;
  typedef _Impl_no_alloc5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
   _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ) > _MyWrapper;
  typedef _Impl5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Alloc > _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset0f ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ), _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



































































































































 template < class _Fty >
  void _Reset ( _Fty _Val )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl_no_alloc5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
   _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fty,
  class _Alloc >
  void _Reset_alloc ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Alloc > _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fty,
  class _Alloc >
  void _Reset0o ( _Fty _Val, _Alloc _Ax )
  {
  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }
















































 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
   _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ),
   _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Farg0 >
   _MyWrapper;
  typedef _Impl5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Alloc > _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset0pmf ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ),
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
   _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const, _Farg0 > _MyWrapper;
  typedef _Impl5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Alloc > _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset0pmfc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
   _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Alloc > _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset0pmfv ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
   _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset_alloc (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Alloc > _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset0pmfcv (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }










































































































































































































































































































































































































































































































































































































































































































































































 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myty & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( _Local ( ) )
   if ( _Right . _Local ( ) )
    {
    _Myty _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
  else
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    :: std :: swap ( _Impl, _Right . _Impl );
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 typedef void ( * _Pfnty ) ( );
 union _Space_union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  char _Alias [ 3 * sizeof ( void * ) ];
  } _Space;

 _Ptrt * _Impl;
 };
#line 1453 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 1454
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4)>  { 
#line 1456
typedef _Function_impl5< _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4>  _Type; 
#line 1457
}; 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 class _Impl_base6
 {
public :
 virtual _Impl_base6 * _Copy ( void * ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base6 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };
#line 33
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 class _Impl_no_alloc6
  : public _Impl_base6 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
 {
public :
 typedef _Impl_no_alloc6 _Myty;
 typedef :: std :: allocator < _Myty > _Myalty;

 _Impl_no_alloc6 ( typename _Callable :: _MyTy & _Val,
  _Myalty = _Myalty ( ) )
  : _Callee ( _Val )
  {
  }

 virtual ~ _Impl_no_alloc6 ( )
  {
  }

 virtual _Impl_base6 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > * _Copy ( void * _Where )
 {
 if ( _Where == 0 )
  {
  _Myalty _Al;
  _Where = _Al . allocate ( 1 );
  }
 new ( _Where ) _Impl_no_alloc6 ( * this );
 return ( ( _Impl_base6 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > * ) _Where );
 }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 };
#line 91
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5,
 class _Alloc >
 class _Impl6
  : public _Impl_no_alloc6 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
 {
public :
 typedef _Impl6 _Myty;
 typedef _Impl_no_alloc6 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  _Mybase;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl6 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Mybase ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl6 ( )
  {
  }

 virtual _Impl_base6 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > * _Copy ( void * _Where )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl6 ( * this );
  return ( ( _Impl_base6 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > * ) _Where );
  }

private :
 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Myalty _Myal;
 };
#line 134
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 class _Function_impl6







 {
 typedef _Function_impl6 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _Myty;
 typedef _Impl_base6 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( 0 ) );
  }

 void _Resetm ( _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   {
   _Set ( _Right . _Impl );
   _Right . _Set ( 0 );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  void _Reset ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) > _MyWrapper;
  typedef _Impl_no_alloc6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
   _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) > _MyWrapper;
  typedef _Impl6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Alloc > _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset0f ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



































































































































 template < class _Fty >
  void _Reset ( _Fty _Val )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl_no_alloc6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
   _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fty,
  class _Alloc >
  void _Reset_alloc ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Alloc > _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fty,
  class _Alloc >
  void _Reset0o ( _Fty _Val, _Alloc _Ax )
  {
  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }
















































 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
   _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ),
   _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Farg0 >
   _MyWrapper;
  typedef _Impl6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Alloc > _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset0pmf ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ),
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
   _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const, _Farg0 > _MyWrapper;
  typedef _Impl6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Alloc > _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset0pmfc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
   _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Alloc > _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset0pmfv ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
   _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset_alloc (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Alloc > _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset0pmfcv (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }










































































































































































































































































































































































































































































































































































































































































































































































 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myty & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( _Local ( ) )
   if ( _Right . _Local ( ) )
    {
    _Myty _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
  else
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    :: std :: swap ( _Impl, _Right . _Impl );
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 typedef void ( * _Pfnty ) ( );
 union _Space_union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  char _Alias [ 3 * sizeof ( void * ) ];
  } _Space;

 _Ptrt * _Impl;
 };
#line 1453 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 1454
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5)>  { 
#line 1456
typedef _Function_impl6< _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5>  _Type; 
#line 1457
}; 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 class _Impl_base7
 {
public :
 virtual _Impl_base7 * _Copy ( void * ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base7 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };
#line 33
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 class _Impl_no_alloc7
  : public _Impl_base7 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
 {
public :
 typedef _Impl_no_alloc7 _Myty;
 typedef :: std :: allocator < _Myty > _Myalty;

 _Impl_no_alloc7 ( typename _Callable :: _MyTy & _Val,
  _Myalty = _Myalty ( ) )
  : _Callee ( _Val )
  {
  }

 virtual ~ _Impl_no_alloc7 ( )
  {
  }

 virtual _Impl_base7 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > * _Copy ( void * _Where )
 {
 if ( _Where == 0 )
  {
  _Myalty _Al;
  _Where = _Al . allocate ( 1 );
  }
 new ( _Where ) _Impl_no_alloc7 ( * this );
 return ( ( _Impl_base7 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > * ) _Where );
 }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 };
#line 91
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6,
 class _Alloc >
 class _Impl7
  : public _Impl_no_alloc7 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
 {
public :
 typedef _Impl7 _Myty;
 typedef _Impl_no_alloc7 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  _Mybase;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl7 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Mybase ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl7 ( )
  {
  }

 virtual _Impl_base7 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > * _Copy ( void * _Where )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl7 ( * this );
  return ( ( _Impl_base7 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > * ) _Where );
  }

private :
 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Myalty _Myal;
 };
#line 134
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 class _Function_impl7







 {
 typedef _Function_impl7 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _Myty;
 typedef _Impl_base7 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( 0 ) );
  }

 void _Resetm ( _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   {
   _Set ( _Right . _Impl );
   _Right . _Set ( 0 );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  void _Reset ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) > _MyWrapper;
  typedef _Impl_no_alloc7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
   _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) > _MyWrapper;
  typedef _Impl7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Alloc > _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset0f ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



































































































































 template < class _Fty >
  void _Reset ( _Fty _Val )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl_no_alloc7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
   _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fty,
  class _Alloc >
  void _Reset_alloc ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Alloc > _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fty,
  class _Alloc >
  void _Reset0o ( _Fty _Val, _Alloc _Ax )
  {
  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }
















































 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
   _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ),
   _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Farg0 >
   _MyWrapper;
  typedef _Impl7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Alloc > _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset0pmf ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ),
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
   _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const, _Farg0 > _MyWrapper;
  typedef _Impl7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Alloc > _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset0pmfc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
   _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Alloc > _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset0pmfv ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
   _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset_alloc (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Alloc > _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset0pmfcv (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }










































































































































































































































































































































































































































































































































































































































































































































































 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myty & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( _Local ( ) )
   if ( _Right . _Local ( ) )
    {
    _Myty _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
  else
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    :: std :: swap ( _Impl, _Right . _Impl );
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 typedef void ( * _Pfnty ) ( );
 union _Space_union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  char _Alias [ 3 * sizeof ( void * ) ];
  } _Space;

 _Ptrt * _Impl;
 };
#line 1453 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 1454
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6)>  { 
#line 1456
typedef _Function_impl7< _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6>  _Type; 
#line 1457
}; 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 class _Impl_base8
 {
public :
 virtual _Impl_base8 * _Copy ( void * ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base8 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };
#line 33
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 class _Impl_no_alloc8
  : public _Impl_base8 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
 {
public :
 typedef _Impl_no_alloc8 _Myty;
 typedef :: std :: allocator < _Myty > _Myalty;

 _Impl_no_alloc8 ( typename _Callable :: _MyTy & _Val,
  _Myalty = _Myalty ( ) )
  : _Callee ( _Val )
  {
  }

 virtual ~ _Impl_no_alloc8 ( )
  {
  }

 virtual _Impl_base8 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > * _Copy ( void * _Where )
 {
 if ( _Where == 0 )
  {
  _Myalty _Al;
  _Where = _Al . allocate ( 1 );
  }
 new ( _Where ) _Impl_no_alloc8 ( * this );
 return ( ( _Impl_base8 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > * ) _Where );
 }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 };
#line 91
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7,
 class _Alloc >
 class _Impl8
  : public _Impl_no_alloc8 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
 {
public :
 typedef _Impl8 _Myty;
 typedef _Impl_no_alloc8 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  _Mybase;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl8 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Mybase ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl8 ( )
  {
  }

 virtual _Impl_base8 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > * _Copy ( void * _Where )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl8 ( * this );
  return ( ( _Impl_base8 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > * ) _Where );
  }

private :
 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Myalty _Myal;
 };
#line 134
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 class _Function_impl8







 {
 typedef _Function_impl8 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _Myty;
 typedef _Impl_base8 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( 0 ) );
  }

 void _Resetm ( _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   {
   _Set ( _Right . _Impl );
   _Right . _Set ( 0 );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  void _Reset ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) > _MyWrapper;
  typedef _Impl_no_alloc8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
   _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) > _MyWrapper;
  typedef _Impl8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Alloc > _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset0f ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



































































































































 template < class _Fty >
  void _Reset ( _Fty _Val )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl_no_alloc8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
   _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fty,
  class _Alloc >
  void _Reset_alloc ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Alloc > _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fty,
  class _Alloc >
  void _Reset0o ( _Fty _Val, _Alloc _Ax )
  {
  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }
















































 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
   _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ),
   _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Farg0 >
   _MyWrapper;
  typedef _Impl8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Alloc > _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset0pmf ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ),
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
   _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const, _Farg0 > _MyWrapper;
  typedef _Impl8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Alloc > _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset0pmfc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
   _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Alloc > _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset0pmfv ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
   _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset_alloc (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Alloc > _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset0pmfcv (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }










































































































































































































































































































































































































































































































































































































































































































































































 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myty & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( _Local ( ) )
   if ( _Right . _Local ( ) )
    {
    _Myty _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
  else
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    :: std :: swap ( _Impl, _Right . _Impl );
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 typedef void ( * _Pfnty ) ( );
 union _Space_union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  char _Alias [ 3 * sizeof ( void * ) ];
  } _Space;

 _Ptrt * _Impl;
 };
#line 1453 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 1454
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7)>  { 
#line 1456
typedef _Function_impl8< _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7>  _Type; 
#line 1457
}; 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 class _Impl_base9
 {
public :
 virtual _Impl_base9 * _Copy ( void * ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base9 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };
#line 33
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 class _Impl_no_alloc9
  : public _Impl_base9 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
 {
public :
 typedef _Impl_no_alloc9 _Myty;
 typedef :: std :: allocator < _Myty > _Myalty;

 _Impl_no_alloc9 ( typename _Callable :: _MyTy & _Val,
  _Myalty = _Myalty ( ) )
  : _Callee ( _Val )
  {
  }

 virtual ~ _Impl_no_alloc9 ( )
  {
  }

 virtual _Impl_base9 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > * _Copy ( void * _Where )
 {
 if ( _Where == 0 )
  {
  _Myalty _Al;
  _Where = _Al . allocate ( 1 );
  }
 new ( _Where ) _Impl_no_alloc9 ( * this );
 return ( ( _Impl_base9 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > * ) _Where );
 }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 };
#line 91
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8,
 class _Alloc >
 class _Impl9
  : public _Impl_no_alloc9 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
 {
public :
 typedef _Impl9 _Myty;
 typedef _Impl_no_alloc9 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  _Mybase;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl9 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Mybase ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl9 ( )
  {
  }

 virtual _Impl_base9 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > * _Copy ( void * _Where )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl9 ( * this );
  return ( ( _Impl_base9 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > * ) _Where );
  }

private :
 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Myalty _Myal;
 };
#line 134
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 class _Function_impl9







 {
 typedef _Function_impl9 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _Myty;
 typedef _Impl_base9 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( 0 ) );
  }

 void _Resetm ( _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   {
   _Set ( _Right . _Impl );
   _Right . _Set ( 0 );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  void _Reset ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) > _MyWrapper;
  typedef _Impl_no_alloc9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
   _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) > _MyWrapper;
  typedef _Impl9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Alloc > _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset0f ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



































































































































 template < class _Fty >
  void _Reset ( _Fty _Val )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl_no_alloc9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
   _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fty,
  class _Alloc >
  void _Reset_alloc ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Alloc > _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fty,
  class _Alloc >
  void _Reset0o ( _Fty _Val, _Alloc _Ax )
  {
  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }
















































 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
   _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ),
   _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Farg0 >
   _MyWrapper;
  typedef _Impl9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Alloc > _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset0pmf ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ),
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
   _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const, _Farg0 > _MyWrapper;
  typedef _Impl9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Alloc > _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset0pmfc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
   _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Alloc > _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset0pmfv ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
   _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset_alloc (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Alloc > _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset0pmfcv (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }










































































































































































































































































































































































































































































































































































































































































































































































 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myty & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( _Local ( ) )
   if ( _Right . _Local ( ) )
    {
    _Myty _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
  else
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    :: std :: swap ( _Impl, _Right . _Impl );
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 typedef void ( * _Pfnty ) ( );
 union _Space_union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  char _Alias [ 3 * sizeof ( void * ) ];
  } _Space;

 _Ptrt * _Impl;
 };
#line 1453 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 1454
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8)>  { 
#line 1456
typedef _Function_impl9< _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8>  _Type; 
#line 1457
}; 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 class _Impl_base10
 {
public :
 virtual _Impl_base10 * _Copy ( void * ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base10 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };
#line 33
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 class _Impl_no_alloc10
  : public _Impl_base10 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
 {
public :
 typedef _Impl_no_alloc10 _Myty;
 typedef :: std :: allocator < _Myty > _Myalty;

 _Impl_no_alloc10 ( typename _Callable :: _MyTy & _Val,
  _Myalty = _Myalty ( ) )
  : _Callee ( _Val )
  {
  }

 virtual ~ _Impl_no_alloc10 ( )
  {
  }

 virtual _Impl_base10 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > * _Copy ( void * _Where )
 {
 if ( _Where == 0 )
  {
  _Myalty _Al;
  _Where = _Al . allocate ( 1 );
  }
 new ( _Where ) _Impl_no_alloc10 ( * this );
 return ( ( _Impl_base10 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > * ) _Where );
 }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 };
#line 91
template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9,
 class _Alloc >
 class _Impl10
  : public _Impl_no_alloc10 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
 {
public :
 typedef _Impl10 _Myty;
 typedef _Impl_no_alloc10 < _Callable, _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  _Mybase;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl10 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Mybase ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl10 ( )
  {
  }

 virtual _Impl_base10 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > * _Copy ( void * _Where )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl10 ( * this );
  return ( ( _Impl_base10 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > * ) _Where );
  }

private :
 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Dest_val ( _Al, this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Myalty _Myal;
 };
#line 134
template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 class _Function_impl10







 {
 typedef _Function_impl10 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _Myty;
 typedef _Impl_base10 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( 0 ) );
  }

 void _Resetm ( _Myty & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   {
   _Set ( _Right . _Impl );
   _Right . _Set ( 0 );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  void _Reset ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) > _MyWrapper;
  typedef _Impl_no_alloc10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
   _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) > _MyWrapper;
  typedef _Impl10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _Alloc > _Myimpl;
  _Reset0f < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset0f ( _Fret ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



































































































































 template < class _Fty >
  void _Reset ( _Fty _Val )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl_no_alloc10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
   _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fty,
  class _Alloc >
  void _Reset_alloc ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _Alloc > _Myimpl;
  _Reset0o < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fty,
  class _Alloc >
  void _Reset0o ( _Fty _Val, _Alloc _Ax )
  {
  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }
















































 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
   _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ),
   _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Farg0 >
   _MyWrapper;
  typedef _Impl10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _Alloc > _Myimpl;
  _Reset0pmf < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset0pmf ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ),
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
   _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const, _Farg0 > _MyWrapper;
  typedef _Impl10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _Alloc > _Myimpl;
  _Reset0pmfc < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset0pmfc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl_no_alloc10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
   _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset_alloc ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile, _Farg0 > _MyWrapper;
  typedef _Impl10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _Alloc > _Myimpl;
  _Reset0pmfv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset0pmfv ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  void _Reset ( _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile )
  {
  typedef :: std :: allocator < _Myty > _Alty0;
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl_no_alloc10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
   _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Alty0 ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset_alloc (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile, _Farg0 >
   _MyWrapper;
  typedef _Impl10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _Alloc > _Myimpl;
  _Reset0pmfcv < _Myimpl > ( _Val, _Ax );
  }

 template < class _Myimpl,
  class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset0pmfcv (
   _Fret ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile,
   _Alloc _Ax )
  {
  if ( _Val == 0 )
   _Set ( 0 );
  else if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }










































































































































































































































































































































































































































































































































































































































































































































































 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myty & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( _Local ( ) )
   if ( _Right . _Local ( ) )
    {
    _Myty _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
  else
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    :: std :: swap ( _Impl, _Right . _Impl );
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 typedef void ( * _Pfnty ) ( );
 union _Space_union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  char _Alias [ 3 * sizeof ( void * ) ];
  } _Space;

 _Ptrt * _Impl;
 };
#line 1453 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxfunction"
template< class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 1454
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9)>  { 
#line 1456
typedef _Function_impl10< _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9>  _Type; 
#line 1457
}; 
#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\functional"
template < class _Fty >
 class function
  : public _Get_function_impl < _Fty > :: _Type
 {
public :
 typedef function < _Fty > _Myt;
 typedef typename _Get_function_impl < _Fty > :: _Type _Mybase;

 function ( )
  {
  this -> _Reset ( );
  }

 function ( const _Myt & _Right )
  {
  this -> _Reset ( ( const _Mybase & ) _Right );
  }

 template < class _Fx >
  function ( _Fx _Func )
  {
  this -> _Reset ( _Func );
  }

 template < class _Fx,
  class _Alloc >
  function ( _Fx _Func, const _Alloc & _Ax )
  {
  this -> _Reset_alloc ( _Func, _Ax );
  }

 template < class _Fx >
  function ( reference_wrapper < _Fx > _Func )
  {
  this -> _Reset ( _Func );
  }

 template < class _Fx,
  class _Alloc >
  function ( reference_wrapper < _Fx > _Func, const _Alloc & _Ax )
  {
  this -> _Reset_alloc ( _Func, _Ax );
  }

 function ( _Unutterable )
  {
  this -> _Reset ( );
  }


 function ( int )
  {
  this -> _Reset ( );
  }


 ~ function ( )
  {
  this -> _Tidy ( );
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  if ( this != & _Right )
   {
   this -> _Tidy ( );
   this -> _Reset ( ( const _Mybase & ) _Right );
   }
  return ( * this );
  }

 function ( _Myt && _Right )
  {
  this -> _Resetm ( ( _Mybase & ) _Right );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   this -> _Tidy ( );
   this -> _Resetm ( ( _Mybase & ) _Right );
   }
  return ( * this );
  }

 template < class _Fx >
  _Myt & operator = ( _Fx _Func )
  {
  this -> _Tidy ( );
  this -> _Reset ( _Func );
  return ( * this );
  }

 function & operator = ( _Unutterable )
  {
  this -> _Tidy ( );
  this -> _Reset ( );
  return ( * this );
  }


 function & operator = ( int )
  {
  this -> _Tidy ( );
  this -> _Reset ( );
  return ( * this );
  }


 template < class _Fx >
  _Myt & operator = ( reference_wrapper < _Fx > _Func )
  {
  this -> _Tidy ( );
  this -> _Reset ( _Func );
  return ( * this );
  }

 template < class _Fx,
  class _Alloc >
  void assign ( _Fx _Func, const _Alloc & _Ax )
  {
  this -> _Tidy ( );
  this -> _Reset_alloc ( _Func, _Ax );
  }

 template < class _Fx,
  class _Alloc >
  void assign ( reference_wrapper < _Fx > _Func, const _Alloc & _Ax )
  {
  this -> _Tidy ( );
  this -> _Reset_alloc ( _Func, _Ax );
  }

 void swap ( _Myt & _Right )
  {
  this -> _Swap ( _Right );
  }

 operator :: std :: _Bool_type ( ) const
  {
  return ( ! this -> _Empty ( ) ? ( & :: std :: _Bool_struct :: _Member ) : 0 );
  }

 const type_info & target_type ( ) const
  {
  return ( this -> _Target_type ( ) );
  }

 template < class _Fty2 >
  _Fty2 * target ( )
  {
  return ( ( _Fty2 * ) this -> _Target ( typeid ( _Fty2 ) ) );
  }

 template < class _Fty2 >
  const _Fty2 * target ( ) const
  {
  return ( ( const _Fty2 * ) this -> _Target ( typeid ( _Fty2 ) ) );
  }

private :
 template < class _Fty2 >
  void operator == ( const function < _Fty2 > & );
 template < class _Fty2 >
  void operator != ( const function < _Fty2 > & );
 };
#line 263 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\functional"
template < class _Fty >
 void swap ( function < _Fty > & _Left, function < _Fty > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 270
template < class _Fty >
 bool operator == ( const function < _Fty > & _Other, _Unutterable )
 {
 return ( ! _Other );
 }
#line 276
template < class _Fty >
 bool operator == ( _Unutterable _Npc, const function < _Fty > & _Other )
 {
 return ( operator == ( _Other, _Npc ) );
 }
#line 282
template < class _Fty >
 bool operator != ( const function < _Fty > & _Other, _Unutterable _Npc )
 {
 return ( ! operator == ( _Other, _Npc ) );
 }
#line 288
template < class _Fty >
 bool operator != ( _Unutterable _Npc, const function < _Fty > & _Other )
 {
 return ( ! operator == ( _Other, _Npc ) );
 }
#line 296
template< int _Nx> 
#line 297
class _Ph { 
#line 299
}; 
#line 301
template< class _Tx> 
#line 302
struct is_placeholder { 
#line 304
static const int value = 0; 
#line 305
}; 
#line 307
template< int _Nx> 
#line 308
struct is_placeholder< _Ph< _Nx> >  { 
#line 310
static const int value = _Nx; 
#line 311
}; 
#line 314
template< class _Tx> 
#line 315
struct is_bind_expression { 
#line 317
static const bool value = false; 
#line 318
}; 
#line 321
struct _Notforced { 
#line 323
}; 
#line 326
template< class _Override, class 
#line 327
_Natural> 
#line 328
struct _Bindret { 
#line 330
typedef _Override _Type; 
#line 331
}; 
#line 333
template< class _Natural> 
#line 334
struct _Bindret< _Notforced, _Natural>  { 
#line 336
typedef _Natural _Type; 
#line 337
}; 
#line 340
template< bool _Has_nested, class 
#line 341
_Ty> struct _Wrap_result_type; 
#line 344
template< class _Ty> 
#line 345
struct _Wrap_result_type< false, _Ty>  { 
#line 347
}; 
#line 349
template< class _Ty> 
#line 350
struct _Wrap_result_type< true, _Ty>  { 
#line 352
typedef typename _Ty::result_type result_type; 
#line 353
}; 
#line 356
template < class _Ret,
 class _BindN >
 class _Bind_base
 {
public :
 typedef typename _BindN :: _MyTy _MyTy;
 typedef _BindN _MyBind;

 _Bind_base ( _BindN _B0 )
  : _Bx ( _B0 )
  {
  }
































 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }





 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }





























template < class _Carg0 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }





























template < class _Carg0, class _Carg1 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }






























template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }

































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }




































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }





































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5, _Carg6 && _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), :: std :: forward < _Carg6 > ( _CA6 ), _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5, _Carg6 && _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), :: std :: forward < _Carg6 > ( _CA6 ), _Nil_obj, _Nil_obj, _Nil_obj ) );
 }








































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5, _Carg6 && _CA6, _Carg7 && _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), :: std :: forward < _Carg6 > ( _CA6 ), :: std :: forward < _Carg7 > ( _CA7 ), _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5, _Carg6 && _CA6, _Carg7 && _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), :: std :: forward < _Carg6 > ( _CA6 ), :: std :: forward < _Carg7 > ( _CA7 ), _Nil_obj, _Nil_obj ) );
 }










































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Carg8, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5, _Carg6 && _CA6, _Carg7 && _CA7, _Carg8 && _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Carg8, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), :: std :: forward < _Carg6 > ( _CA6 ), :: std :: forward < _Carg7 > ( _CA7 ), :: std :: forward < _Carg8 > ( _CA8 ), _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Carg8, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5, _Carg6 && _CA6, _Carg7 && _CA7, _Carg8 && _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Carg8, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), :: std :: forward < _Carg6 > ( _CA6 ), :: std :: forward < _Carg7 > ( _CA7 ), :: std :: forward < _Carg8 > ( _CA8 ), _Nil_obj ) );
 }











































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Carg8, _Carg9 > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5, _Carg6 && _CA6, _Carg7 && _CA7, _Carg8 && _CA8, _Carg9 && _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Carg8, _Carg9 > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), :: std :: forward < _Carg6 > ( _CA6 ), :: std :: forward < _Carg7 > ( _CA7 ), :: std :: forward < _Carg8 > ( _CA8 ), :: std :: forward < _Carg9 > ( _CA9 ) ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Carg8, _Carg9 > :: _Type > :: _Type
  operator ( ) ( _Carg0 && _CA0, _Carg1 && _CA1, _Carg2 && _CA2, _Carg3 && _CA3, _Carg4 && _CA4, _Carg5 && _CA5, _Carg6 && _CA6, _Carg7 && _CA7, _Carg8 && _CA8, _Carg9 && _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   _Carg0, _Carg1, _Carg2, _Carg3, _Carg4, _Carg5, _Carg6, _Carg7, _Carg8, _Carg9 > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( :: std :: forward < _Carg0 > ( _CA0 ), :: std :: forward < _Carg1 > ( _CA1 ), :: std :: forward < _Carg2 > ( _CA2 ), :: std :: forward < _Carg3 > ( _CA3 ), :: std :: forward < _Carg4 > ( _CA4 ), :: std :: forward < _Carg5 > ( _CA5 ), :: std :: forward < _Carg6 > ( _CA6 ), :: std :: forward < _Carg7 > ( _CA7 ), :: std :: forward < _Carg8 > ( _CA8 ), :: std :: forward < _Carg9 > ( _CA9 ) ) );
 }
























private :
 _BindN _Bx;
 };
#line 376 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\functional"
template < class _Result_type,
 class _Ret,
 class _BindN >
 class _Bind
  : public _Bind_base < _Ret, _BindN >
 {
public :
 _Bind ( _BindN _B0 )
  : _Bind_base < _Ret, _BindN > ( _B0 )
  {
  }
 typedef _Result_type result_type;
 };
#line 390
template < class _Ret,
 class _BindN >
 class _Bind < _Notforced, _Ret, _BindN >
  : public _Bind_base < _Ret, _BindN >
 {
public :
 _Bind ( _BindN _B0 )
  : _Bind_base < _Ret, _BindN > ( _B0 )
  {
  }
 };
#line 402
template < class _Fty,
 class _Ret,
 class _BindN >
 class _Bind_fty
  : public _Wrap_result_type < ( sizeof ( :: std :: tr1 :: _Has_result_type ( ( _Fty * ) 0 ) ) == sizeof ( :: std :: tr1 :: _Yes ) ), _Fty >,
    public _Bind_base < _Ret, _BindN >
 {
public :
 _Bind_fty ( _BindN _B0 )
  : _Bind_base < _Ret, _BindN > ( _B0 )
  {
  }
 };
#line 417
template< class _Result_type, class 
#line 418
_Ret, class 
#line 419
_BindN> 
#line 420
struct is_bind_expression< _Bind< _Result_type, _Ret, _BindN> >  { 
#line 423
static const bool value = true; 
#line 424
}; 
#line 427
template< bool _Expr, int 
#line 428
_Nx> struct _Binder; 
#line 439
template<> struct _Binder< true, 0>  { 
#line 441
template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static typename _Arg ::
   _MyBind :: template _Return < _Barg0 &, _Barg1 &, _Barg2 &, _Barg3 &, _Barg4 &, _Barg5 &, _Barg6 &, _Barg7 &, _Barg8 &, _Barg9 & > :: _Type
    _Get ( _Arg _Ax, _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( _Ax ( _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) );
  }
#line 450
template< class _Arg, class 
#line 451
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
#line 452
struct _Ret { 
#line 456
typedef typename _Arg::_MyBind::template _Return< _Barg0, _Barg1, _Barg2, _Barg3, _Barg4, _Barg5, _Barg6, _Barg7, _Barg8, _Barg9> ::_Type _Type; 
#line 457
}; 
#line 458
}; 
#line 461
template<> struct _Binder< false, 0>  { 
#line 463
template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Arg & _Get ( _Arg & _Val, _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( _Val );
  }
#line 470
template< class _Arg, class 
#line 471
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
#line 472
struct _Ret { 
#line 474
typedef _Arg &_Type; 
#line 475
}; 
#line 476
}; 
#line 208 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template < class _Callable >
 class _Bind0
 {
public :
 typedef _Callable _MyCallable;
 typedef typename _Callable :: _MyTy _MyTy;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( ) > :: type _Type;
  };

 _Bind0 ( _MyTy & _Val )
  : _Callee ( _Val )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 _Bx0, _Barg1 _Bx1, _Barg2 _Bx2, _Barg3 _Bx3, _Barg4 _Bx4, _Barg5 _Bx5, _Barg6 _Bx6, _Barg7 _Bx7, _Barg8 _Bx8, _Barg9 _Bx9 ) const
  {
  return ( _Callee . template _ApplyX < _Ret > ( ) );
  }

 _MyCallable _Callee;
 };
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template< class _Result_type, class _Ret, class _BindTy> 
#line 305
struct _Result_of0< _Bind< _Result_type, _Ret, _BindTy> >  { 
#line 307
typedef _Ret _Type; 
#line 308
}; 
#line 310
template< class _Result_type, class _BindTy> 
#line 311
struct _Result_of0< _Bind< _Result_type, _Notforced, _BindTy> >  { 
#line 314
typedef typename _BindTy::template _Return< _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
#line 315
}; 
#line 317
template < class _Ret,
 class _Fty
      > inline
 _Bind < _Ret,
  _Ret,
  _Bind0 < _Callable_obj < _Fty > > >
   bind ( _Fty _Val )
 {
 typedef _Bind0 < _Callable_obj < _Fty > > _MyBind;
 return ( _Bind < _Ret, _Ret, _MyBind > ( _MyBind ( _Val ) ) );
 }
#line 329
template < class _Fty
      > inline
 _Bind_fty < _Fty,
  _Notforced,
  _Bind0 < _Callable_obj < _Fty > > >
   bind ( _Fty _Val )
 {
 typedef _Bind0 < _Callable_obj < _Fty > > _MyBind;
 return ( _Bind_fty < _Fty, _Notforced, _MyBind > ( _MyBind ( _Val ) ) );
 }
#line 341
template < class _Ret,
 class _Rx

      > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind0 < _Callable_fun < _Rx ( __cdecl * const ) ( ) > > >
  > :: type
   bind ( _Rx ( __cdecl * const _Val ) ( ) )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( ) > _Callable;
 typedef _Bind0 < _Callable > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val ) ) );
 }
#line 357
template < class _Rx

      > inline
 _Bind < _Rx,
  _Rx,
  _Bind0 < _Callable_fun < _Rx ( __cdecl * const ) ( ) > > >
   bind ( _Rx ( __cdecl * const _Val ) ( ) )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( ) > _Callable;
 typedef _Bind0 < _Callable > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val ) ) );
 }
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template<> struct _Binder< false, 1>  { 
#line 241
template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg0 & _Get ( _Arg, _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( _Bx0 );
  }
#line 248
template< class _Arg, class 
#line 249
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
#line 250
struct _Ret { 
#line 252
typedef _Barg0 _Type; 
#line 253
}; 
#line 254
}; 
#line 256
template < class _Callable,
 class _Arg0 >
 class _Bind1
  : public _Bind0 < _Callable >
 {
public :
 typedef _Bind1 < _Callable, _Arg0 > _Self;
 typedef _Binder < is_bind_expression < _Arg0 > :: value,
  is_placeholder < _Arg0 > :: value > _Binder0;
 typedef _Arg0 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind0 < _Callable > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0 ) > :: type _Type;
  };

 _Bind1 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0 )
  : _Vx0 ( _Ax0 ), _Bind0 < _Callable > ( _Val )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg0 _Vx0;
 };
#line 299
namespace placeholders { 
#line 300
static _Ph< 1>  _1; 
#line 301
}
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template< class _Result_type, class _Ret, class _BindTy, class _Arg0> 
#line 305
struct _Result_of1< _Bind< _Result_type, _Ret, _BindTy> , _Arg0>  { 
#line 307
typedef _Ret _Type; 
#line 308
}; 
#line 310
template< class _Result_type, class _BindTy, class _Arg0> 
#line 311
struct _Result_of1< _Bind< _Result_type, _Notforced, _BindTy> , _Arg0>  { 
#line 314
typedef typename _BindTy::template _Return< _Arg0, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
#line 315
}; 
#line 317
template < class _Ret,
 class _Fty
 , class _Arg0 > inline
 _Bind < _Ret,
  _Ret,
  _Bind1 < _Callable_obj < _Fty >, _Arg0 > >
   bind ( _Fty _Val, _Arg0 _Ax0 )
 {
 typedef _Bind1 < _Callable_obj < _Fty >, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _Ret, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 329
template < class _Fty
 , class _Arg0 > inline
 _Bind_fty < _Fty,
  _Notforced,
  _Bind1 < _Callable_obj < _Fty >, _Arg0 > >
   bind ( _Fty _Val, _Arg0 _Ax0 )
 {
 typedef _Bind1 < _Callable_obj < _Fty >, _Arg0 > _MyBind;
 return ( _Bind_fty < _Fty, _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 341
template < class _Ret,
 class _Rx
 , class _Farg0
 , class _Arg0 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind1 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0 ) >, _Arg0 > >
  > :: type
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0 ), _Arg0 _Ax0 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0 ) > _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 357
template < class _Rx
 , class _Farg0
 , class _Arg0 > inline
 _Bind < _Rx,
  _Rx,
  _Bind1 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0 ) >, _Arg0 > >
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0 ), _Arg0 _Ax0 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0 ) > _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 465
template < class _Ret,
 class _Rx,
 class _Farg0,
 class _Arg0 > inline
 _Bind < _Ret,
  _Rx,
  _Bind1 < _Callable_pmd < _Rx _Farg0 :: * const, _Farg0 >, _Arg0 > >
   bind ( _Rx _Farg0 :: * const _Val, _Arg0 _A0 )
 {
 typedef _Callable_pmd < _Rx _Farg0 :: * const, _Farg0 > _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _A0 ) ) );
 }
#line 479
template < class _Rx,
 class _Farg0,
 class _Arg0 > inline
 _Bind < _Notforced,
  _Rx,
  _Bind1 < _Callable_pmd < _Rx _Farg0 :: * const, _Farg0 >, _Arg0 > >
   bind ( _Rx _Farg0 :: * const _Val, _Arg0 _A0 )
 {
 typedef _Callable_pmd < _Rx _Farg0 :: * const, _Farg0 > _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Notforced, _Rx, _MyBind > ( _MyBind ( _Val, _A0 ) ) );
 }
#line 494 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template < class _Ret,
 class _Rx,
 class _Farg0,
 class _Arg0 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind1 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ), _Farg0 >,
    _Arg0 > >
  > :: type
    bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( ), _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ), _Farg0 >
  _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 512
template < class _Rx,
 class _Farg0,
 class _Arg0 > inline
 _Bind < _Rx,
  _Rx,
  _Bind1 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ), _Farg0 >,
   _Arg0 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( ), _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ), _Farg0 >
  _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 527
template < class _Ret,
 class _Rx,
 class _Farg0,
 class _Arg0 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind1 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ) const,
    _Farg0 >, _Arg0 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( ) const, _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ) const, _Farg0 >
  _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 545
template < class _Rx,
 class _Farg0,
 class _Arg0 > inline
 _Bind < _Rx,
  _Rx,
  _Bind1 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ) const,
   _Farg0 >, _Arg0 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( ) const, _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ) const, _Farg0 >
  _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 560
template < class _Ret,
 class _Rx,
 class _Farg0,
 class _Arg0 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind1 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ) volatile,
    _Farg0 >, _Arg0 > >
  > :: type
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( ) volatile, _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ) volatile, _Farg0 >
  _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 578
template < class _Rx,
 class _Farg0,
 class _Arg0 > inline
 _Bind < _Rx,
  _Rx,
  _Bind1 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ) volatile,
   _Farg0 >, _Arg0 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( ) volatile, _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ) volatile, _Farg0 >
  _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 593
template < class _Ret,
 class _Rx,
 class _Farg0,
 class _Arg0 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind1 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ) const volatile,
    _Farg0 >, _Arg0 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( )
    const volatile, _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 612
template < class _Rx,
 class _Farg0,
 class _Arg0 > inline
 _Bind < _Rx,
  _Rx,
  _Bind1 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ) const volatile,
   _Farg0 >, _Arg0 > >
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) (
     ) const volatile, _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template<> struct _Binder< false, 2>  { 
#line 241
template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg1 & _Get ( _Arg, _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( _Bx1 );
  }
#line 248
template< class _Arg, class 
#line 249
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
#line 250
struct _Ret { 
#line 252
typedef _Barg1 _Type; 
#line 253
}; 
#line 254
}; 
#line 256
template < class _Callable,
 class _Arg0, class _Arg1 >
 class _Bind2
  : public _Bind1 < _Callable, _Arg0 >
 {
public :
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _Self;
 typedef _Binder < is_bind_expression < _Arg1 > :: value,
  is_placeholder < _Arg1 > :: value > _Binder1;
 typedef _Arg1 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind1 < _Callable, _Arg0 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1 ) > :: type _Type;
  };

 _Bind2 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1 )
  : _Vx1 ( _Ax1 ), _Bind1 < _Callable, _Arg0 > ( _Val, _Ax0 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg1 _Vx1;
 };
#line 299
namespace placeholders { 
#line 300
static _Ph< 2>  _2; 
#line 301
}
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template< class _Result_type, class _Ret, class _BindTy, class _Arg0, class _Arg1> 
#line 305
struct _Result_of2< _Bind< _Result_type, _Ret, _BindTy> , _Arg0, _Arg1>  { 
#line 307
typedef _Ret _Type; 
#line 308
}; 
#line 310
template< class _Result_type, class _BindTy, class _Arg0, class _Arg1> 
#line 311
struct _Result_of2< _Bind< _Result_type, _Notforced, _BindTy> , _Arg0, _Arg1>  { 
#line 314
typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
#line 315
}; 
#line 317
template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1 > inline
 _Bind < _Ret,
  _Ret,
  _Bind2 < _Callable_obj < _Fty >, _Arg0, _Arg1 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Bind2 < _Callable_obj < _Fty >, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Ret, _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 329
template < class _Fty
 , class _Arg0, class _Arg1 > inline
 _Bind_fty < _Fty,
  _Notforced,
  _Bind2 < _Callable_obj < _Fty >, _Arg0, _Arg1 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Bind2 < _Callable_obj < _Fty >, _Arg0, _Arg1 > _MyBind;
 return ( _Bind_fty < _Fty, _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 341
template < class _Ret,
 class _Rx
 , class _Farg0, class _Farg1
 , class _Arg0, class _Arg1 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind2 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1 ) >, _Arg0, _Arg1 > >
  > :: type
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1 ), _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1 ) > _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 357
template < class _Rx
 , class _Farg0, class _Farg1
 , class _Arg0, class _Arg1 > inline
 _Bind < _Rx,
  _Rx,
  _Bind2 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1 ) >, _Arg0, _Arg1 > >
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1 ), _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1 ) > _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 494 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1,
 class _Arg0, class _Arg1 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind2 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ), _Farg0 >,
    _Arg0, _Arg1 > >
  > :: type
    bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ), _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ), _Farg0 >
  _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 512
template < class _Rx,
 class _Farg0, class _Farg1,
 class _Arg0, class _Arg1 > inline
 _Bind < _Rx,
  _Rx,
  _Bind2 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ), _Farg0 >,
   _Arg0, _Arg1 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ), _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ), _Farg0 >
  _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 527
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1,
 class _Arg0, class _Arg1 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind2 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ) const,
    _Farg0 >, _Arg0, _Arg1 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) const, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ) const, _Farg0 >
  _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 545
template < class _Rx,
 class _Farg0, class _Farg1,
 class _Arg0, class _Arg1 > inline
 _Bind < _Rx,
  _Rx,
  _Bind2 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ) const,
   _Farg0 >, _Arg0, _Arg1 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) const, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ) const, _Farg0 >
  _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 560
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1,
 class _Arg0, class _Arg1 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind2 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ) volatile,
    _Farg0 >, _Arg0, _Arg1 > >
  > :: type
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 578
template < class _Rx,
 class _Farg0, class _Farg1,
 class _Arg0, class _Arg1 > inline
 _Bind < _Rx,
  _Rx,
  _Bind2 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ) volatile,
   _Farg0 >, _Arg0, _Arg1 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 593
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1,
 class _Arg0, class _Arg1 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind2 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ) const volatile,
    _Farg0 >, _Arg0, _Arg1 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 612
template < class _Rx,
 class _Farg0, class _Farg1,
 class _Arg0, class _Arg1 > inline
 _Bind < _Rx,
  _Rx,
  _Bind2 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ) const volatile,
   _Farg0 >, _Arg0, _Arg1 > >
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) (
     _Farg1 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template<> struct _Binder< false, 3>  { 
#line 241
template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg2 & _Get ( _Arg, _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( _Bx2 );
  }
#line 248
template< class _Arg, class 
#line 249
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
#line 250
struct _Ret { 
#line 252
typedef _Barg2 _Type; 
#line 253
}; 
#line 254
}; 
#line 256
template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2 >
 class _Bind3
  : public _Bind2 < _Callable, _Arg0, _Arg1 >
 {
public :
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _Self;
 typedef _Binder < is_bind_expression < _Arg2 > :: value,
  is_placeholder < _Arg2 > :: value > _Binder2;
 typedef _Arg2 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind2 < _Callable, _Arg0, _Arg1 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2 ) > :: type _Type;
  };

 _Bind3 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
  : _Vx2 ( _Ax2 ), _Bind2 < _Callable, _Arg0, _Arg1 > ( _Val, _Ax0, _Ax1 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg2 _Vx2;
 };
#line 299
namespace placeholders { 
#line 300
static _Ph< 3>  _3; 
#line 301
}
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template< class _Result_type, class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2> 
#line 305
struct _Result_of3< _Bind< _Result_type, _Ret, _BindTy> , _Arg0, _Arg1, _Arg2>  { 
#line 307
typedef _Ret _Type; 
#line 308
}; 
#line 310
template< class _Result_type, class _BindTy, class _Arg0, class _Arg1, class _Arg2> 
#line 311
struct _Result_of3< _Bind< _Result_type, _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2>  { 
#line 314
typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
#line 315
}; 
#line 317
template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2 > inline
 _Bind < _Ret,
  _Ret,
  _Bind3 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Bind3 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Ret, _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 329
template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2 > inline
 _Bind_fty < _Fty,
  _Notforced,
  _Bind3 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Bind3 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind_fty < _Fty, _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 341
template < class _Ret,
 class _Rx
 , class _Farg0, class _Farg1, class _Farg2
 , class _Arg0, class _Arg1, class _Arg2 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind3 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2 ) >, _Arg0, _Arg1, _Arg2 > >
  > :: type
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2 ) > _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 357
template < class _Rx
 , class _Farg0, class _Farg1, class _Farg2
 , class _Arg0, class _Arg1, class _Arg2 > inline
 _Bind < _Rx,
  _Rx,
  _Bind3 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2 ) >, _Arg0, _Arg1, _Arg2 > >
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2 ) > _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 494 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind3 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ), _Farg0 >,
    _Arg0, _Arg1, _Arg2 > >
  > :: type
    bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ), _Farg0 >
  _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 512
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2 > inline
 _Bind < _Rx,
  _Rx,
  _Bind3 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ), _Farg0 >
  _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 527
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind3 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) const,
    _Farg0 >, _Arg0, _Arg1, _Arg2 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) const, _Farg0 >
  _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 545
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2 > inline
 _Bind < _Rx,
  _Rx,
  _Bind3 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) const, _Farg0 >
  _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 560
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind3 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2 > >
  > :: type
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 578
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2 > inline
 _Bind < _Rx,
  _Rx,
  _Bind3 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 593
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind3 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) const volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 612
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2 > inline
 _Bind < _Rx,
  _Rx,
  _Bind3 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2 > >
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) (
   _Farg1, _Farg2 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template<> struct _Binder< false, 4>  { 
#line 241
template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg3 & _Get ( _Arg, _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( _Bx3 );
  }
#line 248
template< class _Arg, class 
#line 249
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
#line 250
struct _Ret { 
#line 252
typedef _Barg3 _Type; 
#line 253
}; 
#line 254
}; 
#line 256
template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 class _Bind4
  : public _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 >
 {
public :
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _Self;
 typedef _Binder < is_bind_expression < _Arg3 > :: value,
  is_placeholder < _Arg3 > :: value > _Binder3;
 typedef _Arg3 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3 ) > :: type _Type;
  };

 _Bind4 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
  : _Vx3 ( _Ax3 ), _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > ( _Val, _Ax0, _Ax1, _Ax2 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg3 _Vx3;
 };
#line 299
namespace placeholders { 
#line 300
static _Ph< 4>  _4; 
#line 301
}
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template< class _Result_type, class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 305
struct _Result_of4< _Bind< _Result_type, _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3>  { 
#line 307
typedef _Ret _Type; 
#line 308
}; 
#line 310
template< class _Result_type, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
#line 311
struct _Result_of4< _Bind< _Result_type, _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3>  { 
#line 314
typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
#line 315
}; 
#line 317
template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
 _Bind < _Ret,
  _Ret,
  _Bind4 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Bind4 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Ret, _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 329
template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
 _Bind_fty < _Fty,
  _Notforced,
  _Bind4 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Bind4 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind_fty < _Fty, _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 341
template < class _Ret,
 class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind4 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3 ) >, _Arg0, _Arg1, _Arg2, _Arg3 > >
  > :: type
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3 ) > _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 357
template < class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
 _Bind < _Rx,
  _Rx,
  _Bind4 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3 ) >, _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3 ) > _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 494 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind4 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ), _Farg0 >,
    _Arg0, _Arg1, _Arg2, _Arg3 > >
  > :: type
    bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ), _Farg0 >
  _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 512
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
 _Bind < _Rx,
  _Rx,
  _Bind4 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ), _Farg0 >
  _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 527
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind4 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const, _Farg0 >
  _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 545
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
 _Bind < _Rx,
  _Rx,
  _Bind4 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const, _Farg0 >
  _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 560
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind4 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3 > >
  > :: type
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 578
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
 _Bind < _Rx,
  _Rx,
  _Bind4 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 593
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind4 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 612
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 > inline
 _Bind < _Rx,
  _Rx,
  _Bind4 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3 > >
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template<> struct _Binder< false, 5>  { 
#line 241
template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg4 & _Get ( _Arg, _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( _Bx4 );
  }
#line 248
template< class _Arg, class 
#line 249
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
#line 250
struct _Ret { 
#line 252
typedef _Barg4 _Type; 
#line 253
}; 
#line 254
}; 
#line 256
template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 class _Bind5
  : public _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 >
 {
public :
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _Self;
 typedef _Binder < is_bind_expression < _Arg4 > :: value,
  is_placeholder < _Arg4 > :: value > _Binder4;
 typedef _Arg4 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3, _Barg4 ) > :: type _Type;
  };

 _Bind5 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
  : _Vx4 ( _Ax4 ), _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg4 _Vx4;
 };
#line 299
namespace placeholders { 
#line 300
static _Ph< 5>  _5; 
#line 301
}
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template< class _Result_type, class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 305
struct _Result_of5< _Bind< _Result_type, _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4>  { 
#line 307
typedef _Ret _Type; 
#line 308
}; 
#line 310
template< class _Result_type, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
#line 311
struct _Result_of5< _Bind< _Result_type, _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4>  { 
#line 314
typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
#line 315
}; 
#line 317
template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
 _Bind < _Ret,
  _Ret,
  _Bind5 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Bind5 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Ret, _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 329
template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
 _Bind_fty < _Fty,
  _Notforced,
  _Bind5 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Bind5 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind_fty < _Fty, _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 341
template < class _Ret,
 class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind5 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
  > :: type
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ) > _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 357
template < class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
 _Bind < _Rx,
  _Rx,
  _Bind5 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ) > _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 494 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind5 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Farg0 >,
    _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
  > :: type
    bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Farg0 >
  _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 512
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
 _Bind < _Rx,
  _Rx,
  _Bind5 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Farg0 >
  _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 527
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind5 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const, _Farg0 >
  _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 545
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
 _Bind < _Rx,
  _Rx,
  _Bind5 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const, _Farg0 >
  _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 560
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind5 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
  > :: type
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 578
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
 _Bind < _Rx,
  _Rx,
  _Bind5 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 593
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind5 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 612
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 > inline
 _Bind < _Rx,
  _Rx,
  _Bind5 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template<> struct _Binder< false, 6>  { 
#line 241
template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg5 & _Get ( _Arg, _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( _Bx5 );
  }
#line 248
template< class _Arg, class 
#line 249
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
#line 250
struct _Ret { 
#line 252
typedef _Barg5 _Type; 
#line 253
}; 
#line 254
}; 
#line 256
template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 class _Bind6
  : public _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
 {
public :
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _Self;
 typedef _Binder < is_bind_expression < _Arg5 > :: value,
  is_placeholder < _Arg5 > :: value > _Binder5;
 typedef _Arg5 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3, _Barg4, _Barg5 ) > :: type _Type;
  };

 _Bind6 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
  : _Vx5 ( _Ax5 ), _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg5 _Vx5;
 };
#line 299
namespace placeholders { 
#line 300
static _Ph< 6>  _6; 
#line 301
}
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template< class _Result_type, class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 305
struct _Result_of6< _Bind< _Result_type, _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5>  { 
#line 307
typedef _Ret _Type; 
#line 308
}; 
#line 310
template< class _Result_type, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
#line 311
struct _Result_of6< _Bind< _Result_type, _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5>  { 
#line 314
typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
#line 315
}; 
#line 317
template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
 _Bind < _Ret,
  _Ret,
  _Bind6 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Bind6 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Ret, _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 329
template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
 _Bind_fty < _Fty,
  _Notforced,
  _Bind6 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Bind6 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind_fty < _Fty, _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 341
template < class _Ret,
 class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind6 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
  > :: type
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) > _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 357
template < class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
 _Bind < _Rx,
  _Rx,
  _Bind6 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) > _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 494 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind6 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Farg0 >,
    _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
  > :: type
    bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Farg0 >
  _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 512
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
 _Bind < _Rx,
  _Rx,
  _Bind6 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Farg0 >
  _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 527
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind6 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const, _Farg0 >
  _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 545
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
 _Bind < _Rx,
  _Rx,
  _Bind6 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const, _Farg0 >
  _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 560
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind6 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
  > :: type
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 578
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
 _Bind < _Rx,
  _Rx,
  _Bind6 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 593
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind6 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 612
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 > inline
 _Bind < _Rx,
  _Rx,
  _Bind6 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template<> struct _Binder< false, 7>  { 
#line 241
template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg6 & _Get ( _Arg, _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( _Bx6 );
  }
#line 248
template< class _Arg, class 
#line 249
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
#line 250
struct _Ret { 
#line 252
typedef _Barg6 _Type; 
#line 253
}; 
#line 254
}; 
#line 256
template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 class _Bind7
  : public _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
 {
public :
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _Self;
 typedef _Binder < is_bind_expression < _Arg6 > :: value,
  is_placeholder < _Arg6 > :: value > _Binder6;
 typedef _Arg6 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3, _Barg4, _Barg5, _Barg6 ) > :: type _Type;
  };

 _Bind7 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
  : _Vx6 ( _Ax6 ), _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg6 _Vx6;
 };
#line 299
namespace placeholders { 
#line 300
static _Ph< 7>  _7; 
#line 301
}
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template< class _Result_type, class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 305
struct _Result_of7< _Bind< _Result_type, _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6>  { 
#line 307
typedef _Ret _Type; 
#line 308
}; 
#line 310
template< class _Result_type, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
#line 311
struct _Result_of7< _Bind< _Result_type, _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6>  { 
#line 314
typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
#line 315
}; 
#line 317
template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
 _Bind < _Ret,
  _Ret,
  _Bind7 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Bind7 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Ret, _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 329
template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
 _Bind_fty < _Fty,
  _Notforced,
  _Bind7 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Bind7 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind_fty < _Fty, _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 341
template < class _Ret,
 class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind7 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
  > :: type
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) > _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 357
template < class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
 _Bind < _Rx,
  _Rx,
  _Bind7 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) > _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 494 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind7 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Farg0 >,
    _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
  > :: type
    bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Farg0 >
  _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 512
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
 _Bind < _Rx,
  _Rx,
  _Bind7 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Farg0 >
  _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 527
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind7 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const, _Farg0 >
  _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 545
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
 _Bind < _Rx,
  _Rx,
  _Bind7 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const, _Farg0 >
  _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 560
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind7 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
  > :: type
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 578
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
 _Bind < _Rx,
  _Rx,
  _Bind7 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 593
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind7 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 612
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 > inline
 _Bind < _Rx,
  _Rx,
  _Bind7 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template<> struct _Binder< false, 8>  { 
#line 241
template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg7 & _Get ( _Arg, _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( _Bx7 );
  }
#line 248
template< class _Arg, class 
#line 249
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
#line 250
struct _Ret { 
#line 252
typedef _Barg7 _Type; 
#line 253
}; 
#line 254
}; 
#line 256
template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 class _Bind8
  : public _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
 {
public :
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _Self;
 typedef _Binder < is_bind_expression < _Arg7 > :: value,
  is_placeholder < _Arg7 > :: value > _Binder7;
 typedef _Arg7 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3, _Barg4, _Barg5, _Barg6, _Barg7 ) > :: type _Type;
  };

 _Bind8 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
  : _Vx7 ( _Ax7 ), _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder7 :: _Get ( this -> _Vx7, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder7 :: _Get ( this -> _Vx7, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg7 _Vx7;
 };
#line 299
namespace placeholders { 
#line 300
static _Ph< 8>  _8; 
#line 301
}
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template< class _Result_type, class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 305
struct _Result_of8< _Bind< _Result_type, _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7>  { 
#line 307
typedef _Ret _Type; 
#line 308
}; 
#line 310
template< class _Result_type, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
#line 311
struct _Result_of8< _Bind< _Result_type, _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7>  { 
#line 314
typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Nil &, _Nil &> ::_Type _Type; 
#line 315
}; 
#line 317
template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
 _Bind < _Ret,
  _Ret,
  _Bind8 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Bind8 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Ret, _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 329
template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
 _Bind_fty < _Fty,
  _Notforced,
  _Bind8 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Bind8 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind_fty < _Fty, _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 341
template < class _Ret,
 class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind8 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
  > :: type
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) > _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 357
template < class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
 _Bind < _Rx,
  _Rx,
  _Bind8 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) > _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 494 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind8 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Farg0 >,
    _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
  > :: type
    bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Farg0 >
  _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 512
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
 _Bind < _Rx,
  _Rx,
  _Bind8 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Farg0 >
  _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 527
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind8 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const, _Farg0 >
  _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 545
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
 _Bind < _Rx,
  _Rx,
  _Bind8 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const, _Farg0 >
  _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 560
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind8 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
  > :: type
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 578
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
 _Bind < _Rx,
  _Rx,
  _Bind8 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 593
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind8 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 612
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 > inline
 _Bind < _Rx,
  _Rx,
  _Bind8 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template<> struct _Binder< false, 9>  { 
#line 241
template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg8 & _Get ( _Arg, _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( _Bx8 );
  }
#line 248
template< class _Arg, class 
#line 249
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
#line 250
struct _Ret { 
#line 252
typedef _Barg8 _Type; 
#line 253
}; 
#line 254
}; 
#line 256
template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 class _Bind9
  : public _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
 {
public :
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _Self;
 typedef _Binder < is_bind_expression < _Arg8 > :: value,
  is_placeholder < _Arg8 > :: value > _Binder8;
 typedef _Arg8 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3, _Barg4, _Barg5, _Barg6, _Barg7, _Barg8 ) > :: type _Type;
  };

 _Bind9 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
  : _Vx8 ( _Ax8 ), _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder7 :: _Get ( this -> _Vx7, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder8 :: _Get ( this -> _Vx8, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder7 :: _Get ( this -> _Vx7, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder8 :: _Get ( this -> _Vx8, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg8 _Vx8;
 };
#line 299
namespace placeholders { 
#line 300
static _Ph< 9>  _9; 
#line 301
}
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template< class _Result_type, class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 305
struct _Result_of9< _Bind< _Result_type, _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8>  { 
#line 307
typedef _Ret _Type; 
#line 308
}; 
#line 310
template< class _Result_type, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
#line 311
struct _Result_of9< _Bind< _Result_type, _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8>  { 
#line 314
typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Nil &> ::_Type _Type; 
#line 315
}; 
#line 317
template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
 _Bind < _Ret,
  _Ret,
  _Bind9 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Bind9 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Ret, _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 329
template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
 _Bind_fty < _Fty,
  _Notforced,
  _Bind9 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Bind9 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind_fty < _Fty, _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 341
template < class _Ret,
 class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind9 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
  > :: type
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) > _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 357
template < class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
 _Bind < _Rx,
  _Rx,
  _Bind9 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) > _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 494 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind9 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Farg0 >,
    _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
  > :: type
    bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Farg0 >
  _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 512
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
 _Bind < _Rx,
  _Rx,
  _Bind9 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Farg0 >
  _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 527
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind9 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const, _Farg0 >
  _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 545
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
 _Bind < _Rx,
  _Rx,
  _Bind9 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const, _Farg0 >
  _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 560
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind9 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
  > :: type
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 578
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
 _Bind < _Rx,
  _Rx,
  _Bind9 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 593
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind9 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 612
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 > inline
 _Bind < _Rx,
  _Rx,
  _Bind9 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template<> struct _Binder< false, 10>  { 
#line 241
template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg9 & _Get ( _Arg, _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( _Bx9 );
  }
#line 248
template< class _Arg, class 
#line 249
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
#line 250
struct _Ret { 
#line 252
typedef _Barg9 _Type; 
#line 253
}; 
#line 254
}; 
#line 256
template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 class _Bind10
  : public _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
 {
public :
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _Self;
 typedef _Binder < is_bind_expression < _Arg9 > :: value,
  is_placeholder < _Arg9 > :: value > _Binder9;
 typedef _Arg9 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3, _Barg4, _Barg5, _Barg6, _Barg7, _Barg8, _Barg9 ) > :: type _Type;
  };

 _Bind10 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
  : _Vx9 ( _Ax9 ), _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder7 :: _Get ( this -> _Vx7, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder8 :: _Get ( this -> _Vx8, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder9 :: _Get ( this -> _Vx9, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 && _Bx0, _Barg1 && _Bx1, _Barg2 && _Bx2, _Barg3 && _Bx3, _Barg4 && _Bx4, _Barg5 && _Bx5, _Barg6 && _Bx6, _Barg7 && _Bx7, _Barg8 && _Bx8, _Barg9 && _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder7 :: _Get ( this -> _Vx7, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder8 :: _Get ( this -> _Vx8, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Binder9 :: _Get ( this -> _Vx9, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg9 _Vx9;
 };
#line 299
namespace placeholders { 
#line 300
static _Ph< 10>  _10; 
#line 301
}
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template< class _Result_type, class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 305
struct _Result_of10< _Bind< _Result_type, _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9>  { 
#line 307
typedef _Ret _Type; 
#line 308
}; 
#line 310
template< class _Result_type, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
#line 311
struct _Result_of10< _Bind< _Result_type, _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9>  { 
#line 314
typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9> ::_Type _Type; 
#line 315
}; 
#line 317
template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
 _Bind < _Ret,
  _Ret,
  _Bind10 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Bind10 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Ret, _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 329
template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
 _Bind_fty < _Fty,
  _Notforced,
  _Bind10 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Bind10 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind_fty < _Fty, _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 341
template < class _Ret,
 class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind10 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
  > :: type
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) > _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 357
template < class _Rx
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
 _Bind < _Rx,
  _Rx,
  _Bind10 < _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Rx ( __cdecl * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_fun < _Rx ( __cdecl * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) > _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 494 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\xxbind1"
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind10 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Farg0 >,
    _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
  > :: type
    bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Farg0 >
  _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 512
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
 _Bind < _Rx,
  _Rx,
  _Bind10 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Farg0 >
  _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 527
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind10 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const, _Farg0 >
  _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 545
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
 _Bind < _Rx,
  _Rx,
  _Bind10 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const, _Farg0 >
  _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 560
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind10 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
  > :: type
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 578
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
 _Bind < _Rx,
  _Rx,
  _Bind10 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 593
template < class _Ret,
 class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
 typename enable_if < ! is_same < _Ret, _Rx > :: value,
  _Bind < _Ret,
   _Rx,
   _Bind10 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile,
    _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
  > :: type
   bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Ret, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 612
template < class _Rx,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 > inline
 _Bind < _Rx,
  _Rx,
  _Bind10 < _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
  bind ( _Rx ( __thiscall _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( __thiscall _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Rx, _Rx, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 481 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\functional"
}
#line 484
using tr1::bad_function_call;
#line 485
using tr1::bind;
#line 486
using tr1::cref;
#line 487
using tr1::function;
#line 488
using tr1::is_bind_expression;
#line 489
using tr1::is_placeholder;
#line 490
using tr1::mem_fn;
#line 491
using tr1::ref;
#line 492
using tr1::reference_wrapper;
#line 493
using tr1::result_of;
#line 494
using tr1::swap;
#line 496
namespace placeholders { 
#line 497
using namespace tr1::placeholders;
#line 498
}
#line 500 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\functional"
}
#line 505 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\functional"
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\initializer_list"
#pragma warning(push,3)
#line 506 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\functional"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\initializer_list"
#pragma pack ( push, 8 )
#line 11
namespace std { 
#line 13
template < class _Elem >
 class initializer_list
 {
public :
 typedef _Elem value_type;
 typedef const _Elem & reference;
 typedef const _Elem & const_reference;
 typedef size_t size_type;

 typedef const _Elem * iterator;
 typedef const _Elem * const_iterator;

 initializer_list ( )
  : _First ( 0 ), _Last ( 0 )
  {
  }

 initializer_list ( const _Elem * _First_arg, const _Elem * _Last_arg )
  : _First ( _First_arg ), _Last ( _Last_arg )
  {
  }

 const _Elem * begin ( ) const
  {
  return ( _First );
  }

 const _Elem * end ( ) const
  {
  return ( _Last );
  }

 size_t size ( ) const
  {
  return ( ( size_t ) ( _Last - _First ) );
  }

private :
 const _Elem * _First;
 const _Elem * _Last;
 };
#line 56
template < class _Elem > inline
 const _Elem * begin ( initializer_list < _Elem > _Ilist )
 {
 return ( _Ilist . begin ( ) );
 }
#line 63
template < class _Elem > inline
 const _Elem * end ( initializer_list < _Elem > _Ilist )
 {
 return ( _Ilist . end ( ) );
 }
#line 68
}
#line 70
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iostream"
#pragma warning(push,3)
#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\initializer_list"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iostream"
#pragma pack ( push, 8 )
#line 10
namespace std { 
#line 25
__declspec(dllimport) extern istream cin, *_Ptr_cin; 
#line 26
__declspec(dllimport) extern ostream cout, *_Ptr_cout; 
#line 27
__declspec(dllimport) extern ostream cerr, *_Ptr_cerr; 
#line 28
__declspec(dllimport) extern ostream clog, *_Ptr_clog; 
#line 30
__declspec(dllimport) extern wistream wcin, *_Ptr_wcin; 
#line 31
__declspec(dllimport) extern wostream wcout, *_Ptr_wcout; 
#line 32
__declspec(dllimport) extern wostream wcerr, *_Ptr_wcerr; 
#line 33
__declspec(dllimport) extern wostream wclog, *_Ptr_wclog; 
#line 36
class __declspec(dllimport) _Winit { 
#line 38
public: __thiscall _Winit(); 
#line 39
__thiscall ~_Winit(); 
#line 41
private: static int _Init_cnt; 
#line 42
}; 
#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iostream"
}
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\numeric"
#pragma warning(push,3)
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\iostream"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\numeric"
#pragma pack ( push, 8 )
#line 10
namespace std { 
#line 12
template < class _InIt,
 class _Ty > inline
 _Ty _Accumulate ( _InIt _First, _InIt _Last, _Ty _Val )
 {
 for (; _First != _Last; ++ _First )
  _Val = ( _Ty ) ( _Val + * _First );
 return ( _Val );
 }
#line 21
template < class _InIt,
 class _Ty > inline
 _Ty accumulate ( _InIt _First, _InIt _Last, _Ty _Val )
 {
 ;
 return ( _Accumulate ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val ) );
 }
#line 30
template < class _InIt,
 class _Ty,
 class _Fn2 > inline
 _Ty _Accumulate ( _InIt _First, _InIt _Last, _Ty _Val, _Fn2 _Func )
 {
 for (; _First != _Last; ++ _First )
  _Val = _Func ( _Val, * _First );
 return ( _Val );
 }
#line 40
template < class _InIt,
 class _Ty,
 class _Fn2 > inline
 _Ty accumulate ( _InIt _First, _InIt _Last, _Ty _Val, _Fn2 _Func )
 {
 ;
 ;
 return ( _Accumulate ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val, _Func ) );
 }
#line 51
template < class _InIt1,
 class _InIt2,
 class _Ty > inline
 _Ty _Inner_product ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Ty _Val )
 {
 for (; _First1 != _Last1; ++ _First1, ++ _First2 )
  _Val = ( _Ty ) ( _Val + * _First1 * * _First2 );
 return ( _Val );
 }
#line 63
template < class _InIt1,
 class _InIt2,
 class _Ty > inline
 _Ty inner_product ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Ty _Val )
 {
 ;
 ;
 return ( _Inner_product ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _First2, _Val ) );
 }
#line 122 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\numeric"
template < class _InIt1,
 class _InIt2,
 class _Ty,
 class _Fn21,
 class _Fn22 > inline
 _Ty _Inner_product ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Ty _Val,
  _Fn21 _Func1, _Fn22 _Func2 )
 {
 for (; _First1 != _Last1; ++ _First1, ++ _First2 )
  _Val = _Func1 ( _Val, _Func2 ( * _First1, * _First2 ) );
 return ( _Val );
 }
#line 137
template < class _InIt1,
 class _InIt2,
 class _Ty,
 class _Fn21,
 class _Fn22 > inline
 _Ty inner_product ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Ty _Val,
  _Fn21 _Func1, _Fn22 _Func2 )
 {
 ;
 ;
 ;
 ;
 return ( _Inner_product ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _First2, _Val,
  _Func1, _Func2 ) );
 }
#line 220 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\numeric"
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt _Partial_sum ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Ty * )
 {
 _Ty _Val = * _First;
 for ( * _Dest = _Val; ++ _First != _Last; * ++ _Dest = _Val )
  _Val = ( _Ty ) ( _Val + * _First );
 return ( ++ _Dest );
 }
#line 233
template < class _InIt,
 class _OutIt > inline
 _OutIt partial_sum ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 return ( _First == _Last ? _Dest
  : _Partial_sum ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dest, _Val_type ( _First ) ) );
 }
#line 310 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\numeric"
template < class _InIt,
 class _OutIt,
 class _Fn2,
 class _Ty > inline
 _OutIt _Partial_sum ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn2 _Func, _Ty * )
 {
 _Ty _Val = * _First;
 for ( * _Dest = _Val; ++ _First != _Last; * ++ _Dest = _Val )
  _Val = _Func ( _Val, * _First );
 return ( ++ _Dest );
 }
#line 324
template < class _InIt,
 class _OutIt,
 class _Fn2 > inline
 _OutIt partial_sum ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn2 _Func )
 {
 return ( _First == _Last ? _Dest
  : _Partial_sum ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dest, _Func, _Val_type ( _First ) ) );
 }
#line 409 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\numeric"
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt _Adjacent_difference ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Ty * )
 {
 _Ty _Val = * _First;
 for ( * _Dest = _Val; ++ _First != _Last; )
  {
  _Ty _Tmp = * _First;
  * ++ _Dest = ( _Ty ) ( _Tmp - _Val );
  _Val = _Tmp;
  }
 return ( ++ _Dest );
 }
#line 426
template < class _InIt,
 class _OutIt > inline
 _OutIt adjacent_difference ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 return ( _First == _Last ? _Dest
  : _Adjacent_difference ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dest, _Val_type ( _First ) ) );
 }
#line 503 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\numeric"
template < class _InIt,
 class _OutIt,
 class _Fn2,
 class _Ty > inline
 _OutIt _Adjacent_difference ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn2 _Func, _Ty * )
 {
 _Ty _Val = * _First;
 for ( * _Dest = _Val; ++ _First != _Last; )
  {
  _Ty _Tmp = * _First;
  * ++ _Dest = _Func ( _Tmp, _Val );
  _Val = _Tmp;
  }
 return ( ++ _Dest );
 }
#line 521
template < class _InIt,
 class _OutIt,
 class _Fn2 > inline
 _OutIt adjacent_difference ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn2 _Func )
 {
 return ( _First == _Last ? _Dest
  : _Adjacent_difference ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Dest, _Func, _Val_type ( _First ) ) );
 }
#line 606 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\numeric"
template < class _FwdIt,
 class _Ty > inline
 void _Iota ( _FwdIt _First, _FwdIt _Last, _Ty _Val )
 {
 for (; _First != _Last; ++ _First, ++ _Val )
  * _First = _Val;
 }
#line 614
template < class _FwdIt,
 class _Ty > inline
 void iota ( _FwdIt _First, _FwdIt _Last, _Ty _Val )
 {
 ;
 _Iota ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val );
 }
#line 622 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\numeric"
}
#pragma warning(pop)
#pragma pack ( pop )
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\omp.h"
extern "C" { typedef void *omp_lock_t; }
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\omp.h"
extern "C" { typedef void *omp_nest_lock_t; }
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\omp.h"
#pragma comment(lib, "vcomp")
#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\omp.h"
extern "C" { 
#line 40
__declspec(dllimport) void __cdecl 
#line 41
omp_set_num_threads(int ); } 
#line 46
extern "C" { 
#line 45
__declspec(dllimport) int __cdecl 
#line 46
omp_get_num_threads(); } 
#line 51
extern "C" { 
#line 50
__declspec(dllimport) int __cdecl 
#line 51
omp_get_max_threads(); } 
#line 56
extern "C" { 
#line 55
__declspec(dllimport) int __cdecl 
#line 56
omp_get_thread_num(); } 
#line 61
extern "C" { 
#line 60
__declspec(dllimport) int __cdecl 
#line 61
omp_get_num_procs(); } 
#line 66
extern "C" { 
#line 65
__declspec(dllimport) void __cdecl 
#line 66
omp_set_dynamic(int ); } 
#line 71
extern "C" { 
#line 70
__declspec(dllimport) int __cdecl 
#line 71
omp_get_dynamic(); } 
#line 76
extern "C" { 
#line 75
__declspec(dllimport) int __cdecl 
#line 76
omp_in_parallel(); } 
#line 81
extern "C" { 
#line 80
__declspec(dllimport) void __cdecl 
#line 81
omp_set_nested(int ); } 
#line 86
extern "C" { 
#line 85
__declspec(dllimport) int __cdecl 
#line 86
omp_get_nested(); } 
#line 91
extern "C" { 
#line 90
__declspec(dllimport) void __cdecl 
#line 91
omp_init_lock(omp_lock_t * ); } 
#line 96
extern "C" { 
#line 95
__declspec(dllimport) void __cdecl 
#line 96
omp_destroy_lock(omp_lock_t * ); } 
#line 101
extern "C" { 
#line 100
__declspec(dllimport) void __cdecl 
#line 101
omp_set_lock(omp_lock_t * ); } 
#line 106
extern "C" { 
#line 105
__declspec(dllimport) void __cdecl 
#line 106
omp_unset_lock(omp_lock_t * ); } 
#line 111
extern "C" { 
#line 110
__declspec(dllimport) int __cdecl 
#line 111
omp_test_lock(omp_lock_t * ); } 
#line 116
extern "C" { 
#line 115
__declspec(dllimport) void __cdecl 
#line 116
omp_init_nest_lock(omp_nest_lock_t * ); } 
#line 121
extern "C" { 
#line 120
__declspec(dllimport) void __cdecl 
#line 121
omp_destroy_nest_lock(omp_nest_lock_t * ); } 
#line 126
extern "C" { 
#line 125
__declspec(dllimport) void __cdecl 
#line 126
omp_set_nest_lock(omp_nest_lock_t * ); } 
#line 131
extern "C" { 
#line 130
__declspec(dllimport) void __cdecl 
#line 131
omp_unset_nest_lock(omp_nest_lock_t * ); } 
#line 136
extern "C" { 
#line 135
__declspec(dllimport) int __cdecl 
#line 136
omp_test_nest_lock(omp_nest_lock_t * ); } 
#line 141
extern "C" { 
#line 140
__declspec(dllimport) double __cdecl 
#line 141
omp_get_wtime(); } 
#line 146
extern "C" { 
#line 145
__declspec(dllimport) double __cdecl 
#line 146
omp_get_wtick(); } 
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string"
#pragma warning(push,3)
#line 11
#pragma warning(disable: 4189)
#pragma warning(disable: 4172)
#line 8
#pragma pack ( push, 8 )
#line 14
namespace std { 
#line 16
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Left . size ( ) + _Right . size ( ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 30
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Traits :: length ( _Left ) + _Right . size ( ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 44
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( 1 + _Right . size ( ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 58
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Left . size ( ) + _Traits :: length ( _Right ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 72
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Left . size ( ) + 1 );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 86
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 return ( :: std :: move ( _Right . insert ( 0, _Left ) ) );
 }
#line 96
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( :: std :: move ( _Left . append ( _Right ) ) );
 }
#line 106
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 if ( _Right . size ( ) <= _Left . capacity ( ) - _Left . size ( )
  || _Right . capacity ( ) - _Right . size ( ) < _Left . size ( ) )
  return ( :: std :: move ( _Left . append ( _Right ) ) );
 else
  return ( :: std :: move ( _Right . insert ( 0, _Left ) ) );
 }
#line 120
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem * _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 return ( :: std :: move ( _Right . insert ( 0, _Left ) ) );
 }
#line 130
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 return ( :: std :: move ( _Right . insert ( 0, 1, _Left ) ) );
 }
#line 140
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  const _Elem * _Right )
 {
 return ( :: std :: move ( _Left . append ( _Right ) ) );
 }
#line 150
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  const _Elem _Right )
 {
 return ( :: std :: move ( _Left . append ( 1, _Right ) ) );
 }
#line 160
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator == (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Left . compare ( _Right ) == 0 );
 }
#line 170
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator == (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right . compare ( _Left ) == 0 );
 }
#line 180
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator == (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( _Left . compare ( _Right ) == 0 );
 }
#line 190
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator != (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 200
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator != (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 210
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator != (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 220
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator < (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Left . compare ( _Right ) < 0 );
 }
#line 230
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator < (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right . compare ( _Left ) > 0 );
 }
#line 240
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator < (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( _Left . compare ( _Right ) < 0 );
 }
#line 250
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator > (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right < _Left );
 }
#line 260
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator > (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right < _Left );
 }
#line 270
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator > (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( _Right < _Left );
 }
#line 280
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator <= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 290
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator <= (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 300
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator <= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 310
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator >= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 320
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator >= (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 330
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator >= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 341
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > && _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 typedef ctype < _Elem > _Ctype;
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;
 typedef typename _Mystr :: size_type _Mysizt;

 ios_base :: iostate _State = ios_base :: goodbit;
 bool _Changed = false;
 const typename _Myis :: sentry _Ok ( _Istr );

 if ( _Ok )
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( _Istr . getloc ( ) );
  _Str . erase ( );

  try {
  _Mysizt _Size = 0 < _Istr . width ( )
   && ( _Mysizt ) _Istr . width ( ) < _Str . max_size ( )
    ? ( _Mysizt ) _Istr . width ( ) : _Str . max_size ( );
  typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );

  for (; 0 < _Size; -- _Size, _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    {
    _State |= ios_base :: eofbit;
    break;
    }
   else if ( _Ctype_fac . is ( _Ctype :: space,
    _Traits :: to_char_type ( _Meta ) ) )
    break;
   else
    {
    _Str . append ( 1, _Traits :: to_char_type ( _Meta ) );
    _Changed = true;
    }
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Istr . width ( 0 );
 if ( ! _Changed )
  _State |= ios_base :: failbit;
 _Istr . setstate ( _State );
 return ( _Istr );
 }
#line 392
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & getline (
  basic_istream < _Elem, _Traits > && _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str,
  const _Elem _Delim )
 {
 typedef basic_istream < _Elem, _Traits > _Myis;

 ios_base :: iostate _State = ios_base :: goodbit;
 bool _Changed = false;
 const typename _Myis :: sentry _Ok ( _Istr, true );

 if ( _Ok )
  {
  try {
  _Str . erase ( );
  const typename _Traits :: int_type _Metadelim =
   _Traits :: to_int_type ( _Delim );
  typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );

  for (;; _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    {
    _State |= ios_base :: eofbit;
    break;
    }
   else if ( _Traits :: eq_int_type ( _Meta, _Metadelim ) )
    {
    _Changed = true;
    _Istr . rdbuf ( ) -> sbumpc ( );
    break;
    }
   else if ( _Str . max_size ( ) <= _Str . size ( ) )
    {
    _State |= ios_base :: failbit;
    break;
    }
   else
    {
    _Str += _Traits :: to_char_type ( _Meta );
    _Changed = true;
    }
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 if ( ! _Changed )
  _State |= ios_base :: failbit;
 _Istr . setstate ( _State );
 return ( _Istr );
 }
#line 445
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & getline (
  basic_istream < _Elem, _Traits > && _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 return ( getline ( _Istr, _Str, _Istr . widen ( '\n' ) ) );
 }
#line 455
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > & _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 return ( :: std :: move ( _Istr ) >> _Str );
 }
#line 465
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & getline (
  basic_istream < _Elem, _Traits > & _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str,
  const _Elem _Delim )
 {
 return ( getline ( :: std :: move ( _Istr ), _Str, _Delim ) );
 }
#line 476
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & getline (
  basic_istream < _Elem, _Traits > & _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 return ( getline ( :: std :: move ( _Istr ), _Str, _Istr . widen ( '\n' ) ) );
 }
#line 486
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr,
  const basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 typedef basic_ostream < _Elem, _Traits > _Myos;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;
 typedef typename _Mystr :: size_type _Mysizt;

 ios_base :: iostate _State = ios_base :: goodbit;
 _Mysizt _Size = _Str . size ( );
 _Mysizt _Pad = _Ostr . width ( ) <= 0 || ( _Mysizt ) _Ostr . width ( ) <= _Size
  ? 0 : ( _Mysizt ) _Ostr . width ( ) - _Size;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
 try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  if ( _State == ios_base :: goodbit
   && _Ostr . rdbuf ( ) -> sputn ( _Str . c_str ( ), _Size ) != ( streamsize ) _Size )
    _State |= ios_base :: badbit;
  else
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 537
inline int stoi(const string &_Str, size_t *_Idx = 0, int 
#line 538
_Base = 10) 
#line 539
{ 
#line 540
const char *_Ptr = _Str.c_str(); 
#line 541
char *_Eptr; 
#line 542
int _Errno = 0; 
#line 543
long _Ans = ::_Stolx(_Ptr, &_Eptr, _Base, &_Errno); 
#line 545
if (_Ptr == _Eptr) { 
#line 546
_Xinvalid_argument("invalid stoi argument"); }  
#line 547
if (_Errno || ((_Ans < ((-2147483647) - 1)) != ((2147483647) < _Ans))) { 
#line 548
_Xout_of_range("stoi argument out of range"); }  
#line 549
if (_Idx != (0)) { 
#line 550
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 551
return (int)_Ans; 
#line 552
} 
#line 554
inline long stol(const string &_Str, size_t *_Idx = 0, int 
#line 555
_Base = 10) 
#line 556
{ 
#line 557
const char *_Ptr = _Str.c_str(); 
#line 558
char *_Eptr; 
#line 559
int _Errno = 0; 
#line 560
long _Ans = ::_Stoulx(_Ptr, &_Eptr, _Base, &_Errno); 
#line 562
if (_Ptr == _Eptr) { 
#line 563
_Xinvalid_argument("invalid stol argument"); }  
#line 564
if (_Errno) { 
#line 565
_Xout_of_range("stol argument out of range"); }  
#line 566
if (_Idx != (0)) { 
#line 567
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 568
return _Ans; 
#line 569
} 
#line 571
inline unsigned long stoul(const string &_Str, size_t *_Idx = 0, int 
#line 572
_Base = 10) 
#line 573
{ 
#line 574
const char *_Ptr = _Str.c_str(); 
#line 575
char *_Eptr; 
#line 576
int _Errno = 0; 
#line 577
unsigned long _Ans = ::_Stoulx(_Ptr, &_Eptr, _Base, &_Errno); 
#line 579
if (_Ptr == _Eptr) { 
#line 580
_Xinvalid_argument("invalid stoul argument"); }  
#line 581
if (_Errno) { 
#line 582
_Xout_of_range("stoul argument out of range"); }  
#line 583
if (_Idx != (0)) { 
#line 584
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 585
return _Ans; 
#line 586
} 
#line 588
inline _Longlong stoll(const string &_Str, size_t *_Idx = 0, int 
#line 589
_Base = 10) 
#line 590
{ 
#line 591
const char *_Ptr = _Str.c_str(); 
#line 592
char *_Eptr; 
#line 593
int _Errno = 0; 
#line 594
_Longlong _Ans = ::_Stollx(_Ptr, &_Eptr, _Base, &_Errno); 
#line 596
if (_Ptr == _Eptr) { 
#line 597
_Xinvalid_argument("invalid stoll argument"); }  
#line 598
if (_Errno) { 
#line 599
_Xout_of_range("stoll argument out of range"); }  
#line 600
if (_Idx != (0)) { 
#line 601
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 602
return _Ans; 
#line 603
} 
#line 605
inline _ULonglong stoull(const string &_Str, size_t *_Idx = 0, int 
#line 606
_Base = 10) 
#line 607
{ 
#line 608
const char *_Ptr = _Str.c_str(); 
#line 609
int _Errno = 0; 
#line 610
char *_Eptr; 
#line 611
_ULonglong _Ans = ::_Stoullx(_Ptr, &_Eptr, _Base, &_Errno); 
#line 613
if (_Ptr == _Eptr) { 
#line 614
_Xinvalid_argument("invalid stoull argument"); }  
#line 615
if (_Errno) { 
#line 616
_Xout_of_range("stoull argument out of range"); }  
#line 617
if (_Idx != (0)) { 
#line 618
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 619
return _Ans; 
#line 620
} 
#line 622
inline float stof(const string &_Str, size_t *_Idx = 0) 
#line 623
{ 
#line 624
const char *_Ptr = _Str.c_str(); 
#line 625
int _Errno = 0; 
#line 626
char *_Eptr; 
#line 627
float _Ans = ::_Stofx(_Ptr, &_Eptr, 0, &_Errno); 
#line 629
if (_Ptr == _Eptr) { 
#line 630
_Xinvalid_argument("invalid stof argument"); }  
#line 631
if (_Errno) { 
#line 632
_Xout_of_range("stof argument out of range"); }  
#line 633
if (_Idx != (0)) { 
#line 634
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 635
return _Ans; 
#line 636
} 
#line 638
inline double stod(const string &_Str, size_t *_Idx = 0) 
#line 639
{ 
#line 640
const char *_Ptr = _Str.c_str(); 
#line 641
int _Errno = 0; 
#line 642
char *_Eptr; 
#line 643
double _Ans = ::_Stodx(_Ptr, &_Eptr, 0, &_Errno); 
#line 645
if (_Ptr == _Eptr) { 
#line 646
_Xinvalid_argument("invalid stod argument"); }  
#line 647
if (_Errno) { 
#line 648
_Xout_of_range("stod argument out of range"); }  
#line 649
if (_Idx != (0)) { 
#line 650
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 651
return _Ans; 
#line 652
} 
#line 654
inline long double stold(const string &_Str, size_t *_Idx = 0) 
#line 655
{ 
#line 656
const char *_Ptr = _Str.c_str(); 
#line 657
int _Errno = 0; 
#line 658
char *_Eptr; 
#line 659
long double _Ans = ::_Stoldx(_Ptr, &_Eptr, 0, &_Errno); 
#line 661
if (_Ptr == _Eptr) { 
#line 662
_Xinvalid_argument("invalid stold argument"); }  
#line 663
if (_Errno) { 
#line 664
_Xout_of_range("stold argument out of range"); }  
#line 665
if (_Idx != (0)) { 
#line 666
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 667
return _Ans; 
#line 668
} 
#line 672
inline string to_string(_Longlong _Val) 
#line 673
{ 
#line 674
char _Buf[2 * 32]; 
#line 676
::sprintf_s(_Buf, sizeof _Buf, "%I64d", _Val); 
#line 677
return ((string)(_Buf)); 
#line 678
} 
#line 680
inline string to_string(_ULonglong _Val) 
#line 681
{ 
#line 682
char _Buf[2 * 32]; 
#line 684
::sprintf_s(_Buf, sizeof _Buf, "%I64u", _Val); 
#line 685
return ((string)(_Buf)); 
#line 686
} 
#line 688
inline string to_string(long double _Val) 
#line 689
{ 
#line 690
char _Buf[(8 + 36) + 64]; 
#line 692
::sprintf_s(_Buf, sizeof _Buf, "%Lg", _Val); 
#line 693
return ((string)(_Buf)); 
#line 694
} 
#line 697
inline string _Narrow_str(wstring _Str) 
#line 698
{ 
#line 699
string _Ans; 
#line 701
for (const __wchar_t *_Ptr = _Str.c_str(); (*_Ptr) != 0; ++_Ptr) { 
#line 702
_Ans.push_back((char)::wctob(*_Ptr)); }  
#line 703
return _Ans; 
#line 704
} 
#line 706
inline int stoi(const wstring &_Str, size_t *_Idx = 0, int 
#line 707
_Base = 10) 
#line 708
{ 
#line 709
return stoi(_Narrow_str(_Str), _Idx, _Base); 
#line 710
} 
#line 712
inline long stol(const wstring &_Str, size_t *_Idx = 0, int 
#line 713
_Base = 10) 
#line 714
{ 
#line 715
return stol(_Narrow_str(_Str), _Idx, _Base); 
#line 716
} 
#line 718
inline unsigned long stoul(const wstring &_Str, size_t *_Idx = 0, int 
#line 719
_Base = 10) 
#line 720
{ 
#line 721
return stoul(_Narrow_str(_Str), _Idx, _Base); 
#line 722
} 
#line 724
inline _Longlong stoll(const wstring &_Str, size_t *_Idx = 0, int 
#line 725
_Base = 10) 
#line 726
{ 
#line 727
return stoll(_Narrow_str(_Str), _Idx, _Base); 
#line 728
} 
#line 730
inline _ULonglong stoull(const wstring &_Str, size_t *_Idx = 0, int 
#line 731
_Base = 10) 
#line 732
{ 
#line 733
return stoull(_Narrow_str(_Str), _Idx, _Base); 
#line 734
} 
#line 736
inline float stof(const wstring &_Str, size_t *_Idx = 0) 
#line 737
{ 
#line 738
return stof(_Narrow_str(_Str), _Idx); 
#line 739
} 
#line 741
inline double stod(const wstring &_Str, size_t *_Idx = 0) 
#line 742
{ 
#line 743
return stod(_Narrow_str(_Str), _Idx); 
#line 744
} 
#line 746
inline long double stold(const wstring &_Str, size_t *_Idx = 0) 
#line 747
{ 
#line 748
return stold(_Narrow_str(_Str), _Idx); 
#line 749
} 
#line 753
inline wstring to_wstring(_Longlong _Val) 
#line 754
{ 
#line 755
__wchar_t _Buf[2 * 32]; 
#line 757
::swprintf(_Buf, sizeof _Buf / sizeof ((_Buf)[0]), L"\x25\x49\x36\x34\x64", _Val); 
#line 759
return ((wstring)(_Buf)); 
#line 760
} 
#line 762
inline wstring to_wstring(_ULonglong _Val) 
#line 763
{ 
#line 764
__wchar_t _Buf[2 * 32]; 
#line 766
::swprintf(_Buf, sizeof _Buf / sizeof ((_Buf)[0]), L"\x25\x49\x36\x34\x75", _Val); 
#line 768
return ((wstring)(_Buf)); 
#line 769
} 
#line 771
inline wstring to_wstring(long double _Val) 
#line 772
{ 
#line 773
__wchar_t _Buf[(8 + 36) + 64]; 
#line 775
::swprintf(_Buf, sizeof _Buf / sizeof ((_Buf)[0]), L"\x25\x4c\x67", _Val); 
#line 777
return ((wstring)(_Buf)); 
#line 778
} 
#line 780 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string"
}
#line 782
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sstream"
#pragma warning(push,3)
#line 783 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\string"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sstream"
#pragma pack ( push, 8 )
#line 10
namespace std { 
#pragma warning(disable: 4251)
#line 14
template < class _Elem,
 class _Traits,
 class _Alloc >
 class basic_stringbuf
  : public basic_streambuf < _Elem, _Traits >
 {
public :
 typedef basic_stringbuf < _Elem, _Traits, _Alloc > _Myt;
 typedef _Alloc allocator_type;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;

 explicit basic_stringbuf ( ios_base :: openmode _Mode =
  ios_base :: in | ios_base :: out )
  {
  _Init ( 0, 0, _Getstate ( _Mode ) );
  }

 explicit basic_stringbuf ( const _Mystr & _Str,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  {
  _Init ( _Str . c_str ( ), _Str . size ( ), _Getstate ( _Mode ) );
  }

 basic_stringbuf ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   _Tidy ( );
   this -> swap ( _Right );
   }
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Mysb :: swap ( _Right );
   :: std :: swap ( _Seekhigh, _Right . _Seekhigh );
   :: std :: swap ( _Mystate, _Right . _Mystate );
   _Swap_adl ( _Al, _Right . _Al );
   }
  }

 void swap ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 virtual ~ basic_stringbuf ( )
  {
  _Tidy ( );
  }

 enum
  {
  _Allocated = 1,
  _Constant = 2,
  _Noread = 4,
  _Append = 8,
  _Atend = 16 };
 typedef int _Strstate;

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 _Mystr str ( ) const
  {
  if ( ! ( _Mystate & _Constant ) && _Mysb :: pptr ( ) != 0 )
   {
   _Mystr _Str ( _Mysb :: pbase ( ), ( _Seekhigh < _Mysb :: pptr ( )
    ? _Mysb :: pptr ( ) : _Seekhigh ) - _Mysb :: pbase ( ) );
   return ( _Str );
   }
  else if ( ! ( _Mystate & _Noread ) && _Mysb :: gptr ( ) != 0 )
   {
   _Mystr _Str ( _Mysb :: eback ( ), _Mysb :: egptr ( ) - _Mysb :: eback ( ) );
   return ( _Str );
   }
  else
   {
   _Mystr _Nul;
   return ( _Nul );
   }
  }

 void str ( const _Mystr & _Newstr )
  {
  _Tidy ( );
  _Init ( _Newstr . c_str ( ), _Newstr . size ( ), _Mystate );
  }

protected :
 virtual int_type overflow ( int_type _Meta = _Traits :: eof ( ) )
  {
  if ( _Mystate & _Append
   && _Mysb :: pptr ( ) != 0 && _Mysb :: pptr ( ) < _Seekhigh )
   _Mysb :: setp ( _Mysb :: pbase ( ), _Seekhigh, _Mysb :: epptr ( ) );

  if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   return ( _Traits :: not_eof ( _Meta ) );
  else if ( _Mysb :: pptr ( ) != 0
   && _Mysb :: pptr ( ) < _Mysb :: epptr ( ) )
   {
   * _Mysb :: _Pninc ( ) = _Traits :: to_char_type ( _Meta );
   return ( _Meta );
   }
  else if ( _Mystate & _Constant )
   return ( _Traits :: eof ( ) );
  else
   {
   size_t _Oldsize = _Mysb :: pptr ( ) == 0
    ? 0 : _Mysb :: epptr ( ) - _Mysb :: eback ( );
   size_t _Newsize = _Oldsize;
   size_t _Inc = _Newsize / 2 < _MINSIZE
    ? _MINSIZE : _Newsize / 2;

   while ( 0 < _Inc && 2147483647 - _Inc < _Newsize )
    _Inc /= 2;
   if ( _Inc == 0 )
    return ( _Traits :: eof ( ) );

   _Newsize += _Inc;

   _Elem * _Newptr = _Al . allocate ( _Newsize );
   _Elem * _Oldptr = _Mysb :: eback ( );

   if ( 0 < _Oldsize )
    _Traits :: copy ( _Newptr, _Oldptr, _Oldsize );

   if ( _Oldsize == 0 )
    {
    _Seekhigh = _Newptr;
    _Mysb :: setp ( _Newptr, _Newptr + _Newsize );
    if ( _Mystate & _Noread )
     _Mysb :: setg ( _Newptr, 0, _Newptr );
    else
     _Mysb :: setg ( _Newptr, _Newptr, _Newptr + 1 );
    }
   else
    {
    _Seekhigh = _Newptr + ( _Seekhigh - _Oldptr );
    _Mysb :: setp ( _Newptr + ( _Mysb :: pbase ( ) - _Oldptr ),
     _Newptr + ( _Mysb :: pptr ( ) - _Oldptr ),
     _Newptr + _Newsize );
    if ( _Mystate & _Noread )
     _Mysb :: setg ( _Newptr, 0, _Newptr );
    else
     _Mysb :: setg ( _Newptr,
      _Newptr + ( _Mysb :: gptr ( ) - _Oldptr ),
      _Mysb :: pptr ( ) + 1 );
    }

   if ( _Mystate & _Allocated )
    _Al . deallocate ( _Oldptr, _Oldsize );
   _Mystate |= _Allocated;

   * _Mysb :: _Pninc ( ) = _Traits :: to_char_type ( _Meta );
   return ( _Meta );
   }
  }

 virtual int_type pbackfail ( int_type _Meta = _Traits :: eof ( ) )
  {
  if ( _Mysb :: gptr ( ) == 0
   || _Mysb :: gptr ( ) <= _Mysb :: eback ( )
   || ! _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta )
   && ! _Traits :: eq ( _Traits :: to_char_type ( _Meta ), _Mysb :: gptr ( ) [ - 1 ] )
   && _Mystate & _Constant )
   return ( _Traits :: eof ( ) );
  else
   {
   _Mysb :: gbump ( - 1 );
   if ( ! _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    * _Mysb :: gptr ( ) = _Traits :: to_char_type ( _Meta );
   return ( _Traits :: not_eof ( _Meta ) );
   }
  }

 virtual int_type underflow ( )
  {
  if ( _Mysb :: gptr ( ) == 0 )
   return ( _Traits :: eof ( ) );
  else if ( _Mysb :: gptr ( ) < _Mysb :: egptr ( ) )
   return ( _Traits :: to_int_type ( * _Mysb :: gptr ( ) ) );
  else if ( _Mystate & _Noread || _Mysb :: pptr ( ) == 0
   || _Mysb :: pptr ( ) <= _Mysb :: gptr ( ) && _Seekhigh <= _Mysb :: gptr ( ) )
   return ( _Traits :: eof ( ) );
  else
   {
   if ( _Seekhigh < _Mysb :: pptr ( ) )
    _Seekhigh = _Mysb :: pptr ( );
   _Mysb :: setg ( _Mysb :: eback ( ), _Mysb :: gptr ( ), _Seekhigh );
   return ( _Traits :: to_int_type ( * _Mysb :: gptr ( ) ) );
   }
  }

 virtual pos_type seekoff ( off_type _Off,
  ios_base :: seekdir _Way,
  ios_base :: openmode _Which = ios_base :: in | ios_base :: out )
  {
  if ( _Mysb :: pptr ( ) != 0 && _Seekhigh < _Mysb :: pptr ( ) )
   _Seekhigh = _Mysb :: pptr ( );

  if ( _Which & ios_base :: in && _Mysb :: gptr ( ) != 0 )
   {
   if ( _Way == ios_base :: end )
    _Off += ( off_type ) ( _Seekhigh - _Mysb :: eback ( ) );
   else if ( _Way == ios_base :: cur
    && ( _Which & ios_base :: out ) == 0 )
    _Off += ( off_type ) ( _Mysb :: gptr ( ) - _Mysb :: eback ( ) );
   else if ( _Way != ios_base :: beg )
    _Off = _BADOFF;

   if ( 0 <= _Off && _Off <= _Seekhigh - _Mysb :: eback ( ) )
    {
    _Mysb :: gbump ( ( int ) ( _Mysb :: eback ( ) - _Mysb :: gptr ( ) + _Off ) );
    if ( _Which & ios_base :: out && _Mysb :: pptr ( ) != 0 )
     _Mysb :: setp ( _Mysb :: pbase ( ), _Mysb :: gptr ( ),
      _Mysb :: epptr ( ) );
    }
   else
    _Off = _BADOFF;
   }
  else if ( _Which & ios_base :: out && _Mysb :: pptr ( ) != 0 )
   {
   if ( _Way == ios_base :: end )
    _Off += ( off_type ) ( _Seekhigh - _Mysb :: eback ( ) );
   else if ( _Way == ios_base :: cur )
    _Off += ( off_type ) ( _Mysb :: pptr ( ) - _Mysb :: eback ( ) );
   else if ( _Way != ios_base :: beg )
    _Off = _BADOFF;

   if ( 0 <= _Off && _Off <= _Seekhigh - _Mysb :: eback ( ) )
    _Mysb :: pbump ( ( int ) ( _Mysb :: eback ( )
     - _Mysb :: pptr ( ) + _Off ) );
   else
    _Off = _BADOFF;
   }


  else if ( _Off != 0 )





   _Off = _BADOFF;
  return ( pos_type ( _Off ) );
  }

 virtual pos_type seekpos ( pos_type _Ptr,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  {
  streamoff _Off = ( streamoff ) _Ptr;
  if ( _Mysb :: pptr ( ) != 0 && _Seekhigh < _Mysb :: pptr ( ) )
   _Seekhigh = _Mysb :: pptr ( );

  if ( _Off == _BADOFF )
   ;
  else if ( _Mode & ios_base :: in && _Mysb :: gptr ( ) != 0 )
   {
   if ( 0 <= _Off && _Off <= _Seekhigh - _Mysb :: eback ( ) )
    {
    _Mysb :: gbump ( ( int ) ( _Mysb :: eback ( ) - _Mysb :: gptr ( ) + _Off ) );
    if ( _Mode & ios_base :: out && _Mysb :: pptr ( ) != 0 )
     _Mysb :: setp ( _Mysb :: pbase ( ), _Mysb :: gptr ( ),
      _Mysb :: epptr ( ) );
    }
   else
    _Off = _BADOFF;
   }
  else if ( _Mode & ios_base :: out && _Mysb :: pptr ( ) != 0 )
   {
   if ( 0 <= _Off && _Off <= _Seekhigh - _Mysb :: eback ( ) )
    _Mysb :: pbump ( ( int ) ( _Mysb :: eback ( )
     - _Mysb :: pptr ( ) + _Off ) );
   else
    _Off = _BADOFF;
   }
  else
   _Off = _BADOFF;
  return ( streampos ( _Off ) );
  }

 void _Init ( const _Elem * _Ptr,
  size_t _Count, _Strstate _State )
  {
  _Seekhigh = 0;
  _Mystate = _State;

  if ( _Count != 0
   && ( _Mystate & ( _Noread | _Constant ) ) != ( _Noread | _Constant ) )
   {
   _Elem * _Pnew = _Al . allocate ( _Count );
   _Traits :: copy ( _Pnew, _Ptr, _Count );
   _Seekhigh = _Pnew + _Count;

   if ( ! ( _Mystate & _Noread ) )
    _Mysb :: setg ( _Pnew, _Pnew,
     _Pnew + _Count );
   if ( ! ( _Mystate & _Constant ) )
    {
    _Mysb :: setp ( _Pnew,
     ( _Mystate & _Atend ) ? _Pnew + _Count : _Pnew,
     _Pnew + _Count );
    if ( _Mysb :: gptr ( ) == 0 )
     _Mysb :: setg ( _Pnew, 0, _Pnew );
    }
   _Mystate |= _Allocated;
   }
  }

 void _Tidy ( )
  {
  if ( _Mystate & _Allocated )
   _Al . deallocate ( _Mysb :: eback ( ),
    ( _Mysb :: pptr ( ) != 0 ? _Mysb :: epptr ( )
     : _Mysb :: egptr ( ) ) - _Mysb :: eback ( ) );
  _Mysb :: setg ( 0, 0, 0 );
  _Mysb :: setp ( 0, 0 );
  _Seekhigh = 0;
  _Mystate &= ~ _Allocated;
  }

private :
 enum
  {
  _MINSIZE = 32 };

 _Strstate _Getstate ( ios_base :: openmode _Mode )
  {
  _Strstate _State = ( _Strstate ) 0;
  if ( ! ( _Mode & ios_base :: in ) )
   _State |= _Noread;
  if ( ! ( _Mode & ios_base :: out ) )
   _State |= _Constant;
  if ( _Mode & ios_base :: app )
   _State |= _Append;
  if ( _Mode & ios_base :: ate )
   _State |= _Atend;
  return ( _State );
  }

 _Elem * _Seekhigh;
 _Strstate _Mystate;
 allocator_type _Al;
 };
#line 376 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sstream"
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_stringbuf < _Elem, _Traits, _Alloc > & _Left,
  basic_stringbuf < _Elem, _Traits, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 385
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_stringbuf < _Elem, _Traits, _Alloc > & _Left,
  basic_stringbuf < _Elem, _Traits, _Alloc > && _Right )
 {
 typedef basic_stringbuf < _Elem, _Traits, _Alloc > _Myt;
 _Left . swap ( :: std :: forward < _Myt > ( _Right ) );
 }
#line 395
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_stringbuf < _Elem, _Traits, _Alloc > && _Left,
  basic_stringbuf < _Elem, _Traits, _Alloc > & _Right )
 {
 typedef basic_stringbuf < _Elem, _Traits, _Alloc > _Myt;
 _Right . swap ( :: std :: forward < _Myt > ( _Left ) );
 }
#line 406
template < class _Elem,
 class _Traits,
 class _Alloc >
 class basic_istringstream
  : public basic_istream < _Elem, _Traits >
 {
public :
 typedef basic_istringstream < _Elem, _Traits, _Alloc > _Myt;
 typedef basic_istream < _Elem, _Traits > _Mybase;
 typedef _Alloc allocator_type;
 typedef basic_stringbuf < _Elem, _Traits, _Alloc > _Mysb;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;

 explicit basic_istringstream ( ios_base :: openmode _Mode = ios_base :: in )
  : _Mybase ( & _Stringbuffer ),
   _Stringbuffer ( _Mode | ios_base :: in )
  {
  }

 explicit basic_istringstream ( const _Mystr & _Str,
  ios_base :: openmode _Mode = ios_base :: in )
  : _Mybase ( & _Stringbuffer ),
   _Stringbuffer ( _Str, _Mode | ios_base :: in )
  {
  }

 basic_istringstream ( _Myt && _Right )
  : _Mybase ( & _Stringbuffer )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   _Stringbuffer . str ( _Mystr ( ) );
   this -> swap ( _Right );
   }
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Mybase :: swap ( _Right );
   _Stringbuffer . swap ( _Right . _Stringbuffer );
   }
  }

 void swap ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 virtual ~ basic_istringstream ( )
  {
  }

 _Mysb * rdbuf ( ) const
  {
  return ( ( _Mysb * ) & _Stringbuffer );
  }

 _Mystr str ( ) const
  {
  return ( _Stringbuffer . str ( ) );
  }

 void str ( const _Mystr & _Newstr )
  {
  _Stringbuffer . str ( _Newstr );
  }

private :
 _Mysb _Stringbuffer;
 };
#line 491
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_istringstream < _Elem, _Traits, _Alloc > & _Left,
  basic_istringstream < _Elem, _Traits, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 500
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_istringstream < _Elem, _Traits, _Alloc > & _Left,
  basic_istringstream < _Elem, _Traits, _Alloc > && _Right )
 {
 typedef basic_istringstream < _Elem, _Traits, _Alloc > _Myt;
 _Left . swap ( :: std :: forward < _Myt > ( _Right ) );
 }
#line 510
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_istringstream < _Elem, _Traits, _Alloc > && _Left,
  basic_istringstream < _Elem, _Traits, _Alloc > & _Right )
 {
 typedef basic_istringstream < _Elem, _Traits > _Myt;
 _Right . swap ( :: std :: forward < _Myt > ( _Left ) );
 }
#line 521
template < class _Elem,
 class _Traits,
 class _Alloc >
 class basic_ostringstream
  : public basic_ostream < _Elem, _Traits >
 {
public :
 typedef basic_ostringstream < _Elem, _Traits, _Alloc > _Myt;
 typedef basic_ostream < _Elem, _Traits > _Mybase;
 typedef _Alloc allocator_type;
 typedef basic_stringbuf < _Elem, _Traits, _Alloc > _Mysb;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;

 explicit basic_ostringstream ( ios_base :: openmode _Mode = ios_base :: out )
  : _Mybase ( & _Stringbuffer ),
   _Stringbuffer ( _Mode | ios_base :: out )
  {
  }

 explicit basic_ostringstream ( const _Mystr & _Str,
  ios_base :: openmode _Mode = ios_base :: out )
  : _Mybase ( & _Stringbuffer ),
   _Stringbuffer ( _Str, _Mode | ios_base :: out )
  {
  }

 basic_ostringstream ( _Myt && _Right )
  : _Mybase ( & _Stringbuffer )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   _Stringbuffer . str ( _Mystr ( ) );
   this -> swap ( _Right );
   }
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Mybase :: swap ( _Right );
   _Stringbuffer . swap ( _Right . _Stringbuffer );
   }
  }

 void swap ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 virtual ~ basic_ostringstream ( )
  {
  }

 _Mysb * rdbuf ( ) const
  {
  return ( ( _Mysb * ) & _Stringbuffer );
  }

 _Mystr str ( ) const
  {
  return ( _Stringbuffer . str ( ) );
  }

 void str ( const _Mystr & _Newstr )
  {
  _Stringbuffer . str ( _Newstr );
  }

private :
 _Mysb _Stringbuffer;
 };
#line 606
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_ostringstream < _Elem, _Traits, _Alloc > & _Left,
  basic_ostringstream < _Elem, _Traits, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 615
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_ostringstream < _Elem, _Traits, _Alloc > & _Left,
  basic_ostringstream < _Elem, _Traits, _Alloc > && _Right )
 {
 typedef basic_ostringstream < _Elem, _Traits, _Alloc > _Myt;
 _Left . swap ( :: std :: forward < _Myt > ( _Right ) );
 }
#line 625
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_ostringstream < _Elem, _Traits, _Alloc > && _Left,
  basic_ostringstream < _Elem, _Traits, _Alloc > & _Right )
 {
 typedef basic_ostringstream < _Elem, _Traits > _Myt;
 _Right . swap ( :: std :: forward < _Myt > ( _Left ) );
 }
#line 636
template < class _Elem,
 class _Traits,
 class _Alloc >
 class basic_stringstream
  : public basic_iostream < _Elem, _Traits >
 {
public :
 typedef basic_stringstream < _Elem, _Traits, _Alloc > _Myt;
 typedef basic_iostream < _Elem, _Traits > _Mybase;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef _Alloc allocator_type;
 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;
 typedef basic_stringbuf < _Elem, _Traits, _Alloc > _Mysb;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;

 explicit basic_stringstream ( ios_base :: openmode _Mode =
  ios_base :: in | ios_base :: out )
  : _Mybase ( & _Stringbuffer ),
   _Stringbuffer ( _Mode )
  {
  }

 explicit basic_stringstream ( const _Mystr & _Str,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  : _Mybase ( & _Stringbuffer ),
   _Stringbuffer ( _Str, _Mode )
  {
  }

 basic_stringstream ( _Myt && _Right )
  : _Mybase ( & _Stringbuffer )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   _Stringbuffer . str ( _Mystr ( ) );
   this -> swap ( _Right );
   }
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Mybase :: swap ( _Right );
   _Stringbuffer . swap ( _Right . _Stringbuffer );
   }
  }

 void swap ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 virtual ~ basic_stringstream ( )
  {
  }

 _Mysb * rdbuf ( ) const
  {
  return ( ( _Mysb * ) & _Stringbuffer );
  }

 _Mystr str ( ) const
  {
  return ( _Stringbuffer . str ( ) );
  }

 void str ( const _Mystr & _Newstr )
  {
  _Stringbuffer . str ( _Newstr );
  }

private :
 _Mysb _Stringbuffer;
 };
#line 727
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_stringstream < _Elem, _Traits, _Alloc > & _Left,
  basic_stringstream < _Elem, _Traits, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 736
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_stringstream < _Elem, _Traits, _Alloc > & _Left,
  basic_stringstream < _Elem, _Traits, _Alloc > && _Right )
 {
 typedef basic_stringstream < _Elem, _Traits, _Alloc > _Myt;
 _Left . swap ( :: std :: forward < _Myt > ( _Right ) );
 }
#line 746
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_stringstream < _Elem, _Traits, _Alloc > && _Left,
  basic_stringstream < _Elem, _Traits, _Alloc > & _Right )
 {
 typedef basic_ostringstream < _Elem, _Traits > _Myt;
 _Right . swap ( :: std :: forward < _Myt > ( _Left ) );
 }
#line 755
}
#pragma warning(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vector"
#pragma warning(push,3)
#line 13
#pragma warning(disable: 4244)
#line 757 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\sstream"
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vector"
#pragma pack ( push, 8 )
#line 15
namespace std { 
#line 19
template < class _Myvec >
 class _Vector_const_iterator
  : public _Iterator012 < random_access_iterator_tag,
   typename _Myvec :: value_type,
   typename _Myvec :: difference_type,
   typename _Myvec :: const_pointer,
   typename _Myvec :: const_reference,
   _Iterator_base >
 {
public :
 typedef _Vector_const_iterator < _Myvec > _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Myvec :: pointer _Tptr;
 typedef typename _Myvec :: value_type value_type;
 typedef typename _Myvec :: difference_type difference_type;
 typedef typename _Myvec :: const_pointer pointer;
 typedef typename _Myvec :: const_reference reference;

 _Vector_const_iterator ( )
  : _Ptr ( 0 )
  {
  }

 _Vector_const_iterator ( _Tptr _Parg, const _Container_base * _Pvector )
  : _Ptr ( _Parg )
  {
  this -> _Adopt ( _Pvector );
  }

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  this -> _Ptr = ( _Tptr ) _Right;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Unchecked_type ( this -> _Ptr ) );
  }

 reference operator * ( ) const
  {


















  ;

  return ( * this -> _Ptr );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myiter & operator ++ ( )
  {
















  ++ this -> _Ptr;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
















  -- this -> _Ptr;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
















  _Ptr += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Ptr - _Right . _Ptr );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Ptr == _Right . _Ptr );
  }

 bool operator != ( const _Myiter & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Ptr < _Right . _Ptr );
  }

 bool operator > ( const _Myiter & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myiter & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myiter & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }




















 void _Compat ( const _Myiter & ) const
  {
  }


 _Tptr _Ptr;
 };
#line 259 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vector"
template < class _Myvec > inline
 typename _Vector_const_iterator < _Myvec > :: _Unchecked_type
  _Unchecked ( _Vector_const_iterator < _Myvec > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 266
template < class _Myvec > inline
 _Vector_const_iterator < _Myvec > &
  _Rechecked ( _Vector_const_iterator < _Myvec > & _Iter,
   typename _Vector_const_iterator < _Myvec >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 275
template < class _Myvec > inline
 _Vector_const_iterator < _Myvec > operator + (
  typename _Vector_const_iterator < _Myvec > :: difference_type _Off,
  _Vector_const_iterator < _Myvec > _Next )
 {
 return ( _Next += _Off );
 }
#line 284
template < class _Myvec >
 class _Vector_iterator
  : public _Vector_const_iterator < _Myvec >
 {
public :
 typedef _Vector_iterator < _Myvec > _Myiter;
 typedef _Vector_const_iterator < _Myvec > _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Myvec :: value_type value_type;
 typedef typename _Myvec :: difference_type difference_type;
 typedef typename _Myvec :: pointer pointer;
 typedef typename _Myvec :: reference reference;

 _Vector_iterator ( )
  {
  }

 _Vector_iterator ( pointer _Parg, const _Container_base * _Pvector )
  : _Mybase ( _Parg, _Pvector )
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  this -> _Ptr = _Right;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Unchecked_type ( this -> _Ptr ) );
  }

 reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myiter & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 390
template < class _Myvec > inline
 typename _Vector_iterator < _Myvec > :: _Unchecked_type
  _Unchecked ( _Vector_iterator < _Myvec > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 397
template < class _Myvec > inline
 _Vector_iterator < _Myvec > &
  _Rechecked ( _Vector_iterator < _Myvec > & _Iter,
   typename _Vector_iterator < _Myvec >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 406
template < class _Myvec > inline
 _Vector_iterator < _Myvec > operator + (
  typename _Vector_iterator < _Myvec > :: difference_type _Off,
  _Vector_iterator < _Myvec > _Next )
 {
 return ( _Next += _Off );
 }
#line 415
template < class _Ty,
 class _Alloc >
 class _Vector_val
  : public _Container_base
 {
public :
 typedef typename _Alloc :: template rebind < _Ty > :: other _Alty;


 _Vector_val ( _Alloc _Al = _Alloc ( ) )
  : _Alval ( _Al )
  {
  _Myfirst = 0;
  _Mylast = 0;
  _Myend = 0;
  }

 ~ _Vector_val ( )
  {
  }



























 typedef typename _Alty :: size_type size_type;
 typedef typename _Alty :: difference_type difference_type;
 typedef typename _Alty :: pointer pointer;
 typedef typename _Alty :: const_pointer const_pointer;
 typedef typename _Alty :: reference reference;
 typedef typename _Alty :: const_reference const_reference;
 typedef typename _Alty :: value_type value_type;

 pointer _Myfirst;
 pointer _Mylast;
 pointer _Myend;
 _Alty _Alval;
 };
#line 477 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vector"
template < class _Ty,
 class _Ax = allocator < _Ty > >
 class vector
  : public _Vector_val < _Ty, _Ax >
 {
public :
 typedef vector < _Ty, _Ax > _Myt;
 typedef _Vector_val < _Ty, _Ax > _Mybase;
 typedef typename _Mybase :: _Alty _Alloc;

 typedef _Alloc allocator_type;
 typedef typename _Alloc :: size_type size_type;
 typedef typename _Alloc :: difference_type difference_type;
 typedef typename _Alloc :: pointer pointer;
 typedef typename _Alloc :: const_pointer const_pointer;
 typedef typename _Alloc :: reference reference;
 typedef typename _Alloc :: const_reference const_reference;
 typedef typename _Alloc :: value_type value_type;




 typedef _Vector_iterator < _Mybase > iterator;
 typedef _Vector_const_iterator < _Mybase > const_iterator;

 typedef :: std :: reverse_iterator < iterator > reverse_iterator;
 typedef :: std :: reverse_iterator < const_iterator > const_reverse_iterator;

 vector ( )
  : _Mybase ( )
  {
  }

 explicit vector ( const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  }

 explicit vector ( size_type _Count )
  : _Mybase ( )
  {
  resize ( _Count );
  }

 vector ( size_type _Count, const _Ty & _Val )
  : _Mybase ( )
  {
  _Construct_n ( _Count, :: std :: addressof ( _Val ) );
  }

 vector ( size_type _Count, const _Ty & _Val, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Construct_n ( _Count, :: std :: addressof ( _Val ) );
  }

 vector ( const _Myt & _Right )
  : _Mybase ( _Right . _Alval )
  {
  if ( _Buy ( _Right . size ( ) ) )
   try {
   this -> _Mylast = _Ucopy ( _Right . begin ( ), _Right . end ( ),
    this -> _Myfirst );
   } catch ( ... ) {
   _Tidy ( );
   throw;
   }
  }

 template < class _Iter >
  vector ( _Iter _First, _Iter _Last )
  : _Mybase ( )
  {
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  vector ( _Iter _First, _Iter _Last, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Construct ( _Iter _Count, _Iter _Val, _Int_iterator_tag )
  {
  size_type _Size = ( size_type ) _Count;
  _Ty _Newval = ( _Ty ) _Val;
  _Construct_n ( _Size, :: std :: addressof ( _Newval ) );
  }

 template < class _Iter >
  void _Construct ( _Iter _First,
   _Iter _Last, input_iterator_tag )
  {
  try {
  insert ( begin ( ), _First, _Last );
  } catch ( ... ) {
  _Tidy ( );
  throw;
  }
  }

 void _Construct_n ( size_type _Count, const _Ty * _Pval )
  {
  if ( _Buy ( _Count ) )
   {
   try {
   this -> _Mylast = _Ufill ( this -> _Myfirst, _Count, _Pval );
   } catch ( ... ) {
   _Tidy ( );
   throw;
   }
   }
  }

 vector ( _Myt && _Right )
  : _Mybase ( _Right . _Alval )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  if ( this == & _Right )
   ;
  else if ( get_allocator ( ) != _Right . get_allocator ( ) )
   {
   clear ( );
   for ( iterator _Next = _Right . begin ( ); _Next != _Right . end ( );
    ++ _Next )
    push_back ( :: std :: forward < _Ty > ( * _Next ) );
   }
  else
   {
   _Tidy ( );
   this -> _Swap_all ( ( _Myt & ) _Right );
   this -> _Myfirst = _Right . _Myfirst;
   this -> _Mylast = _Right . _Mylast;
   this -> _Myend = _Right . _Myend;

   _Right . _Myfirst = 0;
   _Right . _Mylast = 0;
   _Right . _Myend = 0;
   }
  }

 void push_back ( _Ty && _Val )
  {
  if ( _Inside ( :: std :: addressof ( _Val ) ) )
   {
   size_type _Idx = :: std :: addressof ( _Val ) - this -> _Myfirst;
   if ( this -> _Mylast == this -> _Myend )
    _Reserve ( 1 );
   _Orphan_range ( this -> _Mylast, this -> _Mylast );
   _Cons_val ( this -> _Alval,
    this -> _Mylast,
    :: std :: forward < _Ty > ( this -> _Myfirst [ _Idx ] ) );
   ++ this -> _Mylast;
   }
  else
   {
   if ( this -> _Mylast == this -> _Myend )
    _Reserve ( 1 );
   _Orphan_range ( this -> _Mylast, this -> _Mylast );
   _Cons_val ( this -> _Alval,
    this -> _Mylast,
    :: std :: forward < _Ty > ( _Val ) );
   ++ this -> _Mylast;
   }
  }

 void emplace_back ( _Ty && _Val )
  {
  push_back ( :: std :: forward < _Ty > ( _Val ) );
  }

 template < class _Valty >
  void emplace_back ( _Valty && _Val )
  {
  if ( this -> _Mylast == this -> _Myend )
   _Reserve ( 1 );
  _Orphan_range ( this -> _Mylast, this -> _Mylast );
  _Cons_val ( this -> _Alval,
   this -> _Mylast,
   :: std :: forward < _Valty > ( _Val ) );
  ++ this -> _Mylast;
  }

 template < class _Valty >
  iterator insert ( const_iterator _Where, _Valty && _Val )
  {
  return ( emplace ( _Where, :: std :: forward < _Valty > ( _Val ) ) );
  }

 template < class _Valty >
  iterator emplace ( const_iterator _Where, _Valty && _Val )
  {
  size_type _Off = ( _Where ) . _Ptr - this -> _Myfirst;






  emplace_back ( :: std :: forward < _Valty > ( _Val ) );
  :: std :: rotate ( begin ( ) + _Off, end ( ) - 1, end ( ) );
  return ( begin ( ) + _Off );
  }

 void swap ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   clear ( );
   this -> _Swap_all ( ( _Myt & ) _Right );
   _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
   }
  }

 ~ vector ( )
  {
  _Tidy ( );
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  if ( this != & _Right )
   {
   this -> _Orphan_all ( );

   if ( _Right . size ( ) == 0 )
    clear ( );
   else if ( _Right . size ( ) <= size ( ) )
    {
    pointer _Ptr = :: std :: _Copy_impl ( _Right . _Myfirst, _Right . _Mylast,
     this -> _Myfirst );
    _Destroy ( _Ptr, this -> _Mylast );
    this -> _Mylast = this -> _Myfirst + _Right . size ( );
    }
   else if ( _Right . size ( ) <= capacity ( ) )
    {
    pointer _Ptr = _Right . _Myfirst + size ( );
    :: std :: _Copy_impl ( _Right . _Myfirst, _Ptr, this -> _Myfirst );
    this -> _Mylast = _Ucopy ( _Ptr, _Right . _Mylast, this -> _Mylast );
    }
   else
    {
    if ( this -> _Myfirst != 0 )
     {
     _Destroy ( this -> _Myfirst, this -> _Mylast );
     this -> _Alval . deallocate ( this -> _Myfirst,
      this -> _Myend - this -> _Myfirst );
     }
    if ( _Buy ( _Right . size ( ) ) )
     this -> _Mylast = _Ucopy ( _Right . _Myfirst, _Right . _Mylast,
      this -> _Myfirst );
    }
   }
  return ( * this );
  }

 void reserve ( size_type _Count )
  {
  if ( max_size ( ) < _Count )
   _Xlen ( );
  else if ( capacity ( ) < _Count )
   {
   pointer _Ptr = this -> _Alval . allocate ( _Count );

   try {
   _Umove ( this -> _Myfirst, this -> _Mylast, _Ptr );
   } catch ( ... ) {
   this -> _Alval . deallocate ( _Ptr, _Count );
   throw;
   }

   size_type _Size = size ( );
   if ( this -> _Myfirst != 0 )
    {
    _Destroy ( this -> _Myfirst, this -> _Mylast );
    this -> _Alval . deallocate ( this -> _Myfirst,
     this -> _Myend - this -> _Myfirst );
    }

   this -> _Orphan_all ( );
   this -> _Myend = _Ptr + _Count;
   this -> _Mylast = _Ptr + _Size;
   this -> _Myfirst = _Ptr;
   }
  }

 size_type capacity ( ) const
  {
  return ( this -> _Myend - this -> _Myfirst );
  }

 iterator begin ( )
  {
  return ( iterator ( this -> _Myfirst, this ) );
  }

 const_iterator begin ( ) const
  {
  return ( const_iterator ( this -> _Myfirst, this ) );
  }

 iterator end ( )
  {
  return ( iterator ( this -> _Mylast, this ) );
  }

 const_iterator end ( ) const
  {
  return ( const_iterator ( this -> _Mylast, this ) );
  }

 iterator _Make_iter ( const_iterator _Where ) const
  {
  return ( iterator ( _Where . _Ptr, this ) );
  }

 reverse_iterator rbegin ( )
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( )
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }


 const_iterator cbegin ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> begin ( ) );
  }

 const_iterator cend ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> end ( ) );
  }

 const_reverse_iterator crbegin ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> rbegin ( ) );
  }

 const_reverse_iterator crend ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> rend ( ) );
  }

 void shrink_to_fit ( )
  {
  if ( size ( ) < capacity ( ) )
   {
   _Myt _Tmp ( * this );
   swap ( _Tmp );
   }
  }


 void resize ( size_type _Newsize )
  {
  if ( _Newsize < size ( ) )
   erase ( begin ( ) + _Newsize, end ( ) );
  else if ( size ( ) < _Newsize )
   {
   _Reserve ( _Newsize - size ( ) );
   _Uninitialized_default_fill_n ( this -> _Mylast, _Newsize - size ( ),
    ( _Ty * ) 0, this -> _Alval );
   this -> _Mylast += _Newsize - size ( );
   }
  }

 void resize ( size_type _Newsize, _Ty _Val )
  {
  if ( size ( ) < _Newsize )
   _Insert_n ( end ( ), _Newsize - size ( ), _Val );
  else if ( _Newsize < size ( ) )
   erase ( begin ( ) + _Newsize, end ( ) );
  }

 size_type size ( ) const
  {
  return ( this -> _Mylast - this -> _Myfirst );
  }

 size_type max_size ( ) const
  {
  return ( this -> _Alval . max_size ( ) );
  }

 bool empty ( ) const
  {
  return ( this -> _Myfirst == this -> _Mylast );
  }

 _Alloc get_allocator ( ) const
  {
  return ( this -> _Alval );
  }

 const_reference at ( size_type _Pos ) const
  {
  if ( size ( ) <= _Pos )
   _Xran ( );
  return ( * ( this -> _Myfirst + _Pos ) );
  }

 reference at ( size_type _Pos )
  {
  if ( size ( ) <= _Pos )
   _Xran ( );
  return ( * ( this -> _Myfirst + _Pos ) );
  }

 const_reference operator [ ] ( size_type _Pos ) const
  {











  return ( * ( this -> _Myfirst + _Pos ) );
  }

 reference operator [ ] ( size_type _Pos )
  {











  return ( * ( this -> _Myfirst + _Pos ) );
  }


 pointer data ( )
  {
  return ( this -> _Myfirst );
  }

 const_pointer data ( ) const
  {
  return ( this -> _Myfirst );
  }


 reference front ( )
  {
  return ( * begin ( ) );
  }

 const_reference front ( ) const
  {
  return ( * begin ( ) );
  }

 reference back ( )
  {
  return ( * ( end ( ) - 1 ) );
  }

 const_reference back ( ) const
  {
  return ( * ( end ( ) - 1 ) );
  }

 void push_back ( const _Ty & _Val )
  {
  if ( _Inside ( :: std :: addressof ( _Val ) ) )
   {
   size_type _Idx = :: std :: addressof ( _Val ) - this -> _Myfirst;
   if ( this -> _Mylast == this -> _Myend )
    _Reserve ( 1 );
   _Orphan_range ( this -> _Mylast, this -> _Mylast );
   _Cons_val ( this -> _Alval,
    this -> _Mylast,
    this -> _Myfirst [ _Idx ] );
   ++ this -> _Mylast;
   }
  else
   {
   if ( this -> _Mylast == this -> _Myend )
    _Reserve ( 1 );
   _Orphan_range ( this -> _Mylast, this -> _Mylast );
   _Cons_val ( this -> _Alval,
    this -> _Mylast,
    _Val );
   ++ this -> _Mylast;
   }
  }
















 void pop_back ( )
  {
  if ( ! empty ( ) )
   {
   _Dest_val ( this -> _Alval,
    this -> _Mylast - 1 );
   -- this -> _Mylast;
   }
  }


 template < class _Iter >
  void assign ( _Iter _First, _Iter _Last )
  {
  _Assign ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Assign ( _Iter _Count, _Iter _Val, _Int_iterator_tag )
  {
  _Assign_n ( ( size_type ) _Count, ( _Ty ) _Val );
  }

 template < class _Iter >
  void _Assign ( _Iter _First, _Iter _Last, input_iterator_tag )
  {
  erase ( begin ( ), end ( ) );
  insert ( begin ( ), _First, _Last );
  }

 void assign ( size_type _Count, const _Ty & _Val )
  {
  _Assign_n ( _Count, _Val );
  }

 iterator insert ( const_iterator _Where, const _Ty & _Val )
  {
  size_type _Off = size ( ) == 0 ? 0 : _Where - begin ( );
  _Insert_n ( _Where, ( size_type ) 1, _Val );
  return ( begin ( ) + _Off );
  }

 void insert ( const_iterator _Where, size_type _Count, const _Ty & _Val )
  {
  _Insert_n ( _Where, _Count, _Val );
  }

 template < class _Iter >
  void insert ( const_iterator _Where, _Iter _First, _Iter _Last )
  {
  _Insert ( _Where, _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where, _Iter _First, _Iter _Last,
   _Int_iterator_tag )
  {
  _Insert_n ( _Where, ( size_type ) _First, ( _Ty ) _Last );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where, _Iter _First, _Iter _Last,
   input_iterator_tag )
  {
  size_type _Off = ( _Where ) . _Ptr - this -> _Myfirst;






  if ( _First != _Last )
   {
   size_type _Oldsize = size ( );

   try {
   for (; _First != _Last; ++ _First )
    push_back ( * _First );

   } catch ( ... ) {
   erase ( begin ( ) + _Oldsize, end ( ) );
   throw;
   }

   :: std :: rotate ( begin ( ) + _Off, begin ( ) + _Oldsize, end ( ) );
   }
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where,
   _Iter _First, _Iter _Last, forward_iterator_tag )
  {








  size_type _Count = 0;
  _Distance ( _First, _Last, _Count );

  if ( _Count == 0 )
   ;
  else if ( max_size ( ) - size ( ) < _Count )
   _Xlen ( );
  else if ( capacity ( ) < size ( ) + _Count )
   {
   size_type _Capacity = _Grow_to ( size ( ) + _Count );
   pointer _Newvec = this -> _Alval . allocate ( _Capacity );
   pointer _Ptr = _Newvec;

   try {
   _Ptr = _Umove ( this -> _Myfirst, ( _Where ) . _Ptr,
    _Newvec );
   _Ptr = _Ucopy ( _First, _Last, _Ptr );
   _Umove ( ( _Where ) . _Ptr, this -> _Mylast,
    _Ptr );
   } catch ( ... ) {
   _Destroy ( _Newvec, _Ptr );
   this -> _Alval . deallocate ( _Newvec, _Capacity );
   throw;
   }

   _Count += size ( );
   if ( this -> _Myfirst != 0 )
    {
    _Destroy ( this -> _Myfirst, this -> _Mylast );
    this -> _Alval . deallocate ( this -> _Myfirst,
     this -> _Myend - this -> _Myfirst );
    }

   this -> _Orphan_all ( );
   this -> _Myend = _Newvec + _Capacity;
   this -> _Mylast = _Newvec + _Count;
   this -> _Myfirst = _Newvec;
   }
  else
   {
   _Ucopy ( _First, _Last, this -> _Mylast );
   :: std :: rotate ( ( _Where ) . _Ptr, this -> _Mylast,
    this -> _Mylast + _Count );
   this -> _Mylast += _Count;
   _Orphan_range ( ( _Where ) . _Ptr, this -> _Mylast );
   }
  }
















 iterator erase ( const_iterator _Where )
  {
  _Move ( ( _Where ) . _Ptr + 1, this -> _Mylast,
   ( _Where ) . _Ptr );
  _Destroy ( this -> _Mylast - 1, this -> _Mylast );
  -- this -> _Mylast;
  return ( _Make_iter ( _Where ) );
  }


 iterator erase ( const_iterator _First_arg,
  const_iterator _Last_arg )
  {
  iterator _First = _Make_iter ( _First_arg );
  iterator _Last = _Make_iter ( _Last_arg );

  if ( _First != _Last )
   {










   pointer _Ptr = _Move ( ( _Last ) . _Ptr, this -> _Mylast,
    ( _First ) . _Ptr );


   _Destroy ( _Ptr, this -> _Mylast );
   this -> _Mylast = _Ptr;
   }
  return ( _Make_iter ( _First ) );
  }

 void clear ( )
  {
  erase ( begin ( ), end ( ) );
  }

 void swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( this -> _Alval == _Right . _Alval )
   {
   this -> _Swap_all ( _Right );
   :: std :: swap ( this -> _Myfirst, _Right . _Myfirst );
   :: std :: swap ( this -> _Mylast, _Right . _Mylast );
   :: std :: swap ( this -> _Myend, _Right . _Myend );
   }
  else
   {
   _Myt _Ts = _Move ( * this );

   * this = _Move ( _Right );
   _Right = _Move ( _Ts );
   }
  }

protected :
 void _Assign_n ( size_type _Count, const _Ty & _Val )
  {
  _Ty _Tmp = _Val;
  erase ( begin ( ), end ( ) );
  insert ( begin ( ), _Count, _Tmp );
  }

 bool _Buy ( size_type _Capacity )
  {
  this -> _Myfirst = 0;
  this -> _Mylast = 0;
  this -> _Myend = 0;

  if ( _Capacity == 0 )
   return ( false );
  else if ( max_size ( ) < _Capacity )
   _Xlen ( );
  else
   {
   this -> _Myfirst = this -> _Alval . allocate ( _Capacity );
   this -> _Mylast = this -> _Myfirst;
   this -> _Myend = this -> _Myfirst + _Capacity;
   }
  return ( true );
  }

 void _Destroy ( pointer _First, pointer _Last )
  {
  _Destroy_range ( _First, _Last, this -> _Alval );
  }

 size_type _Grow_to ( size_type _Count ) const
  {
  size_type _Capacity = capacity ( );

  _Capacity = max_size ( ) - _Capacity / 2 < _Capacity
   ? 0 : _Capacity + _Capacity / 2;
  if ( _Capacity < _Count )
   _Capacity = _Count;
  return ( _Capacity );
  }

 bool _Inside ( const _Ty * _Ptr ) const
  {
  return ( _Ptr < this -> _Mylast && this -> _Myfirst <= _Ptr );
  }

 void _Reserve ( size_type _Count )
  {
  size_type _Size = size ( );
  if ( max_size ( ) - _Count < _Size )
   _Xlen ( );
  else if ( ( _Size += _Count ) <= capacity ( ) )
   ;
  else
   reserve ( _Grow_to ( _Size ) );
  }

 void _Tidy ( )
  {
  if ( this -> _Myfirst != 0 )
   {
   this -> _Orphan_all ( );
   _Destroy ( this -> _Myfirst, this -> _Mylast );
   this -> _Alval . deallocate ( this -> _Myfirst,
    this -> _Myend - this -> _Myfirst );
   }
  this -> _Myfirst = 0;
  this -> _Mylast = 0;
  this -> _Myend = 0;
  }

 template < class _Iter >
  pointer _Ucopy ( _Iter _First, _Iter _Last, pointer _Ptr )
  {
  return ( _Uninitialized_copy ( _First, _Last,
   _Ptr, this -> _Alval ) );
  }

 template < class _Iter >
  pointer _Umove ( _Iter _First, _Iter _Last, pointer _Ptr )
  {
  return ( _Uninitialized_move ( _First, _Last,
   _Ptr, this -> _Alval ) );
  }

 void _Insert_n ( const_iterator _Where,
  size_type _Count, const _Ty & _Val )
  {







  if ( _Count == 0 )
   ;
  else if ( max_size ( ) - size ( ) < _Count )
   _Xlen ( );
  else if ( capacity ( ) < size ( ) + _Count )
   {
   size_type _Capacity = _Grow_to ( size ( ) + _Count );
   pointer _Newvec = this -> _Alval . allocate ( _Capacity );
   size_type _Whereoff = ( _Where ) . _Ptr - this -> _Myfirst;
   int _Ncopied = 0;

   try {
   _Ufill ( _Newvec + _Whereoff, _Count,
    :: std :: addressof ( _Val ) );
   ++ _Ncopied;
   _Umove ( this -> _Myfirst, ( _Where ) . _Ptr,
    _Newvec );
   ++ _Ncopied;
   _Umove ( ( _Where ) . _Ptr, this -> _Mylast,
    _Newvec + ( _Whereoff + _Count ) );
   } catch ( ... ) {
   if ( 1 < _Ncopied )
    _Destroy ( _Newvec, _Newvec + _Whereoff );
   if ( 0 < _Ncopied )
    _Destroy ( _Newvec + _Whereoff, _Newvec + _Whereoff + _Count );
   this -> _Alval . deallocate ( _Newvec, _Capacity );
   throw;
   }

   _Count += size ( );
   if ( this -> _Myfirst != 0 )
    {
    _Destroy ( this -> _Myfirst, this -> _Mylast );
    this -> _Alval . deallocate ( this -> _Myfirst,
     this -> _Myend - this -> _Myfirst );
    }

   this -> _Orphan_all ( );
   this -> _Myend = _Newvec + _Capacity;
   this -> _Mylast = _Newvec + _Count;
   this -> _Myfirst = _Newvec;
   }
  else if ( ( size_type ) ( this -> _Mylast - ( _Where ) . _Ptr )
   < _Count )
   {
   _Ty _Tmp = _Val;

   _Umove ( ( _Where ) . _Ptr, this -> _Mylast,
    ( _Where ) . _Ptr + _Count );

   try {
   _Ufill ( this -> _Mylast,
    _Count - ( this -> _Mylast - ( _Where ) . _Ptr ),
    :: std :: addressof ( _Tmp ) );
   } catch ( ... ) {
   _Destroy ( ( _Where ) . _Ptr + _Count,
    this -> _Mylast + _Count );
   throw;
   }

   this -> _Mylast += _Count;
   _Orphan_range ( ( _Where ) . _Ptr, this -> _Mylast );
   :: std :: fill ( ( _Where ) . _Ptr, this -> _Mylast - _Count,
    _Tmp );
   }
  else
   {
   _Ty _Tmp = _Val;

   pointer _Oldend = this -> _Mylast;
   this -> _Mylast = _Umove ( _Oldend - _Count, _Oldend,
    this -> _Mylast );

   _Orphan_range ( ( _Where ) . _Ptr, this -> _Mylast );
   :: std :: _Copy_backward ( ( _Where ) . _Ptr, _Oldend - _Count,
    _Oldend );
   :: std :: fill ( ( _Where ) . _Ptr,
    ( _Where ) . _Ptr + _Count, _Tmp );
   }
  }

 pointer _Ufill ( pointer _Ptr, size_type _Count, const _Ty * _Pval )
  {
  _Uninitialized_fill_n ( _Ptr, _Count, _Pval, this -> _Alval );
  return ( _Ptr + _Count );
  }

 __declspec ( noreturn ) void _Xlen ( ) const
  {
  _Xlength_error ( "vector<T> too long" );
  }

 __declspec ( noreturn ) void _Xran ( ) const
  {
  _Xout_of_range ( "invalid vector<T> subscript" );
  }


















 void _Orphan_range ( pointer, pointer ) const
  {
  }

 };
#line 1460 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vector"
template < class _Ty,
 class _Alloc > inline
 void swap ( vector < _Ty, _Alloc > & _Left, vector < _Ty, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 1467
template < class _Ty,
 class _Alloc > inline
 void swap ( vector < _Ty, _Alloc > & _Left, vector < _Ty, _Alloc > && _Right )
 {
 typedef vector < _Ty, _Alloc > _Myt;
 _Left . swap ( :: std :: forward < _Myt > ( _Right ) );
 }
#line 1475
template < class _Ty,
 class _Alloc > inline
 void swap ( vector < _Ty, _Alloc > && _Left, vector < _Ty, _Alloc > & _Right )
 {
 typedef vector < _Ty, _Alloc > _Myt;
 _Right . swap ( :: std :: forward < _Myt > ( _Left ) );
 }
#line 1483
template < class _Ty,
 class _Alloc > inline
 bool operator == ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( _Left . size ( ) == _Right . size ( )
  && equal ( _Left . begin ( ), _Left . end ( ), _Right . begin ( ) ) );
 }
#line 1492
template < class _Ty,
 class _Alloc > inline
 bool operator != ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 1500
template < class _Ty,
 class _Alloc > inline
 bool operator < ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( lexicographical_compare ( _Left . begin ( ), _Left . end ( ),
  _Right . begin ( ), _Right . end ( ) ) );
 }
#line 1509
template < class _Ty,
 class _Alloc > inline
 bool operator > ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( _Right < _Left );
 }
#line 1517
template < class _Ty,
 class _Alloc > inline
 bool operator <= ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 1525
template < class _Ty,
 class _Alloc > inline
 bool operator >= ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 1536
typedef unsigned _Vbase; 
#line 1537
const int _VBITS = ((8) * sizeof(_Vbase)); 
#line 1540
template < class _Alloc >
 class _Vb_iter_base
  : public _Iterator012 < random_access_iterator_tag,
   _Bool,
   typename _Alloc :: difference_type,
   bool *,
   bool,
   _Iterator_base >
 {
public :
 typedef typename _Alloc :: size_type _Sizet;
 typedef vector < _Bool, _Alloc > _Mycont;

 _Vb_iter_base ( )
  : _Myptr ( 0 ), _Myoff ( 0 )
  {
  }

 _Vb_iter_base ( const _Vbase * _Ptr, _Sizet _Off,
  const _Container_base * _Mypvbool )
  : _Myptr ( _Ptr ), _Myoff ( _Off )
  {
  this -> _Adopt ( _Mypvbool );
  }

 int _Valid ( _Sizet _Inc ) const
  {










  return ( - 1 );

  }

 const _Vbase * _Myptr;
 _Sizet _Myoff;
 };
#line 1586 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vector"
template < class _Alloc >
 class _Vb_reference
  : public _Vb_iter_base < _Alloc >
 {
public :
 typedef _Vb_iter_base < _Alloc > _Mybase;
 typedef _Vb_reference < _Alloc > _Mytype;

 _Vb_reference ( )
  {
  }

 _Vb_reference ( const _Mybase & _Right )
  : _Mybase ( _Right . _Myptr, _Right . _Myoff, _Right . _Getcont ( ) )
  {
  }

 _Mytype & operator = ( const _Mytype & _Right )
  {
  return ( * this = bool ( _Right ) );
  }

 _Mytype & operator = ( bool _Val )
  {
  if ( _Val )
   * ( _Vbase * ) _Getptr ( ) |= _Mask ( );
  else
   * ( _Vbase * ) _Getptr ( ) &= ~ _Mask ( );
  return ( * this );
  }

 void flip ( )
  {
  * ( _Vbase * ) _Getptr ( ) ^= _Mask ( );
  }

 bool operator ~ ( ) const
  {
  return ( ! bool ( * this ) );
  }

 operator bool ( ) const
  {
  return ( ( * _Getptr ( ) & _Mask ( ) ) != 0 );
  }

 const _Vbase * _Getptr ( ) const
  {














  return ( this -> _Myptr );
  }

protected :
 _Vbase _Mask ( ) const
  {
  return ( ( _Vbase ) ( 1 << this -> _Myoff ) );
  }
 };
#line 1658 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vector"
template < class _Alloc >
 void swap ( _Vb_reference < _Alloc > _Left,
  _Vb_reference < _Alloc > _Right )
 {
 bool _Val = _Left;
 _Left = _Right;
 _Right = _Val;
 }
#line 1668
template < class _Alloc >
 class _Vb_const_iterator
  : public _Vb_iter_base < _Alloc >
 {
public :
 typedef _Vb_iter_base < _Alloc > _Mybase;
 typedef _Vb_const_iterator < _Alloc > _Mytype;

 typedef _Vb_reference < _Alloc > _Reft;
 typedef bool const_reference;

 typedef random_access_iterator_tag iterator_category;
 typedef _Bool value_type;
 typedef typename _Alloc :: size_type size_type;
 typedef typename _Alloc :: difference_type difference_type;
 typedef const_reference * pointer;
 typedef const_reference reference;

 _Vb_const_iterator ( )
  {
  }

 _Vb_const_iterator ( const _Vbase * _Ptr, const _Container_base * _Mypvbool )
  : _Mybase ( _Ptr, 0, _Mypvbool )
  {
  }

 const_reference operator * ( ) const
  {
  return ( _Reft ( * this ) );
  }

 _Mytype & operator ++ ( )
  {
  _Inc ( );
  return ( * this );
  }

 _Mytype operator ++ ( int )
  {
  _Mytype _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Mytype & operator -- ( )
  {
  _Dec ( );
  return ( * this );
  }

 _Mytype operator -- ( int )
  {
  _Mytype _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Mytype & operator += ( difference_type _Off )
  {
  if ( _Off < 0 && this -> _Myoff < 0 - ( size_type ) _Off )
   {
   this -> _Myoff += _Off;
   this -> _Myptr -= 1 + ( ( size_type ) ( - 1 ) - this -> _Myoff ) / _VBITS;
   this -> _Myoff %= _VBITS;
   }
  else
   {
   this -> _Myoff += _Off;
   this -> _Myptr += this -> _Myoff / _VBITS;
   this -> _Myoff %= _VBITS;
   }
  return ( * this );
  }

 _Mytype operator + ( difference_type _Off ) const
  {
  _Mytype _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Mytype & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Mytype operator - ( difference_type _Off ) const
  {
  _Mytype _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - (
  const _Mytype & _Right ) const
  {
  _Compat ( _Right );
  return ( _VBITS * ( this -> _Myptr - _Right . _Myptr )
   + ( difference_type ) this -> _Myoff
   - ( difference_type ) _Right . _Myoff );
  }

 const_reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Mytype & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Myptr == _Right . _Myptr
   && this -> _Myoff == _Right . _Myoff );
  }

 bool operator != ( const _Mytype & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Mytype & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Myptr < _Right . _Myptr
   || this -> _Myptr == _Right . _Myptr
    && this -> _Myoff < _Right . _Myoff );
  }

 bool operator > ( const _Mytype & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Mytype & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Mytype & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }

















 void _Compat ( const _Mytype & ) const
  {
  }


 void _Dec ( )
  {
  if ( this -> _Myoff != 0 )
   -- this -> _Myoff;
  else
   {












   this -> _Myoff = _VBITS - 1;
   -- this -> _Myptr;
   }
  }

 void _Inc ( )
  {
  if ( this -> _Myoff < _VBITS - 1 )
   ++ this -> _Myoff;
  else
   {












   this -> _Myoff = 0;
   ++ this -> _Myptr;
   }
  }
 };
#line 1877 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vector"
template < class _Alloc >
 _Vb_const_iterator < _Alloc > operator + (
  typename _Alloc :: difference_type _Off,
  _Vb_const_iterator < _Alloc > _Right )
  {
  return ( _Right += _Off );
  }
#line 1885
template< class _Alloc> 
#line 1886
struct _Is_checked_helper< _Vb_const_iterator< _Alloc> >  : public tr1::true_type { 
#line 1889
}; 
#line 1892
template < class _Alloc >
 class _Vb_iterator
  : public _Vb_const_iterator < _Alloc >
 {
public :
 typedef _Vb_const_iterator < _Alloc > _Mybase;
 typedef _Vb_iterator < _Alloc > _Mytype;

 typedef _Vb_reference < _Alloc > _Reft;
 typedef bool const_reference;

 typedef random_access_iterator_tag iterator_category;
 typedef _Bool value_type;
 typedef typename _Alloc :: size_type size_type;
 typedef typename _Alloc :: difference_type difference_type;
 typedef _Reft * pointer;
 typedef _Reft reference;

 _Vb_iterator ( )
  {
  }

 _Vb_iterator ( _Vbase * _Ptr, _Container_base * _Mypvbool )
  : _Mybase ( _Ptr, _Mypvbool )
  {
  }

 reference operator * ( ) const
  {
  return ( _Reft ( * this ) );
  }

 _Mytype & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _Mytype operator ++ ( int )
  {
  _Mytype _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Mytype & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _Mytype operator -- ( int )
  {
  _Mytype _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Mytype & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

 _Mytype operator + ( difference_type _Off ) const
  {
  _Mytype _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Mytype & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Mytype operator - ( difference_type _Off ) const
  {
  _Mytype _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 1984
template < class _Alloc >
 _Vb_iterator < _Alloc > operator + ( typename _Alloc :: difference_type _Off,
  _Vb_iterator < _Alloc > _Right )
  {
  return ( _Right += _Off );
  }
#line 1991
template< class _Alloc> 
#line 1992
struct _Is_checked_helper< _Vb_iterator< _Alloc> >  : public tr1::true_type { 
#line 1995
}; 
#line 1998
template < class _Alloc >
 class _Vb_val
  : public _Container_base
 {
public :
 typedef typename _Alloc :: template rebind < _Vbase > :: other _Alty;
 typedef typename _Alty :: size_type size_type;


 _Vb_val ( size_type _Count, bool _Val, _Alloc _Al = _Alloc ( ) )
  : _Myvec ( _Nw ( _Count ), ( _Vbase ) ( _Val ? - 1 : 0 ), _Al )
  {
  _Mysize = 0;
  }

 ~ _Vb_val ( )
  {
  }



































 static size_type _Nw ( size_type _Count )
  {
  return ( ( _Count + _VBITS - 1 ) / _VBITS );
  }

 :: std :: vector < _Vbase, _Alty > _Myvec;
 typename _Alty :: size_type _Mysize;
 };
#line 2062 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vector"
template < class _Alloc >
 class vector < _Bool, _Alloc >
  : public _Vb_val < _Alloc >
 {
public :
 typedef typename _Alloc :: size_type size_type;
 typedef typename _Alloc :: difference_type _Dift;
 typedef :: std :: vector < _Vbase,
  typename _Alloc :: template rebind < _Vbase > :: other >
   _Vbtype;

 typedef :: std :: vector < _Bool, _Alloc > _Myt;
 typedef _Vb_val < _Alloc > _Mybase;

 typedef _Dift difference_type;
 typedef _Bool _Ty;
 typedef _Alloc allocator_type;

 typedef _Vb_reference < _Alloc > reference;
 typedef bool const_reference;
 typedef bool value_type;

 typedef reference _Reft;
 typedef _Vb_const_iterator < _Alloc > const_iterator;
 typedef _Vb_iterator < _Alloc > iterator;

 typedef iterator pointer;
 typedef const_iterator const_pointer;
 typedef :: std :: reverse_iterator < iterator > reverse_iterator;
 typedef :: std :: reverse_iterator < const_iterator > const_reverse_iterator;

 static const int _VBITS = :: std :: _VBITS;

 vector ( )
  : _Mybase ( 0, false )
  {
  }

 vector ( const _Myt & _Right )
  : _Mybase ( _Right )
  {
  }

 explicit vector ( const _Alloc & _Al )
  : _Mybase ( 0, false, _Al )
  {
  }

 explicit vector ( size_type _Count, bool _Val = false )
  : _Mybase ( _Count, _Val )
  {
  _Trim ( _Count );
  }

 vector ( size_type _Count, bool _Val, const _Alloc & _Al )
  : _Mybase ( _Count, _Val, _Al )
  {
  _Trim ( _Count );
  }

 template < class _Iter >
  vector ( _Iter _First, _Iter _Last )
  : _Mybase ( 0, false )
  {
  _BConstruct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  vector ( _Iter _First, _Iter _Last, const _Alloc & _Al )
  : _Mybase ( 0, false, _Al )
  {
  _BConstruct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _BConstruct ( _Iter _Count, _Iter _Val, _Int_iterator_tag )
  {
  size_type _Num = ( size_type ) _Count;
  this -> _Myvec . assign ( _Num, ( _Ty ) _Val ? - 1 : 0 );
  _Trim ( _Num );
  }

 template < class _Iter >
  void _BConstruct ( _Iter _First, _Iter _Last, input_iterator_tag )
  {
  insert ( begin ( ), _First, _Last );
  }

 vector ( _Myt && _Right )
  : _Mybase ( 0, false, _Right . get_allocator ( ) )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  if ( this == & _Right )
   ;
  else if ( get_allocator ( ) != _Right . get_allocator ( ) )
   * this = _Right;
  else
   {
   clear ( );
   this -> _Swap_all ( ( _Myt & ) _Right );
   this -> _Mysize = _Right . _Mysize;
   _Right . _Mysize = 0;
   this -> _Myvec = :: std :: move ( _Right . _Myvec );
   }
  }

 void swap ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  }

 ~ vector ( )
  {
  this -> _Mysize = 0;
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  this -> _Mysize = _Right . _Mysize;
  this -> _Myvec = _Right . _Myvec;
  return ( * this );
  }

 void reserve ( size_type _Count )
  {
  this -> _Myvec . reserve ( this -> _Nw ( _Count ) );
  }

 size_type capacity ( ) const
  {
  return ( this -> _Myvec . capacity ( ) * _VBITS );
  }

 iterator begin ( )
  {
  return ( iterator ( ( _Vbase * ) this -> _Myvec . _Myfirst, this ) );
  }

 const_iterator begin ( ) const
  {
  return ( const_iterator ( ( _Vbase * ) this -> _Myvec . _Myfirst, this ) );
  }

 iterator end ( )
  {
  iterator _Tmp = begin ( );
  if ( 0 < this -> _Mysize )
   _Tmp += this -> _Mysize;
  return ( _Tmp );
  }

 const_iterator end ( ) const
  {
  const_iterator _Tmp = begin ( );
  if ( 0 < this -> _Mysize )
   _Tmp += this -> _Mysize;
  return ( _Tmp );
  }


 const_iterator cbegin ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> begin ( ) );
  }

 const_iterator cend ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> end ( ) );
  }

 const_reverse_iterator crbegin ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> rbegin ( ) );
  }

 const_reverse_iterator crend ( ) const
  {
  return ( ( ( const _Myt * ) this ) -> rend ( ) );
  }

 void shrink_to_fit ( )
  {
  _Myt _Tmp ( * this );
  swap ( _Tmp );
  }


 iterator _Make_iter ( const_iterator _Where )
  {
  iterator _Tmp = begin ( );
  if ( 0 < this -> _Mysize )
   _Tmp += _Where - begin ( );
  return ( _Tmp );
  }

 reverse_iterator rbegin ( )
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( )
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }

 void resize ( size_type _Newsize, bool _Val = false )
  {
  if ( size ( ) < _Newsize )
   _Insert_n ( end ( ), _Newsize - size ( ), _Val );
  else if ( _Newsize < size ( ) )
   erase ( begin ( ) + _Newsize, end ( ) );
  }

 size_type size ( ) const
  {
  return ( this -> _Mysize );
  }

 size_type max_size ( ) const
  {
  const size_type _Maxsize = this -> _Myvec . max_size ( );
  return ( _Maxsize < ( size_type ) ( - 1 ) / _VBITS
   ? _Maxsize * _VBITS : ( size_type ) ( - 1 ) );
  }

 bool empty ( ) const
  {
  return ( size ( ) == 0 );
  }

 _Alloc get_allocator ( ) const
  {
  return ( this -> _Myvec . get_allocator ( ) );
  }

 const_reference at ( size_type _Off ) const
  {
  if ( size ( ) <= _Off )
   _Xran ( );
  return ( * ( begin ( ) + _Off ) );
  }

 reference at ( size_type _Off )
  {
  if ( size ( ) <= _Off )
   _Xran ( );
  return ( * ( begin ( ) + _Off ) );
  }

 const_reference operator [ ] ( size_type _Off ) const
  {
  return ( * ( begin ( ) + _Off ) );
  }

 reference operator [ ] ( size_type _Off )
  {
  return ( * ( begin ( ) + _Off ) );
  }

 reference front ( )
  {
  return ( * begin ( ) );
  }

 const_reference front ( ) const
  {
  return ( * begin ( ) );
  }

 reference back ( )
  {
  return ( * ( end ( ) - 1 ) );
  }

 const_reference back ( ) const
  {
  return ( * ( end ( ) - 1 ) );
  }

 void push_back ( bool _Val )
  {
  insert ( end ( ), _Val );
  }

 void pop_back ( )
  {
  if ( ! empty ( ) )
   erase ( end ( ) - 1 );
  }

 template < class _Iter >
  void assign ( _Iter _First, _Iter _Last )
  {
  _Assign ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Assign ( _Iter _Count, _Iter _Val, _Int_iterator_tag )
  {
  _Assign_n ( ( size_type ) _Count, ( bool ) _Val );
  }

 template < class _Iter >
  void _Assign ( _Iter _First, _Iter _Last, input_iterator_tag )
  {
  erase ( begin ( ), end ( ) );
  insert ( begin ( ), _First, _Last );
  }

 void assign ( size_type _Count, bool _Val )
  {
  _Assign_n ( _Count, _Val );
  }

 iterator insert ( const_iterator _Where, bool _Val )
  {
  size_type _Off = _Where - begin ( );
  _Insert_n ( _Where, ( size_type ) 1, _Val );
  return ( begin ( ) + _Off );
  }

 void insert ( const_iterator _Where, size_type _Count, bool _Val )
  {
  _Insert_n ( _Where, _Count, _Val );
  }

 template < class _Iter >
  void insert ( const_iterator _Where, _Iter _First, _Iter _Last )
  {
  _Insert ( _Where, _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where, _Iter _Count, _Iter _Val,
   _Int_iterator_tag )
  {
  _Insert_n ( _Where, ( size_type ) _Count, ( bool ) _Val );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where, _Iter _First, _Iter _Last,
   input_iterator_tag )
  {
  size_type _Off = _Where - begin ( );

  for (; _First != _Last; ++ _First, ++ _Off )
   insert ( begin ( ) + _Off, * _First );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where,
   _Iter _First, _Iter _Last,
   forward_iterator_tag )
  {
  ;
  size_type _Count = 0;
  _Distance ( _First, _Last, _Count );

  size_type _Off = _Insert_x ( _Where, _Count );
  :: std :: copy ( _First, _Last, begin ( ) + _Off );
  }

 iterator erase ( const_iterator _Where_arg )
  {
  iterator _Where = _Make_iter ( _Where_arg );
  size_type _Off = _Where - begin ( );








  :: std :: copy ( _Where + 1, end ( ), _Where );


  _Trim ( this -> _Mysize - 1 );
  return ( begin ( ) + _Off );
  }

 iterator erase ( const_iterator _First_arg, const_iterator _Last_arg )
  {
  iterator _First = _Make_iter ( _First_arg );
  iterator _Last = _Make_iter ( _Last_arg );
  size_type _Off = _First - begin ( );

  if ( _First != _Last )
   {









   iterator _Next = :: std :: copy ( _Last, end ( ), _First );
   _Trim ( _Next - begin ( ) );

   }
  return ( begin ( ) + _Off );
  }

 void clear ( )
  {
  erase ( begin ( ), end ( ) );
  }

 void flip ( )
  {
  for ( typename _Vbtype :: iterator _Next = this -> _Myvec . begin ( );

   _Next != this -> _Myvec . end ( ); ++ _Next )
   * _Next = ( _Vbase ) ~ * _Next;
  _Trim ( this -> _Mysize );
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   this -> _Swap_all ( _Right );
   :: std :: swap ( this -> _Mysize, _Right . _Mysize );
   this -> _Myvec . swap ( _Right . _Myvec );
   }
  }

 static void swap ( reference _Left, reference _Right )
  {
  bool _Val = _Left;

  _Left = _Right;
  _Right = _Val;
  }


 size_t hash ( ) const
  {
  size_t _Val = 2166136261U;
  size_t _First = 0;
  size_t _Last = this -> _Myvec . size ( );

  for (; _First < _Last; ++ _First )
   _Val = 16777619U * _Val ^ ( size_t ) this -> _Myvec [ _First ];
  return ( _Val );
  }


 void _Assign_n ( size_type _Count, bool _Val )
  {
  erase ( begin ( ), end ( ) );
  _Insert_n ( begin ( ), _Count, _Val );
  }

 void _Insert_n ( const_iterator _Where,
  size_type _Count, bool _Val )
  {
  size_type _Off = _Insert_x ( _Where, _Count );
  :: std :: fill ( begin ( ) + _Off, begin ( ) + ( _Off + _Count ), _Val );
  }

 size_type _Insert_x ( const_iterator _Where, size_type _Count )
  {
  size_type _Off = _Where - begin ( );







  if ( _Count == 0 )
   ;
  else if ( max_size ( ) - size ( ) < _Count )
   _Xlen ( );
  else
   {
   this -> _Myvec . resize ( this -> _Nw ( size ( ) + _Count ), 0 );
   if ( size ( ) == 0 )
    this -> _Mysize += _Count;
   else
    {
    iterator _Oldend = end ( );
    this -> _Mysize += _Count;
    :: std :: copy_backward ( begin ( ) + _Off, _Oldend, end ( ) );
    }




   }
  return ( _Off );
  }


























 void _Orphan_range ( size_type, size_type ) const
  {
  }


 void _Trim ( size_type _Size )
  {
  if ( max_size ( ) < _Size )
   _Xlen ( );
  size_type _Words = this -> _Nw ( _Size );

  if ( _Words < this -> _Myvec . size ( ) )
   this -> _Myvec . erase ( this -> _Myvec . begin ( ) + _Words,
    this -> _Myvec . end ( ) );
  this -> _Mysize = _Size;
  _Size %= _VBITS;
  if ( 0 < _Size )
   this -> _Myvec [ _Words - 1 ] &= ( _Vbase ) ( ( 1 << _Size ) - 1 );
  }

 __declspec ( noreturn ) void _Xlen ( ) const
  {
  _Xlength_error ( "vector<bool> too long" );
  }

 __declspec ( noreturn ) void _Xran ( ) const
  {
  _Xout_of_range ( "invalid vector<bool> subscript" );
  }
 };
#line 2634 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vector"
typedef vector< bool, allocator< bool> >  _Bvector; 
#line 2637
template< class _Kty> class hash; 
#line 2640
template < class _Alloc >
 class hash < vector < _Bool, _Alloc > >
  : public unary_function < vector < _Bool, _Alloc >, size_t >
 {
public :
 typedef vector < _Bool, _Alloc > _Kty;

 size_t operator ( ) ( const _Kty & _Keyval ) const
  {
  return ( _Keyval . hash ( ) );
  }
 };
#line 2653 "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\include\\vector"
}
#line 2655
#pragma warning(pop)
#pragma pack ( pop )
#line 28 "c:\\users\\blake\\documents\\github\\pct-reconstruction\\pCT_Reconstruction.h"
using namespace std::placeholders;
#line 38
const bool RUN_ON = false; 
#line 39
const bool EXIT_AFTER_BINNING = false; 
#line 40
const bool EXIT_AFTER_HULLS = false; 
#line 41
const bool EXIT_AFTER_CUTS = false; 
#line 42
const bool EXIT_AFTER_SINOGRAM = false; 
#line 43
const bool EXIT_AFTER_FBP = false; 
#line 47
const bool DEBUG_TEXT_ON = true; 
#line 48
const bool SAMPLE_STD_DEV = true; 
#line 49
const bool FBP_ON = true; 
#line 50
const bool SC_ON = true; 
#line 51
const bool MSC_ON = false; 
#line 52
const bool SM_ON = false; 
#line 53
const bool HULL_FILTER_ON = false; 
#line 54
const bool COUNT_0_WEPLS = false; 
#line 55
const bool REALLOCATE = false; 
#line 63
const char INPUT_DIRECTORY[] = "C:\\Users\\Blake\\Documents\\Visual Studio 2010\\Projects\\pCT_Reconstruction\\Input\\"; 
#line 64
const char OUTPUT_DIRECTORY[] = "C:\\Users\\Blake\\Documents\\Visual Studio 2010\\Projects\\pCT_Reconstruction\\Output\\"; 
#line 68
const char INPUT_FOLDER[] = "input_water_GeantNONUC"; 
#line 69
const char OUTPUT_FOLDER[] = "input_water_GeantNONUC"; 
#line 99
const char INPUT_BASE_NAME[] = "projection"; 
#line 106
const char FILE_EXTENSION[] = ".bin"; 
#line 112
enum DATA_FORMATS { OLD_FORMAT, VERSION_0, VERSION_1}; 
#line 113
const DATA_FORMATS DATA_FORMAT = VERSION_0; 
#line 114
const bool BINARY_ENCODING = true; 
#line 115
const bool SINGLE_DATA_FILE = false; 
#line 116
const bool SSD_IN_MM = true; 
#line 117
const bool DATA_IN_MM = true; 
#line 118
const bool MICAH_SIM = false; 
#line 122
const bool WRITE_SC_HULL = true; 
#line 123
const bool WRITE_MSC_COUNTS = true; 
#line 124
const bool WRITE_MSC_HULL = true; 
#line 125
const bool WRITE_SM_COUNTS = true; 
#line 126
const bool WRITE_SM_HULL = true; 
#line 127
const bool WRITE_FBP_IMAGE = true; 
#line 128
const bool WRITE_FBP_HULL = true; 
#line 129
const bool WRITE_FILTERED_HULL = true; 
#line 130
const bool WRITE_X_HULL = true; 
#line 131
const bool WRITE_X_K0 = true; 
#line 135
enum BIN_ANALYSIS_TYPE { MEANS, COUNTS, MEMBERS}; 
#line 136
enum BIN_ANALYSIS_FOR { ALL_BINS, SPECIFIC_BINS}; 
#line 137
enum BIN_ORGANIZATION { BY_BIN, BY_HISTORY}; 
#line 138
enum BIN_ANALYSIS_OF { WEPLS, ANGLES, POSITIONS, BIN_NUMS}; 
#line 139
const bool WRITE_BIN_WEPLS = false; 
#line 140
const bool WRITE_WEPL_DISTS = true; 
#line 141
const bool WRITE_SSD_ANGLES = false; 
#line 167
double p0, p1, p2, p3, p4; 
#line 168
static double Estage[5] = {(25.850000000000001), (29.039999999999999), (34.43), (47.799999999999997), (52.630000000000003)}; 
#line 169
double ped[5] = {(9.6449999999999996), (-(20.484000000000002)), (-(201.98699999999999)), (62.966000000000001), (-(7.7469999999999999))}; 
#line 170
double ucal = ((216.90000000000001) + (40)); 
#line 187
enum FILTER_TYPES { RAM_LAK, SHEPP_LOGAN, NONE}; 
#line 188
const FILTER_TYPES FBP_FILTER = SHEPP_LOGAN; 
#line 226
enum HULL_TYPES { SC_HULL, MSC_HULL, SM_HULL, FBP_HULL}; 
#line 227
const HULL_TYPES MLP_HULL = FBP_HULL; 
#line 233
double A_0 = (7.4569999999999999) * pow(10, -(6.0)); 
#line 234
double A_1 = (4.548) * pow(10, -(7.0)); 
#line 235
double A_2 = (-(5.7770000000000001)) * pow(10, -(8.0)); 
#line 236
double A_3 = (1.3009999999999999) * pow(10, -(8.0)); 
#line 237
double A_4 = (-(9.2279999999999998)) * pow(10, -(10.0)); 
#line 238
double A_5 = (2.6869999999999998) * pow(10, -(11.0)); 
#line 242
enum INITIAL_ITERATE { X_HULL, FBP_IMAGE, HYBRID}; 
#line 243
const INITIAL_ITERATE X_K0 = HYBRID; 
#line 280
int total_histories = 0, recon_vol_histories = 0, maximum_histories_per_file = 0; 
#line 281
int *histories_per_projection, *histories_per_gantry_angle, *histories_per_file; 
#line 282
int *recon_vol_histories_per_projection; 
#line 283
int histories_per_scan[1]; 
#line 284
int post_cut_histories = 0; 
#line 288
float SSD_u_Positions[8]; 
#line 289
float *ut_entry_angle, *uv_entry_angle, *ut_exit_angle, *uv_exit_angle; 
#line 290
int zero_WEPL = 0; 
#line 291
int zero_WEPL_files = 0; 
#line 295
int *gantry_angle_h, *bin_num_h, *bin_counts_h; 
#line 296
bool *missed_recon_volume_h, *failed_cuts_h; 
#line 297
float *t_in_1_h, *t_in_2_h, *t_out_1_h, *t_out_2_h; 
#line 298
float *u_in_1_h, *u_in_2_h, *u_out_1_h, *u_out_2_h; 
#line 299
float *v_in_1_h, *v_in_2_h, *v_out_1_h, *v_out_2_h; 
#line 300
float *ut_entry_angle_h, *ut_exit_angle_h; 
#line 301
float *uv_entry_angle_h, *uv_exit_angle_h; 
#line 302
float *x_entry_h, *y_entry_h, *z_entry_h; 
#line 303
float *x_exit_h, *y_exit_h, *z_exit_h; 
#line 304
float *xy_entry_angle_h, *xy_exit_angle_h; 
#line 305
float *xz_entry_angle_h, *xz_exit_angle_h; 
#line 306
float *relative_ut_angle_h, *relative_uv_angle_h; 
#line 307
float *WEPL_h; 
#line 311
int *gantry_angle_d, *bin_num_d, *bin_counts_d; 
#line 312
bool *missed_recon_volume_d, *failed_cuts_d; 
#line 313
float *t_in_1_d, *t_in_2_d, *t_out_1_d, *t_out_2_d; 
#line 314
float *u_in_1_d, *u_in_2_d, *u_out_1_d, *u_out_2_d; 
#line 315
float *v_in_1_d, *v_in_2_d, *v_out_1_d, *v_out_2_d; 
#line 316
float *ut_entry_angle_d, *ut_exit_angle_d; 
#line 317
float *uv_entry_angle_d, *uv_exit_angle_d; 
#line 318
float *x_entry_d, *y_entry_d, *z_entry_d; 
#line 319
float *x_exit_d, *y_exit_d, *z_exit_d; 
#line 320
float *xy_entry_angle_d, *xy_exit_angle_d; 
#line 321
float *xz_entry_angle_d, *xz_exit_angle_d; 
#line 322
float *relative_ut_angle_d, *relative_uv_angle_d; 
#line 323
float *WEPL_d; 
#line 327
float *mean_WEPL_h, *mean_WEPL_d; 
#line 328
float *mean_energy_h, *mean_energy_d; 
#line 329
float *mean_rel_ut_angle_h, *mean_rel_ut_angle_d; 
#line 330
float *mean_rel_uv_angle_h, *mean_rel_uv_angle_d; 
#line 331
float *mean_total_rel_angle_h, *mean_total_rel_angle_d; 
#line 332
float *stddev_rel_ut_angle_h, *stddev_rel_ut_angle_d; 
#line 333
float *stddev_rel_uv_angle_h, *stddev_rel_uv_angle_d; 
#line 334
float *stddev_WEPL_h, *stddev_WEPL_d; 
#line 338
float *sinogram_h, *sinogram_d; 
#line 339
float *sinogram_filtered_h, *sinogram_filtered_d; 
#line 343
bool *SC_hull_h, *SC_hull_d; 
#line 344
bool *MSC_hull_h, *MSC_hull_d; 
#line 345
bool *SM_hull_h, *SM_hull_d; 
#line 346
bool *FBP_hull_h, *FBP_hull_d; 
#line 347
bool *x_hull_h, *x_hull_d; 
#line 348
int *MSC_counts_h, *MSC_counts_d; 
#line 349
int *SM_counts_h, *SM_counts_d; 
#line 350
int *MLP_test_image_h, *MLP_test_image_d; 
#line 351
float *FBP_image_h, *FBP_image_d; 
#line 352
float *x_h, *x_d; 
#line 356
std::vector< int>  bin_num_vector; 
#line 357
std::vector< int>  gantry_angle_vector; 
#line 358
std::vector< float>  WEPL_vector; 
#line 359
std::vector< float>  x_entry_vector; 
#line 360
std::vector< float>  y_entry_vector; 
#line 361
std::vector< float>  z_entry_vector; 
#line 362
std::vector< float>  x_exit_vector; 
#line 363
std::vector< float>  y_exit_vector; 
#line 364
std::vector< float>  z_exit_vector; 
#line 365
std::vector< float>  xy_entry_angle_vector; 
#line 366
std::vector< float>  xz_entry_angle_vector; 
#line 367
std::vector< float>  xy_exit_angle_vector; 
#line 368
std::vector< float>  xz_exit_angle_vector; 
#line 369
std::vector< float>  relative_ut_angle_vector; 
#line 370
std::vector< float>  relative_uv_angle_vector; 
#line 374
int *bin_index; 
#line 375
float *bin_WEPL; 
#line 376
int *bin_num; 
#line 377
int *gantry_angle; 
#line 378
float *WEPL; 
#line 379
float *x_entry; 
#line 380
float *y_entry; 
#line 381
float *z_entry; 
#line 382
float *x_exit; 
#line 383
float *y_exit; 
#line 384
float *z_exit; 
#line 385
float *xy_entry_angle; 
#line 386
float *xz_entry_angle; 
#line 387
float *xy_exit_angle; 
#line 388
float *xz_exit_angle; 
#line 389
float *relative_ut_angle; 
#line 390
float *relative_uv_angle; 
#line 394
clock_t start_time, end_time, execution_time; 
#line 405
int MLP_IMAGE_COLUMNS = 100, MLP_IMAGE_ROWS = 100, MLP_IMAGE_SLICES = 5; 
#line 406
int MLP_IMAGE_VOXELS = (MLP_IMAGE_COLUMNS * MLP_IMAGE_ROWS) * MLP_IMAGE_SLICES; 
#line 407
int MLP_IMAGE_SIZE = MLP_IMAGE_VOXELS * sizeof(int); 
#line 409
int MLP_IMAGE_RECON_CYL_RADIUS_VOXELS = 40; 
#line 410
int MLP_IMAGE_RECON_CYL_HEIGHT_VOXELS = 5; 
#line 411
int MLP_PHANTOM_A_VOXELS = 15, MLP_PHANTOM_B_VOXELS = 25; 
#line 413
double MLP_IMAGE_VOXEL_WIDTH = (0.10000000000000001); 
#line 414
double MLP_IMAGE_VOXEL_HEIGHT = (0.10000000000000001); 
#line 415
double MLP_IMAGE_VOXEL_THICKNESS = (1.0); 
#line 417
double MLP_IMAGE_RECON_CYL_RADIUS = MLP_IMAGE_RECON_CYL_RADIUS_VOXELS * MLP_IMAGE_VOXEL_WIDTH; 
#line 418
double MLP_IMAGE_RECON_CYL_HEIGHT = MLP_IMAGE_RECON_CYL_HEIGHT_VOXELS * MLP_IMAGE_VOXEL_THICKNESS; 
#line 419
double MLP_PHANTOM_A = MLP_PHANTOM_A_VOXELS * MLP_IMAGE_VOXEL_WIDTH; 
#line 420
double MLP_PHANTOM_B = MLP_PHANTOM_B_VOXELS * MLP_IMAGE_VOXEL_HEIGHT; 
#line 422
double MLP_IMAGE_WIDTH = MLP_IMAGE_COLUMNS * MLP_IMAGE_VOXEL_WIDTH; 
#line 423
double MLP_IMAGE_HEIGHT = MLP_IMAGE_ROWS * MLP_IMAGE_VOXEL_HEIGHT; 
#line 424
double MLP_IMAGE_THICKNESS = MLP_IMAGE_SLICES * MLP_IMAGE_VOXEL_THICKNESS; 
#line 27 "c:\\users\\blake\\documents\\github\\pct-reconstruction\\pCT_Reconstruction_GPU.cu"
void test_func_3() 
#line 28
{ 
#line 29
(((std::cout << ("Hello"))) << (std::endl)); 
#line 30
} 
#line 18 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void write_run_settings(); 
#line 19
void assign_SSD_positions(); 
#line 20
void initializations(); 
#line 21
void count_histories(); 
#line 22
void count_histories_old(); 
#line 23
void count_histories_v0(); 
#line 24
void count_histories_v1(); 
#line 25
void reserve_vector_capacity(); 
#line 28
void read_energy_responses(const int, const int, const int); 
#line 29
void read_data_chunk(const int, const int, const int); 
#line 30
void read_data_chunk_old(const int, const int, const int); 
#line 31
void read_data_chunk_v0(const int, const int, const int); 
#line 32
void read_data_chunk_v1(const int, const int, const int); 
#line 33
void recon_volume_intersections(const int); 
#line 34
void recon_volume_intersections2(const int); 
#line 35
void binning(const int); 
#line 36
void calculate_means(); 
#line 37
void initialize_stddev(); 
#line 38
void sum_squared_deviations(const int, const int); 
#line 39
void calculate_standard_deviations(); 
#line 40
void statistical_cuts(const int, const int); 
#line 41
void initialize_sinogram(); 
#line 42
void construct_sinogram(); 
#line 43
void FBP(); 
#line 44
void FBP_image_2_hull(); 
#line 45
void filter(); 
#line 46
void backprojection(); 
#line 49
void hull_initializations(); 
#line 50
template< class T> void initialize_hull(T *&, T *&); 
#line 51
void hull_detection(const int); 
#line 52
void hull_detection_finish(); 
#line 53
void SC(const int); 
#line 54
void MSC(const int); 
#line 55
void MSC_edge_detection(); 
#line 56
void SM(const int); 
#line 57
void SM_edge_detection(); 
#line 58
void SM_edge_detection_2(); 
#line 59
void hull_selection(); 
#line 60
template< class T, class T2> void averaging_filter(T *&, T2 *&); 
#line 63
void create_MLP_test_image(); 
#line 64
void MLP_test(); 
#line 65
void MLP(); 
#line 66
void MLP_entry_exit(int &, int &, int &); 
#line 67
float mean_chord_length(float, float); 
#line 70
void create_hull_image_hybrid(); 
#line 71
void define_initial_iterate(); 
#line 74
template< class T> void array_2_disk(char *, const char *, const char *, T *, const int, const int, const int, const int, const bool); 
#line 75
template< class T> void vector_2_disk(char *, const char *, const char *, std::vector< T> , const int, const int, const int, const bool); 
#line 76
void write_t_bin_data(FILE *, const std::vector< int>  &, const std::vector< float>  &, const BIN_ANALYSIS_TYPE, const int); 
#line 77
void write_bin_data(const char *, const std::vector< int>  &, const std::vector< float>  &, const BIN_ANALYSIS_TYPE, const BIN_ANALYSIS_FOR, const BIN_ORGANIZATION, ...); 
#line 78
void write_t_bin_data(FILE *, int *&, float *&, const int, const BIN_ANALYSIS_TYPE, const BIN_ORGANIZATION, int); 
#line 79
void write_bin_data(const char *, int *&, float *&, const int, const BIN_ANALYSIS_TYPE, const BIN_ANALYSIS_FOR, const BIN_ORGANIZATION, ...); 
#line 80
void bin_2_txt(); 
#line 83
void post_cut_memory_clean(); 
#line 84
void resize_vectors(const int); 
#line 85
void shrink_vectors(const int); 
#line 86
void initial_processing_memory_clean(); 
#line 87
void allocations(const int); 
#line 88
void reallocations(const int); 
#line 91
void exit_program_if(bool); 
#line 92
void start_execution_timing(); 
#line 93
void stop_execution_timing(); 
#line 94
void pause_execution(); 
#line 95
bool is_bad_angle(const int); 
#line 96
int calculate_x_voxel(const float, const int, const float); 
#line 97
int calculate_y_voxel(const float, const int, const float); 
#line 98
int calculate_slice(const float, const int, const float); 
#line 99
int positions_2_voxels(const double, const double, const double, int &, int &, int &); 
#line 100
void bin_2_indexes(int, int &, int &, int &); 
#line 103
void test_func(); 
#line 104
void test_func2(std::vector< int>  &, std::vector< float>  &); 
#line 111
bool calculate_intercepts(double, double, double, double &, double &); 
#line 112
void recon_volume_intersections_GPU(int, int *, bool *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *); 
#line 113
void binning_GPU(int, int *, int *, bool *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *); 
#line 114
void calculate_means_GPU(int *, float *, float *, float *); 
#line 115
void sum_squared_deviations_GPU(int, int *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *); 
#line 116
void calculate_standard_deviations_GPU(int *, float *, float *, float *); 
#line 117
void statistical_cuts_GPU(int, int *, int *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, float *, bool *); 
#line 118
void construct_sinogram_GPU(int *, float *); 
#line 119
void filter_GPU(float *, float *); 
#line 120
void backprojection_GPU(float *, float *); 
#line 123
template< class T> static void __wrapper__device_stub_initialize_hull_GPU(T *&); template< class T> void initialize_hull_GPU(T *); 
#line 124
int position_2_voxel_GPU(double , double , double ); 
#line 125
void voxel_walk_GPU(bool *&, float, float, float, float, float, float); 
#line 126
double x_remaining_GPU(double, int, int &); 
#line 127
double y_remaining_GPU(double, int, int &); 
#line 128
double z_remaining_GPU(double, int, int &); 
#line 129
void FBP_image_2_hull_GPU(float *, bool *); 
#line 130
void SC_GPU(const int, bool *, int *, bool *, float *, float *, float *, float *, float *, float *, float *); 
#line 131
void MSC_GPU(const int, int *, int *, bool *, float *, float *, float *, float *, float *, float *, float *); 
#line 132
void SM_GPU(const int, int *, int *, bool *, float *, float *, float *, float *, float *, float *, float *); 
#line 133
void MSC_edge_detection_GPU(int *); 
#line 134
void SM_edge_detection_GPU(int *, int *); 
#line 135
void SM_edge_detection_GPU_2(int *, int *); 
#line 136
void carve_differences(int *, int *); 
#line 137
template< class H, class D> static void __wrapper__device_stub_averaging_filter_GPU(H *&, D *&, bool &); template< class H, class D> void averaging_filter_GPU(H *, D *, bool); 
#line 138
template< class D> static void __wrapper__device_stub_apply_averaging_filter_GPU(D *&, D *&); template< class D> void apply_averaging_filter_GPU(D *, D *); 
#line 141
void create_hull_image_hybrid_GPU(bool *&, float *&); 
#line 144
void test_func_GPU(int *); 
#line 145
void test_func_device(int &, int &, int &); 
#line 150
int main(int argc, char **argv) 
#line 151
{ 
#line 152
if (RUN_ON) 
#line 153
{ 
#line 157
start_execution_timing(); 
#line 161
hull_initializations(); 
#line 166
if (DATA_FORMAT == (OLD_FORMAT)) { 
#line 167
assign_SSD_positions(); }  
#line 168
initializations(); 
#line 169
count_histories(); 
#line 173
int start_file_num = 0, end_file_num = 0, histories_to_process = 0; 
#line 174
while (start_file_num != (1 * ((int)((360) / (6.0))))) 
#line 175
{ 
#line 176
while (end_file_num < (1 * ((int)((360) / (6.0))))) 
#line 177
{ 
#line 178
if ((histories_to_process + (histories_per_file[end_file_num])) < 300000) { 
#line 179
histories_to_process += (histories_per_file[end_file_num]); } else { 
#line 181
break; }  
#line 182
end_file_num++; 
#line 183
}  
#line 184
read_energy_responses(histories_to_process, start_file_num, end_file_num); 
#line 185
start_file_num = end_file_num; 
#line 186
histories_to_process = 0; 
#line 187
}  
#line 197
puts("Iteratively reading data from hard disk"); 
#line 198
puts("Removing proton histories that don\'t pass through the reconstruction volume"); 
#line 199
puts("Binning the data from those that did..."); 
#line 200
((start_file_num = 0), (end_file_num = 0)), (histories_to_process = 0); 
#line 201
while (start_file_num != (1 * ((int)((360) / (6.0))))) 
#line 202
{ 
#line 203
while (end_file_num < (1 * ((int)((360) / (6.0))))) 
#line 204
{ 
#line 205
if ((histories_to_process + (histories_per_file[end_file_num])) < 300000) { 
#line 206
histories_to_process += (histories_per_file[end_file_num]); } else { 
#line 208
break; }  
#line 209
end_file_num++; 
#line 210
}  
#line 211
read_data_chunk(histories_to_process, start_file_num, end_file_num); 
#line 212
recon_volume_intersections(histories_to_process); 
#line 213
binning(histories_to_process); 
#line 214
hull_detection(histories_to_process); 
#line 215
initial_processing_memory_clean(); 
#line 216
start_file_num = end_file_num; 
#line 217
histories_to_process = 0; 
#line 218
}  
#line 219
if (COUNT_0_WEPLS) { 
#line 220
(((((std::cout << ("Histories with WEPL = 0 : "))) << zero_WEPL)) << (std::endl)); }  
#line 221
puts("Data reading complete."); 
#line 222
printf("%d out of %d (%4.2f%%) histories passed through the reconstruction volume.\n", recon_vol_histories, total_histories, (((double)recon_vol_histories) / total_histories) * (100)); 
#line 223
exit_program_if(EXIT_AFTER_BINNING); 
#line 227
shrink_vectors(recon_vol_histories); 
#line 231
hull_detection_finish(); 
#line 232
exit_program_if(EXIT_AFTER_HULLS); 
#line 236
calculate_means(); 
#line 237
initialize_stddev(); 
#line 244
puts("Calculating the cumulative sum of the squared deviation in WEPL and relative ut/uv angles over all histories for each bin..."); 
#line 245
int remaining_histories = recon_vol_histories; 
#line 246
int start_position = 0; 
#line 247
while (remaining_histories > 0) 
#line 248
{ 
#line 249
if (remaining_histories > 300000) { 
#line 250
histories_to_process = 300000; } else { 
#line 252
histories_to_process = remaining_histories; }  
#line 253
sum_squared_deviations(start_position, histories_to_process); 
#line 254
remaining_histories -= 300000; 
#line 255
start_position += 300000; 
#line 256
}  
#line 257
calculate_standard_deviations(); 
#line 261
initialize_sinogram(); 
#line 265
puts("Performing statistical cuts..."); 
#line 266
(remaining_histories = recon_vol_histories), (start_position = 0); 
#line 267
while (remaining_histories > 0) 
#line 268
{ 
#line 269
if (remaining_histories > 300000) { 
#line 270
histories_to_process = 300000; } else { 
#line 272
histories_to_process = remaining_histories; }  
#line 273
statistical_cuts(start_position, histories_to_process); 
#line 274
remaining_histories -= 300000; 
#line 275
start_position += 300000; 
#line 276
}  
#line 277
puts("Statistical cuts complete."); 
#line 278
printf("%d out of %d (%4.2f%%) histories passed cuts\n", post_cut_histories, total_histories, (((double)post_cut_histories) / total_histories) * (100)); 
#line 282
post_cut_memory_clean(); 
#line 283
resize_vectors(post_cut_histories); 
#line 284
shrink_vectors(post_cut_histories); 
#line 285
exit_program_if(EXIT_AFTER_CUTS); 
#line 289
construct_sinogram(); 
#line 290
exit_program_if(EXIT_AFTER_SINOGRAM); 
#line 294
if (FBP_ON) { 
#line 295
FBP(); }  
#line 296
exit_program_if(EXIT_AFTER_FBP); 
#line 299
} else 
#line 301
{ 
#line 303
test_func(); 
#line 304
}  
#line 308
puts("Preprocessing complete.  Press enter to close the console window..."); 
#line 309
exit_program_if(true); return 0; 
#line 310
} 
#line 314
void read_energy_responses(const int num_histories, const int start_file_num, const int end_file_num) 
#line 315
{ 
#line 317
char data_filename[128]; 
#line 318
char magic_number[5]; 
#line 319
int version_id; 
#line 320
int file_histories; 
#line 321
float projection_angle, beam_energy; 
#line 322
int generation_date, preprocess_date; 
#line 323
int phantom_name_size, data_source_size, prepared_by_size; 
#line 324
char *phantom_name, *data_source, *prepared_by; 
#line 325
int data_size; 
#line 327
int gantry_position, gantry_angle, scan_number, scan_histories; 
#line 329
FILE *input_file; 
#line 331
puts("Reading energy detector responses and performing energy response calibration..."); 
#line 333
sprintf(data_filename, "%s%s/%s_%03d%s", INPUT_DIRECTORY, INPUT_FOLDER, INPUT_BASE_NAME, gantry_angle, FILE_EXTENSION); 
#line 334
} 
#line 338
void write_run_settings() 
#line 339
{ 
#line 340
char user_response[20]; 
#line 341
char run_settings_filename[512]; 
#line 342
puts("Reading tracker plane positions..."); 
#line 344
sprintf(run_settings_filename, "%s%s\\run_settings.cfg", INPUT_DIRECTORY, INPUT_FOLDER); 
#line 345
if (DEBUG_TEXT_ON) { 
#line 346
printf("Opening run settings file %s...\n", run_settings_filename); }  
#line 347
std::ofstream run_settings_file(run_settings_filename); 
#line 348
if (!run_settings_file.is_open()) { 
#line 349
printf("ERROR: run settings file file not found at %s!\n", run_settings_filename); 
#line 350
exit_program_if(true); 
#line 351
} else 
#line 353
{ 
#line 354
fputs("Found File", &(__iob_func()[1])); 
#line 355
fflush(&(__iob_func()[1])); 
#line 356
printf("user_response = \"%s\"\n", user_response); 
#line 357
}  
#line 358
if (DEBUG_TEXT_ON) { 
#line 359
puts("Loading run settings..."); }  
#line 360
(((((run_settings_file << ("MAX_GPU_HISTORIES = "))) << (300000))) << (std::endl)); 
#line 361
(((((run_settings_file << ("GANTRY_ANGLE_INTERVAL = "))) << ((6.0)))) << (std::endl)); 
#line 362
(((((run_settings_file << ("SSD_T_SIZE = "))) << ((35.0)))) << (std::endl)); 
#line 363
(((((run_settings_file << ("SSD_V_SIZE = "))) << ((9.0)))) << (std::endl)); 
#line 364
(((((run_settings_file << ("T_BIN_SIZE = "))) << ((0.10000000000000001)))) << (std::endl)); 
#line 365
(((((run_settings_file << ("V_BIN_SIZE = "))) << ((0.25)))) << (std::endl)); 
#line 366
(((((run_settings_file << ("ANGULAR_BIN_SIZE = "))) << ((6.0)))) << (std::endl)); 
#line 367
(((((run_settings_file << ("GANTRY_ANGLE_INTERVAL = "))) << ((6.0)))) << (std::endl)); 
#line 368
(((((run_settings_file << ("RECON_CYL_RADIUS = "))) << ((8.0)))) << (std::endl)); 
#line 369
(((((run_settings_file << ("RECON_CYL_HEIGHT = "))) << ((6.0)))) << (std::endl)); 
#line 370
(((((run_settings_file << ("COLUMNS = "))) << (200))) << (std::endl)); 
#line 371
(((((run_settings_file << ("ROWS = "))) << (200))) << (std::endl)); 
#line 372
(((((run_settings_file << ("SLICE_THICKNESS"))) << ((0.25)))) << (std::endl)); 
#line 378
run_settings_file.close(); 
#line 379
} 
#line 380
void assign_SSD_positions() 
#line 381
{ 
#line 382
char user_response[20]; 
#line 383
char configFilename[512]; 
#line 384
puts("Reading tracker plane positions..."); 
#line 386
sprintf(configFilename, "%s%s\\scan.cfg", INPUT_DIRECTORY, INPUT_FOLDER); 
#line 387
if (DEBUG_TEXT_ON) { 
#line 388
printf("Opening config file %s...\n", configFilename); }  
#line 389
std::ifstream configFile(configFilename); 
#line 390
if (!configFile.is_open()) { 
#line 391
printf("ERROR: config file not found at %s!\n", configFilename); 
#line 392
exit_program_if(true); 
#line 393
} else 
#line 395
{ 
#line 396
fputs("Found File", &(__iob_func()[1])); 
#line 397
fflush(&(__iob_func()[1])); 
#line 398
printf("user_response = \"%s\"\n", user_response); 
#line 399
}  
#line 400
if (DEBUG_TEXT_ON) { 
#line 401
puts("Reading Tracking Plane Positions..."); }  
#line 402
for (int i = 0; i < 8; i++) { 
#line 403
(configFile >> ((SSD_u_Positions)[i])); 
#line 404
if (DEBUG_TEXT_ON) { 
#line 405
printf("SSD_u_Positions[%d] = %3f", i, (SSD_u_Positions)[i]); }  
#line 406
}  
#line 408
configFile.close(); 
#line 410
} 
#line 411
void count_histories() 
#line 412
{ 
#line 413
for (int scan_number = 0; scan_number < 1; scan_number++) { 
#line 414
((histories_per_scan)[scan_number]) = 0; }  
#line 416
histories_per_file = ((int *)calloc(1 * ((int)((360) / (6.0))), sizeof(int))); 
#line 417
histories_per_gantry_angle = ((int *)calloc((int)((360) / (6.0)), sizeof(int))); 
#line 418
recon_vol_histories_per_projection = ((int *)calloc((int)((360) / (6.0)), sizeof(int))); 
#line 420
if (DEBUG_TEXT_ON) { 
#line 421
puts("Counting proton histories...\n"); }  
#line 422
switch (DATA_FORMAT) 
#line 423
{ 
#line 424
case OLD_FORMAT:  count_histories_old(); break; 
#line 425
case VERSION_0:  count_histories_v0(); break; 
#line 426
case VERSION_1:  count_histories_v1(); break; 
#line 427
}  
#line 428
if (DEBUG_TEXT_ON) 
#line 429
{ 
#line 430
for (int file_number = 0, gantry_position_number = 0; file_number < (1 * ((int)((360) / (6.0)))); (file_number++), (gantry_position_number++)) 
#line 431
{ 
#line 432
if ((file_number % 1) == 0) { 
#line 433
printf("There are a Total of %d Histories From Gantry Angle %d\n", histories_per_gantry_angle[gantry_position_number], (int)(gantry_position_number * (6.0))); }  
#line 434
printf("* %d Histories are From Scan Number %d\n", histories_per_file[file_number], (file_number % 1) + 1); 
#line 436
}  
#line 437
for (int scan_number = 0; scan_number < 1; scan_number++) { 
#line 438
printf("There are a Total of %d Histories in Scan Number %d \n", (histories_per_scan)[scan_number], scan_number + 1); }  
#line 439
printf("There are a Total of %d Histories\n", total_histories); 
#line 440
}  
#line 441
} 
#line 442
void count_histories_old() 
#line 443
{ 
#line 445
char data_filename[128]; 
#line 446
int file_size, num_histories, file_number = 0, gantry_position_number = 0; 
#line 447
for (int gantry_angle = 0; gantry_angle < 360; (gantry_angle += ((int)(6.0))), (gantry_position_number++)) 
#line 448
{ 
#line 449
for (int scan_number = 1; scan_number <= 1; (scan_number++), (file_number++)) 
#line 450
{ 
#line 452
sprintf(data_filename, "%s%s/%s_trans%d_%03d%s", INPUT_DIRECTORY, INPUT_FOLDER, INPUT_BASE_NAME, scan_number, gantry_angle, FILE_EXTENSION); 
#line 453
FILE *data_file = fopen(data_filename, "rb"); 
#line 454
if (data_file == (0)) 
#line 455
{ 
#line 456
fputs("Error Opening Data File:  Check that the directories are properly named.", &(__iob_func()[2])); 
#line 457
exit_program_if(true); 
#line 458
}  
#line 459
fseek(data_file, 0, 2); 
#line 460
file_size = (ftell(data_file)); 
#line 461
if (BINARY_ENCODING) 
#line 462
{ 
#line 463
if (file_size % 48) 
#line 464
{ 
#line 465
printf("ERROR! Problem with bytes_per_history!\n"); 
#line 466
exit_program_if(true); 
#line 467
}  
#line 468
num_histories = (file_size / 48); 
#line 469
} else { 
#line 471
num_histories = file_size; }  
#line 472
fclose(data_file); 
#line 473
(histories_per_file[file_number]) = num_histories; 
#line 474
(histories_per_gantry_angle[gantry_position_number]) += num_histories; 
#line 475
((histories_per_scan)[scan_number - 1]) += num_histories; 
#line 476
total_histories += num_histories; 
#line 478
if (DEBUG_TEXT_ON) { 
#line 479
printf("There are %d Histories for Gantry Angle %d From Scan Number %d\n", num_histories, gantry_angle, scan_number); }  
#line 480
}  
#line 481
}  
#line 482
} 
#line 483
void count_histories_v0() 
#line 484
{ 
#line 486
char data_filename[256]; 
#line 487
int num_histories, file_number = 0, gantry_position_number = 0; 
#line 488
for (int gantry_angle = 0; gantry_angle < 360; (gantry_angle += ((int)(6.0))), (gantry_position_number++)) 
#line 489
{ 
#line 490
for (int scan_number = 1; scan_number <= 1; (scan_number++), (file_number++)) 
#line 491
{ 
#line 492
sprintf(data_filename, "%s%s/%s_%03d%s", INPUT_DIRECTORY, INPUT_FOLDER, INPUT_BASE_NAME, gantry_angle, FILE_EXTENSION); 
#line 493
std::ifstream data_file(data_filename, std::_Iosb< int> ::binary); 
#line 494
if (data_file == (0)) 
#line 495
{ 
#line 496
fputs("File not found:  Check that the directories and files are properly named.", &(__iob_func()[2])); 
#line 497
exit_program_if(true); 
#line 498
}  
#line 499
char magic_number[5]; 
#line 500
data_file.read(magic_number, 4); 
#line 501
((magic_number)[4]) = '\000'; 
#line 502
if (strcmp(magic_number, "PCTD")) { 
#line 503
puts("Error: unknown file type (should be PCTD)!\n"); 
#line 504
exit_program_if(true); 
#line 505
}  
#line 506
int version_id; 
#line 507
data_file.read((char *)(&version_id), sizeof(int)); 
#line 508
if (version_id == 0) 
#line 509
{ 
#line 510
data_file.read((char *)(&num_histories), sizeof(int)); 
#line 511
data_file.close(); 
#line 512
(histories_per_file[file_number]) = num_histories; 
#line 513
(histories_per_gantry_angle[gantry_position_number]) += num_histories; 
#line 514
((histories_per_scan)[scan_number - 1]) += num_histories; 
#line 515
total_histories += num_histories; 
#line 517
if (DEBUG_TEXT_ON) { 
#line 518
printf("There are %d Histories for Gantry Angle %d From Scan Number %d\n", num_histories, gantry_angle, scan_number); }  
#line 519
} else 
#line 521
{ 
#line 522
printf("ERROR: Data format is not Version (%d)!\n", version_id); 
#line 523
exit_program_if(true); 
#line 524
}  
#line 525
}  
#line 526
}  
#line 527
} 
#line 528
void count_histories_v1() 
#line 529
{ 
#line 531
char data_filename[256]; 
#line 532
int num_histories, file_number = 0, gantry_position_number = 0; 
#line 533
for (int gantry_angle = 0; gantry_angle < 360; (gantry_angle += ((int)(6.0))), (gantry_position_number++)) 
#line 534
{ 
#line 535
for (int scan_number = 1; scan_number <= 1; (scan_number++), (file_number++)) 
#line 536
{ 
#line 537
sprintf(data_filename, "%s%s/%s_%03d%s", INPUT_DIRECTORY, INPUT_FOLDER, INPUT_BASE_NAME, gantry_angle, FILE_EXTENSION); 
#line 538
std::ifstream data_file(data_filename, std::_Iosb< int> ::binary); 
#line 539
if (data_file == (0)) 
#line 540
{ 
#line 541
fputs("File not found:  Check that the directories and files are properly named.", &(__iob_func()[2])); 
#line 542
exit_program_if(true); 
#line 543
}  
#line 544
char magic_number[5]; 
#line 545
data_file.read(magic_number, 4); 
#line 546
((magic_number)[4]) = '\000'; 
#line 547
if (strcmp(magic_number, "PCTD")) { 
#line 548
puts("Error: unknown file type (should be PCTD)!\n"); 
#line 549
exit_program_if(true); 
#line 550
}  
#line 551
int version_id; 
#line 552
data_file.read((char *)(&version_id), sizeof(int)); 
#line 553
if (version_id == 1) 
#line 554
{ 
#line 555
data_file.read((char *)(&num_histories), sizeof(int)); 
#line 556
data_file.close(); 
#line 557
(histories_per_file[file_number]) = num_histories; 
#line 558
(histories_per_gantry_angle[gantry_position_number]) += num_histories; 
#line 559
((histories_per_scan)[scan_number - 1]) += num_histories; 
#line 560
total_histories += num_histories; 
#line 562
if (DEBUG_TEXT_ON) { 
#line 563
printf("There are %d Histories for Gantry Angle %d From Scan Number %d\n", num_histories, gantry_angle, scan_number); }  
#line 564
} else 
#line 566
{ 
#line 567
printf("ERROR: Data format is not Version (%d)!\n", version_id); 
#line 568
exit_program_if(true); 
#line 569
}  
#line 570
}  
#line 571
}  
#line 572
} 
#line 576
void read_data_chunk(const int num_histories, const int start_file_num, const int end_file_num) 
#line 577
{ 
#line 583
unsigned size_floats = sizeof(float) * num_histories; 
#line 584
unsigned size_ints = sizeof(int) * num_histories; 
#line 586
t_in_1_h = ((float *)malloc(size_floats)); 
#line 587
t_in_2_h = ((float *)malloc(size_floats)); 
#line 588
t_out_1_h = ((float *)malloc(size_floats)); 
#line 589
t_out_2_h = ((float *)malloc(size_floats)); 
#line 590
u_in_1_h = ((float *)malloc(size_floats)); 
#line 591
u_in_2_h = ((float *)malloc(size_floats)); 
#line 592
u_out_1_h = ((float *)malloc(size_floats)); 
#line 593
u_out_2_h = ((float *)malloc(size_floats)); 
#line 594
v_in_1_h = ((float *)malloc(size_floats)); 
#line 595
v_in_2_h = ((float *)malloc(size_floats)); 
#line 596
v_out_1_h = ((float *)malloc(size_floats)); 
#line 597
v_out_2_h = ((float *)malloc(size_floats)); 
#line 598
WEPL_h = ((float *)malloc(size_floats)); 
#line 599
gantry_angle_h = ((int *)malloc(size_ints)); 
#line 601
if (WRITE_SSD_ANGLES) 
#line 602
{ 
#line 603
ut_entry_angle = ((float *)malloc(size_floats)); 
#line 604
uv_entry_angle = ((float *)malloc(size_floats)); 
#line 605
ut_exit_angle = ((float *)malloc(size_floats)); 
#line 606
uv_exit_angle = ((float *)malloc(size_floats)); 
#line 607
}  
#line 608
switch (DATA_FORMAT) 
#line 609
{ 
#line 610
case OLD_FORMAT:  read_data_chunk_old(num_histories, start_file_num, end_file_num - 1); break; 
#line 611
case VERSION_0:  read_data_chunk_v0(num_histories, start_file_num, end_file_num - 1); break; 
#line 612
case VERSION_1:  read_data_chunk_v1(num_histories, start_file_num, end_file_num - 1); break; 
#line 613
}  
#line 614
} 
#line 615
void read_data_chunk_old(const int num_histories, const int start_file_num, const int end_file_num) 
#line 616
{ 
#line 617
int array_index = 0, gantry_position, gantry_angle, scan_number, scan_histories; 
#line 618
float v_data[4], t_data[4], WEPL_data, gantry_angle_data, dummy_data; 
#line 619
char tracker_plane[4]; 
#line 620
char data_filename[128]; 
#line 621
FILE *data_file; 
#line 623
for (int file_num = start_file_num; file_num <= end_file_num; file_num++) 
#line 624
{ 
#line 625
gantry_position = (file_num / 1); 
#line 626
gantry_angle = ((int)(gantry_position * (6.0))); 
#line 627
scan_number = ((file_num % 1) + 1); 
#line 628
scan_histories = (histories_per_file[file_num]); 
#line 630
printf("Reading File for Gantry Angle %d from Scan Number %d...\n", gantry_angle, scan_number); 
#line 631
sprintf(data_filename, "%s%s/%s_trans%d_%03d%s", INPUT_DIRECTORY, INPUT_FOLDER, INPUT_BASE_NAME, scan_number, gantry_angle, FILE_EXTENSION); 
#line 632
data_file = fopen(data_filename, "rb"); 
#line 634
for (int history = 0; history < scan_histories; (history++), (array_index++)) 
#line 635
{ 
#line 636
fread(&v_data, sizeof(float), 4, data_file); 
#line 637
fread(&t_data, sizeof(float), 4, data_file); 
#line 638
fread(&tracker_plane, sizeof(char), 4, data_file); 
#line 639
fread(&WEPL_data, sizeof(float), 1, data_file); 
#line 640
fread(&gantry_angle_data, sizeof(float), 1, data_file); 
#line 641
fread(&dummy_data, sizeof(float), 1, data_file); 
#line 642
if (DATA_IN_MM) 
#line 643
{ 
#line 645
(v_in_1_h[array_index]) = (((v_data)[0]) * (0.10000000000000001)); ; 
#line 646
(v_in_2_h[array_index]) = (((v_data)[1]) * (0.10000000000000001)); ; 
#line 647
(v_out_1_h[array_index]) = (((v_data)[2]) * (0.10000000000000001)); ; 
#line 648
(v_out_2_h[array_index]) = (((v_data)[3]) * (0.10000000000000001)); ; 
#line 649
(t_in_1_h[array_index]) = (((t_data)[0]) * (0.10000000000000001)); ; 
#line 650
(t_in_2_h[array_index]) = (((t_data)[1]) * (0.10000000000000001)); ; 
#line 651
(t_out_1_h[array_index]) = (((t_data)[2]) * (0.10000000000000001)); ; 
#line 652
(t_out_2_h[array_index]) = (((t_data)[3]) * (0.10000000000000001)); ; 
#line 653
(WEPL_h[array_index]) = (WEPL_data * (0.10000000000000001)); ; 
#line 654
} else 
#line 656
{ 
#line 657
(v_in_1_h[array_index]) = ((v_data)[0]); 
#line 658
(v_in_2_h[array_index]) = ((v_data)[1]); 
#line 659
(v_out_1_h[array_index]) = ((v_data)[2]); 
#line 660
(v_out_2_h[array_index]) = ((v_data)[3]); 
#line 661
(t_in_1_h[array_index]) = ((t_data)[0]); 
#line 662
(t_in_2_h[array_index]) = ((t_data)[1]); 
#line 663
(t_out_1_h[array_index]) = ((t_data)[2]); 
#line 664
(t_out_2_h[array_index]) = ((t_data)[3]); 
#line 665
(WEPL_h[array_index]) = WEPL_data; 
#line 666
}  
#line 667
if (!MICAH_SIM) 
#line 668
{ 
#line 669
(u_in_1_h[array_index]) = ((SSD_u_Positions)[(int)((tracker_plane)[0])]); 
#line 670
(u_in_2_h[array_index]) = ((SSD_u_Positions)[(int)((tracker_plane)[1])]); 
#line 671
(u_out_1_h[array_index]) = ((SSD_u_Positions)[(int)((tracker_plane)[2])]); 
#line 672
(u_out_2_h[array_index]) = ((SSD_u_Positions)[(int)((tracker_plane)[3])]); 
#line 673
} else 
#line 675
{ 
#line 676
(u_in_1_h[array_index]) = ((SSD_u_Positions)[0]); 
#line 677
(u_in_2_h[array_index]) = ((SSD_u_Positions)[2]); 
#line 678
(u_out_1_h[array_index]) = ((SSD_u_Positions)[4]); 
#line 679
(u_out_2_h[array_index]) = ((SSD_u_Positions)[6]); 
#line 680
}  
#line 681
if (SSD_IN_MM) 
#line 682
{ 
#line 684
(u_in_1_h[array_index]) *= (0.10000000000000001); ; 
#line 685
(u_in_2_h[array_index]) *= (0.10000000000000001); ; 
#line 686
(u_out_1_h[array_index]) *= (0.10000000000000001); ; 
#line 687
(u_out_2_h[array_index]) *= (0.10000000000000001); ; 
#line 688
}  
#line 689
(gantry_angle_h[array_index]) = ((int)gantry_angle_data); 
#line 690
}  
#line 691
fclose(data_file); 
#line 692
}  
#line 693
} 
#line 694
void read_data_chunk_v0(const int num_histories, const int start_file_num, const int end_file_num) 
#line 695
{ 
#line 729
char data_filename[128]; 
#line 730
char magic_number[5]; 
#line 731
int version_id; 
#line 732
int file_histories; 
#line 733
float projection_angle, beam_energy; 
#line 734
int generation_date, preprocess_date; 
#line 735
int phantom_name_size, data_source_size, prepared_by_size; 
#line 736
char *phantom_name, *data_source, *prepared_by; 
#line 737
int data_size; 
#line 739
int gantry_position, gantry_angle, scan_number, scan_histories; 
#line 741
for (int file_num = start_file_num; file_num <= end_file_num; file_num++) 
#line 742
{ 
#line 743
gantry_position = (file_num / 1); 
#line 744
gantry_angle = ((int)(gantry_position * (6.0))); 
#line 745
scan_number = ((file_num % 1) + 1); 
#line 746
scan_histories = (histories_per_file[file_num]); 
#line 748
printf("Reading File for Gantry Angle %d from Scan Number %d...\n", gantry_angle, scan_number); 
#line 749
sprintf(data_filename, "%s%s/%s_%03d%s", INPUT_DIRECTORY, INPUT_FOLDER, INPUT_BASE_NAME, gantry_angle, FILE_EXTENSION); 
#line 750
std::ifstream data_file(data_filename, std::_Iosb< int> ::binary); 
#line 751
if (data_file == (0)) 
#line 752
{ 
#line 753
fputs("File not found:  Check that the directories and files are properly named.", &(__iob_func()[2])); 
#line 754
exit_program_if(true); 
#line 755
}  
#line 757
data_file.read(magic_number, 4); 
#line 758
((magic_number)[4]) = '\000'; 
#line 759
if (strcmp(magic_number, "PCTD")) { 
#line 760
puts("Error: unknown file type (should be PCTD)!\n"); 
#line 761
exit_program_if(true); 
#line 762
}  
#line 764
data_file.read((char *)(&version_id), sizeof(int)); 
#line 765
if (version_id == 0) 
#line 766
{ 
#line 767
data_file.read((char *)(&file_histories), sizeof(int)); 
#line 769
puts("Reading headers from file...\n"); 
#line 771
data_file.read((char *)(&projection_angle), sizeof(float)); 
#line 772
data_file.read((char *)(&beam_energy), sizeof(float)); 
#line 773
data_file.read((char *)(&generation_date), sizeof(int)); 
#line 774
data_file.read((char *)(&preprocess_date), sizeof(int)); 
#line 775
data_file.read((char *)(&phantom_name_size), sizeof(int)); 
#line 776
phantom_name = ((char *)malloc(phantom_name_size)); 
#line 777
data_file.read(phantom_name, phantom_name_size); 
#line 778
data_file.read((char *)(&data_source_size), sizeof(int)); 
#line 779
data_source = ((char *)malloc(data_source_size)); 
#line 780
data_file.read(data_source, data_source_size); 
#line 781
data_file.read((char *)(&prepared_by_size), sizeof(int)); 
#line 782
prepared_by = ((char *)malloc(prepared_by_size)); 
#line 783
data_file.read(prepared_by, prepared_by_size); 
#line 785
printf("Loading %d histories from file\n", num_histories); 
#line 787
data_size = (num_histories * sizeof(float)); 
#line 789
data_file.read((char *)t_in_1_h, data_size); 
#line 790
data_file.read((char *)t_in_2_h, data_size); 
#line 791
data_file.read((char *)t_out_1_h, data_size); 
#line 792
data_file.read((char *)t_out_2_h, data_size); 
#line 793
data_file.read((char *)v_in_1_h, data_size); 
#line 794
data_file.read((char *)v_in_2_h, data_size); 
#line 795
data_file.read((char *)v_out_1_h, data_size); 
#line 796
data_file.read((char *)v_out_2_h, data_size); 
#line 797
data_file.read((char *)u_in_1_h, data_size); 
#line 798
data_file.read((char *)u_in_2_h, data_size); 
#line 799
data_file.read((char *)u_out_1_h, data_size); 
#line 800
data_file.read((char *)u_out_2_h, data_size); 
#line 801
data_file.read((char *)WEPL_h, data_size); 
#line 803
for (int i = 0; i < num_histories; i++) 
#line 804
{ 
#line 805
if (DATA_IN_MM) 
#line 806
{ 
#line 808
(v_in_1_h[i]) *= (0.10000000000000001); 
#line 809
(v_in_2_h[i]) *= (0.10000000000000001); 
#line 810
(v_out_1_h[i]) *= (0.10000000000000001); 
#line 811
(v_out_2_h[i]) *= (0.10000000000000001); 
#line 812
(t_in_1_h[i]) *= (0.10000000000000001); 
#line 813
(t_in_2_h[i]) *= (0.10000000000000001); 
#line 814
(t_out_1_h[i]) *= (0.10000000000000001); 
#line 815
(t_out_2_h[i]) *= (0.10000000000000001); 
#line 816
(t_in_1_h[i]) += (0.0); 
#line 817
(t_in_2_h[i]) += (0.0); 
#line 818
(t_out_1_h[i]) += (0.0); 
#line 819
(t_out_2_h[i]) += (0.0); 
#line 820
(WEPL_h[i]) *= (0.10000000000000001); 
#line 823
(u_in_1_h[i]) *= (0.10000000000000001); 
#line 824
(u_in_2_h[i]) *= (0.10000000000000001); 
#line 825
(u_out_1_h[i]) *= (0.10000000000000001); 
#line 826
(u_out_2_h[i]) *= (0.10000000000000001); 
#line 827
(u_in_1_h[i]) += (0.0); 
#line 828
(u_in_2_h[i]) += (0.0); 
#line 829
(u_out_1_h[i]) += (0.0); 
#line 830
(u_out_2_h[i]) += (0.0); 
#line 831
if (COUNT_0_WEPLS && ((WEPL_h[i]) == (0))) 
#line 832
{ 
#line 833
zero_WEPL++; 
#line 834
zero_WEPL_files++; 
#line 835
}  
#line 836
}  
#line 837
if (WRITE_SSD_ANGLES) 
#line 838
{ 
#line 839
(ut_entry_angle[i]) = atan2((t_in_2_h[i]) - (t_in_1_h[i]), (u_in_2_h[i]) - (u_in_1_h[i])); 
#line 840
(uv_entry_angle[i]) = atan2((v_in_2_h[i]) - (v_in_1_h[i]), (u_in_2_h[i]) - (u_in_1_h[i])); 
#line 841
(ut_exit_angle[i]) = atan2((t_out_2_h[i]) - (t_out_1_h[i]), (u_out_2_h[i]) - (u_out_1_h[i])); 
#line 842
(uv_exit_angle[i]) = atan2((v_out_2_h[i]) - (v_out_1_h[i]), (u_out_2_h[i]) - (u_out_1_h[i])); 
#line 843
}  
#line 844
(gantry_angle_h[i]) = ((int)projection_angle); 
#line 845
}  
#line 846
data_file.close(); 
#line 847
if (WRITE_SSD_ANGLES) 
#line 848
{ 
#line 849
sprintf(data_filename, "%s_%03d%s", "ut_entry_angle", gantry_angle, ".txt"); 
#line 850
array_2_disk(data_filename, OUTPUT_DIRECTORY, OUTPUT_FOLDER, ut_entry_angle, 200, 200, (int)((6.0) / (0.25)), file_histories, true); 
#line 851
sprintf(data_filename, "%s_%03d%s", "uv_entry_angle", gantry_angle, ".txt"); 
#line 852
array_2_disk((char *)("ut_entry_angle"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, uv_entry_angle, 200, 200, (int)((6.0) / (0.25)), file_histories, true); 
#line 853
sprintf(data_filename, "%s_%03d%s", "ut_exit_angle", gantry_angle, ".txt"); 
#line 854
array_2_disk((char *)("ut_entry_angle"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, ut_exit_angle, 200, 200, (int)((6.0) / (0.25)), file_histories, true); 
#line 855
sprintf(data_filename, "%s_%03d%s", "uv_exit_angle", gantry_angle, ".txt"); 
#line 856
array_2_disk((char *)("ut_entry_angle"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, uv_exit_angle, 200, 200, (int)((6.0) / (0.25)), file_histories, true); 
#line 857
}  
#line 858
}  
#line 859
}  
#line 860
if (COUNT_0_WEPLS) 
#line 861
{ 
#line 862
(((((((((std::cout << ("Histories in "))) << (gantry_angle_h[0]))) << ("with WEPL = 0 :"))) << zero_WEPL_files)) << (std::endl)); 
#line 863
zero_WEPL_files = 0; 
#line 864
}  
#line 865
} 
#line 866
void read_data_chunk_v1(const int num_histories, const int start_file_num, const int end_file_num) 
#line 867
{ 
#line 900
char data_filename[128]; 
#line 902
for (int file_num = start_file_num; file_num <= end_file_num; file_num++) 
#line 903
{ 
#line 904
int gantry_position = file_num / 1; 
#line 905
int gantry_angle = (int)(gantry_position * (6.0)); 
#line 906
int scan_number = (file_num % 1) + 1; 
#line 909
printf("Reading File for Gantry Angle %d from Scan Number %d...\n", gantry_angle, scan_number); 
#line 910
sprintf(data_filename, "%s%s/%s_%03d%s", INPUT_DIRECTORY, INPUT_FOLDER, INPUT_BASE_NAME, gantry_angle, FILE_EXTENSION); 
#line 911
std::ifstream data_file(data_filename, std::_Iosb< int> ::binary); 
#line 912
if (data_file == (0)) 
#line 913
{ 
#line 914
fputs("File not found:  Check that the directories and files are properly named.", &(__iob_func()[2])); 
#line 915
exit_program_if(true); 
#line 916
}  
#line 917
char magic_number[5]; 
#line 918
data_file.read(magic_number, 4); 
#line 919
((magic_number)[4]) = '\000'; 
#line 920
if (strcmp(magic_number, "PCTD")) { 
#line 921
puts("Error: unknown file type (should be PCTD)!\n"); 
#line 922
exit_program_if(true); 
#line 923
}  
#line 924
int version_id; 
#line 925
data_file.read((char *)(&version_id), sizeof(int)); 
#line 926
if (version_id == 0) 
#line 927
{ 
#line 928
int num_histories; 
#line 929
data_file.read((char *)(&num_histories), sizeof(int)); 
#line 931
puts("Reading headers from file...\n"); 
#line 933
float projection_angle, beam_energy; 
#line 934
int generation_date, preprocess_date; 
#line 935
int phantom_name_size, data_source_size, prepared_by_size; 
#line 936
char *phantom_name, *data_source, *prepared_by; 
#line 938
data_file.read((char *)(&projection_angle), sizeof(float)); 
#line 939
data_file.read((char *)(&beam_energy), sizeof(float)); 
#line 940
data_file.read((char *)(&generation_date), sizeof(int)); 
#line 941
data_file.read((char *)(&preprocess_date), sizeof(int)); 
#line 942
data_file.read((char *)(&phantom_name_size), sizeof(int)); 
#line 943
phantom_name = ((char *)malloc(phantom_name_size)); 
#line 944
data_file.read(phantom_name, phantom_name_size); 
#line 945
data_file.read((char *)(&data_source_size), sizeof(int)); 
#line 946
data_source = ((char *)malloc(data_source_size)); 
#line 947
data_file.read(data_source, data_source_size); 
#line 948
data_file.read((char *)(&prepared_by_size), sizeof(int)); 
#line 949
prepared_by = ((char *)malloc(prepared_by_size)); 
#line 950
data_file.read(prepared_by, prepared_by_size); 
#line 952
printf("Loading %d histories from file\n", num_histories); 
#line 954
int data_size = num_histories * sizeof(float); 
#line 956
data_file.read((char *)t_in_1_h, data_size); 
#line 957
data_file.read((char *)t_in_2_h, data_size); 
#line 958
data_file.read((char *)t_out_1_h, data_size); 
#line 959
data_file.read((char *)t_out_2_h, data_size); 
#line 960
data_file.read((char *)v_in_1_h, data_size); 
#line 961
data_file.read((char *)v_in_2_h, data_size); 
#line 962
data_file.read((char *)v_out_1_h, data_size); 
#line 963
data_file.read((char *)v_out_2_h, data_size); 
#line 964
data_file.read((char *)u_in_1_h, data_size); 
#line 965
data_file.read((char *)u_in_2_h, data_size); 
#line 966
data_file.read((char *)u_out_1_h, data_size); 
#line 967
data_file.read((char *)u_out_2_h, data_size); 
#line 968
data_file.read((char *)WEPL_h, data_size); 
#line 971
for (int i = 0; i < num_histories; i++) 
#line 972
{ 
#line 973
if (DATA_IN_MM) 
#line 974
{ 
#line 976
(v_in_1_h[i]) *= (0.10000000000000001); 
#line 977
(v_in_2_h[i]) *= (0.10000000000000001); 
#line 978
(v_out_1_h[i]) *= (0.10000000000000001); 
#line 979
(v_out_2_h[i]) *= (0.10000000000000001); 
#line 980
(t_in_1_h[i]) *= (0.10000000000000001); 
#line 981
(t_in_2_h[i]) *= (0.10000000000000001); 
#line 982
(t_out_1_h[i]) *= (0.10000000000000001); 
#line 983
(t_out_2_h[i]) *= (0.10000000000000001); 
#line 984
(WEPL_h[i]) *= (0.10000000000000001); 
#line 985
if ((WEPL_h[i]) < (0)) { 
#line 986
printf("WEPL[%d] = %3f\n", i, WEPL_h[i]); }  
#line 987
(u_in_1_h[i]) *= (0.10000000000000001); 
#line 988
(u_in_2_h[i]) *= (0.10000000000000001); 
#line 989
(u_out_1_h[i]) *= (0.10000000000000001); 
#line 990
(u_out_2_h[i]) *= (0.10000000000000001); 
#line 991
}  
#line 992
(gantry_angle_h[i]) = ((int)projection_angle); 
#line 993
}  
#line 994
data_file.close(); 
#line 995
}  
#line 996
}  
#line 997
} 
#line 998
void recon_volume_intersections(const int num_histories) 
#line 999
{ 
#line 1001
unsigned size_floats = sizeof(float) * num_histories; 
#line 1002
unsigned size_ints = sizeof(int) * num_histories; 
#line 1003
unsigned size_bool = sizeof(bool) * num_histories; 
#line 1006
cudaMalloc((void **)(&t_in_1_d), size_floats); 
#line 1007
cudaMalloc((void **)(&t_in_2_d), size_floats); 
#line 1008
cudaMalloc((void **)(&t_out_1_d), size_floats); 
#line 1009
cudaMalloc((void **)(&t_out_2_d), size_floats); 
#line 1010
cudaMalloc((void **)(&u_in_1_d), size_floats); 
#line 1011
cudaMalloc((void **)(&u_in_2_d), size_floats); 
#line 1012
cudaMalloc((void **)(&u_out_1_d), size_floats); 
#line 1013
cudaMalloc((void **)(&u_out_2_d), size_floats); 
#line 1014
cudaMalloc((void **)(&v_in_1_d), size_floats); 
#line 1015
cudaMalloc((void **)(&v_in_2_d), size_floats); 
#line 1016
cudaMalloc((void **)(&v_out_1_d), size_floats); 
#line 1017
cudaMalloc((void **)(&v_out_2_d), size_floats); 
#line 1018
cudaMalloc((void **)(&gantry_angle_d), size_ints); 
#line 1020
cudaMalloc((void **)(&x_entry_d), size_floats); 
#line 1021
cudaMalloc((void **)(&y_entry_d), size_floats); 
#line 1022
cudaMalloc((void **)(&z_entry_d), size_floats); 
#line 1023
cudaMalloc((void **)(&x_exit_d), size_floats); 
#line 1024
cudaMalloc((void **)(&y_exit_d), size_floats); 
#line 1025
cudaMalloc((void **)(&z_exit_d), size_floats); 
#line 1026
cudaMalloc((void **)(&xy_entry_angle_d), size_floats); 
#line 1027
cudaMalloc((void **)(&xz_entry_angle_d), size_floats); 
#line 1028
cudaMalloc((void **)(&xy_exit_angle_d), size_floats); 
#line 1029
cudaMalloc((void **)(&xz_exit_angle_d), size_floats); 
#line 1030
cudaMalloc((void **)(&missed_recon_volume_d), size_bool); 
#line 1032
cudaMemcpy(t_in_1_d, t_in_1_h, size_floats, cudaMemcpyHostToDevice); 
#line 1033
cudaMemcpy(t_in_2_d, t_in_2_h, size_floats, cudaMemcpyHostToDevice); 
#line 1034
cudaMemcpy(t_out_1_d, t_out_1_h, size_floats, cudaMemcpyHostToDevice); 
#line 1035
cudaMemcpy(t_out_2_d, t_out_2_h, size_floats, cudaMemcpyHostToDevice); 
#line 1036
cudaMemcpy(u_in_1_d, u_in_1_h, size_floats, cudaMemcpyHostToDevice); 
#line 1037
cudaMemcpy(u_in_2_d, u_in_2_h, size_floats, cudaMemcpyHostToDevice); 
#line 1038
cudaMemcpy(u_out_1_d, u_out_1_h, size_floats, cudaMemcpyHostToDevice); 
#line 1039
cudaMemcpy(u_out_2_d, u_out_2_h, size_floats, cudaMemcpyHostToDevice); 
#line 1040
cudaMemcpy(v_in_1_d, v_in_1_h, size_floats, cudaMemcpyHostToDevice); 
#line 1041
cudaMemcpy(v_in_2_d, v_in_2_h, size_floats, cudaMemcpyHostToDevice); 
#line 1042
cudaMemcpy(v_out_1_d, v_out_1_h, size_floats, cudaMemcpyHostToDevice); 
#line 1043
cudaMemcpy(v_out_2_d, v_out_2_h, size_floats, cudaMemcpyHostToDevice); 
#line 1044
cudaMemcpy(gantry_angle_d, gantry_angle_h, size_ints, cudaMemcpyHostToDevice); 
#line 1046
dim3 dimBlock(1024); 
#line 1047
dim3 dimGrid(((int)(num_histories / 1024)) + 1); 
#line 1048
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : recon_volume_intersections_GPU(num_histories, gantry_angle_d, missed_recon_volume_d, t_in_1_d, t_in_2_d, t_out_1_d, t_out_2_d, u_in_1_d, u_in_2_d, u_out_1_d, u_out_2_d, v_in_1_d, v_in_2_d, v_out_1_d, v_out_2_d, x_entry_d, y_entry_d, z_entry_d, x_exit_d, y_exit_d, z_exit_d, xy_entry_angle_d, xz_entry_angle_d, xy_exit_angle_d, xz_exit_angle_d); 
#line 1058
free(t_in_1_h); 
#line 1059
free(t_in_2_h); 
#line 1060
free(v_in_1_h); 
#line 1061
free(v_in_2_h); 
#line 1062
free(u_in_1_h); 
#line 1063
free(u_in_2_h); 
#line 1064
free(t_out_1_h); 
#line 1065
free(t_out_2_h); 
#line 1066
free(v_out_1_h); 
#line 1067
free(v_out_2_h); 
#line 1068
free(u_out_1_h); 
#line 1069
free(u_out_2_h); 
#line 1071
cudaFree(t_in_1_d); 
#line 1072
cudaFree(t_in_2_d); 
#line 1073
cudaFree(v_in_1_d); 
#line 1074
cudaFree(v_in_2_d); 
#line 1075
cudaFree(u_in_1_d); 
#line 1076
cudaFree(u_in_2_d); 
#line 1077
cudaFree(t_out_1_d); 
#line 1078
cudaFree(t_out_2_d); 
#line 1079
cudaFree(v_out_1_d); 
#line 1080
cudaFree(v_out_2_d); 
#line 1081
cudaFree(u_out_1_d); 
#line 1082
cudaFree(u_out_2_d); 
#line 1083
cudaFree(gantry_angle_d); 
#line 1084
} 
#line 1085
void recon_volume_intersections_GPU(int 
#line 1087
num_histories, int *gantry_angle, bool *missed_recon_volume, float *t_in_1, float *t_in_2, float *t_out_1, float *t_out_2, float *u_in_1, float *u_in_2, float *
#line 1088
u_out_1, float *u_out_2, float *v_in_1, float *v_in_2, float *v_out_1, float *v_out_2, float *x_entry, float *y_entry, float *z_entry, float *x_exit, float *
#line 1089
y_exit, float *z_exit, float *xy_entry_angle, float *xz_entry_angle, float *xy_exit_angle, float *xz_exit_angle) ;
#if 0
{ 
#line 1111
int i = (threadIdx.x) + ((blockIdx.x) * (1024)); 
#line 1112
if (i < num_histories) 
#line 1113
{ 
#line 1114
double rotation_angle_radians = (gantry_angle[i]) * (((4) * atan((1.0))) / (180.0)); 
#line 1126
double ut_entry_angle = atan2((t_in_2[i]) - (t_in_1[i]), (u_in_2[i]) - (u_in_1[i])); 
#line 1127
double u_entry, t_entry; 
#line 1130
bool entered = calculate_intercepts(u_in_2[i], t_in_2[i], ut_entry_angle, u_entry, t_entry); 
#line 1132
(xy_entry_angle[i]) = (ut_entry_angle + rotation_angle_radians); 
#line 1135
(x_entry[i]) = ((cos(rotation_angle_radians) * u_entry) - (sin(rotation_angle_radians) * t_entry)); 
#line 1136
(y_entry[i]) = ((sin(rotation_angle_radians) * u_entry) + (cos(rotation_angle_radians) * t_entry)); 
#line 1140
double ut_exit_angle = atan2((t_out_2[i]) - (t_out_1[i]), (u_out_2[i]) - (u_out_1[i])); 
#line 1141
double u_exit, t_exit; 
#line 1144
bool exited = calculate_intercepts(u_out_1[i], t_out_1[i], ut_exit_angle, u_exit, t_exit); 
#line 1146
(xy_exit_angle[i]) = (ut_exit_angle + rotation_angle_radians); 
#line 1149
(x_exit[i]) = ((cos(rotation_angle_radians) * u_exit) - (sin(rotation_angle_radians) * t_exit)); 
#line 1150
(y_exit[i]) = ((sin(rotation_angle_radians) * u_exit) + (cos(rotation_angle_radians) * t_exit)); 
#line 1156
double uv_entry_slope = ((v_in_2[i]) - (v_in_1[i])) / ((u_in_2[i]) - (u_in_1[i])); 
#line 1157
double uv_exit_slope = ((v_out_2[i]) - (v_out_1[i])) / ((u_out_2[i]) - (u_out_1[i])); 
#line 1159
(xz_entry_angle[i]) = atan2((v_in_2[i]) - (v_in_1[i]), (u_in_2[i]) - (u_in_1[i])); 
#line 1160
(xz_exit_angle[i]) = atan2((v_out_2[i]) - (v_out_1[i]), (u_out_2[i]) - (u_out_1[i])); 
#line 1169
u_entry = ((cos(rotation_angle_radians) * (x_entry[i])) + (sin(rotation_angle_radians) * (y_entry[i]))); 
#line 1170
u_exit = ((cos(rotation_angle_radians) * (x_exit[i])) + (sin(rotation_angle_radians) * (y_exit[i]))); 
#line 1171
(z_entry[i]) = ((v_in_2[i]) + (uv_entry_slope * (u_entry - (u_in_2[i])))); 
#line 1172
(z_exit[i]) = ((v_out_1[i]) - (uv_exit_slope * ((u_out_1[i]) - u_exit))); 
#line 1180
if (entered && exited) 
#line 1181
{ 
#line 1182
if (((abs(z_entry[i])) < ((6.0) * (0.5))) && ((abs(z_exit[i])) > ((6.0) * (0.5)))) 
#line 1183
{ 
#line 1184
double recon_cyl_fraction = abs(((((((z_exit[i]) >= (0)) - ((z_exit[i]) < (0))) * (6.0)) * (0.5)) - (z_entry[i])) / ((z_exit[i]) - (z_entry[i]))); 
#line 1185
(x_exit[i]) = ((x_entry[i]) + (recon_cyl_fraction * ((x_exit[i]) - (x_entry[i])))); 
#line 1186
(y_exit[i]) = ((y_entry[i]) + (recon_cyl_fraction * ((y_exit[i]) - (y_entry[i])))); 
#line 1187
(z_exit[i]) = (((((z_exit[i]) >= (0)) - ((z_exit[i]) < (0))) * (6.0)) * (0.5)); 
#line 1188
} else { 
#line 1189
if ((abs(z_entry[i])) > ((6.0) * (0.5))) 
#line 1190
{ 
#line 1191
entered = false; 
#line 1192
exited = false; 
#line 1193
}  }  
#line 1198
if ((abs((t_out_1[i]) - (t_in_2[i])) > (5)) || (abs((v_out_1[i]) - (v_in_2[i])) > (5))) 
#line 1199
{ 
#line 1200
entered = false; 
#line 1201
exited = false; 
#line 1202
}  
#line 1203
}  
#line 1206
(missed_recon_volume[i]) = ((!entered) || (!exited)); 
#line 1207
}  
#line 1208
} 
#endif
#line 1209 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
bool calculate_intercepts(double u, double t, double ut_angle, double &u_intercept, double &t_intercept) 
#line 1210
{int volatile ___ = 1;(void)u;(void)t;(void)ut_angle;(void)u_intercept;(void)t_intercept;
#line 1295
::exit(___);}
#if 0
#line 1210
{ 
#line 1241
bool entry_in_cone = ((ut_angle > atan((1.0))) && (ut_angle < ((3) * atan((1.0))))) || ((ut_angle > ((5) * atan((1.0)))) && (ut_angle < ((7) * atan((1.0))))); 
#line 1245
double u_temp; 
#line 1246
if (entry_in_cone) 
#line 1247
{ 
#line 1248
u_temp = u; 
#line 1249
u = (-t); 
#line 1250
t = u_temp; 
#line 1251
ut_angle += ((2) * atan((1.0))); 
#line 1252
}  
#line 1253
double m = tan(ut_angle); 
#line 1254
double b_in = t - (m * u); 
#line 1257
double a = (1) + pow(m, 2); 
#line 1258
double b = ((2) * m) * b_in; 
#line 1259
double c = pow(b_in, 2) - pow((8.0), 2); 
#line 1260
double entry_discriminant = pow(b, 2) - (((4) * a) * c); 
#line 1261
bool intersected = entry_discriminant > (0); 
#line 1274
if (intersected) 
#line 1275
{ 
#line 1276
double u_intercept_1 = (sqrt(entry_discriminant) - b) / ((2) * a); 
#line 1277
double u_intercept_2 = (sqrt(entry_discriminant) + b) / ((2) * a); 
#line 1278
double t_intercept_1 = (m * u_intercept_1) + b_in; 
#line 1279
double t_intercept_2 = (m * u_intercept_2) - b_in; 
#line 1280
double squared_distance_1 = pow(u_intercept_1 - u, 2) + pow(t_intercept_1 - t, 2); 
#line 1281
double squared_distance_2 = pow(u_intercept_2 + u, 2) + pow(t_intercept_2 + t, 2); 
#line 1282
u_intercept = ((u_intercept_1 * (squared_distance_1 <= squared_distance_2)) - (u_intercept_2 * (squared_distance_1 > squared_distance_2))); 
#line 1283
t_intercept = ((t_intercept_1 * (squared_distance_1 <= squared_distance_2)) - (t_intercept_2 * (squared_distance_1 > squared_distance_2))); 
#line 1284
}  
#line 1286
if (entry_in_cone) 
#line 1287
{ 
#line 1288
u_temp = u_intercept; 
#line 1289
u_intercept = t_intercept; 
#line 1290
t_intercept = (-u_temp); 
#line 1291
ut_angle -= ((2) * atan((1.0))); 
#line 1292
}  
#line 1294
return intersected; 
#line 1295
} 
#endif
#line 1296 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void binning(const int num_histories) 
#line 1297
{ 
#line 1298
unsigned size_floats = sizeof(float) * num_histories; 
#line 1299
unsigned size_ints = sizeof(int) * num_histories; 
#line 1300
unsigned size_bool = sizeof(bool) * num_histories; 
#line 1302
missed_recon_volume_h = ((bool *)calloc(num_histories, sizeof(bool))); 
#line 1304
bin_num_h = ((int *)calloc(num_histories, sizeof(int))); 
#line 1305
x_entry_h = ((float *)calloc(num_histories, sizeof(float))); 
#line 1306
y_entry_h = ((float *)calloc(num_histories, sizeof(float))); 
#line 1307
z_entry_h = ((float *)calloc(num_histories, sizeof(float))); 
#line 1308
x_exit_h = ((float *)calloc(num_histories, sizeof(float))); 
#line 1309
y_exit_h = ((float *)calloc(num_histories, sizeof(float))); 
#line 1310
z_exit_h = ((float *)calloc(num_histories, sizeof(float))); 
#line 1311
xy_entry_angle_h = ((float *)calloc(num_histories, sizeof(float))); 
#line 1312
xz_entry_angle_h = ((float *)calloc(num_histories, sizeof(float))); 
#line 1313
xy_exit_angle_h = ((float *)calloc(num_histories, sizeof(float))); 
#line 1314
xz_exit_angle_h = ((float *)calloc(num_histories, sizeof(float))); 
#line 1316
cudaMalloc((void **)(&WEPL_d), size_floats); 
#line 1317
cudaMalloc((void **)(&bin_num_d), size_ints); 
#line 1319
cudaMemcpy(WEPL_d, WEPL_h, size_floats, cudaMemcpyHostToDevice); 
#line 1320
cudaMemcpy(bin_num_d, bin_num_h, size_ints, cudaMemcpyHostToDevice); 
#line 1322
dim3 dimBlock(1024); 
#line 1323
dim3 dimGrid(((int)(num_histories / 1024)) + 1); 
#line 1324
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : binning_GPU(num_histories, bin_counts_d, bin_num_d, missed_recon_volume_d, x_entry_d, y_entry_d, z_entry_d, x_exit_d, y_exit_d, z_exit_d, mean_WEPL_d, mean_rel_ut_angle_d, mean_rel_uv_angle_d, WEPL_d, xy_entry_angle_d, xz_entry_angle_d, xy_exit_angle_d, xz_exit_angle_d); 
#line 1331
cudaMemcpy(missed_recon_volume_h, missed_recon_volume_d, size_bool, cudaMemcpyDeviceToHost); 
#line 1332
cudaMemcpy(bin_num_h, bin_num_d, size_ints, cudaMemcpyDeviceToHost); 
#line 1333
cudaMemcpy(x_entry_h, x_entry_d, size_floats, cudaMemcpyDeviceToHost); 
#line 1334
cudaMemcpy(y_entry_h, y_entry_d, size_floats, cudaMemcpyDeviceToHost); 
#line 1335
cudaMemcpy(z_entry_h, z_entry_d, size_floats, cudaMemcpyDeviceToHost); 
#line 1336
cudaMemcpy(x_exit_h, x_exit_d, size_floats, cudaMemcpyDeviceToHost); 
#line 1337
cudaMemcpy(y_exit_h, y_exit_d, size_floats, cudaMemcpyDeviceToHost); 
#line 1338
cudaMemcpy(z_exit_h, z_exit_d, size_floats, cudaMemcpyDeviceToHost); 
#line 1339
cudaMemcpy(xy_entry_angle_h, xy_entry_angle_d, size_floats, cudaMemcpyDeviceToHost); 
#line 1340
cudaMemcpy(xz_entry_angle_h, xz_entry_angle_d, size_floats, cudaMemcpyDeviceToHost); 
#line 1341
cudaMemcpy(xy_exit_angle_h, xy_exit_angle_d, size_floats, cudaMemcpyDeviceToHost); 
#line 1342
cudaMemcpy(xz_exit_angle_h, xz_exit_angle_d, size_floats, cudaMemcpyDeviceToHost); 
#line 1344
char data_filename[128]; 
#line 1345
if (WRITE_BIN_WEPLS) 
#line 1346
{ 
#line 1347
sprintf(data_filename, "%s_%03d%s", "bin_numbers", gantry_angle_h[0], ".txt"); 
#line 1348
array_2_disk(data_filename, OUTPUT_DIRECTORY, OUTPUT_FOLDER, bin_num_h, 200, 200, (int)((6.0) / (0.25)), num_histories, true); 
#line 1349
}  
#line 1351
int offset = 0; 
#line 1352
for (int i = 0; i < num_histories; i++) 
#line 1353
{ 
#line 1354
if ((!(missed_recon_volume_h[i])) && ((bin_num_h[i]) >= 0)) 
#line 1355
{ 
#line 1356
bin_num_vector.push_back(bin_num_h[i]); 
#line 1358
WEPL_vector.push_back(WEPL_h[i]); 
#line 1359
x_entry_vector.push_back(x_entry_h[i]); 
#line 1360
y_entry_vector.push_back(y_entry_h[i]); 
#line 1361
z_entry_vector.push_back(z_entry_h[i]); 
#line 1362
x_exit_vector.push_back(x_exit_h[i]); 
#line 1363
y_exit_vector.push_back(y_exit_h[i]); 
#line 1364
z_exit_vector.push_back(z_exit_h[i]); 
#line 1365
xy_entry_angle_vector.push_back(xy_entry_angle_h[i]); 
#line 1366
xz_entry_angle_vector.push_back(xz_entry_angle_h[i]); 
#line 1367
xy_exit_angle_vector.push_back(xy_exit_angle_h[i]); 
#line 1368
xz_exit_angle_vector.push_back(xz_exit_angle_h[i]); 
#line 1382
offset++; 
#line 1383
recon_vol_histories++; 
#line 1384
}  
#line 1385
}  
#line 1386
printf("%d out of %d histories passed intersection cuts this iteration\n", offset, num_histories); 
#line 1388
free(missed_recon_volume_h); 
#line 1389
free(bin_num_h); 
#line 1390
free(x_entry_h); 
#line 1391
free(y_entry_h); 
#line 1392
free(z_entry_h); 
#line 1393
free(x_exit_h); 
#line 1394
free(y_exit_h); 
#line 1395
free(z_exit_h); 
#line 1396
free(xy_entry_angle_h); 
#line 1397
free(xz_entry_angle_h); 
#line 1398
free(xy_exit_angle_h); 
#line 1399
free(xz_exit_angle_h); 
#line 1402
cudaFree(xy_entry_angle_d); 
#line 1403
cudaFree(xz_entry_angle_d); 
#line 1404
cudaFree(xy_exit_angle_d); 
#line 1405
cudaFree(xz_exit_angle_d); 
#line 1406
} 
#line 1407
void binning_GPU(int 
#line 1409
num_histories, int *bin_counts, int *bin_num, bool *missed_recon_volume, float *
#line 1410
x_entry, float *y_entry, float *z_entry, float *x_exit, float *y_exit, float *z_exit, float *
#line 1411
mean_WEPL, float *mean_rel_ut_angle, float *mean_rel_uv_angle, float *WEPL, float *
#line 1412
xy_entry_angle, float *xz_entry_angle, float *xy_exit_angle, float *xz_exit_angle) ;
#if 0
{ 
#line 1415
int i = (threadIdx.x) + ((blockIdx.x) * (1024)); 
#line 1416
if (i < num_histories) 
#line 1417
{ 
#line 1423
double x_midpath, y_midpath, z_midpath, path_angle; 
#line 1424
int angle_bin, t_bin, v_bin; 
#line 1425
double angle, t, v; 
#line 1426
double rel_ut_angle, rel_uv_angle; 
#line 1429
x_midpath = (((x_entry[i]) + (x_exit[i])) / (2)); 
#line 1430
y_midpath = (((y_entry[i]) + (y_exit[i])) / (2)); 
#line 1431
z_midpath = (((z_entry[i]) + (z_exit[i])) / (2)); 
#line 1434
path_angle = (atan2((y_exit[i]) - (y_entry[i]), (x_exit[i]) - (x_entry[i]))); 
#line 1435
if (path_angle < (0)) { 
#line 1436
path_angle += ((2) * ((4) * atan((1.0)))); }  
#line 1437
angle_bin = (((int)(((path_angle * ((180.0) / ((4) * atan((1.0))))) / (6.0)) + (0.5))) % ((int)(((360) / (6.0)) + (0.5)))); 
#line 1438
angle = ((angle_bin * (6.0)) * (((4) * atan((1.0))) / (180.0))); 
#line 1441
t = ((y_midpath * cos(angle)) - (x_midpath * sin(angle))); 
#line 1442
t_bin = ((int)((t / (0.10000000000000001)) + (((int)(((35.0) / (0.10000000000000001)) + (0.5))) / 2))); 
#line 1444
v = z_midpath; 
#line 1445
v_bin = ((int)((v / (0.25)) + (((int)(((9.0) / (0.25)) + (0.5))) / 2))); 
#line 1448
if ((((t_bin >= 0) && (v_bin >= 0)) && (t_bin < ((int)(((35.0) / (0.10000000000000001)) + (0.5))))) && (v_bin < ((int)(((9.0) / (0.25)) + (0.5))))) 
#line 1449
{ 
#line 1450
(bin_num[i]) = ((t_bin + (angle_bin * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))) + ((v_bin * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((360) / (6.0)) + (0.5))))); 
#line 1451
if (!(missed_recon_volume[i])) 
#line 1452
{ 
#line 1457
rel_ut_angle = ((xy_exit_angle[i]) - (xy_entry_angle[i])); 
#line 1458
if (rel_ut_angle > ((4) * atan((1.0)))) { 
#line 1459
rel_ut_angle -= ((2) * ((4) * atan((1.0)))); }  
#line 1460
if (rel_ut_angle < (-((4) * atan((1.0))))) { 
#line 1461
rel_ut_angle += ((2) * ((4) * atan((1.0)))); }  
#line 1462
rel_uv_angle = ((xz_exit_angle[i]) - (xz_entry_angle[i])); 
#line 1463
if (rel_uv_angle > ((4) * atan((1.0)))) { 
#line 1464
rel_uv_angle -= ((2) * ((4) * atan((1.0)))); }  
#line 1465
if (rel_uv_angle < (-((4) * atan((1.0))))) { 
#line 1466
rel_uv_angle += ((2) * ((4) * atan((1.0)))); }  
#line 1467
atomicAdd(&(bin_counts[bin_num[i]]), 1); 
#line 1468
atomicAdd(&(mean_WEPL[bin_num[i]]), WEPL[i]); 
#line 1469
atomicAdd(&(mean_rel_ut_angle[bin_num[i]]), rel_ut_angle); 
#line 1470
atomicAdd(&(mean_rel_ut_angle[bin_num[i]]), rel_uv_angle); 
#line 1473
} else { 
#line 1475
(bin_num[i]) = (-1); }  
#line 1476
}  
#line 1477
}  
#line 1478
} 
#endif
#line 1482 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void calculate_means() 
#line 1483
{ 
#line 1484
puts("Calculating the Mean for Each Bin Before Cuts..."); 
#line 1486
dim3 dimBlock((int)(((35.0) / (0.10000000000000001)) + (0.5))); 
#line 1487
dim3 dimGrid((int)(((9.0) / (0.25)) + (0.5)), (int)(((360) / (6.0)) + (0.5))); 
#line 1488
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : calculate_means_GPU(bin_counts_d, mean_WEPL_d, mean_rel_ut_angle_d, mean_rel_uv_angle_d); 
#line 1493
if (WRITE_WEPL_DISTS) 
#line 1494
{ 
#line 1495
cudaMemcpy(mean_WEPL_h, mean_WEPL_d, ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float), cudaMemcpyDeviceToHost); 
#line 1496
int *empty_parameter; 
#line 1497
write_bin_data("WEPL_dist_pre_test2", empty_parameter, mean_WEPL_h, (((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5))), MEANS, ALL_BINS, BY_BIN); 
#line 1498
}  
#line 1509
free(bin_counts_h); 
#line 1510
free(mean_WEPL_h); 
#line 1511
free(mean_rel_ut_angle_h); 
#line 1512
free(mean_rel_uv_angle_h); 
#line 1513
} 
#line 1514
void calculate_means_GPU(int *bin_counts, float *mean_WEPL, float *mean_rel_ut_angle, float *mean_rel_uv_angle) ;
#if 0
#line 1515
{ 
#line 1516
int v = blockIdx.x, angle = blockIdx.y, t = threadIdx.x; 
#line 1517
int bin = (t + (angle * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))) + ((v * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((360) / (6.0)) + (0.5)))); 
#line 1518
if ((bin_counts[bin]) > 0) 
#line 1519
{ 
#line 1520
(mean_WEPL[bin]) /= (bin_counts[bin]); 
#line 1521
(mean_rel_ut_angle[bin]) /= (bin_counts[bin]); 
#line 1522
(mean_rel_uv_angle[bin]) /= (bin_counts[bin]); 
#line 1523
}  
#line 1524
} 
#endif
#line 1525 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void sum_squared_deviations(const int start_position, const int num_histories) 
#line 1526
{ 
#line 1527
unsigned size_floats = sizeof(float) * num_histories; 
#line 1528
unsigned size_ints = sizeof(int) * num_histories; 
#line 1530
cudaMalloc((void **)(&bin_num_d), size_ints); 
#line 1531
cudaMalloc((void **)(&WEPL_d), size_floats); 
#line 1532
cudaMalloc((void **)(&xy_entry_angle_d), size_floats); 
#line 1533
cudaMalloc((void **)(&xz_entry_angle_d), size_floats); 
#line 1534
cudaMalloc((void **)(&xy_exit_angle_d), size_floats); 
#line 1535
cudaMalloc((void **)(&xz_exit_angle_d), size_floats); 
#line 1536
cudaMalloc((void **)(&xy_exit_angle_d), size_floats); 
#line 1537
cudaMalloc((void **)(&xz_exit_angle_d), size_floats); 
#line 1539
cudaMemcpy(bin_num_d, &bin_num_vector[start_position], size_ints, cudaMemcpyHostToDevice); 
#line 1540
cudaMemcpy(WEPL_d, &WEPL_vector[start_position], size_floats, cudaMemcpyHostToDevice); 
#line 1541
cudaMemcpy(xy_entry_angle_d, &xy_entry_angle_vector[start_position], size_floats, cudaMemcpyHostToDevice); 
#line 1542
cudaMemcpy(xz_entry_angle_d, &xz_entry_angle_vector[start_position], size_floats, cudaMemcpyHostToDevice); 
#line 1543
cudaMemcpy(xy_exit_angle_d, &xy_exit_angle_vector[start_position], size_floats, cudaMemcpyHostToDevice); 
#line 1544
cudaMemcpy(xz_exit_angle_d, &xz_exit_angle_vector[start_position], size_floats, cudaMemcpyHostToDevice); 
#line 1553
dim3 dimBlock(1024); 
#line 1554
dim3 dimGrid(((int)(num_histories / 1024)) + 1); 
#line 1555
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : sum_squared_deviations_GPU(num_histories, bin_num_d, mean_WEPL_d, mean_rel_ut_angle_d, mean_rel_uv_angle_d, WEPL_d, xy_entry_angle_d, xz_entry_angle_d, xy_exit_angle_d, xz_exit_angle_d, stddev_WEPL_d, stddev_rel_ut_angle_d, stddev_rel_uv_angle_d); 
#line 1561
cudaFree(bin_num_d); 
#line 1562
cudaFree(WEPL_d); 
#line 1563
cudaFree(xy_entry_angle_d); 
#line 1564
cudaFree(xz_entry_angle_d); 
#line 1565
cudaFree(xy_exit_angle_d); 
#line 1566
cudaFree(xz_exit_angle_d); 
#line 1567
} 
#line 1568
void sum_squared_deviations_GPU(int 
#line 1570
num_histories, int *bin_num, float *mean_WEPL, float *mean_rel_ut_angle, float *mean_rel_uv_angle, float *
#line 1571
WEPL, float *xy_entry_angle, float *xz_entry_angle, float *xy_exit_angle, float *xz_exit_angle, float *
#line 1572
stddev_WEPL, float *stddev_rel_ut_angle, float *stddev_rel_uv_angle) ;
#if 0
{ 
#line 1575
double WEPL_difference, rel_ut_angle_difference, rel_uv_angle_difference; 
#line 1576
int i = (threadIdx.x) + ((blockIdx.x) * (1024)); 
#line 1577
if (i < num_histories) 
#line 1578
{ 
#line 1579
double rel_ut_angle = (xy_exit_angle[i]) - (xy_entry_angle[i]); 
#line 1580
if (rel_ut_angle > ((4) * atan((1.0)))) { 
#line 1581
rel_ut_angle -= ((2) * ((4) * atan((1.0)))); }  
#line 1582
if (rel_ut_angle < (-((4) * atan((1.0))))) { 
#line 1583
rel_ut_angle += ((2) * ((4) * atan((1.0)))); }  
#line 1584
double rel_uv_angle = (xz_exit_angle[i]) - (xz_entry_angle[i]); 
#line 1585
if (rel_uv_angle > ((4) * atan((1.0)))) { 
#line 1586
rel_uv_angle -= ((2) * ((4) * atan((1.0)))); }  
#line 1587
if (rel_uv_angle < (-((4) * atan((1.0))))) { 
#line 1588
rel_uv_angle += ((2) * ((4) * atan((1.0)))); }  
#line 1589
WEPL_difference = ((WEPL[i]) - (mean_WEPL[bin_num[i]])); 
#line 1590
rel_ut_angle_difference = (rel_ut_angle - (mean_rel_ut_angle[bin_num[i]])); 
#line 1591
rel_uv_angle_difference = (rel_uv_angle - (mean_rel_uv_angle[bin_num[i]])); 
#line 1593
atomicAdd(&(stddev_WEPL[bin_num[i]]), pow(WEPL_difference, 2)); 
#line 1594
atomicAdd(&(stddev_rel_ut_angle[bin_num[i]]), pow(rel_ut_angle_difference, 2)); 
#line 1595
atomicAdd(&(stddev_rel_uv_angle[bin_num[i]]), pow(rel_uv_angle_difference, 2)); 
#line 1596
}  
#line 1597
} 
#endif
#line 1598 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void calculate_standard_deviations() 
#line 1599
{ 
#line 1600
puts("Calculating standard deviations for each bin..."); 
#line 1601
dim3 dimBlock((int)(((35.0) / (0.10000000000000001)) + (0.5))); 
#line 1602
dim3 dimGrid((int)(((9.0) / (0.25)) + (0.5)), (int)(((360) / (6.0)) + (0.5))); 
#line 1603
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : calculate_standard_deviations_GPU(bin_counts_d, stddev_WEPL_d, stddev_rel_ut_angle_d, stddev_rel_uv_angle_d); 
#line 1608
} 
#line 1609
void calculate_standard_deviations_GPU(int *bin_counts, float *stddev_WEPL, float *stddev_rel_ut_angle, float *stddev_rel_uv_angle) ;
#if 0
#line 1610
{ 
#line 1611
int v = blockIdx.x, angle = blockIdx.y, t = threadIdx.x; 
#line 1612
int bin = (t + (angle * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))) + ((v * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((360) / (6.0)) + (0.5)))); 
#line 1613
if ((bin_counts[bin]) > 0) 
#line 1614
{ 
#line 1616
(stddev_WEPL[bin]) = sqrtf((stddev_WEPL[bin]) / ((bin_counts[bin]) - SAMPLE_STD_DEV)); 
#line 1617
(stddev_rel_ut_angle[bin]) = sqrtf((stddev_rel_ut_angle[bin]) / ((bin_counts[bin]) - SAMPLE_STD_DEV)); 
#line 1618
(stddev_rel_uv_angle[bin]) = sqrtf((stddev_rel_uv_angle[bin]) / ((bin_counts[bin]) - SAMPLE_STD_DEV)); 
#line 1619
}  
#line 1620
syncthreads(); 
#line 1621
(bin_counts[bin]) = 0; 
#line 1622
} 
#endif
#line 1623 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void statistical_cuts(const int start_position, const int num_histories) 
#line 1624
{ 
#line 1625
unsigned size_floats = sizeof(float) * num_histories; 
#line 1626
unsigned size_ints = sizeof(int) * num_histories; 
#line 1627
unsigned size_bools = sizeof(bool) * num_histories; 
#line 1629
failed_cuts_h = ((bool *)calloc(num_histories, sizeof(bool))); 
#line 1631
cudaMalloc((void **)(&bin_num_d), size_ints); 
#line 1632
cudaMalloc((void **)(&WEPL_d), size_floats); 
#line 1633
cudaMalloc((void **)(&xy_entry_angle_d), size_floats); 
#line 1634
cudaMalloc((void **)(&xz_entry_angle_d), size_floats); 
#line 1635
cudaMalloc((void **)(&xy_exit_angle_d), size_floats); 
#line 1636
cudaMalloc((void **)(&xz_exit_angle_d), size_floats); 
#line 1637
cudaMalloc((void **)(&failed_cuts_d), size_bools); 
#line 1639
cudaMemcpy(bin_num_d, &bin_num_vector[start_position], size_ints, cudaMemcpyHostToDevice); 
#line 1640
cudaMemcpy(WEPL_d, &WEPL_vector[start_position], size_floats, cudaMemcpyHostToDevice); 
#line 1641
cudaMemcpy(xy_entry_angle_d, &xy_entry_angle_vector[start_position], size_floats, cudaMemcpyHostToDevice); 
#line 1642
cudaMemcpy(xz_entry_angle_d, &xz_entry_angle_vector[start_position], size_floats, cudaMemcpyHostToDevice); 
#line 1643
cudaMemcpy(xy_exit_angle_d, &xy_exit_angle_vector[start_position], size_floats, cudaMemcpyHostToDevice); 
#line 1644
cudaMemcpy(xz_exit_angle_d, &xz_exit_angle_vector[start_position], size_floats, cudaMemcpyHostToDevice); 
#line 1645
cudaMemcpy(failed_cuts_d, failed_cuts_h, size_bools, cudaMemcpyHostToDevice); 
#line 1654
dim3 dimBlock(1024); 
#line 1655
dim3 dimGrid(((int)(num_histories / 1024)) + 1); 
#line 1656
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : statistical_cuts_GPU(num_histories, bin_counts_d, bin_num_d, sinogram_d, WEPL_d, xy_entry_angle_d, xz_entry_angle_d, xy_exit_angle_d, xz_exit_angle_d, mean_WEPL_d, mean_rel_ut_angle_d, mean_rel_uv_angle_d, stddev_WEPL_d, stddev_rel_ut_angle_d, stddev_rel_uv_angle_d, failed_cuts_d); 
#line 1664
cudaMemcpy(failed_cuts_h, failed_cuts_d, size_bools, cudaMemcpyDeviceToHost); 
#line 1666
for (int i = 0; i < num_histories; i++) 
#line 1667
{ 
#line 1668
if (!(failed_cuts_h[i])) 
#line 1669
{ 
#line 1670
bin_num_vector[post_cut_histories] = bin_num_vector[start_position + i]; 
#line 1672
WEPL_vector[post_cut_histories] = WEPL_vector[start_position + i]; 
#line 1673
x_entry_vector[post_cut_histories] = x_entry_vector[start_position + i]; 
#line 1674
y_entry_vector[post_cut_histories] = y_entry_vector[start_position + i]; 
#line 1675
z_entry_vector[post_cut_histories] = z_entry_vector[start_position + i]; 
#line 1676
x_exit_vector[post_cut_histories] = x_exit_vector[start_position + i]; 
#line 1677
y_exit_vector[post_cut_histories] = y_exit_vector[start_position + i]; 
#line 1678
z_exit_vector[post_cut_histories] = z_exit_vector[start_position + i]; 
#line 1679
xy_entry_angle_vector[post_cut_histories] = xy_entry_angle_vector[start_position + i]; 
#line 1680
xz_entry_angle_vector[post_cut_histories] = xz_entry_angle_vector[start_position + i]; 
#line 1681
xy_exit_angle_vector[post_cut_histories] = xy_exit_angle_vector[start_position + i]; 
#line 1682
xz_exit_angle_vector[post_cut_histories] = xz_exit_angle_vector[start_position + i]; 
#line 1696
post_cut_histories++; 
#line 1697
}  
#line 1698
}  
#line 1701
} 
#line 1702
void statistical_cuts_GPU(int 
#line 1704
num_histories, int *bin_counts, int *bin_num, float *sinogram, float *WEPL, float *
#line 1705
xy_entry_angle, float *xz_entry_angle, float *xy_exit_angle, float *xz_exit_angle, float *
#line 1706
mean_WEPL, float *mean_rel_ut_angle, float *mean_rel_uv_angle, float *
#line 1707
stddev_WEPL, float *stddev_rel_ut_angle, float *stddev_rel_uv_angle, bool *
#line 1708
failed_cuts) ;
#if 0
{ 
#line 1711
int i = (threadIdx.x) + ((blockIdx.x) * (1024)); 
#line 1712
if (i < num_histories) 
#line 1713
{ 
#line 1714
double rel_ut_angle = (xy_exit_angle[i]) - (xy_entry_angle[i]); 
#line 1715
if (rel_ut_angle > ((4) * atan((1.0)))) { 
#line 1716
rel_ut_angle -= ((2) * ((4) * atan((1.0)))); }  
#line 1717
if (rel_ut_angle < (-((4) * atan((1.0))))) { 
#line 1718
rel_ut_angle += ((2) * ((4) * atan((1.0)))); }  
#line 1719
double rel_uv_angle = (xz_exit_angle[i]) - (xz_entry_angle[i]); 
#line 1720
if (rel_uv_angle > ((4) * atan((1.0)))) { 
#line 1721
rel_uv_angle -= ((2) * ((4) * atan((1.0)))); }  
#line 1722
if (rel_uv_angle < (-((4) * atan((1.0))))) { 
#line 1723
rel_uv_angle += ((2) * ((4) * atan((1.0)))); }  
#line 1724
bool passed_ut_cut = abs(rel_ut_angle - (mean_rel_ut_angle[bin_num[i]])) < ((3) * (stddev_rel_ut_angle[bin_num[i]])); 
#line 1725
bool passed_uv_cut = abs(rel_uv_angle - (mean_rel_uv_angle[bin_num[i]])) < ((3) * (stddev_rel_uv_angle[bin_num[i]])); 
#line 1726
bool passed_WEPL_cut = abs((mean_WEPL[bin_num[i]]) - (WEPL[i])) <= ((3) * (stddev_WEPL[bin_num[i]])); 
#line 1727
(failed_cuts[i]) = (((!passed_ut_cut) || (!passed_uv_cut)) || (!passed_WEPL_cut)); 
#line 1729
if (!(failed_cuts[i])) 
#line 1730
{ 
#line 1731
atomicAdd(&(bin_counts[bin_num[i]]), 1); 
#line 1732
atomicAdd(&(sinogram[bin_num[i]]), WEPL[i]); 
#line 1733
}  
#line 1734
}  
#line 1735
} 
#endif
#line 1739 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void initialize_sinogram() 
#line 1740
{ 
#line 1741
puts("Allocating host/GPU memory and initializing sinogram..."); 
#line 1742
sinogram_h = ((float *)calloc((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5))), sizeof(float))); 
#line 1743
cudaMalloc((void **)(&sinogram_d), ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float)); 
#line 1744
cudaMemcpy(sinogram_d, sinogram_h, ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float), cudaMemcpyHostToDevice); 
#line 1745
} 
#line 1746
void construct_sinogram() 
#line 1747
{ 
#line 1748
puts("Recalculating the mean WEPL for each bin and constructing the sinogram..."); 
#line 1749
dim3 dimBlock((int)(((35.0) / (0.10000000000000001)) + (0.5))); 
#line 1750
dim3 dimGrid((int)(((9.0) / (0.25)) + (0.5)), (int)(((360) / (6.0)) + (0.5))); 
#line 1751
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : construct_sinogram_GPU(bin_counts_d, sinogram_d); 
#line 1753
if (WRITE_WEPL_DISTS) 
#line 1754
{ 
#line 1755
cudaMemcpy(sinogram_h, sinogram_d, ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float), cudaMemcpyDeviceToHost); 
#line 1756
int *empty_parameter; 
#line 1757
write_bin_data("WEPL_dist_post_test2", empty_parameter, sinogram_h, (((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5))), MEANS, ALL_BINS, BY_BIN); 
#line 1758
}  
#line 1765
} 
#line 1766
void construct_sinogram_GPU(int *bin_counts, float *sinogram) ;
#if 0
#line 1767
{ 
#line 1768
int v = blockIdx.x, angle = blockIdx.y, t = threadIdx.x; 
#line 1769
int bin = (t + (angle * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))) + ((v * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((360) / (6.0)) + (0.5)))); 
#line 1770
if ((bin_counts[bin]) > 0) { 
#line 1771
(sinogram[bin]) /= (bin_counts[bin]); }  
#line 1772
} 
#endif
#line 1773 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void FBP() 
#line 1774
{ 
#line 1776
filter(); 
#line 1778
free(sinogram_h); 
#line 1779
cudaFree(sinogram_d); 
#line 1781
puts("Performing backprojection..."); 
#line 1783
bool FBP_on_GPU = true; 
#line 1784
FBP_image_h = ((float *)calloc((200 * 200) * ((int)((6.0) / (0.25))), sizeof(float))); 
#line 1785
if (FBP_image_h == (0)) 
#line 1786
{ 
#line 1787
printf("ERROR: Memory not allocated for FBP_image_h!\n"); 
#line 1788
exit_program_if(true); 
#line 1789
}  
#line 1790
if (FBP_on_GPU) 
#line 1791
{ 
#line 1792
free(sinogram_filtered_h); 
#line 1793
cudaMalloc((void **)(&FBP_image_d), ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(float)); 
#line 1794
cudaMemcpy(FBP_image_d, FBP_image_h, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(float), cudaMemcpyHostToDevice); 
#line 1796
dim3 dimBlock((int)((6.0) / (0.25))); 
#line 1797
dim3 dimGrid(200, 200); 
#line 1798
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : backprojection_GPU(sinogram_filtered_d, FBP_image_d); 
#line 1799
cudaFree(sinogram_filtered_d); 
#line 1800
} else 
#line 1802
{ 
#line 1803
cudaMemcpy(sinogram_filtered_h, sinogram_filtered_d, ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float), cudaMemcpyDeviceToHost); 
#line 1804
cudaFree(sinogram_filtered_d); 
#line 1805
backprojection(); 
#line 1806
free(sinogram_filtered_h); 
#line 1807
}  
#line 1809
if (WRITE_FBP_IMAGE) 
#line 1810
{ 
#line 1811
cudaMemcpy(FBP_image_h, FBP_image_d, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(float), cudaMemcpyDeviceToHost); 
#line 1812
array_2_disk((char *)("FBP_image_h"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, FBP_image_h, 200, 200, (int)((6.0) / (0.25)), (200 * 200) * ((int)((6.0) / (0.25))), true); 
#line 1813
}  
#line 1816
FBP_image_2_hull(); 
#line 1821
if ((X_K0 != (FBP_IMAGE)) && (X_K0 != (HYBRID))) 
#line 1822
{ 
#line 1823
free(FBP_image_h); 
#line 1824
cudaFree(FBP_image_d); 
#line 1825
}  
#line 1826
} 
#line 1827
void filter() 
#line 1828
{ 
#line 1829
puts("Filtering the sinogram..."); 
#line 1831
sinogram_filtered_h = ((float *)calloc((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5))), sizeof(float))); 
#line 1832
cudaMalloc((void **)(&sinogram_filtered_d), ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float)); 
#line 1833
cudaMemcpy(sinogram_filtered_d, sinogram_filtered_h, ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float), cudaMemcpyHostToDevice); 
#line 1835
dim3 dimBlock((int)(((35.0) / (0.10000000000000001)) + (0.5))); 
#line 1836
dim3 dimGrid((int)(((9.0) / (0.25)) + (0.5)), (int)(((360) / (6.0)) + (0.5))); 
#line 1837
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : filter_GPU(sinogram_d, sinogram_filtered_d); 
#line 1838
} 
#line 1839
void filter_GPU(float *sinogram, float *sinogram_filtered) ;
#if 0
#line 1840
{ 
#line 1841
int v_bin = blockIdx.x, angle_bin = blockIdx.y, t_bin = threadIdx.x; 
#line 1842
int t_bin_ref, t_bin_sep, strip_index; 
#line 1843
double filtered, t, scale_factor; 
#line 1844
double v = ((v_bin - (((int)(((9.0) / (0.25)) + (0.5))) / 2)) * (0.25)) + ((0.25) / (2.0)); 
#line 1847
for (t_bin_ref = 0; t_bin_ref < ((int)(((35.0) / (0.10000000000000001)) + (0.5))); t_bin_ref++) 
#line 1848
{ 
#line 1849
t = (((t_bin_ref - (((int)(((35.0) / (0.10000000000000001)) + (0.5))) / 2)) * (0.10000000000000001)) + ((0.10000000000000001) / (2.0))); 
#line 1850
t_bin_sep = (t_bin - t_bin_ref); 
#line 1852
scale_factor = ((265.69999999999999) / sqrt((((265.69999999999999) * (265.69999999999999)) + (t * t)) + (v * v))); 
#line 1853
switch (FBP_FILTER) 
#line 1854
{ 
#line 1855
case NONE:  
#line 1856
break; 
#line 1857
case RAM_LAK:  
#line 1858
if (t_bin_sep == 0) { 
#line 1859
filtered = ((1.0) / ((4.0) * pow(((2) / sqrtf((2.0))) * (0.10000000000000001), (2.0)))); } else { 
#line 1860
if ((t_bin_sep % 2) == 0) { 
#line 1861
filtered = (0); } else { 
#line 1863
filtered = ((-(1.0)) / pow(((((2) / sqrtf((2.0))) * (0.10000000000000001)) * ((4) * atan((1.0)))) * t_bin_sep, (2.0))); }  }  
#line 1864
break; 
#line 1865
case SHEPP_LOGAN:  
#line 1866
filtered = pow(pow((0.10000000000000001) * ((4) * atan((1.0))), (2.0)) * ((1.0) - pow(2 * t_bin_sep, (2.0))), -(1.0)); 
#line 1867
}  
#line 1868
strip_index = (((v_bin * ((int)(((360) / (6.0)) + (0.5)))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) + (angle_bin * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))); 
#line 1869
(sinogram_filtered[strip_index + t_bin]) += ((((0.10000000000000001) * (sinogram[strip_index + t_bin_ref])) * filtered) * scale_factor); 
#line 1870
}  
#line 1871
} 
#endif
#line 1872 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void backprojection() 
#line 1873
{ 
#line 1879
double delta = (6.0) * (((4) * atan((1.0))) / (180.0)); 
#line 1880
int voxel; 
#line 1881
double x, y, z; 
#line 1882
double u, t, v; 
#line 1883
double detector_number_t, detector_number_v; 
#line 1884
double eta, epsilon; 
#line 1885
double scale_factor; 
#line 1886
int t_bin, v_bin, bin, bin_below; 
#line 1888
for (int slice = 0; slice < ((int)((6.0) / (0.25))); slice++) 
#line 1889
{ 
#line 1890
for (int column = 0; column < 200; column++) 
#line 1891
{ 
#line 1893
for (int row = 0; row < 200; row++) 
#line 1894
{ 
#line 1895
voxel = ((column + (row * 200)) + ((slice * 200) * 200)); 
#line 1896
x = ((-(8.0)) + ((column + (0.5)) * (((2) * (8.0)) / (200)))); 
#line 1897
y = ((8.0) - ((row + (0.5)) * (((2) * (8.0)) / (200)))); 
#line 1898
z = (((-(6.0)) / (2.0)) + ((slice + (0.5)) * (0.25))); 
#line 1900
if (((x * x) + (y * y)) > ((8.0) * (8.0))) { 
#line 1901
(FBP_image_h[voxel]) = ((0.0011299999999999999)); } else 
#line 1903
{ 
#line 1905
for (int angle_bin = 0; angle_bin < ((int)(((360) / (6.0)) + (0.5))); angle_bin++) 
#line 1906
{ 
#line 1908
u = ((x * cos(angle_bin * delta)) + (y * sin(angle_bin * delta))); 
#line 1909
t = (((-x) * sin(angle_bin * delta)) + (y * cos(angle_bin * delta))); 
#line 1910
v = z; 
#line 1913
detector_number_t = (((t - (u * (t / ((265.69999999999999) + u)))) / (0.10000000000000001)) + (((int)(((35.0) / (0.10000000000000001)) + (0.5))) / (2.0))); 
#line 1914
t_bin = ((int)detector_number_t); 
#line 1915
if (t_bin > detector_number_t) { 
#line 1916
t_bin -= 1; }  
#line 1917
eta = (detector_number_t - t_bin); 
#line 1920
detector_number_v = (((v - (u * (v / ((265.69999999999999) + u)))) / (0.25)) + (((int)(((9.0) / (0.25)) + (0.5))) / (2.0))); 
#line 1921
v_bin = ((int)detector_number_v); 
#line 1922
if (v_bin > detector_number_v) { 
#line 1923
v_bin -= 1; }  
#line 1924
epsilon = (detector_number_v - v_bin); 
#line 1927
scale_factor = pow((265.69999999999999) / ((265.69999999999999) + u), 2); 
#line 1930
bin = ((t_bin + (angle_bin * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))) + ((v_bin * ((int)(((360) / (6.0)) + (0.5)))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))); 
#line 1931
bin_below = (bin + (((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))); 
#line 1934
if ((v_bin == (((int)(((9.0) / (0.25)) + (0.5))) - 1)) || (bin < 0)) { 
#line 1935
(FBP_image_h[voxel]) += (scale_factor * ((((1) - eta) * (sinogram_filtered_h[bin])) + (eta * (sinogram_filtered_h[bin + 1])))); } else 
#line 1943
{ 
#line 1945
(FBP_image_h[voxel]) += (scale_factor * (((((((1) - eta) * ((1) - epsilon)) * (sinogram_filtered_h[bin])) + ((eta * ((1) - epsilon)) * (sinogram_filtered_h[bin + 1]))) + ((((1) - eta) * epsilon) * (sinogram_filtered_h[bin_below]))) + ((eta * epsilon) * (sinogram_filtered_h[bin_below + 1])))); 
#line 1949
}  
#line 1950
}  
#line 1951
(FBP_image_h[voxel]) *= delta; 
#line 1952
}  
#line 1953
}  
#line 1954
}  
#line 1955
}  
#line 1956
} 
#line 1957
void backprojection_GPU(float *sinogram_filtered, float *FBP_image) ;
#if 0
#line 1958
{ 
#line 1959
int row = blockIdx.y, column = blockIdx.x, slice = threadIdx.x; 
#line 1960
int voxel = (((slice * 200) * 200) + (row * 200)) + column; 
#line 1961
if (voxel < ((200 * 200) * ((int)((6.0) / (0.25))))) 
#line 1962
{ 
#line 1963
double delta = (6.0) * (((4) * atan((1.0))) / (180.0)); 
#line 1964
double u, t, v; 
#line 1965
double detector_number_t, detector_number_v; 
#line 1966
double eta, epsilon; 
#line 1967
double scale_factor; 
#line 1968
int t_bin, v_bin, bin; 
#line 1969
double x = (-(8.0)) + ((column + (0.5)) * (((2) * (8.0)) / (200))); 
#line 1970
double y = (8.0) - ((row + (0.5)) * (((2) * (8.0)) / (200))); 
#line 1971
double z = ((-(6.0)) / (2.0)) + ((slice + (0.5)) * (0.25)); 
#line 1974
if (((x * x) + (y * y)) > ((8.0) * (8.0))) { 
#line 1975
(FBP_image[(((slice * 200) * 200) + (row * 200)) + column]) = ((0.0011299999999999999)); } else 
#line 1977
{ 
#line 1979
for (int angle_bin = 0; angle_bin < ((int)(((360) / (6.0)) + (0.5))); angle_bin++) 
#line 1980
{ 
#line 1982
u = ((x * cos(angle_bin * delta)) + (y * sin(angle_bin * delta))); 
#line 1983
t = (((-x) * sin(angle_bin * delta)) + (y * cos(angle_bin * delta))); 
#line 1984
v = z; 
#line 1987
detector_number_t = (((t - (u * (t / ((265.69999999999999) + u)))) / (0.10000000000000001)) + (((int)(((35.0) / (0.10000000000000001)) + (0.5))) / (2.0))); 
#line 1988
t_bin = ((int)detector_number_t); 
#line 1989
if (t_bin > detector_number_t) { 
#line 1990
t_bin -= 1; }  
#line 1991
eta = (detector_number_t - t_bin); 
#line 1994
detector_number_v = (((v - (u * (v / ((265.69999999999999) + u)))) / (0.25)) + (((int)(((9.0) / (0.25)) + (0.5))) / (2.0))); 
#line 1995
v_bin = ((int)detector_number_v); 
#line 1996
if (v_bin > detector_number_v) { 
#line 1997
v_bin -= 1; }  
#line 1998
epsilon = (detector_number_v - v_bin); 
#line 2001
scale_factor = pow((265.69999999999999) / ((265.69999999999999) + u), 2); 
#line 2005
bin = ((t_bin + (angle_bin * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))) + ((v_bin * ((int)(((360) / (6.0)) + (0.5)))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))); 
#line 2010
if ((v_bin == (((int)(((9.0) / (0.25)) + (0.5))) - 1)) || (bin < 0)) { 
#line 2011
(FBP_image[voxel]) += (scale_factor * ((((1) - eta) * (sinogram_filtered[bin])) + (eta * (sinogram_filtered[bin + 1])))); } else 
#line 2014
{ 
#line 2023
(FBP_image[voxel]) += (scale_factor * (((((((1) - eta) * ((1) - epsilon)) * (sinogram_filtered[bin])) + ((eta * ((1) - epsilon)) * (sinogram_filtered[bin + 1]))) + ((((1) - eta) * epsilon) * (sinogram_filtered[bin + (((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))]))) + ((eta * epsilon) * (sinogram_filtered[(bin + (((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))) + 1])))); 
#line 2027
}  
#line 2028
}  
#line 2029
(FBP_image[voxel]) *= delta; 
#line 2030
}  
#line 2031
}  
#line 2032
} 
#endif
#line 2033 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void FBP_image_2_hull() 
#line 2034
{ 
#line 2035
puts("Performing thresholding on FBP image to generate FBP hull..."); 
#line 2037
bool FBP_hull_on_GPU = false; 
#line 2039
if (FBP_hull_on_GPU) 
#line 2040
{ 
#line 2041
initialize_hull(FBP_hull_h, FBP_hull_d); 
#line 2042
dim3 dimBlock((int)((6.0) / (0.25))); 
#line 2043
dim3 dimGrid(200, 200); 
#line 2044
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : FBP_image_2_hull_GPU(FBP_image_d, FBP_hull_d); 
#line 2045
cudaMemcpy(FBP_hull_h, FBP_hull_d, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(bool), cudaMemcpyDeviceToHost); 
#line 2046
} else 
#line 2048
{ 
#line 2049
FBP_hull_h = ((bool *)calloc((200 * 200) * ((int)((6.0) / (0.25))), sizeof(bool))); 
#line 2050
std::transform(FBP_image_h, FBP_image_h + ((200 * 200) * ((int)((6.0) / (0.25)))), FBP_hull_h, std::bind2nd(std::greater< float> (), (0.59999999999999998))); 
#line 2069
}  
#line 2070
if (WRITE_FBP_HULL) { 
#line 2071
array_2_disk((char *)("x_FBP"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, FBP_hull_h, 200, 200, (int)((6.0) / (0.25)), (200 * 200) * ((int)((6.0) / (0.25))), true); }  
#line 2073
if (MLP_HULL != (FBP_HULL)) 
#line 2074
{ 
#line 2076
free(FBP_hull_h); 
#line 2077
cudaFree(FBP_hull_d); 
#line 2078
}  
#line 2079
} 
#line 2080
void FBP_image_2_hull_GPU(float *FBP_image, bool *FBP_hull) ;
#if 0
#line 2081
{ 
#line 2082
int row = blockIdx.y, column = blockIdx.x, slice = threadIdx.x; 
#line 2083
int voxel = (((slice * 200) * 200) + (row * 200)) + column; 
#line 2084
double x = (-(8.0)) + ((column + (0.5)) * (((2) * (8.0)) / (200))); 
#line 2085
double y = (8.0) - ((row + (0.5)) * (((2) * (8.0)) / (200))); 
#line 2086
double d_squared = pow(x, 2) + pow(y, 2); 
#line 2087
if (((FBP_image[voxel]) > (0.59999999999999998)) && (d_squared < pow((8.0), 2))) { 
#line 2088
(FBP_hull[voxel]) = true; } else { 
#line 2090
(FBP_hull[voxel]) = false; }  
#line 2091
} 
#endif
#line 2095 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
template< class T> void initialize_hull(T *&hull_h, T *&hull_d) 
#line 2096
{ 
#line 2101
int image_size = (((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(T)); 
#line 2102
cudaMalloc((void **)(&hull_d), image_size); 
#line 2104
::dim3 dimBlock((int)((6.0) / (0.25))); 
#line 2105
::dim3 dimGrid(200, 200); 
#line 2106
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : (initialize_hull_GPU)(hull_d); 
#line 2107
} 
#line 2108
template< class T> static void __wrapper__device_stub_initialize_hull_GPU(T *&hull) {exit(1);}
#if 0
#line 2109
{ 
#line 2110
int row = blockIdx.y, column = blockIdx.x, slice = threadIdx.x; 
#line 2111
int voxel = (column + (row * 200)) + ((slice * 200) * 200); 
#line 2112
double x = ((column - (200 / 2)) + (0.5)) * (((2) * (8.0)) / (200)); 
#line 2113
double y = (((200 / 2) - row) - (0.5)) * (((2) * (8.0)) / (200)); 
#line 2114
if ((pow(x, 2) + pow(y, 2)) < pow((8.0), 2)) { 
#line 2115
(hull[voxel]) = 1; } else { 
#line 2117
(hull[voxel]) = 0; }  
#line 2118
} 
#endif
#line 2108 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
template< class T> void initialize_hull_GPU(T *hull) 
#line 2109
{__wrapper__device_stub_initialize_hull_GPU<T>(hull);
#line 2118
return;}
#if 0
#line 2109
{ 
#line 2110
int row = blockIdx.y, column = blockIdx.x, slice = threadIdx.x; 
#line 2111
int voxel = (column + (row * 200)) + ((slice * 200) * 200); 
#line 2112
double x = ((column - (200 / 2)) + (0.5)) * (((2) * (8.0)) / (200)); 
#line 2113
double y = (((200 / 2) - row) - (0.5)) * (((2) * (8.0)) / (200)); 
#line 2114
if ((pow(x, 2) + pow(y, 2)) < pow((8.0), 2)) { 
#line 2115
(hull[voxel]) = 1; } else { 
#line 2117
(hull[voxel]) = 0; }  
#line 2118
} 
#endif
#line 2122 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void hull_initializations() 
#line 2123
{ 
#line 2124
if (SC_ON) { 
#line 2125
initialize_hull(SC_hull_h, SC_hull_d); }  
#line 2126
if (MSC_ON) { 
#line 2127
initialize_hull(MSC_counts_h, MSC_counts_d); }  
#line 2128
if (SM_ON) { 
#line 2129
initialize_hull(SM_counts_h, SM_counts_d); }  
#line 2130
} 
#line 2131
void hull_detection(const int histories_to_process) 
#line 2132
{ 
#line 2133
if (SC_ON) { 
#line 2134
SC(histories_to_process); }  
#line 2135
if (MSC_ON) { 
#line 2136
MSC(histories_to_process); }  
#line 2137
if (SM_ON) { 
#line 2138
SM(histories_to_process); }  
#line 2139
} 
#line 2140
void voxel_walk_GPU(bool *&image, float x_entry, float y_entry, float z_entry, float x_exit, float y_exit, float z_exit) 
#line 2141
{int volatile ___ = 1;(void)image;(void)x_entry;(void)y_entry;(void)z_entry;(void)x_exit;(void)y_exit;(void)z_exit;
#line 2309
::exit(___);}
#if 0
#line 2141
{ 
#line 2145
int x_move_direction, y_move_direction, z_move_direction; 
#line 2146
float delta_yx, delta_zx, delta_zy; 
#line 2151
float x = x_entry, y = y_entry, z = z_entry; 
#line 2152
float x_to_go, y_to_go, z_to_go; 
#line 2153
float x_extension, y_extension; 
#line 2154
int voxel_x, voxel_y, voxel_z; 
#line 2155
int voxel, voxel_x_out, voxel_y_out, voxel_z_out, voxel_out; 
#line 2156
bool end_walk; 
#line 2160
x_move_direction = ((x_entry <= x_exit) - (x_entry > x_exit)); 
#line 2161
y_move_direction = ((y_entry <= y_exit) - (y_entry > y_exit)); 
#line 2162
z_move_direction = ((z_entry <= z_exit) - (z_entry > z_exit)); 
#line 2164
x_to_go = (x_remaining_GPU(x, x_move_direction, voxel_x)); 
#line 2165
y_to_go = (y_remaining_GPU(y, -y_move_direction, voxel_y)); 
#line 2166
z_to_go = (z_remaining_GPU(z, -z_move_direction, voxel_z)); 
#line 2167
voxel = ((voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200)); 
#line 2172
delta_yx = abs((y_exit - y_entry) / (x_exit - x_entry)); 
#line 2173
delta_zx = abs((z_exit - z_entry) / (x_exit - x_entry)); 
#line 2174
delta_zy = abs((z_exit - z_entry) / (y_exit - y_entry)); 
#line 2178
voxel_x_out = ((int)((x_exit + (8.0)) / (((2) * (8.0)) / (200)))); 
#line 2179
voxel_y_out = ((int)(((8.0) - y_exit) / (((2) * (8.0)) / (200)))); 
#line 2180
voxel_z_out = ((int)((((6.0) / (2)) - z_exit) / ((((int)((6.0) / (0.25))) * (0.25)) / ((int)((6.0) / (0.25)))))); 
#line 2181
voxel_out = ((int)((voxel_x_out + (voxel_y_out * 200)) + ((voxel_z_out * 200) * 200))); 
#line 2183
end_walk = ((((voxel == voxel_out) || (voxel_x >= 200)) || (voxel_y >= 200)) || (voxel_z >= ((int)((6.0) / (0.25))))); 
#line 2184
if (!end_walk) { 
#line 2185
(image[voxel]) = (0); }  
#line 2189
if (z_entry != z_exit) 
#line 2190
{ 
#line 2191
while (!end_walk) 
#line 2192
{ 
#line 2194
x_extension = (delta_zx * x_to_go); 
#line 2195
y_extension = (delta_zy * y_to_go); 
#line 2196
if ((z_to_go <= x_extension) && (z_to_go <= y_extension)) 
#line 2197
{ 
#line 2204
x_to_go -= (z_to_go / delta_zx); 
#line 2205
y_to_go -= (z_to_go / delta_zy); 
#line 2206
z_to_go = ((((int)((6.0) / (0.25))) * (0.25)) / ((int)((6.0) / (0.25)))); 
#line 2207
voxel_z -= z_move_direction; 
#line 2208
if (x_to_go <= (0)) 
#line 2209
{ 
#line 2210
voxel_x += x_move_direction; 
#line 2211
x_to_go = (((2) * (8.0)) / (200)); 
#line 2212
}  
#line 2213
if (y_to_go <= (0)) 
#line 2214
{ 
#line 2215
voxel_y -= y_move_direction; 
#line 2216
y_to_go = (((2) * (8.0)) / (200)); 
#line 2217
}  
#line 2218
} else { 
#line 2220
if (x_extension <= y_extension) 
#line 2221
{ 
#line 2226
x_to_go = (((2) * (8.0)) / (200)); 
#line 2227
y_to_go -= (delta_yx * x_to_go); 
#line 2228
z_to_go -= (delta_zx * x_to_go); 
#line 2232
voxel_x += x_move_direction; 
#line 2233
if (y_to_go <= (0)) 
#line 2234
{ 
#line 2235
y_to_go = (((2) * (8.0)) / (200)); 
#line 2236
voxel_y -= y_move_direction; 
#line 2237
}  
#line 2238
} else 
#line 2241
{ 
#line 2246
x_to_go -= (y_to_go / delta_yx); 
#line 2247
y_to_go = (((2) * (8.0)) / (200)); 
#line 2248
z_to_go -= (delta_zy * y_to_go); 
#line 2252
voxel_y -= y_move_direction; 
#line 2253
}  }  
#line 2257
voxel = ((voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200)); 
#line 2258
end_walk = ((((voxel == voxel_out) || (voxel_x >= 200)) || (voxel_y >= 200)) || (voxel_z >= ((int)((6.0) / (0.25))))); 
#line 2259
if (!end_walk) { 
#line 2260
(image[voxel]) = (0); }  
#line 2261
}  
#line 2262
} else 
#line 2264
{ 
#line 2268
while (!end_walk) 
#line 2269
{ 
#line 2271
y_extension = (y_to_go / delta_yx); 
#line 2273
if (x_to_go <= y_extension) 
#line 2274
{ 
#line 2278
x_to_go = (((2) * (8.0)) / (200)); 
#line 2279
y_to_go -= (delta_yx * x_to_go); 
#line 2281
voxel_x += x_move_direction; 
#line 2282
if (y_to_go <= (0)) 
#line 2283
{ 
#line 2284
y_to_go = (((2) * (8.0)) / (200)); 
#line 2285
voxel_y -= y_move_direction; 
#line 2286
}  
#line 2287
} else 
#line 2290
{ 
#line 2295
x_to_go -= (y_to_go / delta_yx); 
#line 2296
y_to_go = (((2) * (8.0)) / (200)); 
#line 2297
voxel_y -= y_move_direction; 
#line 2298
}  
#line 2301
voxel = ((voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200)); 
#line 2302
end_walk = ((((voxel == voxel_out) || (voxel_x >= 200)) || (voxel_y >= 200)) || (voxel_z >= ((int)((6.0) / (0.25))))); 
#line 2303
if (!end_walk) { 
#line 2304
(image[voxel]) = (0); }  
#line 2306
}  
#line 2308
}  
#line 2309
} 
#endif
#line 2310 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
double x_remaining_GPU(double x, int x_move_direction, int &voxel_x) 
#line 2311
{int volatile ___ = 1;(void)x;(void)x_move_direction;(void)voxel_x;
#line 2316
::exit(___);}
#if 0
#line 2311
{ 
#line 2312
double voxel_x_float; 
#line 2313
double x_inside = modf((x + (8.0)) / (((2) * (8.0)) / (200)), &voxel_x_float) * (((2) * (8.0)) / (200)); 
#line 2314
voxel_x = voxel_x_float; 
#line 2315
return ((x_move_direction > 0) * ((((2) * (8.0)) / (200)) - x_inside)) + ((x_move_direction <= 0) * x_inside); 
#line 2316
} 
#endif
#line 2317 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
double y_remaining_GPU(double y, int y_move_direction, int &voxel_y) 
#line 2318
{int volatile ___ = 1;(void)y;(void)y_move_direction;(void)voxel_y;
#line 2323
::exit(___);}
#if 0
#line 2318
{ 
#line 2319
double voxel_y_float; 
#line 2320
double y_inside = modf(((8.0) - y) / (((2) * (8.0)) / (200)), &voxel_y_float) * (((2) * (8.0)) / (200)); 
#line 2321
voxel_y = voxel_y_float; 
#line 2322
return ((y_move_direction > 0) * ((((2) * (8.0)) / (200)) - y_inside)) + ((y_move_direction <= 0) * y_inside); 
#line 2323
} 
#endif
#line 2324 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
double z_remaining_GPU(double z, int z_move_direction, int &voxel_z) 
#line 2325
{int volatile ___ = 1;(void)z;(void)z_move_direction;(void)voxel_z;
#line 2330
::exit(___);}
#if 0
#line 2325
{ 
#line 2326
float voxel_z_float; 
#line 2327
float z_inside = (modf((((6.0) / (2)) - z) / ((((int)((6.0) / (0.25))) * (0.25)) / ((int)((6.0) / (0.25)))), &voxel_z_float)) * ((((int)((6.0) / (0.25))) * (0.25)) / ((int)((6.0) / (0.25)))); 
#line 2328
voxel_z = voxel_z_float; 
#line 2329
return ((z_move_direction > 0) * (((((int)((6.0) / (0.25))) * (0.25)) / ((int)((6.0) / (0.25)))) - z_inside)) + ((z_move_direction <= 0) * z_inside); 
#line 2330
} 
#endif
#line 2331 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void carve_differences(int *carve_differences, int *image) ;
#if 0
#line 2332
{ 
#line 2333
int row = blockIdx.y, column = blockIdx.x, slice = threadIdx.x; 
#line 2334
int voxel = (column + (row * 200)) + ((slice * 200) * 200); 
#line 2335
if ((((row != 0) && (row != (200 - 1))) && (column != 0)) && (column != (200 - 1))) 
#line 2336
{ 
#line 2337
int difference, max_difference = 0; 
#line 2338
for (int current_row = row - 1; current_row <= (row + 1); current_row++) 
#line 2339
{ 
#line 2340
for (int current_column = column - 1; current_column <= (column + 1); current_column++) 
#line 2341
{ 
#line 2342
difference = ((image[voxel]) - (image[(current_column + (current_row * 200)) + ((slice * 200) * 200)])); 
#line 2343
if (difference > max_difference) { 
#line 2344
max_difference = difference; }  
#line 2345
}  
#line 2346
}  
#line 2347
(carve_differences[voxel]) = max_difference; 
#line 2348
}  
#line 2349
} 
#endif
#line 2351 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void SC(const int num_histories) 
#line 2352
{ 
#line 2353
dim3 dimBlock(1024); 
#line 2354
dim3 dimGrid(((int)(num_histories / 1024)) + 1); 
#line 2355
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : SC_GPU(num_histories, SC_hull_d, bin_num_d, missed_recon_volume_d, WEPL_d, x_entry_d, y_entry_d, z_entry_d, x_exit_d, y_exit_d, z_exit_d); 
#line 2360
char user_response[20]; 
#line 2361
if (true) { 
#line 2362
fgets(user_response, sizeof user_response, &(__iob_func()[0])); }  
#line 2363
} 
#line 2364
void SC_GPU(const int 
#line 2366
num_histories, bool *SC_hull, int *bin_num, bool *missed_recon_volume, float *WEPL, float *
#line 2367
x_entry, float *y_entry, float *z_entry, float *x_exit, float *y_exit, float *z_exit) ;
#if 0
{ 
#line 2370
int i = (threadIdx.x) + ((blockIdx.x) * (1024)); 
#line 2372
bool run_it = i == 192644; 
#line 2373
if (((run_it && (i < num_histories)) && (!(missed_recon_volume[i]))) && ((WEPL[i]) <= (0.0))) 
#line 2374
{ 
#line 2378
int x_move_direction, y_move_direction, z_move_direction; 
#line 2379
double delta_yx, delta_zx, delta_zy; 
#line 2380
double x_move = (0), y_move = (0), z_move = (0); 
#line 2385
double x_to_go, y_to_go, z_to_go; 
#line 2386
double x_extension, y_extension; 
#line 2387
int voxel_x, voxel_y, voxel_z; 
#line 2389
int voxel, voxel_out; 
#line 2390
bool end_walk; 
#line 2391
bool debug_run = true; 
#line 2395
x_move_direction = (((x_entry[i]) <= (x_exit[i])) - ((x_entry[i]) >= (x_exit[i]))); 
#line 2396
y_move_direction = (((y_entry[i]) <= (y_exit[i])) - ((y_entry[i]) >= (y_exit[i]))); 
#line 2397
z_move_direction = (((z_entry[i]) <= (z_exit[i])) - ((z_entry[i]) >= (z_exit[i]))); 
#line 2398
x_to_go = x_remaining_GPU(x_entry[i], x_move_direction, voxel_x); 
#line 2399
y_to_go = y_remaining_GPU(y_entry[i], -y_move_direction, voxel_y); 
#line 2400
z_to_go = z_remaining_GPU(z_entry[i], -z_move_direction, voxel_z); 
#line 2401
voxel = ((voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200)); 
#line 2402
double x_replace = x_exit[i]; 
#line 2403
voxel_out = position_2_voxel_GPU(x_replace, y_exit[i], z_exit[i]); 
#line 2409
delta_yx = (fabs((y_exit[i]) - (y_entry[i])) / fabs((x_exit[i]) - (x_entry[i]))); 
#line 2410
delta_zx = (fabs((z_exit[i]) - (z_entry[i])) / fabs((x_exit[i]) - (x_entry[i]))); 
#line 2411
delta_zy = (fabs((z_exit[i]) - (z_entry[i])) / fabs((y_exit[i]) - (y_entry[i]))); 
#line 2415
int voxel_x_out = ((x_exit[i]) + (8.0)) / (((2) * (8.0)) / (200)); 
#line 2416
int voxel_y_out = ((8.0) - (y_exit[i])) / (((2) * (8.0)) / (200)); 
#line 2417
int voxel_z_out = (((6.0) / (2)) - (z_exit[i])) / ((((int)((6.0) / (0.25))) * (0.25)) / ((int)((6.0) / (0.25)))); 
#line 2418
if (debug_run) 
#line 2419
{ 
#line 2420
printf("bin_num[i] = %d NUM_BINS = %d", bin_num[i], (((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))); 
#line 2421
printf("x_move_direction = %d y_move_direction = %d z_move_direction = %d\n", x_move_direction, y_move_direction, z_move_direction); 
#line 2422
printf("VOXEL_WIDTH = %3f VOXEL_HEIGHT = %3f SLICE_THICKNESS = %3f\n", ((2) * (8.0)) / (200), ((2) * (8.0)) / (200), (0.25)); 
#line 2423
printf("voxel_x_in = %d voxel_y_in = %d voxel_z_in = %d\n", voxel_x, voxel_y, voxel_z); 
#line 2424
printf("voxel_x_out = %d voxel_y_out = %d voxel_z_out = %d\n", voxel_x_out, voxel_y_out, voxel_z_out); 
#line 2425
printf("voxel_in = %d voxel_out = %d\n", voxel, voxel_out); 
#line 2426
printf("x_entry[i] = %3f y_entry[i] = %3f z_entry[i] = %3f\n", x_entry[i], y_entry[i], z_entry[i]); 
#line 2427
printf("x_exit[i] = %8e y_exit[i] = %3f z_exit[i] = %3f\n", x_replace, y_exit[i], z_exit[i]); 
#line 2428
printf("x_replace > -7.28\?: %d\n", x_replace > (-(7.2800000000000002))); 
#line 2429
printf("x_replace < -7.28\?: %d\n", x_replace < (-(7.2800000000000002))); 
#line 2430
printf("x_replace = -7.28\?: %d\n", x_replace == (-(7.2800000000000002))); 
#line 2431
printf("x_exit[i] > -7.28\?: %d\n", (x_exit[i]) > (-(7.2800000000000002))); 
#line 2432
printf("x_exit[i] < -7.28\?: %d\n", (x_exit[i]) < (-(7.2800000000000002))); 
#line 2433
printf("x_exit[i] = -7.28\?: %d\n", (x_exit[i]) == (-(7.2800000000000002))); 
#line 2434
printf("x_exit[i] voxel %8f\n", ((x_exit[i]) + (8.0)) / (((2) * (8.0)) / (200))); 
#line 2436
printf("delta_yx = %3f delta_zx = %3f delta_zy = %3f\n", delta_yx, delta_zx, delta_zy); 
#line 2437
printf("x_to_go = %3f y_to_go = %3f z_to_go = %3f\n", x_to_go, y_to_go, z_to_go); 
#line 2438
}  
#line 2439
end_walk = ((((voxel == voxel_out) || (voxel_x >= 200)) || (voxel_y >= 200)) || (voxel_z >= ((int)((6.0) / (0.25))))); 
#line 2440
if (!end_walk) { 
#line 2441
(SC_hull[voxel]) = (0); }  
#line 2443
int j = 0; 
#line 2444
int j_low_limit = 185; 
#line 2445
int j_high_limit = 250; 
#line 2449
if (z_move_direction != 0) 
#line 2450
{ 
#line 2451
if ((debug_run && (j < j_high_limit)) && (j > j_low_limit)) { 
#line 2452
printf("z_exit[i] != z_entry[i]\n"); }  
#line 2453
while (!end_walk) 
#line 2454
{ 
#line 2456
x_extension = (delta_zx * x_to_go); 
#line 2457
y_extension = (delta_zy * y_to_go); 
#line 2458
if ((z_to_go <= x_extension) && (z_to_go <= y_extension)) 
#line 2459
{ 
#line 2461
x_move = (z_to_go / delta_zx); 
#line 2462
y_move = (z_to_go / delta_zy); 
#line 2463
z_move = z_to_go; 
#line 2464
x_to_go -= ((z_to_go / delta_zx) * (abs(x_move_direction))); 
#line 2465
y_to_go -= ((z_to_go / delta_zy) * (abs(y_move_direction))); 
#line 2466
z_to_go = ((((int)((6.0) / (0.25))) * (0.25)) / ((int)((6.0) / (0.25)))); 
#line 2467
voxel_z -= z_move_direction; 
#line 2468
if (x_to_go <= (9.9999999999999995e-008)) 
#line 2469
{ 
#line 2470
voxel_x += x_move_direction; 
#line 2471
x_to_go = (((2) * (8.0)) / (200)); 
#line 2472
}  
#line 2473
if (y_to_go <= (9.9999999999999995e-008)) 
#line 2474
{ 
#line 2475
voxel_y -= y_move_direction; 
#line 2476
y_to_go = (((2) * (8.0)) / (200)); 
#line 2477
}  
#line 2478
if ((debug_run && (j < j_high_limit)) && (j > j_low_limit)) 
#line 2479
{ 
#line 2480
printf("z_to_go <= x_extension && z_to_go <= y_extension\n"); 
#line 2481
printf("x_move = %3f y_move = %3f z_move = %3f\n", x_move, y_move, z_move); 
#line 2482
printf("x_to_go = %8f y_to_go = %3f z_to_go = %3f\n", x_to_go, y_to_go, z_to_go); 
#line 2483
}  
#line 2484
} else { 
#line 2486
if (x_extension <= y_extension) 
#line 2487
{ 
#line 2489
x_move = x_to_go; 
#line 2490
y_move = (delta_yx * x_to_go); 
#line 2491
z_move = (delta_zx * x_to_go); 
#line 2492
y_to_go -= ((delta_yx * x_to_go) * (abs(y_move_direction))); 
#line 2493
z_to_go -= ((delta_zx * x_to_go) * (abs(z_move_direction))); 
#line 2494
x_to_go = (((2) * (8.0)) / (200)); 
#line 2495
voxel_x += x_move_direction; 
#line 2496
if (y_to_go <= (9.9999999999999995e-008)) 
#line 2497
{ 
#line 2498
y_to_go = (((2) * (8.0)) / (200)); 
#line 2499
voxel_y -= y_move_direction; 
#line 2500
}  
#line 2501
if ((debug_run && (j < j_high_limit)) && (j > j_low_limit)) 
#line 2502
{ 
#line 2503
printf(" x_extension <= y_extension \n"); 
#line 2504
printf("x_move = %3f y_move = %3f z_move = %3f\n", x_move, y_move, z_move); 
#line 2505
printf("x_to_go = %3f y_to_go = %3f z_to_go = %3f\n", x_to_go, y_to_go, z_to_go); 
#line 2506
}  
#line 2507
} else 
#line 2510
{ 
#line 2512
x_move = (y_to_go / delta_yx); 
#line 2513
y_move = y_to_go; 
#line 2514
z_move = (delta_zy * y_to_go); 
#line 2515
x_to_go -= ((y_to_go / delta_yx) * (abs(x_move_direction))); 
#line 2516
z_to_go -= ((delta_zy * y_to_go) * (abs(z_move_direction))); 
#line 2517
y_to_go = (((2) * (8.0)) / (200)); 
#line 2518
voxel_y -= y_move_direction; 
#line 2519
if ((debug_run && (j < j_high_limit)) && (j > j_low_limit)) 
#line 2520
{ 
#line 2521
printf(" y_extension < x_extension \n"); 
#line 2522
printf("x_move = %3f y_move = %3f z_move = %3f\n", x_move, y_move, z_move); 
#line 2523
printf("x_to_go = %3f y_to_go = %3f z_to_go = %3f\n", x_to_go, y_to_go, z_to_go); 
#line 2524
}  
#line 2525
}  }  
#line 2529
voxel_z = max(voxel_z, 0); 
#line 2530
voxel = ((voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200)); 
#line 2531
if ((debug_run && (j < j_high_limit)) && (j > j_low_limit)) { 
#line 2532
printf("voxel_x = %d voxel_y = %d voxel_z = %d voxel = %d\n", voxel_x, voxel_y, voxel_z, voxel); }  
#line 2533
end_walk = ((((voxel == voxel_out) || (voxel_x >= 200)) || (voxel_y >= 200)) || (voxel_z >= ((int)((6.0) / (0.25))))); 
#line 2534
if (!end_walk) { 
#line 2535
(SC_hull[voxel]) = (0); }  
#line 2536
j++; 
#line 2537
}  
#line 2538
} else 
#line 2540
{ 
#line 2541
if ((debug_run && (j < j_high_limit)) && (j > j_low_limit)) { 
#line 2542
printf("z_exit[i] == z_entry[i]\n"); }  
#line 2543
while (!end_walk) 
#line 2544
{ 
#line 2546
y_extension = (y_to_go / delta_yx); 
#line 2548
if (x_to_go <= y_extension) 
#line 2549
{ 
#line 2551
x_move = x_to_go; 
#line 2552
y_move = (delta_yx * x_to_go); 
#line 2553
y_to_go -= ((delta_yx * x_to_go) * (abs(y_move_direction))); 
#line 2554
x_to_go = (((2) * (8.0)) / (200)); 
#line 2555
voxel_x += x_move_direction; 
#line 2556
if (y_to_go <= (9.9999999999999995e-008)) 
#line 2557
{ 
#line 2558
y_to_go = (((2) * (8.0)) / (200)); 
#line 2559
voxel_y -= y_move_direction; 
#line 2560
}  
#line 2561
if ((debug_run && (j < j_high_limit)) && (j > j_low_limit)) 
#line 2562
{ 
#line 2563
printf(" x_to_go <= y_extension\n"); 
#line 2564
printf("x_move = %3f y_move = %3f \n", x_move, y_move); 
#line 2565
printf("x_to_go = %3f y_to_go = %3f\n", x_to_go, y_to_go); 
#line 2566
}  
#line 2567
} else 
#line 2570
{ 
#line 2572
x_move = (y_to_go / delta_yx); 
#line 2573
y_move = y_to_go; 
#line 2574
x_to_go -= ((y_to_go / delta_yx) * (abs(x_move_direction))); 
#line 2575
y_to_go = (((2) * (8.0)) / (200)); 
#line 2576
voxel_y -= y_move_direction; 
#line 2577
if ((debug_run && (j < j_high_limit)) && (j > j_low_limit)) 
#line 2578
{ 
#line 2579
printf(" y_extension < x_extension\n"); 
#line 2580
printf("x_move = %3f y_move = %3f \n", x_move, y_move); 
#line 2581
printf("x_to_go = %3f y_to_go = %3f\n", x_to_go, y_to_go); 
#line 2582
}  
#line 2583
}  
#line 2586
voxel_z = max(voxel_z, 0); 
#line 2587
voxel = ((voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200)); 
#line 2588
if ((debug_run && (j < j_high_limit)) && (j > j_low_limit)) { 
#line 2589
printf("voxel_x_in = %d voxel_y_in = %d voxel_z_in = %d\n", voxel_x, voxel_y, voxel_z); }  
#line 2590
end_walk = ((((voxel == voxel_out) || (voxel_x >= 200)) || (voxel_y >= 200)) || (voxel_z >= ((int)((6.0) / (0.25))))); 
#line 2591
if (!end_walk) { 
#line 2592
(SC_hull[voxel]) = (0); }  
#line 2593
j++; 
#line 2594
}  
#line 2596
}  
#line 2597
}  
#line 2598
} 
#endif
#line 2600 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void MSC(const int num_histories) 
#line 2601
{ 
#line 2602
dim3 dimBlock(1024); 
#line 2603
dim3 dimGrid(((int)(num_histories / 1024)) + 1); 
#line 2604
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : MSC_GPU(num_histories, MSC_counts_d, bin_num_d, missed_recon_volume_d, WEPL_d, x_entry_d, y_entry_d, z_entry_d, x_exit_d, y_exit_d, z_exit_d); 
#line 2609
} 
#line 2610
void MSC_GPU(const int 
#line 2612
num_histories, int *MSC_counts, int *bin_num, bool *missed_recon_volume, float *WEPL, float *
#line 2613
x_entry, float *y_entry, float *z_entry, float *x_exit, float *y_exit, float *z_exit) ;
#if 0
{ 
#line 2616
int i = (threadIdx.x) + ((blockIdx.x) * (1024)); 
#line 2618
if (((i < num_histories) && (!(missed_recon_volume[i]))) && ((WEPL[i]) <= (0.0))) 
#line 2619
{ 
#line 2623
int x_move_direction, y_move_direction, z_move_direction; 
#line 2624
double delta_yx, delta_zx, delta_zy; 
#line 2625
double x_move = (0), y_move = (0), z_move = (0); 
#line 2630
double x_to_go, y_to_go, z_to_go; 
#line 2631
double x_extension, y_extension; 
#line 2632
int voxel_x, voxel_y, voxel_z; 
#line 2634
int voxel, voxel_out; 
#line 2635
bool end_walk; 
#line 2639
x_move_direction = (((x_entry[i]) <= (x_exit[i])) - ((x_entry[i]) >= (x_exit[i]))); 
#line 2640
y_move_direction = (((y_entry[i]) <= (y_exit[i])) - ((y_entry[i]) >= (y_exit[i]))); 
#line 2641
z_move_direction = (((z_entry[i]) <= (z_exit[i])) - ((z_entry[i]) >= (z_exit[i]))); 
#line 2642
x_to_go = x_remaining_GPU(x_entry[i], x_move_direction, voxel_x); 
#line 2643
y_to_go = y_remaining_GPU(y_entry[i], -y_move_direction, voxel_y); 
#line 2644
z_to_go = z_remaining_GPU(z_entry[i], -z_move_direction, voxel_z); 
#line 2645
voxel = ((voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200)); 
#line 2646
voxel_out = position_2_voxel_GPU(x_exit[i], y_exit[i], z_exit[i]); 
#line 2651
delta_yx = (abs((y_exit[i]) - (y_entry[i])) / abs((x_exit[i]) - (x_entry[i]))); 
#line 2652
delta_zx = (abs((z_exit[i]) - (z_entry[i])) / abs((x_exit[i]) - (x_entry[i]))); 
#line 2653
delta_zy = (abs((z_exit[i]) - (z_entry[i])) / abs((y_exit[i]) - (y_entry[i]))); 
#line 2657
end_walk = ((((voxel == voxel_out) || (voxel_x >= 200)) || (voxel_y >= 200)) || (voxel_z >= ((int)((6.0) / (0.25))))); 
#line 2658
if (!end_walk) { 
#line 2659
atomicAdd(&(MSC_counts[voxel]), 1); }  
#line 2663
if (z_move_direction != 0) 
#line 2664
{ 
#line 2666
while (!end_walk) 
#line 2667
{ 
#line 2669
x_extension = (delta_zx * x_to_go); 
#line 2670
y_extension = (delta_zy * y_to_go); 
#line 2671
if ((z_to_go <= x_extension) && (z_to_go <= y_extension)) 
#line 2672
{ 
#line 2674
x_move = (z_to_go / delta_zx); 
#line 2675
y_move = (z_to_go / delta_zy); 
#line 2676
z_move = z_to_go; 
#line 2677
x_to_go -= (x_move * (abs(x_move_direction))); 
#line 2678
y_to_go -= (y_move * (abs(y_move_direction))); 
#line 2681
z_to_go = ((((int)((6.0) / (0.25))) * (0.25)) / ((int)((6.0) / (0.25)))); 
#line 2682
voxel_z -= z_move_direction; 
#line 2683
if (x_to_go == (0)) 
#line 2684
{ 
#line 2685
voxel_x += x_move_direction; 
#line 2686
x_to_go = (((2) * (8.0)) / (200)); 
#line 2687
}  
#line 2688
if (y_to_go == (0)) 
#line 2689
{ 
#line 2690
voxel_y -= y_move_direction; 
#line 2691
y_to_go = (((2) * (8.0)) / (200)); 
#line 2692
}  
#line 2693
} else { 
#line 2695
if (x_extension <= y_extension) 
#line 2696
{ 
#line 2698
x_move = x_to_go; 
#line 2699
y_move = (delta_yx * x_to_go); 
#line 2700
z_move = (delta_zx * x_to_go); 
#line 2701
x_to_go = (((2) * (8.0)) / (200)); 
#line 2702
y_to_go -= (y_move * (abs(y_move_direction))); 
#line 2703
z_to_go -= (z_move * (abs(z_move_direction))); 
#line 2707
voxel_x += x_move_direction; 
#line 2708
if (y_to_go == (0)) 
#line 2709
{ 
#line 2710
y_to_go = (((2) * (8.0)) / (200)); 
#line 2711
voxel_y -= y_move_direction; 
#line 2712
}  
#line 2713
} else 
#line 2716
{ 
#line 2718
x_move = (y_to_go / delta_yx); 
#line 2719
y_move = y_to_go; 
#line 2720
z_move = (delta_zy * y_to_go); 
#line 2721
x_to_go -= (x_move * (abs(x_move_direction))); 
#line 2722
y_to_go = (((2) * (8.0)) / (200)); 
#line 2723
z_to_go -= (z_move * (abs(z_move_direction))); 
#line 2727
voxel_y -= y_move_direction; 
#line 2728
}  }  
#line 2732
voxel = ((voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200)); 
#line 2733
end_walk = ((((voxel == voxel_out) || (voxel_x >= 200)) || (voxel_y >= 200)) || (voxel_z >= ((int)((6.0) / (0.25))))); 
#line 2734
if (!end_walk) { 
#line 2735
atomicAdd(&(MSC_counts[voxel]), 1); }  
#line 2736
}  
#line 2737
} else 
#line 2739
{ 
#line 2741
while (!end_walk) 
#line 2742
{ 
#line 2744
y_extension = (y_to_go / delta_yx); 
#line 2746
if (x_to_go <= y_extension) 
#line 2747
{ 
#line 2749
x_move = x_to_go; 
#line 2750
y_move = (delta_yx * x_to_go); 
#line 2751
x_to_go = (((2) * (8.0)) / (200)); 
#line 2753
y_to_go -= (y_move * (abs(y_move_direction))); 
#line 2754
voxel_x += x_move_direction; 
#line 2755
if (y_to_go == (0)) 
#line 2756
{ 
#line 2757
y_to_go = (((2) * (8.0)) / (200)); 
#line 2758
voxel_y -= y_move_direction; 
#line 2759
}  
#line 2760
} else 
#line 2763
{ 
#line 2765
x_move = (y_to_go / delta_yx); 
#line 2766
y_move = y_to_go; 
#line 2767
x_to_go -= (x_move * (abs(x_move_direction))); 
#line 2769
y_to_go = (((2) * (8.0)) / (200)); 
#line 2770
voxel_y -= y_move_direction; 
#line 2771
}  
#line 2774
voxel = ((voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200)); 
#line 2775
end_walk = ((((voxel == voxel_out) || (voxel_x >= 200)) || (voxel_y >= 200)) || (voxel_z >= ((int)((6.0) / (0.25))))); 
#line 2776
if (!end_walk) { 
#line 2777
atomicAdd(&(MSC_counts[voxel]), 1); }  
#line 2778
}  
#line 2780
}  
#line 2781
}  
#line 2782
} 
#endif
#line 2783 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void MSC_edge_detection() 
#line 2784
{ 
#line 2785
puts("Performing edge-detection on MSC_counts..."); 
#line 2787
dim3 dimBlock((int)((6.0) / (0.25))); 
#line 2788
dim3 dimGrid(200, 200); 
#line 2789
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : MSC_edge_detection_GPU(MSC_counts_d); 
#line 2791
puts("MSC hull-detection and edge-detection complete."); 
#line 2792
} 
#line 2793
void MSC_edge_detection_GPU(int *MSC_counts) ;
#if 0
#line 2794
{ 
#line 2795
int row = blockIdx.y, column = blockIdx.x, slice = threadIdx.x; 
#line 2796
int voxel = (column + (row * 200)) + ((slice * 200) * 200); 
#line 2797
float x = ((column - (200 / 2)) + (0.5)) * (((2) * (8.0)) / (200)); 
#line 2798
float y = (((200 / 2) - row) - (0.5)) * (((2) * (8.0)) / (200)); 
#line 2799
int difference, max_difference = 0; 
#line 2800
if ((((row != 0) && (row != (200 - 1))) && (column != 0)) && (column != (200 - 1))) 
#line 2801
{ 
#line 2802
for (int current_row = row - 1; current_row <= (row + 1); current_row++) 
#line 2803
{ 
#line 2804
for (int current_column = column - 1; current_column <= (column + 1); current_column++) 
#line 2805
{ 
#line 2806
difference = ((MSC_counts[voxel]) - (MSC_counts[(current_column + (current_row * 200)) + ((slice * 200) * 200)])); 
#line 2807
if (difference > max_difference) { 
#line 2808
max_difference = difference; }  
#line 2809
}  
#line 2810
}  
#line 2811
}  
#line 2812
syncthreads(); 
#line 2813
if (max_difference > 50) { 
#line 2814
(MSC_counts[voxel]) = 0; } else { 
#line 2816
(MSC_counts[voxel]) = 1; }  
#line 2817
if ((pow(x, 2) + pow(y, 2)) >= pow((8.0) - (max(((2) * (8.0)) / (200), ((2) * (8.0)) / (200)) / (2)), 2)) { 
#line 2818
(MSC_counts[voxel]) = 0; }  
#line 2820
} 
#endif
#line 2822 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void SM(const int num_histories) 
#line 2823
{ 
#line 2824
dim3 dimBlock(1024); 
#line 2825
dim3 dimGrid(((int)(num_histories / 1024)) + 1); 
#line 2826
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : SM_GPU(num_histories, SM_counts_d, bin_num_d, missed_recon_volume_d, WEPL_d, x_entry_d, y_entry_d, z_entry_d, x_exit_d, y_exit_d, z_exit_d); 
#line 2831
} 
#line 2832
void SM_GPU(const int 
#line 2834
num_histories, int *SM_counts, int *bin_num, bool *missed_recon_volume, float *WEPL, float *
#line 2835
x_entry, float *y_entry, float *z_entry, float *x_exit, float *y_exit, float *z_exit) ;
#if 0
{ 
#line 2838
int i = (threadIdx.x) + ((blockIdx.x) * (1024)); 
#line 2839
if (((i < num_histories) && (!(missed_recon_volume[i]))) && ((WEPL[i]) >= (6.0))) 
#line 2840
{ 
#line 2844
int x_move_direction, y_move_direction, z_move_direction; 
#line 2845
double delta_yx, delta_zx, delta_zy; 
#line 2846
double x_move = (0), y_move = (0), z_move = (0); 
#line 2851
double x_to_go, y_to_go, z_to_go; 
#line 2852
double x_extension, y_extension; 
#line 2853
int voxel_x, voxel_y, voxel_z; 
#line 2855
int voxel, voxel_out; 
#line 2856
bool end_walk; 
#line 2860
x_move_direction = (((x_entry[i]) <= (x_exit[i])) - ((x_entry[i]) >= (x_exit[i]))); 
#line 2861
y_move_direction = (((y_entry[i]) <= (y_exit[i])) - ((y_entry[i]) >= (y_exit[i]))); 
#line 2862
z_move_direction = (((z_entry[i]) <= (z_exit[i])) - ((z_entry[i]) >= (z_exit[i]))); 
#line 2863
x_to_go = x_remaining_GPU(x_entry[i], x_move_direction, voxel_x); 
#line 2864
y_to_go = y_remaining_GPU(y_entry[i], -y_move_direction, voxel_y); 
#line 2865
z_to_go = z_remaining_GPU(z_entry[i], -z_move_direction, voxel_z); 
#line 2866
voxel = ((voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200)); 
#line 2867
voxel_out = position_2_voxel_GPU(x_exit[i], y_exit[i], z_exit[i]); 
#line 2872
delta_yx = (abs((y_exit[i]) - (y_entry[i])) / abs((x_exit[i]) - (x_entry[i]))); 
#line 2873
delta_zx = (abs((z_exit[i]) - (z_entry[i])) / abs((x_exit[i]) - (x_entry[i]))); 
#line 2874
delta_zy = (abs((z_exit[i]) - (z_entry[i])) / abs((y_exit[i]) - (y_entry[i]))); 
#line 2878
end_walk = ((((voxel == voxel_out) || (voxel_x >= 200)) || (voxel_y >= 200)) || (voxel_z >= ((int)((6.0) / (0.25))))); 
#line 2879
if (!end_walk) { 
#line 2880
atomicAdd(&(SM_counts[voxel]), 1); }  
#line 2884
if (z_move_direction != 0) 
#line 2885
{ 
#line 2887
while (!end_walk) 
#line 2888
{ 
#line 2890
x_extension = (delta_zx * x_to_go); 
#line 2891
y_extension = (delta_zy * y_to_go); 
#line 2892
if ((z_to_go <= x_extension) && (z_to_go <= y_extension)) 
#line 2893
{ 
#line 2895
x_move = (z_to_go / delta_zx); 
#line 2896
y_move = (z_to_go / delta_zy); 
#line 2897
z_move = z_to_go; 
#line 2898
x_to_go -= (x_move * (abs(x_move_direction))); 
#line 2899
y_to_go -= (y_move * (abs(y_move_direction))); 
#line 2902
z_to_go = ((((int)((6.0) / (0.25))) * (0.25)) / ((int)((6.0) / (0.25)))); 
#line 2903
voxel_z -= z_move_direction; 
#line 2904
if (x_to_go == (0)) 
#line 2905
{ 
#line 2906
voxel_x += x_move_direction; 
#line 2907
x_to_go = (((2) * (8.0)) / (200)); 
#line 2908
}  
#line 2909
if (y_to_go == (0)) 
#line 2910
{ 
#line 2911
voxel_y -= y_move_direction; 
#line 2912
y_to_go = (((2) * (8.0)) / (200)); 
#line 2913
}  
#line 2914
} else { 
#line 2916
if (x_extension <= y_extension) 
#line 2917
{ 
#line 2919
x_move = x_to_go; 
#line 2920
y_move = (delta_yx * x_to_go); 
#line 2921
z_move = (delta_zx * x_to_go); 
#line 2922
x_to_go = (((2) * (8.0)) / (200)); 
#line 2923
y_to_go -= (y_move * (abs(y_move_direction))); 
#line 2924
z_to_go -= (z_move * (abs(z_move_direction))); 
#line 2928
voxel_x += x_move_direction; 
#line 2929
if (y_to_go == (0)) 
#line 2930
{ 
#line 2931
y_to_go = (((2) * (8.0)) / (200)); 
#line 2932
voxel_y -= y_move_direction; 
#line 2933
}  
#line 2934
} else 
#line 2937
{ 
#line 2939
x_move = (y_to_go / delta_yx); 
#line 2940
y_move = y_to_go; 
#line 2941
z_move = (delta_zy * y_to_go); 
#line 2942
x_to_go -= (x_move * (abs(x_move_direction))); 
#line 2943
y_to_go = (((2) * (8.0)) / (200)); 
#line 2944
z_to_go -= (z_move * (abs(z_move_direction))); 
#line 2948
voxel_y -= y_move_direction; 
#line 2949
}  }  
#line 2953
voxel = ((voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200)); 
#line 2954
end_walk = ((((voxel == voxel_out) || (voxel_x >= 200)) || (voxel_y >= 200)) || (voxel_z >= ((int)((6.0) / (0.25))))); 
#line 2955
if (!end_walk) { 
#line 2956
atomicAdd(&(SM_counts[voxel]), 1); }  
#line 2957
}  
#line 2958
} else 
#line 2960
{ 
#line 2962
while (!end_walk) 
#line 2963
{ 
#line 2965
y_extension = (y_to_go / delta_yx); 
#line 2967
if (x_to_go <= y_extension) 
#line 2968
{ 
#line 2970
x_move = x_to_go; 
#line 2971
y_move = (delta_yx * x_to_go); 
#line 2972
x_to_go = (((2) * (8.0)) / (200)); 
#line 2974
y_to_go -= (y_move * (abs(y_move_direction))); 
#line 2975
voxel_x += x_move_direction; 
#line 2976
if (y_to_go == (0)) 
#line 2977
{ 
#line 2978
y_to_go = (((2) * (8.0)) / (200)); 
#line 2979
voxel_y -= y_move_direction; 
#line 2980
}  
#line 2981
} else 
#line 2984
{ 
#line 2986
x_move = (y_to_go / delta_yx); 
#line 2987
y_move = y_to_go; 
#line 2988
x_to_go -= (x_move * (abs(x_move_direction))); 
#line 2990
y_to_go = (((2) * (8.0)) / (200)); 
#line 2991
voxel_y -= y_move_direction; 
#line 2992
}  
#line 2995
voxel = ((voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200)); 
#line 2996
end_walk = ((((voxel == voxel_out) || (voxel_x >= 200)) || (voxel_y >= 200)) || (voxel_z >= ((int)((6.0) / (0.25))))); 
#line 2997
if (!end_walk) { 
#line 2998
atomicAdd(&(SM_counts[voxel]), 1); }  
#line 2999
}  
#line 3001
}  
#line 3002
}  
#line 3003
} 
#endif
#line 3004 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void SM_edge_detection() 
#line 3005
{ 
#line 3006
puts("Performing edge-detection on SM_counts..."); 
#line 3014
int *SM_differences_h = (int *)calloc((200 * 200) * ((int)((6.0) / (0.25))), sizeof(int)); 
#line 3015
int *SM_differences_d; 
#line 3016
cudaMalloc((void **)(&SM_differences_d), ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(int)); 
#line 3017
cudaMemcpy(SM_differences_d, SM_differences_h, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(int), cudaMemcpyHostToDevice); 
#line 3019
dim3 dimBlock((int)((6.0) / (0.25))); 
#line 3020
dim3 dimGrid(200, 200); 
#line 3021
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : carve_differences(SM_differences_d, SM_counts_d); 
#line 3023
cudaMemcpy(SM_differences_h, SM_differences_d, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(int), cudaMemcpyDeviceToHost); 
#line 3025
int *SM_thresholds_h = (int *)calloc((int)((6.0) / (0.25)), sizeof(int)); 
#line 3026
int voxel; 
#line 3027
int max_difference = 0; 
#line 3028
for (int slice = 0; slice < ((int)((6.0) / (0.25))); slice++) 
#line 3029
{ 
#line 3030
for (int pixel = 0; pixel < (200 * 200); pixel++) 
#line 3031
{ 
#line 3032
voxel = (pixel + ((slice * 200) * 200)); 
#line 3033
if ((SM_differences_h[voxel]) > max_difference) 
#line 3034
{ 
#line 3035
max_difference = (SM_differences_h[voxel]); 
#line 3036
(SM_thresholds_h[slice]) = (SM_counts_h[voxel]); 
#line 3037
}  
#line 3038
}  
#line 3039
if (DEBUG_TEXT_ON) 
#line 3040
{ 
#line 3042
}  
#line 3043
max_difference = 0; 
#line 3044
}  
#line 3046
int *SM_thresholds_d; 
#line 3047
unsigned threshold_size = (((int)((6.0) / (0.25))) * sizeof(int)); 
#line 3048
cudaMalloc((void **)(&SM_thresholds_d), threshold_size); 
#line 3049
cudaMemcpy(SM_thresholds_d, SM_thresholds_h, threshold_size, cudaMemcpyHostToDevice); 
#line 3051
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : SM_edge_detection_GPU(SM_counts_d, SM_thresholds_d); 
#line 3053
puts("SM hull-detection and edge-detection complete."); 
#line 3056
cudaFree(SM_differences_d); 
#line 3057
cudaFree(SM_thresholds_d); 
#line 3059
free(SM_differences_h); 
#line 3060
free(SM_thresholds_h); 
#line 3066
} 
#line 3067
void SM_edge_detection_GPU(int *SM_counts, int *SM_threshold) ;
#if 0
#line 3068
{ 
#line 3069
int row = blockIdx.y, column = blockIdx.x, slice = threadIdx.x; 
#line 3070
float x = ((column - (200 / 2)) + (0.5)) * (((2) * (8.0)) / (200)); 
#line 3071
float y = (((200 / 2) - row) - (0.5)) * (((2) * (8.0)) / (200)); 
#line 3072
int voxel = (column + (row * 200)) + ((slice * 200) * 200); 
#line 3073
if (voxel < ((200 * 200) * ((int)((6.0) / (0.25))))) 
#line 3074
{ 
#line 3075
if ((SM_counts[voxel]) > ((1.0) * (SM_threshold[slice]))) { 
#line 3076
(SM_counts[voxel]) = 1; } else { 
#line 3078
(SM_counts[voxel]) = 0; }  
#line 3079
if ((pow(x, 2) + pow(y, 2)) >= pow((8.0) - (max(((2) * (8.0)) / (200), ((2) * (8.0)) / (200)) / (2)), 2)) { 
#line 3080
(SM_counts[voxel]) = 0; }  
#line 3081
}  
#line 3082
} 
#endif
#line 3083 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void SM_edge_detection_2() 
#line 3084
{ 
#line 3085
puts("Performing edge-detection on SM_counts..."); 
#line 3088
cudaMemcpy(SM_counts_h, SM_counts_d, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(int), cudaMemcpyDeviceToHost); 
#line 3089
array_2_disk((char *)("SM_counts"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, SM_counts_h, 200, 200, (int)((6.0) / (0.25)), (200 * 200) * ((int)((6.0) / (0.25))), false); 
#line 3091
int *SM_differences_h = (int *)calloc((200 * 200) * ((int)((6.0) / (0.25))), sizeof(int)); 
#line 3092
int *SM_differences_d; 
#line 3093
cudaMalloc((void **)(&SM_differences_d), ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(int)); 
#line 3094
cudaMemcpy(SM_differences_d, SM_differences_h, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(int), cudaMemcpyHostToDevice); 
#line 3096
dim3 dimBlock((int)((6.0) / (0.25))); 
#line 3097
dim3 dimGrid(200, 200); 
#line 3099
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : carve_differences(SM_differences_d, SM_counts_d); 
#line 3100
cudaMemcpy(SM_differences_h, SM_differences_d, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(int), cudaMemcpyDeviceToHost); 
#line 3102
int *SM_thresholds_h = (int *)calloc((int)((6.0) / (0.25)), sizeof(int)); 
#line 3103
int voxel; 
#line 3104
int max_difference = 0; 
#line 3105
for (int slice = 0; slice < ((int)((6.0) / (0.25))); slice++) 
#line 3106
{ 
#line 3107
for (int pixel = 0; pixel < (200 * 200); pixel++) 
#line 3108
{ 
#line 3109
voxel = (pixel + ((slice * 200) * 200)); 
#line 3110
if ((SM_differences_h[voxel]) > max_difference) 
#line 3111
{ 
#line 3112
max_difference = (SM_differences_h[voxel]); 
#line 3113
(SM_thresholds_h[slice]) = (SM_counts_h[voxel]); 
#line 3114
}  
#line 3115
}  
#line 3116
printf("Slice %d : The maximum space_model difference = %d and the space_model threshold = %d\n", slice, max_difference, SM_thresholds_h[slice]); 
#line 3117
max_difference = 0; 
#line 3118
}  
#line 3120
int *SM_thresholds_d; 
#line 3121
unsigned threshold_size = (((int)((6.0) / (0.25))) * sizeof(int)); 
#line 3122
cudaMalloc((void **)(&SM_thresholds_d), threshold_size); 
#line 3123
cudaMemcpy(SM_thresholds_d, SM_thresholds_h, threshold_size, cudaMemcpyHostToDevice); 
#line 3125
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : SM_edge_detection_GPU(SM_counts_d, SM_thresholds_d); 
#line 3127
puts("SM hull-detection complete.  Writing results to disk..."); 
#line 3129
cudaMemcpy(SM_counts_h, SM_counts_d, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(int), cudaMemcpyDeviceToHost); 
#line 3130
cudaFree(SM_counts_d); 
#line 3131
cudaFree(SM_differences_d); 
#line 3132
cudaFree(SM_thresholds_d); 
#line 3134
free(SM_differences_h); 
#line 3135
free(SM_thresholds_h); 
#line 3137
if (WRITE_SM_HULL) { 
#line 3138
array_2_disk((char *)("x_SM"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, SM_counts_h, 200, 200, (int)((6.0) / (0.25)), (200 * 200) * ((int)((6.0) / (0.25))), true); }  
#line 3139
if (MLP_HULL != (SM_HULL)) { 
#line 3140
free(SM_counts_h); }  
#line 3141
} 
#line 3142
void SM_edge_detection_GPU_2(int *SM_counts, int *SM_differences) ;
#if 0
#line 3143
{ 
#line 3144
int row = blockIdx.y, column = blockIdx.x, slice = threadIdx.x; 
#line 3145
int voxel = (column + (row * 200)) + ((slice * 200) * 200); 
#line 3146
int difference, max_difference = 0; 
#line 3147
if ((((row != 0) && (row != (200 - 1))) && (column != 0)) && (column != (200 - 1))) 
#line 3148
{ 
#line 3149
for (int current_row = row - 1; current_row <= (row + 1); current_row++) 
#line 3150
{ 
#line 3151
for (int current_column = column - 1; current_column <= (column + 1); current_column++) 
#line 3152
{ 
#line 3153
difference = ((SM_counts[voxel]) - (SM_counts[(current_column + (current_row * 200)) + ((slice * 200) * 200)])); 
#line 3154
if (difference > max_difference) { 
#line 3155
max_difference = difference; }  
#line 3156
}  
#line 3157
}  
#line 3158
(SM_differences[voxel]) = max_difference; 
#line 3159
}  
#line 3160
syncthreads(); 
#line 3161
int slice_threshold; 
#line 3162
max_difference = 0; 
#line 3163
for (int pixel = 0; pixel < (200 * 200); pixel++) 
#line 3164
{ 
#line 3165
voxel = (pixel + ((slice * 200) * 200)); 
#line 3166
if ((SM_differences[voxel]) > max_difference) 
#line 3167
{ 
#line 3168
max_difference = (SM_differences[voxel]); 
#line 3169
slice_threshold = (SM_counts[voxel]); 
#line 3170
}  
#line 3171
}  
#line 3172
syncthreads(); 
#line 3173
float x = ((column - (200 / 2)) + (0.5)) * (((2) * (8.0)) / (200)); 
#line 3174
float y = (((200 / 2) - row) - (0.5)) * (((2) * (8.0)) / (200)); 
#line 3175
if (voxel < ((200 * 200) * ((int)((6.0) / (0.25))))) 
#line 3176
{ 
#line 3177
if ((SM_counts[voxel]) > ((1.0) * slice_threshold)) { 
#line 3178
(SM_counts[voxel]) = 1; } else { 
#line 3180
(SM_counts[voxel]) = 0; }  
#line 3181
if ((pow(x, 2) + pow(y, 2)) >= pow((8.0) - (max(((2) * (8.0)) / (200), ((2) * (8.0)) / (200)) / (2)), 2)) { 
#line 3182
(SM_counts[voxel]) = 0; }  
#line 3183
}  
#line 3184
} 
#endif
#line 3185 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void hull_detection_finish() 
#line 3186
{ 
#line 3187
if (SC_ON) 
#line 3188
{ 
#line 3189
SC_hull_h = ((bool *)calloc((200 * 200) * ((int)((6.0) / (0.25))), sizeof(bool))); 
#line 3190
cudaMemcpy(SC_hull_h, SC_hull_d, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(bool), cudaMemcpyDeviceToHost); 
#line 3191
if (WRITE_SC_HULL) 
#line 3192
{ 
#line 3193
puts("Writing SC hull to disk..."); 
#line 3194
array_2_disk((char *)("x_SC"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, SC_hull_h, 200, 200, (int)((6.0) / (0.25)), (200 * 200) * ((int)((6.0) / (0.25))), true); 
#line 3195
}  
#line 3196
if (MLP_HULL != (SC_HULL)) 
#line 3197
{ 
#line 3198
free(SC_hull_h); 
#line 3199
cudaFree(SC_hull_d); 
#line 3200
}  
#line 3201
}  
#line 3202
if (MSC_ON) 
#line 3203
{ 
#line 3204
MSC_counts_h = ((int *)calloc((200 * 200) * ((int)((6.0) / (0.25))), sizeof(int))); 
#line 3205
if (WRITE_MSC_COUNTS) 
#line 3206
{ 
#line 3207
puts("Writing MSC counts to disk..."); 
#line 3208
cudaMemcpy(MSC_counts_h, MSC_counts_d, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(int), cudaMemcpyDeviceToHost); 
#line 3209
array_2_disk((char *)("MSC_counts_h"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, MSC_counts_h, 200, 200, (int)((6.0) / (0.25)), (200 * 200) * ((int)((6.0) / (0.25))), true); 
#line 3210
}  
#line 3211
if (WRITE_MSC_HULL || (MLP_HULL == (MSC_HULL))) 
#line 3212
{ 
#line 3213
MSC_edge_detection(); 
#line 3214
cudaMemcpy(MSC_counts_h, MSC_counts_d, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(int), cudaMemcpyDeviceToHost); 
#line 3215
if (WRITE_MSC_HULL) 
#line 3216
{ 
#line 3217
puts("Writing MSC hull to disk..."); 
#line 3218
array_2_disk((char *)("x_MSC"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, MSC_counts_h, 200, 200, (int)((6.0) / (0.25)), (200 * 200) * ((int)((6.0) / (0.25))), true); 
#line 3219
}  
#line 3220
}  
#line 3221
if (MLP_HULL != (MSC_HULL)) { 
#line 3222
free(MSC_counts_h); }  
#line 3223
cudaFree(MSC_counts_d); 
#line 3224
}  
#line 3225
if (SM_ON) 
#line 3226
{ 
#line 3227
SM_counts_h = ((int *)calloc((200 * 200) * ((int)((6.0) / (0.25))), sizeof(int))); 
#line 3228
if (WRITE_SM_COUNTS) 
#line 3229
{ 
#line 3230
puts("Writing SM counts to disk..."); 
#line 3231
cudaMemcpy(SM_counts_h, SM_counts_d, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(int), cudaMemcpyDeviceToHost); 
#line 3232
array_2_disk((char *)("SM_counts_h"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, SM_counts_h, 200, 200, (int)((6.0) / (0.25)), (200 * 200) * ((int)((6.0) / (0.25))), true); 
#line 3233
}  
#line 3234
if (WRITE_SM_HULL || (MLP_HULL == (SM_HULL))) 
#line 3235
{ 
#line 3236
SM_edge_detection(); 
#line 3237
cudaMemcpy(SM_counts_h, SM_counts_d, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(int), cudaMemcpyDeviceToHost); 
#line 3238
if (WRITE_SM_HULL) 
#line 3239
{ 
#line 3240
puts("Writing SM hull to disk..."); 
#line 3241
array_2_disk((char *)("x_SM"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, SM_counts_h, 200, 200, (int)((6.0) / (0.25)), (200 * 200) * ((int)((6.0) / (0.25))), true); 
#line 3242
}  
#line 3243
}  
#line 3244
if (MLP_HULL != (SM_HULL)) { 
#line 3245
free(SM_counts_h); }  
#line 3246
cudaFree(SM_counts_d); 
#line 3247
}  
#line 3248
} 
#line 3250
template< class H, class D> void averaging_filter(H *&image_h, D *&image_d) 
#line 3251
{ 
#line 3252
bool is_hull = ((typeid(bool)) == (typeid(D))); 
#line 3253
D *new_value_d; 
#line 3254
int new_value_size = (((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(D)); 
#line 3255
cudaMalloc(&new_value_d, new_value_size); 
#line 3257
::dim3 dimBlock((int)((6.0) / (0.25))); 
#line 3258
::dim3 dimGrid(200, 200); 
#line 3259
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : (averaging_filter_GPU)(image_d, new_value_d, is_hull); 
#line 3262
cudaFree(image_d); 
#line 3263
image_d = new_value_d; 
#line 3264
} 
#line 3265
template< class D> static void __wrapper__device_stub_averaging_filter_GPU(D *&image, D *&new_value, bool &is_hull) {exit(1);}
#if 0
#line 3266
{ 
#line 3267
int voxel_x = blockIdx.x; 
#line 3268
int voxel_y = blockIdx.y; 
#line 3269
int voxel_z = threadIdx.x; 
#line 3270
int voxel = (voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200); 
#line 3271
int left_edge = max(voxel_x - 2, 0); 
#line 3272
int right_edge = min(voxel_x + 2, 200 - 1); 
#line 3273
int top_edge = max(voxel_y - 2, 0); 
#line 3274
int bottom_edge = min(voxel_y + 2, 200 - 1); 
#line 3275
int neighborhood_voxels = ((right_edge - left_edge) + 1) * ((bottom_edge - top_edge) + 1); 
#line 3276
double sum_threshold = neighborhood_voxels * (0.10000000000000001); 
#line 3277
double sum = (0); 
#line 3280
for (int column = left_edge; column <= right_edge; column++) { 
#line 3281
for (int row = top_edge; row <= bottom_edge; row++) { 
#line 3282
sum += (image[(column + (row * 200)) + ((voxel_z * 200) * 200)]); }  }  
#line 3283
if (is_hull) { 
#line 3284
(new_value[voxel]) = (sum > sum_threshold); } else { 
#line 3286
(new_value[voxel]) = (sum / neighborhood_voxels); }  
#line 3287
} 
#endif
#line 3265 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
template< class D> void averaging_filter_GPU(D *image, D *new_value, bool is_hull) 
#line 3266
{__wrapper__device_stub_averaging_filter_GPU<D>(image,new_value,is_hull);
#line 3287
return;}
#if 0
#line 3266
{ 
#line 3267
int voxel_x = blockIdx.x; 
#line 3268
int voxel_y = blockIdx.y; 
#line 3269
int voxel_z = threadIdx.x; 
#line 3270
int voxel = (voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200); 
#line 3271
int left_edge = max(voxel_x - 2, 0); 
#line 3272
int right_edge = min(voxel_x + 2, 200 - 1); 
#line 3273
int top_edge = max(voxel_y - 2, 0); 
#line 3274
int bottom_edge = min(voxel_y + 2, 200 - 1); 
#line 3275
int neighborhood_voxels = ((right_edge - left_edge) + 1) * ((bottom_edge - top_edge) + 1); 
#line 3276
double sum_threshold = neighborhood_voxels * (0.10000000000000001); 
#line 3277
double sum = (0); 
#line 3280
for (int column = left_edge; column <= right_edge; column++) { 
#line 3281
for (int row = top_edge; row <= bottom_edge; row++) { 
#line 3282
sum += (image[(column + (row * 200)) + ((voxel_z * 200) * 200)]); }  }  
#line 3283
if (is_hull) { 
#line 3284
(new_value[voxel]) = (sum > sum_threshold); } else { 
#line 3286
(new_value[voxel]) = (sum / neighborhood_voxels); }  
#line 3287
} 
#endif
#line 3288 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
template< class T, class T2> static void __wrapper__device_stub_apply_averaging_filter_GPU(T *&image, T2 *&new_value) {exit(1);}
#if 0
#line 3289
{ 
#line 3290
int voxel_x = blockIdx.x; 
#line 3291
int voxel_y = blockIdx.y; 
#line 3292
int voxel_z = threadIdx.x; 
#line 3293
int voxel = (voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200); 
#line 3294
(image[voxel]) = (new_value[voxel]); 
#line 3295
} 
#endif
#line 3288 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
template< class T, class T2> void apply_averaging_filter_GPU(T *image, T2 *new_value) 
#line 3289
{__wrapper__device_stub_apply_averaging_filter_GPU<T,T2>(image,new_value);
#line 3295
return;}
#if 0
#line 3289
{ 
#line 3290
int voxel_x = blockIdx.x; 
#line 3291
int voxel_y = blockIdx.y; 
#line 3292
int voxel_z = threadIdx.x; 
#line 3293
int voxel = (voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200); 
#line 3294
(image[voxel]) = (new_value[voxel]); 
#line 3295
} 
#endif
#line 3296 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void hull_selection() 
#line 3297
{ 
#line 3298
puts("Performing hull selection..."); 
#line 3300
x_hull_h = ((bool *)calloc((200 * 200) * ((int)((6.0) / (0.25))), sizeof(bool))); 
#line 3301
switch (MLP_HULL) 
#line 3302
{ 
#line 3303
case SC_HULL:  x_hull_h = SC_hull_h; break; 
#line 3304
case MSC_HULL:  std::transform(MSC_counts_h, MSC_counts_h + ((200 * 200) * ((int)((6.0) / (0.25)))), MSC_counts_h, x_hull_h, std::logical_or< int> ()); break; 
#line 3305
case SM_HULL:  std::transform(SM_counts_h, SM_counts_h + ((200 * 200) * ((int)((6.0) / (0.25)))), SM_counts_h, x_hull_h, std::logical_or< int> ()); break; 
#line 3306
case FBP_HULL:  x_hull_h = FBP_hull_h; 
#line 3307
}  
#line 3308
if (WRITE_X_HULL) 
#line 3309
{ 
#line 3310
puts("Writing selected hull to disk..."); 
#line 3311
array_2_disk((char *)("x_hull"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, x_hull_h, 200, 200, (int)((6.0) / (0.25)), (200 * 200) * ((int)((6.0) / (0.25))), true); 
#line 3312
}  
#line 3315
cudaMalloc((void **)(&x_hull_d), ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(bool)); 
#line 3316
cudaMemcpy(x_hull_d, x_hull_h, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(bool), cudaMemcpyHostToDevice); 
#line 3319
if (HULL_FILTER_ON) 
#line 3320
{ 
#line 3321
puts("Filtering hull..."); 
#line 3322
averaging_filter(x_hull_h, x_hull_d); 
#line 3323
puts("Hull Filtering complete"); 
#line 3324
if (WRITE_FILTERED_HULL) 
#line 3325
{ 
#line 3326
puts("Writing filtered hull to disk..."); 
#line 3327
cudaMemcpy(x_hull_h, x_hull_d, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(bool), cudaMemcpyDeviceToHost); 
#line 3328
array_2_disk((char *)("x_hull_filtered"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, x_hull_h, 200, 200, (int)((6.0) / (0.25)), (200 * 200) * ((int)((6.0) / (0.25))), true); 
#line 3329
}  
#line 3330
}  
#line 3331
puts("Hull selection complete."); 
#line 3332
} 
#line 3336
void create_MLP_test_image() 
#line 3337
{ 
#line 3338
double x, y; 
#line 3340
MLP_test_image_h = ((int *)calloc(MLP_IMAGE_VOXELS, sizeof(int))); 
#line 3342
for (int slice = 0; slice < MLP_IMAGE_SLICES; slice++) 
#line 3343
{ 
#line 3344
for (int row = 0; row < MLP_IMAGE_ROWS; row++) 
#line 3345
{ 
#line 3346
for (int column = 0; column < MLP_IMAGE_COLUMNS; column++) 
#line 3347
{ 
#line 3348
x = (((column - (MLP_IMAGE_COLUMNS / 2)) + (0.5)) * MLP_IMAGE_VOXEL_WIDTH); 
#line 3349
y = ((((MLP_IMAGE_ROWS / 2) - row) - (0.5)) * MLP_IMAGE_VOXEL_HEIGHT); 
#line 3350
if ((pow(x, 2) + pow(y, 2)) <= pow(MLP_IMAGE_RECON_CYL_RADIUS, 2)) { 
#line 3351
(MLP_test_image_h[(((slice * MLP_IMAGE_COLUMNS) * MLP_IMAGE_ROWS) + (row * MLP_IMAGE_COLUMNS)) + column]) = 1; }  
#line 3352
if ((pow(x / MLP_PHANTOM_A, 2) + pow(y / MLP_PHANTOM_B, 2)) <= (1)) { 
#line 3353
(MLP_test_image_h[(((slice * MLP_IMAGE_COLUMNS) * MLP_IMAGE_ROWS) + (row * MLP_IMAGE_COLUMNS)) + column]) = 8; }  
#line 3354
}  
#line 3355
}  
#line 3356
}  
#line 3357
} 
#line 3358
void MLP_entry_exit(int *&image, bool entry, float x_start, float y_start, float z_start, float xy_angle, float xz_angle, float x_object, float y_object, float z_object) 
#line 3359
{ 
#line 3547
} 
#line 3548
void MLP_test() 
#line 3549
{ 
#line 3550
char user_response[20]; 
#line 3551
double x_entry = (-(3.0)); 
#line 3552
double y_entry = -sqrt(pow(MLP_IMAGE_RECON_CYL_RADIUS, 2) - pow(x_entry, 2)); 
#line 3553
double z_entry = (0.0); 
#line 3554
double x_exit = (2.5); 
#line 3555
double y_exit = sqrt(pow(MLP_IMAGE_RECON_CYL_RADIUS, 2) - pow(x_exit, 2)); 
#line 3556
double z_exit = (0.0); 
#line 3557
double xy_entry_angle = ((25) * ((4) * atan((1.0)))) / (180), xz_entry_angle = (0.0); 
#line 3558
double xy_exit_angle = ((45) * ((4) * atan((1.0)))) / (180), xz_exit_angle = (0.0); 
#line 3559
double x_in_object, y_in_object, z_in_object; 
#line 3560
double u_in_object, t_in_object, v_in_object; 
#line 3561
double x_out_object, y_out_object, z_out_object; 
#line 3562
double u_out_object, t_out_object, v_out_object; 
#line 3567
double voxel_x, voxel_y, voxel_z; 
#line 3568
int voxel; 
#line 3569
int x_move_direction, y_move_direction, z_move_direction; 
#line 3570
int x_voxel_step, y_voxel_step, z_voxel_step; 
#line 3571
double x, y, z; 
#line 3572
double x_inside, y_inside, z_inside; 
#line 3573
double x_to_go, y_to_go, z_to_go; 
#line 3574
double delta_x, delta_y, delta_z; 
#line 3575
double x_extension, y_extension; 
#line 3576
double x_move, y_move, z_move; 
#line 3577
bool end_walk, outside_image; 
#line 3578
bool entered_object = false, exited_object = false; 
#line 3589
x_inside = (modf((x_entry + (MLP_IMAGE_WIDTH / (2))) / MLP_IMAGE_VOXEL_WIDTH, &voxel_x) * MLP_IMAGE_VOXEL_WIDTH); 
#line 3590
y_inside = (modf(((MLP_IMAGE_HEIGHT / (2)) - y_entry) / MLP_IMAGE_VOXEL_HEIGHT, &voxel_y) * MLP_IMAGE_VOXEL_HEIGHT); 
#line 3591
z_inside = (modf(((MLP_IMAGE_THICKNESS / (2)) - z_entry) / MLP_IMAGE_VOXEL_THICKNESS, &voxel_z) * MLP_IMAGE_VOXEL_THICKNESS); 
#line 3595
voxel = ((int)((voxel_x + (voxel_y * MLP_IMAGE_COLUMNS)) + ((voxel_z * MLP_IMAGE_COLUMNS) * MLP_IMAGE_ROWS))); 
#line 3602
delta_x = MLP_IMAGE_VOXEL_WIDTH; 
#line 3603
delta_y = (tan(xy_entry_angle) * MLP_IMAGE_VOXEL_WIDTH); 
#line 3604
delta_z = (tan(xz_entry_angle) * MLP_IMAGE_VOXEL_WIDTH); 
#line 3605
if (x_entry == x_exit) 
#line 3606
{ 
#line 3607
delta_x = (0); 
#line 3608
delta_y = MLP_IMAGE_VOXEL_HEIGHT; 
#line 3609
delta_z = ((tan(xz_entry_angle) / tan(xy_entry_angle)) * MLP_IMAGE_VOXEL_HEIGHT); 
#line 3610
if (y_entry == y_exit) 
#line 3611
{ 
#line 3612
delta_x = (0); 
#line 3613
delta_y = (0); 
#line 3614
delta_z = MLP_IMAGE_VOXEL_THICKNESS; 
#line 3615
}  
#line 3616
}  
#line 3618
((x_move = (0)), (y_move = (0))), (z_move = (0)); 
#line 3622
x_move_direction = ((cos(xy_entry_angle) >= (0)) - (cos(xy_entry_angle) < (0))); 
#line 3623
y_move_direction = ((sin(xy_entry_angle) >= (0)) - (sin(xy_entry_angle) < (0))); 
#line 3624
z_move_direction = ((sin(xy_entry_angle) >= (0)) - (sin(xy_entry_angle) < (0))); 
#line 3625
x_voxel_step = x_move_direction; 
#line 3626
y_voxel_step = (-y_move_direction); 
#line 3627
z_voxel_step = (-z_move_direction); 
#line 3631
((x = x_entry), (y = y_entry)), (z = z_entry); 
#line 3632
x_to_go = (((x_voxel_step > 0) * (MLP_IMAGE_VOXEL_WIDTH - x_inside)) + ((x_voxel_step <= 0) * x_inside)); 
#line 3633
y_to_go = (((y_voxel_step > 0) * (MLP_IMAGE_VOXEL_HEIGHT - y_inside)) + ((y_voxel_step <= 0) * y_inside)); 
#line 3634
z_to_go = (((z_voxel_step > 0) * (MLP_IMAGE_VOXEL_THICKNESS - z_inside)) + ((z_voxel_step <= 0) * z_inside)); 
#line 3638
outside_image = (((voxel_x >= MLP_IMAGE_COLUMNS) || (voxel_y >= MLP_IMAGE_ROWS)) || (voxel_z >= MLP_IMAGE_SLICES)); 
#line 3639
if (!outside_image) 
#line 3640
{ 
#line 3641
entered_object = ((MLP_test_image_h[voxel]) == 8); 
#line 3642
(MLP_test_image_h[voxel]) = 4; 
#line 3643
}  
#line 3644
end_walk = (entered_object || outside_image); 
#line 3648
if (z_entry != z_exit) 
#line 3649
{ 
#line 3650
while (!end_walk) 
#line 3651
{ 
#line 3653
x_extension = ((delta_z / delta_x) * x_to_go); 
#line 3654
y_extension = ((delta_z / delta_y) * y_to_go); 
#line 3655
if ((z_to_go <= x_extension) && (z_to_go <= y_extension)) 
#line 3656
{ 
#line 3658
x_move = ((delta_x / delta_z) * z_to_go); 
#line 3659
y_move = ((delta_y / delta_z) * z_to_go); 
#line 3660
z_move = z_to_go; 
#line 3661
x_to_go -= x_move; 
#line 3662
y_to_go -= y_move; 
#line 3663
z_to_go = MLP_IMAGE_VOXEL_THICKNESS; 
#line 3664
voxel_z += z_voxel_step; 
#line 3665
if (x_to_go == (0)) 
#line 3666
{ 
#line 3667
voxel_x += x_voxel_step; 
#line 3668
x_to_go = MLP_IMAGE_VOXEL_WIDTH; 
#line 3669
}  
#line 3670
if (y_to_go == (0)) 
#line 3671
{ 
#line 3672
voxel_y += y_voxel_step; 
#line 3673
y_to_go = MLP_IMAGE_VOXEL_HEIGHT; 
#line 3674
}  
#line 3675
} else { 
#line 3677
if (x_extension <= y_extension) 
#line 3678
{ 
#line 3680
x_move = x_to_go; 
#line 3681
y_move = ((delta_y / delta_x) * x_to_go); 
#line 3682
z_move = ((delta_z / delta_x) * x_to_go); 
#line 3683
x_to_go = MLP_IMAGE_VOXEL_WIDTH; 
#line 3684
y_to_go -= y_move; 
#line 3685
z_to_go -= z_move; 
#line 3686
voxel_x += x_voxel_step; 
#line 3687
if (y_to_go == (0)) 
#line 3688
{ 
#line 3689
y_to_go = MLP_IMAGE_VOXEL_HEIGHT; 
#line 3690
voxel_y += y_voxel_step; 
#line 3691
}  
#line 3692
} else 
#line 3695
{ 
#line 3697
x_move = ((delta_x / delta_y) * y_to_go); 
#line 3698
y_move = y_to_go; 
#line 3699
z_move = ((delta_z / delta_y) * y_to_go); 
#line 3700
x_to_go -= x_move; 
#line 3701
y_to_go = MLP_IMAGE_VOXEL_HEIGHT; 
#line 3702
z_to_go -= z_move; 
#line 3703
voxel_y += y_voxel_step; 
#line 3704
}  }  
#line 3705
voxel = ((int)((voxel_x + (voxel_y * MLP_IMAGE_COLUMNS)) + ((voxel_z * MLP_IMAGE_COLUMNS) * MLP_IMAGE_ROWS))); 
#line 3706
outside_image = (((voxel_x >= MLP_IMAGE_COLUMNS) || (voxel_y >= MLP_IMAGE_ROWS)) || (voxel_z >= MLP_IMAGE_SLICES)); 
#line 3707
if (!outside_image) 
#line 3708
{ 
#line 3709
entered_object = ((MLP_test_image_h[voxel]) == 8); 
#line 3710
(MLP_test_image_h[voxel]) = 4; 
#line 3711
}  
#line 3712
x += (x_move_direction * x_move); 
#line 3713
y += (y_move_direction * y_move); 
#line 3714
z += (z_move_direction * z_move); 
#line 3715
end_walk = (entered_object || outside_image); 
#line 3716
}  
#line 3717
} else 
#line 3719
{ 
#line 3721
while (!end_walk) 
#line 3722
{ 
#line 3728
y_extension = ((delta_x / delta_y) * y_to_go); 
#line 3731
if (x_to_go <= y_extension) 
#line 3732
{ 
#line 3734
x_move = x_to_go; 
#line 3735
y_move = ((delta_y / delta_x) * x_to_go); 
#line 3736
x_to_go = MLP_IMAGE_VOXEL_WIDTH; 
#line 3737
y_to_go -= y_move; 
#line 3738
voxel_x += x_voxel_step; 
#line 3739
if (y_to_go == (0)) 
#line 3740
{ 
#line 3741
y_to_go = MLP_IMAGE_VOXEL_HEIGHT; 
#line 3742
voxel_y += y_voxel_step; 
#line 3743
}  
#line 3744
} else 
#line 3747
{ 
#line 3749
x_move = ((delta_x / delta_y) * y_to_go); 
#line 3750
y_move = y_to_go; 
#line 3751
x_to_go -= x_move; 
#line 3752
y_to_go = MLP_IMAGE_VOXEL_HEIGHT; 
#line 3753
voxel_y += y_voxel_step; 
#line 3754
}  
#line 3755
voxel = ((int)((voxel_x + (voxel_y * MLP_IMAGE_COLUMNS)) + ((voxel_z * MLP_IMAGE_COLUMNS) * MLP_IMAGE_ROWS))); 
#line 3761
outside_image = (((voxel_x >= MLP_IMAGE_COLUMNS) || (voxel_y >= MLP_IMAGE_ROWS)) || (voxel_z >= MLP_IMAGE_SLICES)); 
#line 3762
if (!outside_image) 
#line 3763
{ 
#line 3764
entered_object = ((MLP_test_image_h[voxel]) == 8); 
#line 3765
(MLP_test_image_h[voxel]) = 4; 
#line 3766
}  
#line 3768
x += (x_move_direction * x_move); 
#line 3769
y += (y_move_direction * y_move); 
#line 3770
end_walk = (entered_object || outside_image); 
#line 3772
}  
#line 3773
}  
#line 3774
if (entered_object) 
#line 3775
{ 
#line 3776
x_in_object = x; 
#line 3777
y_in_object = y; 
#line 3778
z_in_object = z; 
#line 3779
}  
#line 3789
x_inside = (modf((x_exit + (MLP_IMAGE_WIDTH / (2))) / MLP_IMAGE_VOXEL_WIDTH, &voxel_x) * MLP_IMAGE_VOXEL_WIDTH); 
#line 3790
y_inside = (modf(((MLP_IMAGE_HEIGHT / (2)) - y_exit) / MLP_IMAGE_VOXEL_HEIGHT, &voxel_y) * MLP_IMAGE_VOXEL_HEIGHT); 
#line 3791
z_inside = (modf(((MLP_IMAGE_THICKNESS / (2)) - z_exit) / MLP_IMAGE_VOXEL_THICKNESS, &voxel_z) * MLP_IMAGE_VOXEL_THICKNESS); 
#line 3795
voxel = ((int)((voxel_x + (voxel_y * MLP_IMAGE_COLUMNS)) + ((voxel_z * MLP_IMAGE_COLUMNS) * MLP_IMAGE_ROWS))); 
#line 3802
delta_x = MLP_IMAGE_VOXEL_WIDTH; 
#line 3803
delta_y = (tan(xy_exit_angle) * MLP_IMAGE_VOXEL_WIDTH); 
#line 3804
delta_z = (tan(xz_exit_angle) * MLP_IMAGE_VOXEL_WIDTH); 
#line 3805
if (x_entry == x_exit) 
#line 3806
{ 
#line 3807
delta_x = (0); 
#line 3808
delta_y = MLP_IMAGE_VOXEL_HEIGHT; 
#line 3809
delta_z = ((tan(xz_exit_angle) / tan(xy_exit_angle)) * MLP_IMAGE_VOXEL_HEIGHT); 
#line 3810
if (y_entry == y_exit) 
#line 3811
{ 
#line 3812
delta_x = (0); 
#line 3813
delta_y = (0); 
#line 3814
delta_z = MLP_IMAGE_VOXEL_THICKNESS; 
#line 3815
}  
#line 3816
}  
#line 3818
((x_move = (0)), (y_move = (0))), (z_move = (0)); 
#line 3822
x_move_direction = ((cos(xy_exit_angle) < (0)) - (cos(xy_exit_angle) >= (0))); 
#line 3823
y_move_direction = ((sin(xy_exit_angle) < (0)) - (sin(xy_exit_angle) >= (0))); 
#line 3824
z_move_direction = ((sin(xy_exit_angle) < (0)) - (sin(xy_exit_angle) >= (0))); 
#line 3825
x_voxel_step = x_move_direction; 
#line 3826
y_voxel_step = (-y_move_direction); 
#line 3827
z_voxel_step = (-z_move_direction); 
#line 3831
((x = x_exit), (y = y_exit)), (z = z_exit); 
#line 3832
x_to_go = (((x_voxel_step > 0) * (MLP_IMAGE_VOXEL_WIDTH - x_inside)) + ((x_voxel_step <= 0) * x_inside)); 
#line 3833
y_to_go = (((y_voxel_step > 0) * (MLP_IMAGE_VOXEL_HEIGHT - y_inside)) + ((y_voxel_step <= 0) * y_inside)); 
#line 3834
z_to_go = (((z_voxel_step > 0) * (MLP_IMAGE_VOXEL_THICKNESS - z_inside)) + ((z_voxel_step <= 0) * z_inside)); 
#line 3838
outside_image = (((voxel_x >= MLP_IMAGE_COLUMNS) || (voxel_y >= MLP_IMAGE_ROWS)) || (voxel_z >= MLP_IMAGE_SLICES)); 
#line 3839
if (!outside_image) 
#line 3840
{ 
#line 3841
exited_object = ((MLP_test_image_h[voxel]) == 8); 
#line 3842
(MLP_test_image_h[voxel]) = 4; 
#line 3843
}  
#line 3844
end_walk = (exited_object || outside_image); 
#line 3848
if (z_entry != z_exit) 
#line 3849
{ 
#line 3851
while (!end_walk) 
#line 3852
{ 
#line 3854
x_extension = ((delta_z / delta_x) * x_to_go); 
#line 3855
y_extension = ((delta_z / delta_y) * y_to_go); 
#line 3856
if ((z_to_go <= x_extension) && (z_to_go <= y_extension)) 
#line 3857
{ 
#line 3859
x_move = ((delta_x / delta_z) * z_to_go); 
#line 3860
y_move = ((delta_y / delta_z) * z_to_go); 
#line 3861
z_move = z_to_go; 
#line 3862
x_to_go -= x_move; 
#line 3863
y_to_go -= y_move; 
#line 3864
z_to_go = MLP_IMAGE_VOXEL_THICKNESS; 
#line 3865
voxel_z += z_voxel_step; 
#line 3866
if (x_to_go == (0)) 
#line 3867
{ 
#line 3868
voxel_x += x_voxel_step; 
#line 3869
x_to_go = MLP_IMAGE_VOXEL_WIDTH; 
#line 3870
}  
#line 3871
if (y_to_go == (0)) 
#line 3872
{ 
#line 3873
voxel_y += y_voxel_step; 
#line 3874
y_to_go = MLP_IMAGE_VOXEL_HEIGHT; 
#line 3875
}  
#line 3876
} else { 
#line 3878
if (x_extension <= y_extension) 
#line 3879
{ 
#line 3881
x_move = x_to_go; 
#line 3882
y_move = ((delta_y / delta_x) * x_to_go); 
#line 3883
z_move = ((delta_z / delta_x) * x_to_go); 
#line 3884
x_to_go = MLP_IMAGE_VOXEL_WIDTH; 
#line 3885
y_to_go -= y_move; 
#line 3886
z_to_go -= z_move; 
#line 3887
voxel_x += x_voxel_step; 
#line 3888
if (y_to_go == (0)) 
#line 3889
{ 
#line 3890
y_to_go = MLP_IMAGE_VOXEL_HEIGHT; 
#line 3891
voxel_y += y_voxel_step; 
#line 3892
}  
#line 3893
} else 
#line 3896
{ 
#line 3898
x_move = ((delta_x / delta_y) * y_to_go); 
#line 3899
y_move = y_to_go; 
#line 3900
z_move = ((delta_z / delta_y) * y_to_go); 
#line 3901
x_to_go -= x_move; 
#line 3902
y_to_go = MLP_IMAGE_VOXEL_HEIGHT; 
#line 3903
z_to_go -= z_move; 
#line 3904
voxel_y += y_voxel_step; 
#line 3905
}  }  
#line 3906
voxel = ((int)((voxel_x + (voxel_y * MLP_IMAGE_COLUMNS)) + ((voxel_z * MLP_IMAGE_COLUMNS) * MLP_IMAGE_ROWS))); 
#line 3907
outside_image = (((voxel_x >= MLP_IMAGE_COLUMNS) || (voxel_y >= MLP_IMAGE_ROWS)) || (voxel_z >= MLP_IMAGE_SLICES)); 
#line 3908
if (!outside_image) 
#line 3909
{ 
#line 3910
exited_object = ((MLP_test_image_h[voxel]) == 8); 
#line 3911
(MLP_test_image_h[voxel]) = 4; 
#line 3912
}  
#line 3913
x += (x_move_direction * x_move); 
#line 3914
y += (y_move_direction * y_move); 
#line 3915
z += (z_move_direction * z_move); 
#line 3916
end_walk = (exited_object || outside_image); 
#line 3917
}  
#line 3918
} else 
#line 3920
{ 
#line 3922
while (!end_walk) 
#line 3923
{ 
#line 3929
y_extension = ((delta_x / delta_y) * y_to_go); 
#line 3932
if (x_to_go <= y_extension) 
#line 3933
{ 
#line 3935
x_move = x_to_go; 
#line 3936
y_move = ((delta_y / delta_x) * x_to_go); 
#line 3937
x_to_go = MLP_IMAGE_VOXEL_WIDTH; 
#line 3938
y_to_go -= y_move; 
#line 3939
voxel_x += x_voxel_step; 
#line 3940
if (y_to_go == (0)) 
#line 3941
{ 
#line 3942
y_to_go = MLP_IMAGE_VOXEL_HEIGHT; 
#line 3943
voxel_y += y_voxel_step; 
#line 3944
}  
#line 3945
} else 
#line 3948
{ 
#line 3950
x_move = ((delta_x / delta_y) * y_to_go); 
#line 3951
y_move = y_to_go; 
#line 3952
x_to_go -= x_move; 
#line 3953
y_to_go = MLP_IMAGE_VOXEL_HEIGHT; 
#line 3954
voxel_y += y_voxel_step; 
#line 3955
}  
#line 3956
voxel = ((int)((voxel_x + (voxel_y * MLP_IMAGE_COLUMNS)) + ((voxel_z * MLP_IMAGE_COLUMNS) * MLP_IMAGE_ROWS))); 
#line 3962
outside_image = (((voxel_x >= MLP_IMAGE_COLUMNS) || (voxel_y >= MLP_IMAGE_ROWS)) || (voxel_z >= MLP_IMAGE_SLICES)); 
#line 3963
if (!outside_image) 
#line 3964
{ 
#line 3965
exited_object = ((MLP_test_image_h[voxel]) == 8); 
#line 3966
(MLP_test_image_h[voxel]) = 4; 
#line 3967
}  
#line 3969
x += (x_move_direction * x_move); 
#line 3970
y += (y_move_direction * y_move); 
#line 3971
end_walk = (exited_object || outside_image); 
#line 3973
}  
#line 3974
}  
#line 3975
if (exited_object) 
#line 3976
{ 
#line 3977
x_out_object = x; 
#line 3978
y_out_object = y; 
#line 3979
z_out_object = z; 
#line 3980
}  
#line 3982
x_inside = (modf((x_in_object + (MLP_IMAGE_WIDTH / (2))) / MLP_IMAGE_VOXEL_WIDTH, &voxel_x) * MLP_IMAGE_VOXEL_WIDTH); 
#line 3983
y_inside = (modf(((MLP_IMAGE_HEIGHT / (2)) - y_in_object) / MLP_IMAGE_VOXEL_HEIGHT, &voxel_y) * MLP_IMAGE_VOXEL_HEIGHT); 
#line 3984
z_inside = (modf(((MLP_IMAGE_THICKNESS / (2)) - z_in_object) / MLP_IMAGE_VOXEL_THICKNESS, &voxel_z) * MLP_IMAGE_VOXEL_THICKNESS); 
#line 3991
voxel = ((int)((voxel_x + (voxel_y * MLP_IMAGE_COLUMNS)) + ((voxel_z * MLP_IMAGE_COLUMNS) * MLP_IMAGE_ROWS))); 
#line 3993
int path[1000]; 
#line 3994
int path_index = 0; 
#line 3995
double chord_lengths[1000]; 
#line 3996
(MLP_test_image_h[voxel]) = 0; 
#line 3997
((path)[path_index++]) = voxel; 
#line 3999
u_in_object = ((cos(xy_entry_angle) * x_in_object) + (sin(xy_entry_angle) * y_in_object)); 
#line 4000
u_out_object = ((cos(xy_entry_angle) * x_out_object) + (sin(xy_entry_angle) * y_out_object)); 
#line 4001
t_in_object = ((cos(xy_entry_angle) * y_in_object) - (sin(xy_entry_angle) * x_in_object)); 
#line 4002
t_out_object = ((cos(xy_entry_angle) * y_out_object) - (sin(xy_entry_angle) * x_out_object)); 
#line 4003
v_in_object = z_in_object; 
#line 4004
v_out_object = z_out_object; 
#line 4006
double T_0[2] = {t_in_object, (0)}; 
#line 4007
double T_2[2] = {t_out_object, xy_exit_angle - xy_entry_angle}; 
#line 4008
double V_0[2] = {v_in_object, xz_entry_angle}; 
#line 4009
double V_2[2] = {v_out_object, xz_exit_angle}; 
#line 4010
double u_2 = abs(u_out_object - u_in_object); 
#line 4011
double u_0 = (0), u_1 = min(((2) * (8.0)) / (200), ((2) * (8.0)) / (200)) / (2); 
#line 4012
double t_1_previous, v_1_previous; 
#line 4013
double x_1_previous = x, y_1_previous = y, z_1_previous = z; 
#line 4014
int voxel_x_previous = voxel_x; 
#line 4015
int voxel_y_previous = voxel_y; 
#line 4016
int voxel_z_previous = voxel_z; 
#line 4017
int voxel_previous = voxel; 
#line 4018
int voxels_passed; 
#line 4019
double chord_segment; 
#line 4020
double chord_fraction; 
#line 4021
double x_to_edge, y_to_edge, z_to_edge; 
#line 4023
while (u_1 <= (u_2 - (min(((2) * (8.0)) / (200), ((2) * (8.0)) / (200)) / (2)))) 
#line 4024
{ 
#line 4025
double R_0[4] = {(1.0), u_1 - u_0, (0.0), (1.0)}; 
#line 4026
double R_0T[4] = {(1.0), (0.0), u_1 - u_0, (1.0)}; 
#line 4027
double R_1[4] = {(1.0), u_2 - u_1, (0.0), (1.0)}; 
#line 4028
double R_1T[4] = {(1.0), (0.0), u_2 - u_1, (1.0)}; 
#line 4030
double sigma_1_coefficient = pow((13.6) * ((1) + ((0.037999999999999999) * log((u_1 - u_0) / (36.100000000000001)))), (2.0)) / (36.100000000000001); 
#line 4031
double sigma_t1 = ((((((A_0 / (3)) * pow(u_1, (3.0))) + ((A_1 / (12)) * pow(u_1, (4.0)))) + ((A_2 / (30)) * pow(u_1, (5.0)))) + ((A_3 / (60)) * pow(u_1, (6.0)))) + ((A_4 / (105)) * pow(u_1, (7.0)))) + ((A_5 / (168)) * pow(u_1, (8.0))); 
#line 4032
double sigma_t1_theta1 = pow(u_1, (2.0)) * ((((((A_0 / (2)) + ((A_1 / (6)) * u_1)) + ((A_2 / (12)) * pow(u_1, (2.0)))) + ((A_3 / (20)) * pow(u_1, (3.0)))) + ((A_4 / (30)) * pow(u_1, (4.0)))) + ((A_5 / (42)) * pow(u_1, (5.0)))); 
#line 4033
double sigma_theta1 = (((((A_0 * u_1) + ((A_1 / (2)) * pow(u_1, (2.0)))) + ((A_2 / (3)) * pow(u_1, (3.0)))) + ((A_3 / (4)) * pow(u_1, (4.0)))) + ((A_4 / (5)) * pow(u_1, (5.0)))) + ((A_5 / (6)) * pow(u_1, (6.0))); 
#line 4034
double determinant_Sigma_1 = (sigma_t1 * sigma_theta1) - pow(sigma_t1_theta1, 2); 
#line 4035
double Sigma_1I[4] = {sigma_theta1 / determinant_Sigma_1, (-sigma_t1_theta1) / determinant_Sigma_1, (-sigma_t1_theta1) / determinant_Sigma_1, sigma_t1 / determinant_Sigma_1}; 
#line 4042
double sigma_2_coefficient = pow((13.6) * ((1) + ((0.037999999999999999) * log((u_2 - u_1) / (36.100000000000001)))), (2.0)) / (36.100000000000001); 
#line 4043
double sigma_t2 = ((((((((((((((A_0 / (3)) * pow(u_2, (3.0))) + ((A_1 / (12)) * pow(u_2, (4.0)))) + ((A_2 / (30)) * pow(u_2, (5.0)))) + ((A_3 / (60)) * pow(u_2, (6.0)))) + ((A_4 / (105)) * pow(u_2, (7.0)))) + ((A_5 / (168)) * pow(u_2, (8.0)))) - ((A_0 / (3)) * pow(u_1, (3.0)))) - ((A_1 / (4)) * pow(u_1, (4.0)))) - ((A_2 / (5)) * pow(u_1, (5.0)))) - ((A_3 / (6)) * pow(u_1, (6.0)))) - ((A_4 / (7)) * pow(u_1, (7.0)))) - ((A_5 / (8)) * pow(u_1, (8.0)))) + (((2) * u_2) * (((((((A_0 / (2)) * pow(u_1, (2.0))) + ((A_1 / (3)) * pow(u_1, (3.0)))) + ((A_2 / (4)) * pow(u_1, (4.0)))) + ((A_3 / (5)) * pow(u_1, (5.0)))) + ((A_4 / (6)) * pow(u_1, (6.0)))) + ((A_5 / (7)) * pow(u_1, (7.0)))))) - (pow(u_2, (2.0)) * ((((((A_0 * u_1) + ((A_1 / (2)) * pow(u_1, (2.0)))) + ((A_2 / (3)) * pow(u_1, (3.0)))) + ((A_3 / (4)) * pow(u_1, (4.0)))) + ((A_4 / (5)) * pow(u_1, (5.0)))) + ((A_5 / (6)) * pow(u_1, (6.0))))); 
#line 4047
double sigma_t2_theta2 = ((pow(u_2, (2.0)) * ((((((A_0 / (2)) + ((A_1 / (6)) * u_2)) + ((A_2 / (12)) * pow(u_2, (2.0)))) + ((A_3 / (20)) * pow(u_2, (3.0)))) + ((A_4 / (30)) * pow(u_2, (4.0)))) + ((A_5 / (42)) * pow(u_2, (5.0))))) - ((u_2 * u_1) * (((((A_0 + ((A_1 / (2)) * u_1)) + ((A_2 / (3)) * pow(u_1, (2.0)))) + ((A_3 / (4)) * pow(u_1, (3.0)))) + ((A_4 / (5)) * pow(u_1, (4.0)))) + ((A_5 / (6)) * pow(u_1, (5.0)))))) + (pow(u_1, (2.0)) * ((((((A_0 / (2)) + ((A_1 / (3)) * u_1)) + ((A_2 / (4)) * pow(u_1, (2.0)))) + ((A_3 / (5)) * pow(u_1, (3.0)))) + ((A_4 / (6)) * pow(u_1, (4.0)))) + ((A_5 / (7)) * pow(u_1, (5.0))))); 
#line 4050
double sigma_theta2 = (((((A_0 * (u_2 - u_1)) + ((A_1 / (2)) * (pow(u_2, (2.0)) - pow(u_1, (2.0))))) + ((A_2 / (3)) * (pow(u_2, (3.0)) - pow(u_1, (3.0))))) + ((A_3 / (4)) * (pow(u_2, (4.0)) - pow(u_1, (4.0))))) + ((A_4 / (5)) * (pow(u_2, (5.0)) - pow(u_1, (5.0))))) + ((A_5 / (6)) * (pow(u_2, (6.0)) - pow(u_1, (6.0)))); 
#line 4052
double determinant_Sigma_2 = (sigma_t2 * sigma_theta2) - pow(sigma_t2_theta2, 2); 
#line 4053
double Sigma_2I[4] = {sigma_theta2 / determinant_Sigma_2, (-sigma_t2_theta2) / determinant_Sigma_2, (-sigma_t2_theta2) / determinant_Sigma_2, sigma_t2 / determinant_Sigma_2}; 
#line 4060
double first_term[4] = {(((Sigma_1I)[0]) + (((R_1T)[0]) * ((((Sigma_2I)[0]) * ((R_1)[0])) + (((Sigma_2I)[1]) * ((R_1)[2]))))) + (((R_1T)[1]) * ((((Sigma_2I)[2]) * ((R_1)[0])) + (((Sigma_2I)[3]) * ((R_1)[2])))), (((Sigma_1I)[1]) + (((R_1T)[0]) * ((((Sigma_2I)[0]) * ((R_1)[1])) + (((Sigma_2I)[1]) * ((R_1)[3]))))) + (((R_1T)[1]) * ((((Sigma_2I)[2]) * ((R_1)[1])) + (((Sigma_2I)[3]) * ((R_1)[3])))), (((Sigma_1I)[2]) + (((R_1T)[2]) * ((((Sigma_2I)[0]) * ((R_1)[0])) + (((Sigma_2I)[1]) * ((R_1)[2]))))) + (((R_1T)[3]) * ((((Sigma_2I)[2]) * ((R_1)[0])) + (((Sigma_2I)[3]) * ((R_1)[2])))), (((Sigma_1I)[3]) + (((R_1T)[2]) * ((((Sigma_2I)[0]) * ((R_1)[1])) + (((Sigma_2I)[1]) * ((R_1)[3]))))) + (((R_1T)[3]) * ((((Sigma_2I)[2]) * ((R_1)[1])) + (((Sigma_2I)[3]) * ((R_1)[3]))))}; 
#line 4067
double determinant_first_term = (((first_term)[0]) * ((first_term)[3])) - (((first_term)[1]) * ((first_term)[2])); 
#line 4068
((first_term)[0]) = (((first_term)[3]) / determinant_first_term); 
#line 4069
((first_term)[1]) = ((-((first_term)[1])) / determinant_first_term); 
#line 4070
((first_term)[2]) = ((-((first_term)[2])) / determinant_first_term); 
#line 4071
((first_term)[3]) = (((first_term)[0]) / determinant_first_term); 
#line 4072
double second_term[2] = {(((((Sigma_1I)[0]) * ((((R_0)[0]) * ((T_0)[0])) + (((R_0)[1]) * ((T_0)[1])))) + (((Sigma_1I)[1]) * ((((R_0)[2]) * ((T_0)[0])) + (((R_0)[3]) * ((T_0)[1]))))) + (((R_1T)[0]) * ((((Sigma_2I)[0]) * ((T_2)[0])) + (((Sigma_2I)[1]) * ((T_2)[1]))))) + (((R_1T)[1]) * ((((Sigma_2I)[2]) * ((T_2)[0])) + (((Sigma_2I)[3]) * ((T_2)[1])))), (((((Sigma_1I)[2]) * ((((R_0)[0]) * ((T_0)[0])) + (((R_0)[1]) * ((T_0)[1])))) + (((Sigma_1I)[3]) * ((((R_0)[2]) * ((T_0)[0])) + (((R_0)[3]) * ((T_0)[1]))))) + (((R_1T)[2]) * ((((Sigma_2I)[0]) * ((T_2)[0])) + (((Sigma_2I)[1]) * ((T_2)[1]))))) + (((R_1T)[3]) * ((((Sigma_2I)[2]) * ((T_2)[0])) + (((Sigma_2I)[3]) * ((T_2)[1]))))}; 
#line 4084
double t_1 = (((first_term)[0]) * ((second_term)[0])) + (((first_term)[1]) * ((second_term)[1])); 
#line 4085
double theta_1 = (((first_term)[2]) * ((second_term)[0])) + (((first_term)[3]) * ((second_term)[1])); 
#line 4088
((second_term)[0]) = ((((((Sigma_1I)[0]) * ((((R_0)[0]) * ((V_0)[0])) + (((R_0)[1]) * ((V_0)[1])))) + (((Sigma_1I)[1]) * ((((R_0)[2]) * ((V_0)[0])) + (((R_0)[3]) * ((V_0)[1]))))) + (((R_1T)[0]) * ((((Sigma_2I)[0]) * ((V_2)[0])) + (((Sigma_2I)[1]) * ((V_2)[1]))))) + (((R_1T)[1]) * ((((Sigma_2I)[2]) * ((V_2)[0])) + (((Sigma_2I)[3]) * ((V_2)[1]))))); 
#line 4092
((second_term)[1]) = ((((((Sigma_1I)[2]) * ((((R_0)[0]) * ((V_0)[0])) + (((R_0)[1]) * ((V_0)[1])))) + (((Sigma_1I)[3]) * ((((R_0)[2]) * ((V_0)[0])) + (((R_0)[3]) * ((V_0)[1]))))) + (((R_1T)[2]) * ((((Sigma_2I)[0]) * ((V_2)[0])) + (((Sigma_2I)[1]) * ((V_2)[1]))))) + (((R_1T)[3]) * ((((Sigma_2I)[2]) * ((V_2)[0])) + (((Sigma_2I)[3]) * ((V_2)[1]))))); 
#line 4096
double v_1 = (((first_term)[0]) * ((second_term)[0])) + (((first_term)[1]) * ((second_term)[1])); 
#line 4097
double phi_1 = (((first_term)[2]) * ((second_term)[0])) + (((first_term)[3]) * ((second_term)[1])); 
#line 4100
double x_1 = (cos(xy_entry_angle) * (u_in_object + u_1)) - (sin(xy_entry_angle) * t_1); 
#line 4101
double y_1 = (sin(xy_entry_angle) * (u_in_object + u_1)) + (cos(xy_entry_angle) * t_1); 
#line 4102
double z_1 = v_in_object + v_1; 
#line 4103
x_inside = (modf((x_1 + (MLP_IMAGE_WIDTH / (2))) / MLP_IMAGE_VOXEL_WIDTH, &voxel_x) * MLP_IMAGE_VOXEL_WIDTH); 
#line 4104
y_inside = (modf(((MLP_IMAGE_HEIGHT / (2)) - y_1) / MLP_IMAGE_VOXEL_HEIGHT, &voxel_y) * MLP_IMAGE_VOXEL_HEIGHT); 
#line 4105
z_inside = (modf(((MLP_IMAGE_THICKNESS / (2)) - z_1) / MLP_IMAGE_VOXEL_THICKNESS, &voxel_z) * MLP_IMAGE_VOXEL_THICKNESS); 
#line 4107
x_voxel_step = ((voxel_x >= voxel_x_previous) - (voxel_x <= voxel_x_previous)); 
#line 4108
y_voxel_step = ((voxel_y >= voxel_y_previous) - (voxel_y <= voxel_y_previous)); 
#line 4109
z_voxel_step = ((voxel_z >= voxel_z_previous) - (voxel_z <= voxel_z_previous)); 
#line 4111
x_to_edge = (((x_voxel_step < 0) * x_inside) + ((x_voxel_step > 0) * ((((2) * (8.0)) / (200)) - x_inside))); 
#line 4112
y_to_edge = (((y_voxel_step < 0) * y_inside) + ((y_voxel_step > 0) * ((((2) * (8.0)) / (200)) - y_inside))); 
#line 4113
z_to_edge = (((z_voxel_step < 0) * z_inside) + ((z_voxel_step > 0) * (((((int)((6.0) / (0.25))) * (0.25)) / ((int)((6.0) / (0.25)))) - z_inside))); 
#line 4115
voxel = ((int)((voxel_x + (voxel_y * MLP_IMAGE_COLUMNS)) + ((voxel_z * MLP_IMAGE_COLUMNS) * MLP_IMAGE_ROWS))); 
#line 4116
if (voxel != ((path)[path_index - 1])) { 
#line 4117
((path)[path_index++]) = voxel; }  
#line 4118
for (int i = 0; i < path_index; i++) { 
#line 4119
printf("path[i] = %d\n", (path)[i]); }  
#line 4120
printf("path_index = %d\n\n", path_index); 
#line 4121
fgets(user_response, sizeof user_response, &(__iob_func()[0])); 
#line 4122
(MLP_test_image_h[voxel]) = 0; 
#line 4124
voxels_passed = (((voxel_x - voxel_x_previous) + (voxel_y - voxel_y_previous)) + (voxel_z - voxel_z_previous)); 
#line 4125
chord_segment = sqrt((pow(x_1_previous - x_1, 2) + pow(y_1_previous - y_1, 2)) + pow(z_1_previous - z_1, 2)); 
#line 4126
if (voxels_passed == 0) 
#line 4127
{ 
#line 4128
((chord_lengths)[path_index - 1]) += chord_segment; 
#line 4129
} else { 
#line 4130
if (voxels_passed == 1) 
#line 4131
{ 
#line 4132
if (x_voxel_step != 0) 
#line 4133
{ 
#line 4134
chord_fraction = (x_to_edge / (x_1_previous - x_1)); 
#line 4135
} else { 
#line 4136
if (y_voxel_step != 0) 
#line 4137
{ 
#line 4138
chord_fraction = (y_to_edge / (y_1_previous - y_1)); 
#line 4139
} else 
#line 4141
{ 
#line 4142
chord_fraction = (z_to_edge / (z_1_previous - z_1)); 
#line 4143
}  }  
#line 4144
((chord_lengths)[path_index - 1]) += (chord_fraction * chord_segment); 
#line 4145
((chord_lengths)[path_index]) += (chord_segment - ((chord_lengths)[path_index - 1])); 
#line 4146
} else { 
#line 4147
if (voxels_passed == 2) 
#line 4148
{ 
#line 4150
} else { 
#line 4151
if (voxels_passed == 3) 
#line 4152
{ 
#line 4154
}  }  }  }  
#line 4155
u_1 += (min(((2) * (8.0)) / (200), ((2) * (8.0)) / (200)) / (2)); 
#line 4156
t_1_previous = t_1; 
#line 4157
v_1_previous = v_1; 
#line 4158
x_1_previous = x_1; 
#line 4159
y_1_previous = y_1; 
#line 4160
z_1_previous = z_1; 
#line 4161
voxel_x_previous = voxel_x; 
#line 4162
voxel_y_previous = voxel_y; 
#line 4163
voxel_z_previous = voxel_z; 
#line 4164
voxel_previous = voxel; 
#line 4165
}  
#line 4166
} 
#line 4167
float mean_chord_length(float, float) 
#line 4168
{ 
#line 4169
float eff_angle_t, eff_angle_v; 
#line 4185
return 0; 
#line 4187
} 
#line 4191
void define_initial_iterate() 
#line 4192
{ 
#line 4193
float *x_h = (float *)calloc((200 * 200) * ((int)((6.0) / (0.25))), sizeof(float)); 
#line 4195
switch (X_K0) 
#line 4196
{ 
#line 4197
case X_HULL:  std::copy(x_hull_h, x_hull_h + ((200 * 200) * ((int)((6.0) / (0.25)))), x_h); break; 
#line 4198
case FBP_IMAGE:  x_h = FBP_image_h; break; 
#line 4199
case HYBRID:  std::transform(FBP_image_h, FBP_image_h + ((200 * 200) * ((int)((6.0) / (0.25)))), x_hull_h, x_h, std::multiplies< float> ()); 
#line 4200
}  
#line 4202
if (WRITE_X_K0) { 
#line 4203
array_2_disk((char *)("x_k0"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, x_h, 200, 200, (int)((6.0) / (0.25)), (200 * 200) * ((int)((6.0) / (0.25))), true); }  
#line 4204
} 
#line 4205
void create_hull_image_hybrid() 
#line 4206
{ 
#line 4214
dim3 dimBlock((int)((6.0) / (0.25))); 
#line 4215
dim3 dimGrid(200, 200); 
#line 4217
(cudaConfigureCall(dimGrid, dimBlock)) ? ((void)0) : create_hull_image_hybrid_GPU(x_hull_d, FBP_image_d); 
#line 4218
cudaMemcpy(x_h, FBP_image_d, ((200 * 200) * ((int)((6.0) / (0.25)))) * sizeof(float), cudaMemcpyDeviceToHost); 
#line 4220
if (WRITE_X_K0) { 
#line 4221
array_2_disk((char *)("x_k0"), OUTPUT_DIRECTORY, OUTPUT_FOLDER, x_h, 200, 200, (int)((6.0) / (0.25)), (200 * 200) * ((int)((6.0) / (0.25))), true); }  
#line 4222
} 
#line 4223
void create_hull_image_hybrid_GPU(bool *&x_hull, float *&FBP_image) ;
#if 0
#line 4224
{ 
#line 4225
int row = blockIdx.y, column = blockIdx.x, slice = threadIdx.x; 
#line 4226
int voxel = (column + (row * 200)) + ((slice * 200) * 200); 
#line 4227
(FBP_image[voxel]) *= (x_hull[voxel]); 
#line 4228
} 
#endif
#line 4232 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void initializations() 
#line 4233
{ 
#line 4234
puts("Allocating statistical analysis arrays on host/GPU..."); 
#line 4236
bin_counts_h = ((int *)calloc((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5))), sizeof(int))); 
#line 4237
mean_WEPL_h = ((float *)calloc((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5))), sizeof(float))); 
#line 4238
mean_rel_ut_angle_h = ((float *)calloc((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5))), sizeof(float))); 
#line 4239
mean_rel_uv_angle_h = ((float *)calloc((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5))), sizeof(float))); 
#line 4241
cudaMalloc((void **)(&bin_counts_d), ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(int)); 
#line 4242
cudaMalloc((void **)(&mean_WEPL_d), ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float)); 
#line 4243
cudaMalloc((void **)(&mean_rel_ut_angle_d), ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float)); 
#line 4244
cudaMalloc((void **)(&mean_rel_uv_angle_d), ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float)); 
#line 4246
cudaMemcpy(bin_counts_d, bin_counts_h, ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(int), cudaMemcpyHostToDevice); 
#line 4247
cudaMemcpy(mean_WEPL_d, mean_WEPL_h, ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float), cudaMemcpyHostToDevice); 
#line 4248
cudaMemcpy(mean_rel_ut_angle_d, mean_rel_ut_angle_h, ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float), cudaMemcpyHostToDevice); 
#line 4249
cudaMemcpy(mean_rel_uv_angle_d, mean_rel_uv_angle_h, ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float), cudaMemcpyHostToDevice); 
#line 4250
} 
#line 4251
void reserve_vector_capacity() 
#line 4252
{ 
#line 4253
bin_num_vector.reserve(total_histories); 
#line 4255
WEPL_vector.reserve(total_histories); 
#line 4256
x_entry_vector.reserve(total_histories); 
#line 4257
y_entry_vector.reserve(total_histories); 
#line 4258
z_entry_vector.reserve(total_histories); 
#line 4259
x_exit_vector.reserve(total_histories); 
#line 4260
y_exit_vector.reserve(total_histories); 
#line 4261
z_exit_vector.reserve(total_histories); 
#line 4262
xy_entry_angle_vector.reserve(total_histories); 
#line 4263
xz_entry_angle_vector.reserve(total_histories); 
#line 4264
xy_exit_angle_vector.reserve(total_histories); 
#line 4265
xz_exit_angle_vector.reserve(total_histories); 
#line 4266
} 
#line 4267
void initial_processing_memory_clean() 
#line 4268
{ 
#line 4271
free(gantry_angle_h); 
#line 4272
cudaFree(x_entry_d); 
#line 4273
cudaFree(y_entry_d); 
#line 4274
cudaFree(z_entry_d); 
#line 4275
cudaFree(x_exit_d); 
#line 4276
cudaFree(y_exit_d); 
#line 4277
cudaFree(z_exit_d); 
#line 4278
cudaFree(missed_recon_volume_d); 
#line 4279
cudaFree(bin_num_d); 
#line 4280
cudaFree(WEPL_d); 
#line 4281
} 
#line 4282
void post_cut_memory_clean() 
#line 4283
{ 
#line 4284
puts("Freeing unnecessary memory, resizing vectors, and shrinking vectors to fit just the remaining histories..."); 
#line 4286
free(failed_cuts_h); 
#line 4287
free(stddev_rel_ut_angle_h); 
#line 4288
free(stddev_rel_uv_angle_h); 
#line 4289
free(stddev_WEPL_h); 
#line 4291
cudaFree(failed_cuts_d); 
#line 4292
cudaFree(bin_num_d); 
#line 4293
cudaFree(WEPL_d); 
#line 4294
cudaFree(xy_entry_angle_d); 
#line 4295
cudaFree(xz_entry_angle_d); 
#line 4296
cudaFree(xy_exit_angle_d); 
#line 4297
cudaFree(xz_exit_angle_d); 
#line 4299
cudaFree(mean_rel_ut_angle_d); 
#line 4300
cudaFree(mean_rel_uv_angle_d); 
#line 4301
cudaFree(mean_WEPL_d); 
#line 4302
cudaFree(stddev_rel_ut_angle_d); 
#line 4303
cudaFree(stddev_rel_uv_angle_d); 
#line 4304
cudaFree(stddev_WEPL_d); 
#line 4305
} 
#line 4306
void resize_vectors(const int new_size) 
#line 4307
{ 
#line 4308
bin_num_vector.resize(new_size); 
#line 4310
WEPL_vector.resize(new_size); 
#line 4311
x_entry_vector.resize(new_size); 
#line 4312
y_entry_vector.resize(new_size); 
#line 4313
z_entry_vector.resize(new_size); 
#line 4314
x_exit_vector.resize(new_size); 
#line 4315
y_exit_vector.resize(new_size); 
#line 4316
z_exit_vector.resize(new_size); 
#line 4317
xy_entry_angle_vector.resize(new_size); 
#line 4318
xz_entry_angle_vector.resize(new_size); 
#line 4319
xy_exit_angle_vector.resize(new_size); 
#line 4320
xz_exit_angle_vector.resize(new_size); 
#line 4321
} 
#line 4322
void shrink_vectors(const int new_capacity) 
#line 4323
{ 
#line 4324
bin_num_vector.shrink_to_fit(); 
#line 4326
WEPL_vector.shrink_to_fit(); 
#line 4327
x_entry_vector.shrink_to_fit(); 
#line 4328
y_entry_vector.shrink_to_fit(); 
#line 4329
z_entry_vector.shrink_to_fit(); 
#line 4330
x_exit_vector.shrink_to_fit(); 
#line 4331
y_exit_vector.shrink_to_fit(); 
#line 4332
z_exit_vector.shrink_to_fit(); 
#line 4333
xy_entry_angle_vector.shrink_to_fit(); 
#line 4334
xz_entry_angle_vector.shrink_to_fit(); 
#line 4335
xy_exit_angle_vector.shrink_to_fit(); 
#line 4336
xz_exit_angle_vector.shrink_to_fit(); 
#line 4337
} 
#line 4338
void initialize_stddev() 
#line 4339
{ 
#line 4340
stddev_rel_ut_angle_h = ((float *)calloc((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5))), sizeof(float))); 
#line 4341
stddev_rel_uv_angle_h = ((float *)calloc((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5))), sizeof(float))); 
#line 4342
stddev_WEPL_h = ((float *)calloc((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5))), sizeof(float))); 
#line 4344
cudaMalloc((void **)(&stddev_rel_ut_angle_d), ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float)); 
#line 4345
cudaMalloc((void **)(&stddev_rel_uv_angle_d), ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float)); 
#line 4346
cudaMalloc((void **)(&stddev_WEPL_d), ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float)); 
#line 4348
cudaMemcpy(stddev_rel_ut_angle_d, stddev_rel_ut_angle_h, ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float), cudaMemcpyHostToDevice); 
#line 4349
cudaMemcpy(stddev_rel_uv_angle_d, stddev_rel_uv_angle_h, ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float), cudaMemcpyHostToDevice); 
#line 4350
cudaMemcpy(stddev_WEPL_d, stddev_WEPL_h, ((((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) * ((int)(((9.0) / (0.25)) + (0.5)))) * sizeof(float), cudaMemcpyHostToDevice); 
#line 4351
} 
#line 4352
void allocations(const int num_histories) 
#line 4353
{ 
#line 4354
bin_num = ((int *)calloc(num_histories, sizeof(int))); 
#line 4355
gantry_angle = ((int *)calloc(num_histories, sizeof(int))); 
#line 4356
WEPL = ((float *)calloc(num_histories, sizeof(float))); 
#line 4357
x_entry = ((float *)calloc(num_histories, sizeof(float))); 
#line 4358
y_entry = ((float *)calloc(num_histories, sizeof(float))); 
#line 4359
z_entry = ((float *)calloc(num_histories, sizeof(float))); 
#line 4360
x_exit = ((float *)calloc(num_histories, sizeof(float))); 
#line 4361
y_exit = ((float *)calloc(num_histories, sizeof(float))); 
#line 4362
z_exit = ((float *)calloc(num_histories, sizeof(float))); 
#line 4363
xy_entry_angle = ((float *)calloc(num_histories, sizeof(float))); 
#line 4364
xz_entry_angle = ((float *)calloc(num_histories, sizeof(float))); 
#line 4365
xy_exit_angle = ((float *)calloc(num_histories, sizeof(float))); 
#line 4366
xz_exit_angle = ((float *)calloc(num_histories, sizeof(float))); 
#line 4367
} 
#line 4368
void reallocations(const int new_size) 
#line 4369
{ 
#line 4370
bin_num = ((int *)realloc(bin_num, new_size * sizeof(int))); 
#line 4371
gantry_angle = ((int *)realloc(gantry_angle, new_size * sizeof(int))); 
#line 4372
WEPL = ((float *)realloc(WEPL, new_size * sizeof(float))); 
#line 4373
x_entry = ((float *)realloc(x_entry, new_size * sizeof(float))); 
#line 4374
y_entry = ((float *)realloc(y_entry, new_size * sizeof(float))); 
#line 4375
z_entry = ((float *)realloc(z_entry, new_size * sizeof(float))); 
#line 4376
x_exit = ((float *)realloc(x_exit, new_size * sizeof(float))); 
#line 4377
y_exit = ((float *)realloc(y_exit, new_size * sizeof(float))); 
#line 4378
z_exit = ((float *)realloc(z_exit, new_size * sizeof(float))); 
#line 4379
xy_entry_angle = ((float *)realloc(xy_entry_angle, new_size * sizeof(float))); 
#line 4380
xz_entry_angle = ((float *)realloc(xz_entry_angle, new_size * sizeof(float))); 
#line 4381
xy_exit_angle = ((float *)realloc(xy_exit_angle, new_size * sizeof(float))); 
#line 4382
xz_exit_angle = ((float *)realloc(xz_exit_angle, new_size * sizeof(float))); 
#line 4383
} 
#line 4387
template< class T> void array_2_disk(char *filename_base, const char *directory, const char *folder, T *data, const int x_max, const int y_max, const int z_max, const int elements, const bool single_file) 
#line 4388
{ 
#line 4389
char filename[256]; 
#line 4390
std::ofstream output_file; 
#line 4391
int index; 
#line 4392
int num_files = z_max; 
#line 4393
int z_start = 0; 
#line 4394
int z_end = 1; 
#line 4395
if (single_file) 
#line 4396
{ 
#line 4397
num_files = 1; 
#line 4398
z_end = z_max; 
#line 4399
}  
#line 4400
for (int file = 0; file < num_files; file++) 
#line 4401
{ 
#line 4402
if (num_files == z_max) { 
#line 4403
sprintf(filename, "%s%s/%s_%d.txt", directory, folder, filename_base, file); } else { 
#line 4405
sprintf(filename, "%s%s/%s.txt", directory, folder, filename_base); }  
#line 4406
output_file.open(filename); 
#line 4407
for (int z = z_start; z < z_end; z++) 
#line 4408
{ 
#line 4409
for (int y = 0; y < y_max; y++) 
#line 4410
{ 
#line 4411
for (int x = 0; x < x_max; x++) 
#line 4412
{ 
#line 4413
index = ((x + (y * x_max)) + ((z * x_max) * y_max)); 
#line 4414
if (index >= elements) { 
#line 4415
break; }  
#line 4416
(output_file << (data[index])) << " "; 
#line 4417
}  
#line 4418
if (index >= elements) { 
#line 4419
break; }  
#line 4420
(output_file << (std::endl)); 
#line 4421
}  
#line 4422
if (index >= elements) { 
#line 4423
break; }  
#line 4424
}  
#line 4425
z_start += 1; 
#line 4426
z_end += 1; 
#line 4427
output_file.close(); 
#line 4428
}  
#line 4429
} 
#line 4430
template< class T> void vector_2_disk(char *filename_base, const char *directory, const char *folder, std::vector< T>  data, const int x_max, const int y_max, const int z_max, const bool single_file) 
#line 4431
{ 
#line 4432
char filename[256]; 
#line 4433
std::ofstream output_file; 
#line 4434
int elements = (data.size()); 
#line 4435
int index; 
#line 4436
int num_files = z_max; 
#line 4437
int z_start = 0; 
#line 4438
int z_end = 1; 
#line 4439
if (single_file) 
#line 4440
{ 
#line 4441
num_files = 1; 
#line 4442
z_end = z_max; 
#line 4443
}  
#line 4444
for (int file = 0; file < num_files; file++) 
#line 4445
{ 
#line 4446
if (num_files == z_max) { 
#line 4447
sprintf(filename, "%s%s/%s_%d.txt", directory, folder, filename_base, file); } else { 
#line 4449
sprintf(filename, "%s%s/%s.txt", directory, folder, filename_base); }  
#line 4450
output_file.open(filename); 
#line 4451
for (int z = z_start; z < z_end; z++) 
#line 4452
{ 
#line 4453
for (int y = 0; y < y_max; y++) 
#line 4454
{ 
#line 4455
for (int x = 0; x < x_max; x++) 
#line 4456
{ 
#line 4457
index = ((x + (y * x_max)) + ((z * x_max) * y_max)); 
#line 4458
if (index >= elements) { 
#line 4459
break; }  
#line 4460
(output_file << (data[index])) << " "; 
#line 4461
}  
#line 4462
if (index >= elements) { 
#line 4463
break; }  
#line 4464
(output_file << (std::endl)); 
#line 4465
}  
#line 4466
if (index >= elements) { 
#line 4467
break; }  
#line 4468
}  
#line 4469
z_start += 1; 
#line 4470
z_end += 1; 
#line 4471
output_file.close(); 
#line 4472
}  
#line 4473
} 
#line 4474
void write_t_bin_data(FILE *output_file, const std::vector< int>  &bin_numbers, const std::vector< float>  &data, const BIN_ANALYSIS_TYPE type, const BIN_ORGANIZATION bin_order, int bin) 
#line 4475
{ 
#line 4476
std::vector< float>  bin_histories; 
#line 4477
int num_histories; 
#line 4478
for (int t_bin = 0; t_bin < ((int)(((35.0) / (0.10000000000000001)) + (0.5))); (t_bin++), (bin++)) 
#line 4479
{ 
#line 4480
if (bin_order == (BY_HISTORY)) 
#line 4481
{ 
#line 4482
for (int i = 0; i < data.size(); i++) { 
#line 4483
if (bin_numbers[i] == bin) { 
#line 4484
bin_histories.push_back(data[i]); }  }  
#line 4485
} else { 
#line 4487
bin_histories.push_back(data[bin]); }  
#line 4488
num_histories = (bin_histories.size()); 
#line 4489
switch (type) 
#line 4490
{ 
#line 4491
case COUNTS:  
#line 4492
fprintf(output_file, "%d ", num_histories); 
#line 4493
break; 
#line 4494
case MEANS:  
#line 4495
fprintf(output_file, "%f ", std::accumulate(bin_histories.begin(), bin_histories.end(), (0.0)) / (max(num_histories, 1))); 
#line 4496
break; 
#line 4497
case MEMBERS:  
#line 4498
for (int i = 0; i < num_histories; i++) { 
#line 4499
fprintf(output_file, "%f ", bin_histories[i]); }  
#line 4500
if (t_bin != (((int)(((35.0) / (0.10000000000000001)) + (0.5))) - 1)) { 
#line 4501
fputs("\n", output_file); }  
#line 4502
}  
#line 4503
bin_histories.resize(0); 
#line 4504
bin_histories.shrink_to_fit(); 
#line 4505
}  
#line 4506
} 
#line 4507
void write_bin_data(const char *filename_base, const std::vector< int>  &bin_numbers, const std::vector< float>  &data, const BIN_ANALYSIS_TYPE type, const BIN_ANALYSIS_FOR which_bins, const BIN_ORGANIZATION bin_order, ...) 
#line 4508
{ 
#line 4509
std::vector< int>  angles; 
#line 4510
std::vector< int>  angular_bins; 
#line 4511
std::vector< int>  v_bins; 
#line 4512
if (which_bins == (ALL_BINS)) 
#line 4513
{ 
#line 4514
angular_bins.resize((int)(((360) / (6.0)) + (0.5))); 
#line 4515
v_bins.resize((int)(((9.0) / (0.25)) + (0.5))); 
#line 4516
std::iota(angular_bins.begin(), angular_bins.end(), 0); 
#line 4517
std::iota(v_bins.begin(), v_bins.end(), 0); 
#line 4518
} else 
#line 4520
{ 
#line 4521
va_list specific_bins; 
#line 4522
__va_start(&specific_bins, bin_order); 
#line 4523
(angles = (((sizeof(std::vector< int> ) > sizeof(__int64)) || ((sizeof(std::vector< int> ) & (sizeof(std::vector< int> ) - (1))) != (0))) ? (*(*((std::vector< int>  **)((specific_bins += sizeof(__int64)) - sizeof(__int64))))) : (*((std::vector< int>  *)((specific_bins += sizeof(__int64)) - sizeof(__int64)))))); 
#line 4524
(v_bins = (((sizeof(std::vector< int> ) > sizeof(__int64)) || ((sizeof(std::vector< int> ) & (sizeof(std::vector< int> ) - (1))) != (0))) ? (*(*((std::vector< int>  **)((specific_bins += sizeof(__int64)) - sizeof(__int64))))) : (*((std::vector< int>  *)((specific_bins += sizeof(__int64)) - sizeof(__int64)))))); 
#line 4525
specific_bins = ((va_list)0); 
#line 4526
angular_bins.resize(angles.size()); 
#line 4527
std::transform(angles.begin(), angles.end(), angular_bins.begin(), std::bind2nd(std::divides< int> (), (6.0))); 
#line 4528
}  
#line 4530
int num_angles = angular_bins.size(); 
#line 4531
int num_v_bins = v_bins.size(); 
#line 4538
char filename[256]; 
#line 4539
int start_bin, angle; 
#line 4540
FILE *output_file; 
#line 4542
for (int angular_bin = 0; angular_bin < num_angles; angular_bin++) 
#line 4543
{ 
#line 4544
angle = ((angular_bins[angular_bin]) * (6.0)); 
#line 4546
sprintf(filename, "%s%s/%s_%03d%s", OUTPUT_DIRECTORY, OUTPUT_FOLDER, filename_base, angle, ".txt"); 
#line 4547
output_file = fopen(filename, "w"); 
#line 4548
for (int v_bin = 0; v_bin < num_v_bins; v_bin++) 
#line 4549
{ 
#line 4551
start_bin = ((angular_bins[angular_bin] * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) + ((v_bins[v_bin] * ((int)(((360) / (6.0)) + (0.5)))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))); 
#line 4552
write_t_bin_data(output_file, bin_numbers, data, type, bin_order, start_bin); 
#line 4553
if (v_bin != (num_v_bins - 1)) { 
#line 4554
fputs("\n", output_file); }  
#line 4555
}  
#line 4556
fclose(output_file); 
#line 4557
}  
#line 4558
} 
#line 4559
void write_t_bin_data(FILE *output_file, int *&bin_numbers, float *&data, const int data_elements, const BIN_ANALYSIS_TYPE type, const BIN_ORGANIZATION bin_order, int bin) 
#line 4560
{ 
#line 4561
std::vector< float>  bin_histories; 
#line 4563
int num_bin_members; 
#line 4564
for (int t_bin = 0; t_bin < ((int)(((35.0) / (0.10000000000000001)) + (0.5))); (t_bin++), (bin++)) 
#line 4565
{ 
#line 4566
if (bin_order == (BY_HISTORY)) 
#line 4567
{ 
#line 4568
for (int i = 0; i < data_elements; i++) { 
#line 4569
if ((bin_numbers[i]) == bin) { 
#line 4570
bin_histories.push_back(data[i]); }  }  
#line 4571
} else { 
#line 4573
bin_histories.push_back(data[bin]); }  
#line 4574
num_bin_members = (bin_histories.size()); 
#line 4575
switch (type) 
#line 4576
{ 
#line 4577
case COUNTS:  
#line 4578
fprintf(output_file, "%d ", num_bin_members); 
#line 4579
break; 
#line 4580
case MEANS:  
#line 4581
fprintf(output_file, "%f ", std::accumulate(bin_histories.begin(), bin_histories.end(), (0.0)) / (max(num_bin_members, 1))); 
#line 4582
break; 
#line 4583
case MEMBERS:  
#line 4584
for (int i = 0; i < num_bin_members; i++) { 
#line 4585
fprintf(output_file, "%f ", bin_histories[i]); }  
#line 4586
if (t_bin != (((int)(((35.0) / (0.10000000000000001)) + (0.5))) - 1)) { 
#line 4587
fputs("\n", output_file); }  
#line 4588
}  
#line 4589
bin_histories.resize(0); 
#line 4590
bin_histories.shrink_to_fit(); 
#line 4591
}  
#line 4592
} 
#line 4593
void write_bin_data(const char *filename_base, int *&bin_numbers, float *&data, const int data_elements, const BIN_ANALYSIS_TYPE type, const BIN_ANALYSIS_FOR which_bins, const BIN_ORGANIZATION bin_order, ...) 
#line 4594
{ 
#line 4595
std::vector< int>  angles; 
#line 4596
std::vector< int>  angular_bins; 
#line 4597
std::vector< int>  v_bins; 
#line 4598
if (which_bins == (ALL_BINS)) 
#line 4599
{ 
#line 4600
angular_bins.resize((int)(((360) / (6.0)) + (0.5))); 
#line 4601
v_bins.resize((int)(((9.0) / (0.25)) + (0.5))); 
#line 4602
std::iota(angular_bins.begin(), angular_bins.end(), 0); 
#line 4603
std::iota(v_bins.begin(), v_bins.end(), 0); 
#line 4604
} else 
#line 4606
{ 
#line 4607
va_list specific_bins; 
#line 4608
__va_start(&specific_bins, bin_order); 
#line 4609
(angles = (((sizeof(std::vector< int> ) > sizeof(__int64)) || ((sizeof(std::vector< int> ) & (sizeof(std::vector< int> ) - (1))) != (0))) ? (*(*((std::vector< int>  **)((specific_bins += sizeof(__int64)) - sizeof(__int64))))) : (*((std::vector< int>  *)((specific_bins += sizeof(__int64)) - sizeof(__int64)))))); 
#line 4610
(v_bins = (((sizeof(std::vector< int> ) > sizeof(__int64)) || ((sizeof(std::vector< int> ) & (sizeof(std::vector< int> ) - (1))) != (0))) ? (*(*((std::vector< int>  **)((specific_bins += sizeof(__int64)) - sizeof(__int64))))) : (*((std::vector< int>  *)((specific_bins += sizeof(__int64)) - sizeof(__int64)))))); 
#line 4611
specific_bins = ((va_list)0); 
#line 4612
angular_bins.resize(angles.size()); 
#line 4613
std::transform(angles.begin(), angles.end(), angular_bins.begin(), std::bind2nd(std::divides< int> (), (6.0))); 
#line 4614
}  
#line 4617
int num_angles = angular_bins.size(); 
#line 4618
int num_v_bins = v_bins.size(); 
#line 4625
char filename[256]; 
#line 4626
int start_bin, angle; 
#line 4627
FILE *output_file; 
#line 4629
for (int angular_bin = 0; angular_bin < num_angles; angular_bin++) 
#line 4630
{ 
#line 4631
angle = ((angular_bins[angular_bin]) * (6.0)); 
#line 4633
sprintf(filename, "%s%s/%s_%03d%s", OUTPUT_DIRECTORY, OUTPUT_FOLDER, filename_base, angle, ".txt"); 
#line 4634
output_file = fopen(filename, "w"); 
#line 4635
for (int v_bin = 0; v_bin < num_v_bins; v_bin++) 
#line 4636
{ 
#line 4638
start_bin = ((angular_bins[angular_bin] * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) + ((v_bins[v_bin] * ((int)(((360) / (6.0)) + (0.5)))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))); 
#line 4639
write_t_bin_data(output_file, bin_numbers, data, data_elements, type, bin_order, start_bin); 
#line 4640
if (v_bin != (num_v_bins - 1)) { 
#line 4641
fputs("\n", output_file); }  
#line 4642
}  
#line 4643
fclose(output_file); 
#line 4644
}  
#line 4645
} 
#line 4646
void bin_2_txt() 
#line 4647
{ 
#line 4648
count_histories(); 
#line 4649
char filename[256]; 
#line 4650
FILE *output_file; 
#line 4651
int start_file_num = 0, end_file_num = 0, histories_to_process = 0; 
#line 4652
while (start_file_num != (1 * ((int)((360) / (6.0))))) 
#line 4653
{ 
#line 4654
while (end_file_num < (1 * ((int)((360) / (6.0))))) 
#line 4655
{ 
#line 4656
if ((histories_to_process + (histories_per_file[end_file_num])) < 300000) { 
#line 4657
histories_to_process += (histories_per_file[end_file_num]); } else { 
#line 4659
break; }  
#line 4660
end_file_num++; 
#line 4661
}  
#line 4662
read_data_chunk(histories_to_process, start_file_num, end_file_num); 
#line 4663
sprintf(filename, "%s%s/%s%s%d%s", OUTPUT_DIRECTORY, OUTPUT_FOLDER, INPUT_BASE_NAME, "_", gantry_angle_h[0], ".txt"); 
#line 4664
output_file = fopen(filename, "w"); 
#line 4666
for (int i = 0; i < histories_to_process; i++) 
#line 4667
{ 
#line 4668
fprintf(output_file, "%3f %3f %3f %3f %3f %3f %3f %3f %3f\n", t_in_1_h[i], t_in_2_h[i], t_out_1_h[i], t_out_2_h[i], v_in_1_h[i], v_in_2_h[i], v_out_1_h[i], v_out_2_h[i], WEPL_h[i]); 
#line 4669
}  
#line 4670
fclose(output_file); 
#line 4671
initial_processing_memory_clean(); 
#line 4672
start_file_num = end_file_num; 
#line 4673
histories_to_process = 0; 
#line 4674
}  
#line 4675
} 
#line 4679
bool is_bad_angle(const int angle) 
#line 4680
{ 
#line 4681
static const int bad_angles[] = {0, 80, 84, 88, 92, 96, 100, 180, 260, 264, 268, 272, 276}; 
#line 4682
return std::binary_search(bad_angles, (bad_angles) + (sizeof bad_angles / sizeof(int)), angle); 
#line 4683
} 
#line 4684
int calculate_x_voxel(const float x, const int x_voxels, const float voxel_width) 
#line 4685
{ 
#line 4687
return (int)(((200) / (2.0)) + (x / (((2) * (8.0)) / (200)))); 
#line 4688
} 
#line 4689
int calculate_y_voxel(const float y, const int y_voxels, const float voxel_height) 
#line 4690
{ 
#line 4692
return (int)(((200) / (2.0)) - (y / (((2) * (8.0)) / (200)))); 
#line 4693
} 
#line 4694
int calculate_slice(const float z, const int z_voxels, const float voxel_thickness) 
#line 4695
{ 
#line 4697
return (int)((((int)((6.0) / (0.25))) / (2.0)) - (z / ((((int)((6.0) / (0.25))) * (0.25)) / ((int)((6.0) / (0.25)))))); 
#line 4698
} 
#line 4699
int positions_2_voxels(const double x, const double y, const double z, int &voxel_x, int &voxel_y, int &voxel_z) 
#line 4700
{ 
#line 4701
voxel_x = ((x + (8.0)) / (((2) * (8.0)) / (200))); 
#line 4702
voxel_y = (((8.0) - y) / (((2) * (8.0)) / (200))); 
#line 4703
voxel_z = ((((6.0) / (2)) - z) / ((((int)((6.0) / (0.25))) * (0.25)) / ((int)((6.0) / (0.25))))); 
#line 4704
return (voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200); 
#line 4705
} 
#line 4706
int position_2_voxel_GPU(double x, double y, double z) 
#line 4707
{int volatile ___ = 1;(void)x;(void)y;(void)z;
#line 4712
::exit(___);}
#if 0
#line 4707
{ 
#line 4708
int voxel_x = (x + (8.0)) / (((2) * (8.0)) / (200)); 
#line 4709
int voxel_y = ((8.0) - y) / (((2) * (8.0)) / (200)); 
#line 4710
int voxel_z = (((6.0) / (2)) - z) / ((((int)((6.0) / (0.25))) * (0.25)) / ((int)((6.0) / (0.25)))); 
#line 4711
return (voxel_x + (voxel_y * 200)) + ((voxel_z * 200) * 200); 
#line 4712
} 
#endif
#line 4713 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void bin_2_indexes(int &bin_num, int &t_bin, int &v_bin, int &angular_bin) 
#line 4714
{ 
#line 4716
while ((bin_num - (((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))) > 0) 
#line 4717
{ 
#line 4718
bin_num -= (((int)(((360) / (6.0)) + (0.5))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))); 
#line 4719
v_bin++; 
#line 4720
}  
#line 4722
while ((bin_num - ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) > 0) 
#line 4723
{ 
#line 4724
bin_num -= ((int)(((35.0) / (0.10000000000000001)) + (0.5))); 
#line 4725
angular_bin++; 
#line 4726
}  
#line 4728
t_bin = bin_num; 
#line 4729
} 
#line 4730
void exit_program_if(bool early_exit) 
#line 4731
{ 
#line 4732
if (early_exit) 
#line 4733
{ 
#line 4734
char user_response[20]; 
#line 4735
stop_execution_timing(); 
#line 4736
puts("Hit enter to stop..."); 
#line 4737
fgets(user_response, sizeof user_response, &(__iob_func()[0])); 
#line 4738
exit(1); 
#line 4739
}  
#line 4740
} 
#line 4741
void start_execution_timing() 
#line 4742
{ 
#line 4743
start_time = clock(); 
#line 4744
} 
#line 4745
void stop_execution_timing() 
#line 4746
{ 
#line 4747
end_time = clock(); 
#line 4748
execution_time = ((end_time - start_time) / (1000)); 
#line 4749
printf("Total execution time : %3f\n", (double)execution_time); 
#line 4750
} 
#line 4751
void pause_execution() 
#line 4752
{ 
#line 4753
char user_response[20]; 
#line 4754
fgets(user_response, sizeof user_response, &(__iob_func()[0])); 
#line 4755
} 
#line 4759
int my_divide(int x, int y) { return x * y; } 
#line 4760
void test_func() 
#line 4761
{ 
#line 4762
int x[] = {2, 3, 4, 6, 7}; 
#line 4763
test_func_3(); 
#line 4767
int y[20]; 
#line 4768
int index = 0; 
#line 4769
for (int i = 0; i < 20; i++) { 
#line 4770
((y)[index++]) = i; }  
#line 4771
for (int i = 0; i < 20; i++) { 
#line 4772
(((std::cout << ((y)[i]))) << (std::endl)); }  
#line 4828
} 
#line 4829
void test_func2(std::vector< int>  &bin_numbers, std::vector< float>  &data) 
#line 4830
{ 
#line 4831
int angular_bin = 8; 
#line 4832
int v_bin = 14; 
#line 4833
int bin_num = (angular_bin * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) + ((v_bin * ((int)(((360) / (6.0)) + (0.5)))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))); 
#line 4834
bin_numbers.push_back(bin_num); 
#line 4835
bin_numbers.push_back(bin_num); 
#line 4836
bin_numbers.push_back(bin_num); 
#line 4837
bin_numbers.push_back(bin_num + 1); 
#line 4838
bin_numbers.push_back(bin_num + 1); 
#line 4839
bin_numbers.push_back(bin_num + 3); 
#line 4840
data.push_back((1.1000000000000001)); 
#line 4841
data.push_back((1.2)); 
#line 4842
data.push_back((1.3)); 
#line 4843
data.push_back((0.10000000000000001)); 
#line 4844
data.push_back((0.10000000000000001)); 
#line 4845
data.push_back((5.4000000000000004)); 
#line 4847
v_bin = 15; 
#line 4848
bin_num = ((angular_bin * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) + ((v_bin * ((int)(((360) / (6.0)) + (0.5)))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))); 
#line 4849
bin_numbers.push_back(bin_num); 
#line 4850
bin_numbers.push_back(bin_num); 
#line 4851
bin_numbers.push_back(bin_num); 
#line 4852
bin_numbers.push_back(bin_num + 1); 
#line 4853
bin_numbers.push_back(bin_num + 1); 
#line 4854
bin_numbers.push_back(bin_num + 3); 
#line 4855
data.push_back((1.1000000000000001)); 
#line 4856
data.push_back((1.2)); 
#line 4857
data.push_back((1.3)); 
#line 4858
data.push_back((0.10000000000000001)); 
#line 4859
data.push_back((0.10000000000000001)); 
#line 4860
data.push_back((5.4000000000000004)); 
#line 4862
angular_bin = 30; 
#line 4863
v_bin = 14; 
#line 4864
bin_num = ((angular_bin * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) + ((v_bin * ((int)(((360) / (6.0)) + (0.5)))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))); 
#line 4865
bin_numbers.push_back(bin_num); 
#line 4866
bin_numbers.push_back(bin_num); 
#line 4867
bin_numbers.push_back(bin_num); 
#line 4868
bin_numbers.push_back(bin_num + 1); 
#line 4869
bin_numbers.push_back(bin_num + 1); 
#line 4870
bin_numbers.push_back(bin_num + 3); 
#line 4871
data.push_back((1.1000000000000001)); 
#line 4872
data.push_back((1.2)); 
#line 4873
data.push_back((1.3)); 
#line 4874
data.push_back((0.10000000000000001)); 
#line 4875
data.push_back((0.10000000000000001)); 
#line 4876
data.push_back((5.4000000000000004)); 
#line 4878
v_bin = 16; 
#line 4879
bin_num = ((angular_bin * ((int)(((35.0) / (0.10000000000000001)) + (0.5)))) + ((v_bin * ((int)(((360) / (6.0)) + (0.5)))) * ((int)(((35.0) / (0.10000000000000001)) + (0.5))))); 
#line 4880
bin_numbers.push_back(bin_num); 
#line 4881
bin_numbers.push_back(bin_num); 
#line 4882
bin_numbers.push_back(bin_num); 
#line 4883
bin_numbers.push_back(bin_num + 1); 
#line 4884
bin_numbers.push_back(bin_num + 1); 
#line 4885
bin_numbers.push_back(bin_num + 3); 
#line 4886
data.push_back((1.1000000000000001)); 
#line 4887
data.push_back((1.2)); 
#line 4888
data.push_back((1.3)); 
#line 4889
data.push_back((0.10000000000000001)); 
#line 4890
data.push_back((0.10000000000000001)); 
#line 4891
data.push_back((5.4000000000000004)); 
#line 4892
} 
#line 4893
void test_func_device(int &x, int &y, int &z) 
#line 4894
{int volatile ___ = 1;(void)x;(void)y;(void)z;
#line 4898
::exit(___);}
#if 0
#line 4894
{ 
#line 4895
x = 2; 
#line 4896
y = 3; 
#line 4897
z = 4; 
#line 4898
} 
#endif
#line 4899 "C:/Users/Blake/Documents/GitHub/pct-reconstruction/pCT_Reconstruction.cu"
void test_func_GPU(int *a) ;
#if 0
#line 4900
{ 
#line 4902
double delta_yx = ((1.0) / (1.0)); 
#line 4903
double x_to_go = (0.024); 
#line 4904
double y_to_go = (0.014999999999999999); 
#line 4905
double y_to_go2 = y_to_go; 
#line 4906
double y_move = delta_yx * x_to_go; 
#line 4907
if (-1) { 
#line 4908
printf("-1"); }  
#line 4909
if (1) { 
#line 4910
printf("1"); }  
#line 4911
if (0) { 
#line 4912
printf("0"); }  
#line 4913
y_to_go -= ((!(sin(delta_yx))) * y_move); 
#line 4915
y_to_go2 -= (((!(sin(delta_yx))) * delta_yx) * x_to_go); 
#line 4917
printf(" delta_yx = %8f y_move = %8f y_to_go = %8f y_to_go2 = %8f\n", delta_yx, y_move, y_to_go, y_to_go2); 
#line 4918
double y = (1.3600000000000001); 
#line 4928
float x = ((1.0)); 
#line 4929
y = (1.0); 
#line 4930
float z = abs((2.0)) / abs(x - y); 
#line 4931
float z2 = abs(-(2.0)) / abs(x - y); 
#line 4932
float z3 = z * x; 
#line 4933
bool less = z < z2; 
#line 4934
bool less2 = x < z; 
#line 4935
bool less3 = x < z2; 
#line 4936
if (less) { 
#line 4937
(a[0]) = 1; }  
#line 4938
if (less2) { 
#line 4939
(a[1]) = 1; }  
#line 4940
if (less3) { 
#line 4941
(a[2]) = 1; }  
#line 4943
printf("%3f %3f %3f %d %d %d\n", z, z2, z3, less, less2, less3); 
#line 4951
} 
#endif
#line 1 "pCT_Reconstruction.cudafe1.stub.c"
#define _NV_ANON_NAMESPACE _GLOBAL__N__26_pCT_Reconstruction_cpp1_ii_ped
#line 1 "pCT_Reconstruction.cudafe1.stub.c"
#include "pCT_Reconstruction.cudafe1.stub.c"
#line 1 "pCT_Reconstruction.cudafe1.stub.c"
#undef _NV_ANON_NAMESPACE
